var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// node_modules/howler/dist/howler.js
var require_howler = __commonJS({
  "node_modules/howler/dist/howler.js"(exports) {
    (function() {
      "use strict";
      var HowlerGlobal2 = function() {
        this.init();
      };
      HowlerGlobal2.prototype = {
        /**
         * Initialize the global Howler object.
         * @return {Howler}
         */
        init: function() {
          var self2 = this || Howler7;
          self2._counter = 1e3;
          self2._html5AudioPool = [];
          self2.html5PoolSize = 10;
          self2._codecs = {};
          self2._howls = [];
          self2._muted = false;
          self2._volume = 1;
          self2._canPlayEvent = "canplaythrough";
          self2._navigator = typeof window !== "undefined" && window.navigator ? window.navigator : null;
          self2.masterGain = null;
          self2.noAudio = false;
          self2.usingWebAudio = true;
          self2.autoSuspend = true;
          self2.ctx = null;
          self2.autoUnlock = true;
          self2._setup();
          return self2;
        },
        /**
         * Get/set the global volume for all sounds.
         * @param  {Float} vol Volume from 0.0 to 1.0.
         * @return {Howler/Float}     Returns self or current volume.
         */
        volume: function(vol) {
          var self2 = this || Howler7;
          vol = parseFloat(vol);
          if (!self2.ctx) {
            setupAudioContext();
          }
          if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
            self2._volume = vol;
            if (self2._muted) {
              return self2;
            }
            if (self2.usingWebAudio) {
              self2.masterGain.gain.setValueAtTime(vol, Howler7.ctx.currentTime);
            }
            for (var i = 0; i < self2._howls.length; i++) {
              if (!self2._howls[i]._webAudio) {
                var ids = self2._howls[i]._getSoundIds();
                for (var j = 0; j < ids.length; j++) {
                  var sound = self2._howls[i]._soundById(ids[j]);
                  if (sound && sound._node) {
                    sound._node.volume = sound._volume * vol;
                  }
                }
              }
            }
            return self2;
          }
          return self2._volume;
        },
        /**
         * Handle muting and unmuting globally.
         * @param  {Boolean} muted Is muted or not.
         */
        mute: function(muted) {
          var self2 = this || Howler7;
          if (!self2.ctx) {
            setupAudioContext();
          }
          self2._muted = muted;
          if (self2.usingWebAudio) {
            self2.masterGain.gain.setValueAtTime(muted ? 0 : self2._volume, Howler7.ctx.currentTime);
          }
          for (var i = 0; i < self2._howls.length; i++) {
            if (!self2._howls[i]._webAudio) {
              var ids = self2._howls[i]._getSoundIds();
              for (var j = 0; j < ids.length; j++) {
                var sound = self2._howls[i]._soundById(ids[j]);
                if (sound && sound._node) {
                  sound._node.muted = muted ? true : sound._muted;
                }
              }
            }
          }
          return self2;
        },
        /**
         * Handle stopping all sounds globally.
         */
        stop: function() {
          var self2 = this || Howler7;
          for (var i = 0; i < self2._howls.length; i++) {
            self2._howls[i].stop();
          }
          return self2;
        },
        /**
         * Unload and destroy all currently loaded Howl objects.
         * @return {Howler}
         */
        unload: function() {
          var self2 = this || Howler7;
          for (var i = self2._howls.length - 1; i >= 0; i--) {
            self2._howls[i].unload();
          }
          if (self2.usingWebAudio && self2.ctx && typeof self2.ctx.close !== "undefined") {
            self2.ctx.close();
            self2.ctx = null;
            setupAudioContext();
          }
          return self2;
        },
        /**
         * Check for codec support of specific extension.
         * @param  {String} ext Audio file extention.
         * @return {Boolean}
         */
        codecs: function(ext) {
          return (this || Howler7)._codecs[ext.replace(/^x-/, "")];
        },
        /**
         * Setup various state values for global tracking.
         * @return {Howler}
         */
        _setup: function() {
          var self2 = this || Howler7;
          self2.state = self2.ctx ? self2.ctx.state || "suspended" : "suspended";
          self2._autoSuspend();
          if (!self2.usingWebAudio) {
            if (typeof Audio !== "undefined") {
              try {
                var test = new Audio();
                if (typeof test.oncanplaythrough === "undefined") {
                  self2._canPlayEvent = "canplay";
                }
              } catch (e) {
                self2.noAudio = true;
              }
            } else {
              self2.noAudio = true;
            }
          }
          try {
            var test = new Audio();
            if (test.muted) {
              self2.noAudio = true;
            }
          } catch (e) {
          }
          if (!self2.noAudio) {
            self2._setupCodecs();
          }
          return self2;
        },
        /**
         * Check for browser support for various codecs and cache the results.
         * @return {Howler}
         */
        _setupCodecs: function() {
          var self2 = this || Howler7;
          var audioTest = null;
          try {
            audioTest = typeof Audio !== "undefined" ? new Audio() : null;
          } catch (err) {
            return self2;
          }
          if (!audioTest || typeof audioTest.canPlayType !== "function") {
            return self2;
          }
          var mpegTest = audioTest.canPlayType("audio/mpeg;").replace(/^no$/, "");
          var ua = self2._navigator ? self2._navigator.userAgent : "";
          var checkOpera = ua.match(/OPR\/(\d+)/g);
          var isOldOpera = checkOpera && parseInt(checkOpera[0].split("/")[1], 10) < 33;
          var checkSafari = ua.indexOf("Safari") !== -1 && ua.indexOf("Chrome") === -1;
          var safariVersion = ua.match(/Version\/(.*?) /);
          var isOldSafari = checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15;
          self2._codecs = {
            mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType("audio/mp3;").replace(/^no$/, ""))),
            mpeg: !!mpegTest,
            opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
            ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
            oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
            wav: !!(audioTest.canPlayType('audio/wav; codecs="1"') || audioTest.canPlayType("audio/wav")).replace(/^no$/, ""),
            aac: !!audioTest.canPlayType("audio/aac;").replace(/^no$/, ""),
            caf: !!audioTest.canPlayType("audio/x-caf;").replace(/^no$/, ""),
            m4a: !!(audioTest.canPlayType("audio/x-m4a;") || audioTest.canPlayType("audio/m4a;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
            m4b: !!(audioTest.canPlayType("audio/x-m4b;") || audioTest.canPlayType("audio/m4b;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
            mp4: !!(audioTest.canPlayType("audio/x-mp4;") || audioTest.canPlayType("audio/mp4;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
            weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
            webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
            dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
            flac: !!(audioTest.canPlayType("audio/x-flac;") || audioTest.canPlayType("audio/flac;")).replace(/^no$/, "")
          };
          return self2;
        },
        /**
         * Some browsers/devices will only allow audio to be played after a user interaction.
         * Attempt to automatically unlock audio on the first user interaction.
         * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
         * @return {Howler}
         */
        _unlockAudio: function() {
          var self2 = this || Howler7;
          if (self2._audioUnlocked || !self2.ctx) {
            return;
          }
          self2._audioUnlocked = false;
          self2.autoUnlock = false;
          if (!self2._mobileUnloaded && self2.ctx.sampleRate !== 44100) {
            self2._mobileUnloaded = true;
            self2.unload();
          }
          self2._scratchBuffer = self2.ctx.createBuffer(1, 1, 22050);
          var unlock = function(e) {
            while (self2._html5AudioPool.length < self2.html5PoolSize) {
              try {
                var audioNode = new Audio();
                audioNode._unlocked = true;
                self2._releaseHtml5Audio(audioNode);
              } catch (e2) {
                self2.noAudio = true;
                break;
              }
            }
            for (var i = 0; i < self2._howls.length; i++) {
              if (!self2._howls[i]._webAudio) {
                var ids = self2._howls[i]._getSoundIds();
                for (var j = 0; j < ids.length; j++) {
                  var sound = self2._howls[i]._soundById(ids[j]);
                  if (sound && sound._node && !sound._node._unlocked) {
                    sound._node._unlocked = true;
                    sound._node.load();
                  }
                }
              }
            }
            self2._autoResume();
            var source = self2.ctx.createBufferSource();
            source.buffer = self2._scratchBuffer;
            source.connect(self2.ctx.destination);
            if (typeof source.start === "undefined") {
              source.noteOn(0);
            } else {
              source.start(0);
            }
            if (typeof self2.ctx.resume === "function") {
              self2.ctx.resume();
            }
            source.onended = function() {
              source.disconnect(0);
              self2._audioUnlocked = true;
              document.removeEventListener("touchstart", unlock, true);
              document.removeEventListener("touchend", unlock, true);
              document.removeEventListener("click", unlock, true);
              document.removeEventListener("keydown", unlock, true);
              for (var i2 = 0; i2 < self2._howls.length; i2++) {
                self2._howls[i2]._emit("unlock");
              }
            };
          };
          document.addEventListener("touchstart", unlock, true);
          document.addEventListener("touchend", unlock, true);
          document.addEventListener("click", unlock, true);
          document.addEventListener("keydown", unlock, true);
          return self2;
        },
        /**
         * Get an unlocked HTML5 Audio object from the pool. If none are left,
         * return a new Audio object and throw a warning.
         * @return {Audio} HTML5 Audio object.
         */
        _obtainHtml5Audio: function() {
          var self2 = this || Howler7;
          if (self2._html5AudioPool.length) {
            return self2._html5AudioPool.pop();
          }
          var testPlay = new Audio().play();
          if (testPlay && typeof Promise !== "undefined" && (testPlay instanceof Promise || typeof testPlay.then === "function")) {
            testPlay.catch(function() {
              console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
            });
          }
          return new Audio();
        },
        /**
         * Return an activated HTML5 Audio object to the pool.
         * @return {Howler}
         */
        _releaseHtml5Audio: function(audio) {
          var self2 = this || Howler7;
          if (audio._unlocked) {
            self2._html5AudioPool.push(audio);
          }
          return self2;
        },
        /**
         * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
         * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
         * @return {Howler}
         */
        _autoSuspend: function() {
          var self2 = this;
          if (!self2.autoSuspend || !self2.ctx || typeof self2.ctx.suspend === "undefined" || !Howler7.usingWebAudio) {
            return;
          }
          for (var i = 0; i < self2._howls.length; i++) {
            if (self2._howls[i]._webAudio) {
              for (var j = 0; j < self2._howls[i]._sounds.length; j++) {
                if (!self2._howls[i]._sounds[j]._paused) {
                  return self2;
                }
              }
            }
          }
          if (self2._suspendTimer) {
            clearTimeout(self2._suspendTimer);
          }
          self2._suspendTimer = setTimeout(function() {
            if (!self2.autoSuspend) {
              return;
            }
            self2._suspendTimer = null;
            self2.state = "suspending";
            var handleSuspension = function() {
              self2.state = "suspended";
              if (self2._resumeAfterSuspend) {
                delete self2._resumeAfterSuspend;
                self2._autoResume();
              }
            };
            self2.ctx.suspend().then(handleSuspension, handleSuspension);
          }, 3e4);
          return self2;
        },
        /**
         * Automatically resume the Web Audio AudioContext when a new sound is played.
         * @return {Howler}
         */
        _autoResume: function() {
          var self2 = this;
          if (!self2.ctx || typeof self2.ctx.resume === "undefined" || !Howler7.usingWebAudio) {
            return;
          }
          if (self2.state === "running" && self2.ctx.state !== "interrupted" && self2._suspendTimer) {
            clearTimeout(self2._suspendTimer);
            self2._suspendTimer = null;
          } else if (self2.state === "suspended" || self2.state === "running" && self2.ctx.state === "interrupted") {
            self2.ctx.resume().then(function() {
              self2.state = "running";
              for (var i = 0; i < self2._howls.length; i++) {
                self2._howls[i]._emit("resume");
              }
            });
            if (self2._suspendTimer) {
              clearTimeout(self2._suspendTimer);
              self2._suspendTimer = null;
            }
          } else if (self2.state === "suspending") {
            self2._resumeAfterSuspend = true;
          }
          return self2;
        }
      };
      var Howler7 = new HowlerGlobal2();
      var Howl3 = function(o) {
        var self2 = this;
        if (!o.src || o.src.length === 0) {
          console.error("An array of source files must be passed with any new Howl.");
          return;
        }
        self2.init(o);
      };
      Howl3.prototype = {
        /**
         * Initialize a new Howl group object.
         * @param  {Object} o Passed in properties for this group.
         * @return {Howl}
         */
        init: function(o) {
          var self2 = this;
          if (!Howler7.ctx) {
            setupAudioContext();
          }
          self2._autoplay = o.autoplay || false;
          self2._format = typeof o.format !== "string" ? o.format : [o.format];
          self2._html5 = o.html5 || false;
          self2._muted = o.mute || false;
          self2._loop = o.loop || false;
          self2._pool = o.pool || 5;
          self2._preload = typeof o.preload === "boolean" || o.preload === "metadata" ? o.preload : true;
          self2._rate = o.rate || 1;
          self2._sprite = o.sprite || {};
          self2._src = typeof o.src !== "string" ? o.src : [o.src];
          self2._volume = o.volume !== void 0 ? o.volume : 1;
          self2._xhr = {
            method: o.xhr && o.xhr.method ? o.xhr.method : "GET",
            headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,
            withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false
          };
          self2._duration = 0;
          self2._state = "unloaded";
          self2._sounds = [];
          self2._endTimers = {};
          self2._queue = [];
          self2._playLock = false;
          self2._onend = o.onend ? [{ fn: o.onend }] : [];
          self2._onfade = o.onfade ? [{ fn: o.onfade }] : [];
          self2._onload = o.onload ? [{ fn: o.onload }] : [];
          self2._onloaderror = o.onloaderror ? [{ fn: o.onloaderror }] : [];
          self2._onplayerror = o.onplayerror ? [{ fn: o.onplayerror }] : [];
          self2._onpause = o.onpause ? [{ fn: o.onpause }] : [];
          self2._onplay = o.onplay ? [{ fn: o.onplay }] : [];
          self2._onstop = o.onstop ? [{ fn: o.onstop }] : [];
          self2._onmute = o.onmute ? [{ fn: o.onmute }] : [];
          self2._onvolume = o.onvolume ? [{ fn: o.onvolume }] : [];
          self2._onrate = o.onrate ? [{ fn: o.onrate }] : [];
          self2._onseek = o.onseek ? [{ fn: o.onseek }] : [];
          self2._onunlock = o.onunlock ? [{ fn: o.onunlock }] : [];
          self2._onresume = [];
          self2._webAudio = Howler7.usingWebAudio && !self2._html5;
          if (typeof Howler7.ctx !== "undefined" && Howler7.ctx && Howler7.autoUnlock) {
            Howler7._unlockAudio();
          }
          Howler7._howls.push(self2);
          if (self2._autoplay) {
            self2._queue.push({
              event: "play",
              action: function() {
                self2.play();
              }
            });
          }
          if (self2._preload && self2._preload !== "none") {
            self2.load();
          }
          return self2;
        },
        /**
         * Load the audio file.
         * @return {Howler}
         */
        load: function() {
          var self2 = this;
          var url = null;
          if (Howler7.noAudio) {
            self2._emit("loaderror", null, "No audio support.");
            return;
          }
          if (typeof self2._src === "string") {
            self2._src = [self2._src];
          }
          for (var i = 0; i < self2._src.length; i++) {
            var ext, str8;
            if (self2._format && self2._format[i]) {
              ext = self2._format[i];
            } else {
              str8 = self2._src[i];
              if (typeof str8 !== "string") {
                self2._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                continue;
              }
              ext = /^data:audio\/([^;,]+);/i.exec(str8);
              if (!ext) {
                ext = /\.([^.]+)$/.exec(str8.split("?", 1)[0]);
              }
              if (ext) {
                ext = ext[1].toLowerCase();
              }
            }
            if (!ext) {
              console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
            }
            if (ext && Howler7.codecs(ext)) {
              url = self2._src[i];
              break;
            }
          }
          if (!url) {
            self2._emit("loaderror", null, "No codec support for selected audio sources.");
            return;
          }
          self2._src = url;
          self2._state = "loading";
          if (window.location.protocol === "https:" && url.slice(0, 5) === "http:") {
            self2._html5 = true;
            self2._webAudio = false;
          }
          new Sound2(self2);
          if (self2._webAudio) {
            loadBuffer(self2);
          }
          return self2;
        },
        /**
         * Play a sound or resume previous playback.
         * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
         * @param  {Boolean} internal Internal Use: true prevents event firing.
         * @return {Number}          Sound ID.
         */
        play: function(sprite, internal) {
          var self2 = this;
          var id = null;
          if (typeof sprite === "number") {
            id = sprite;
            sprite = null;
          } else if (typeof sprite === "string" && self2._state === "loaded" && !self2._sprite[sprite]) {
            return null;
          } else if (typeof sprite === "undefined") {
            sprite = "__default";
            if (!self2._playLock) {
              var num = 0;
              for (var i = 0; i < self2._sounds.length; i++) {
                if (self2._sounds[i]._paused && !self2._sounds[i]._ended) {
                  num++;
                  id = self2._sounds[i]._id;
                }
              }
              if (num === 1) {
                sprite = null;
              } else {
                id = null;
              }
            }
          }
          var sound = id ? self2._soundById(id) : self2._inactiveSound();
          if (!sound) {
            return null;
          }
          if (id && !sprite) {
            sprite = sound._sprite || "__default";
          }
          if (self2._state !== "loaded") {
            sound._sprite = sprite;
            sound._ended = false;
            var soundId = sound._id;
            self2._queue.push({
              event: "play",
              action: function() {
                self2.play(soundId);
              }
            });
            return soundId;
          }
          if (id && !sound._paused) {
            if (!internal) {
              self2._loadQueue("play");
            }
            return sound._id;
          }
          if (self2._webAudio) {
            Howler7._autoResume();
          }
          var seek = Math.max(0, sound._seek > 0 ? sound._seek : self2._sprite[sprite][0] / 1e3);
          var duration = Math.max(0, (self2._sprite[sprite][0] + self2._sprite[sprite][1]) / 1e3 - seek);
          var timeout2 = duration * 1e3 / Math.abs(sound._rate);
          var start = self2._sprite[sprite][0] / 1e3;
          var stop = (self2._sprite[sprite][0] + self2._sprite[sprite][1]) / 1e3;
          sound._sprite = sprite;
          sound._ended = false;
          var setParams = function() {
            sound._paused = false;
            sound._seek = seek;
            sound._start = start;
            sound._stop = stop;
            sound._loop = !!(sound._loop || self2._sprite[sprite][2]);
          };
          if (seek >= stop) {
            self2._ended(sound);
            return;
          }
          var node = sound._node;
          if (self2._webAudio) {
            var playWebAudio = function() {
              self2._playLock = false;
              setParams();
              self2._refreshBuffer(sound);
              var vol = sound._muted || self2._muted ? 0 : sound._volume;
              node.gain.setValueAtTime(vol, Howler7.ctx.currentTime);
              sound._playStart = Howler7.ctx.currentTime;
              if (typeof node.bufferSource.start === "undefined") {
                sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
              } else {
                sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
              }
              if (timeout2 !== Infinity) {
                self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout2);
              }
              if (!internal) {
                setTimeout(function() {
                  self2._emit("play", sound._id);
                  self2._loadQueue();
                }, 0);
              }
            };
            if (Howler7.state === "running" && Howler7.ctx.state !== "interrupted") {
              playWebAudio();
            } else {
              self2._playLock = true;
              self2.once("resume", playWebAudio);
              self2._clearTimer(sound._id);
            }
          } else {
            var playHtml5 = function() {
              node.currentTime = seek;
              node.muted = sound._muted || self2._muted || Howler7._muted || node.muted;
              node.volume = sound._volume * Howler7.volume();
              node.playbackRate = sound._rate;
              try {
                var play = node.play();
                if (play && typeof Promise !== "undefined" && (play instanceof Promise || typeof play.then === "function")) {
                  self2._playLock = true;
                  setParams();
                  play.then(function() {
                    self2._playLock = false;
                    node._unlocked = true;
                    if (!internal) {
                      self2._emit("play", sound._id);
                    } else {
                      self2._loadQueue();
                    }
                  }).catch(function() {
                    self2._playLock = false;
                    self2._emit("playerror", sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                    sound._ended = true;
                    sound._paused = true;
                  });
                } else if (!internal) {
                  self2._playLock = false;
                  setParams();
                  self2._emit("play", sound._id);
                }
                node.playbackRate = sound._rate;
                if (node.paused) {
                  self2._emit("playerror", sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                  return;
                }
                if (sprite !== "__default" || sound._loop) {
                  self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout2);
                } else {
                  self2._endTimers[sound._id] = function() {
                    self2._ended(sound);
                    node.removeEventListener("ended", self2._endTimers[sound._id], false);
                  };
                  node.addEventListener("ended", self2._endTimers[sound._id], false);
                }
              } catch (err) {
                self2._emit("playerror", sound._id, err);
              }
            };
            if (node.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA") {
              node.src = self2._src;
              node.load();
            }
            var loadedNoReadyState = window && window.ejecta || !node.readyState && Howler7._navigator.isCocoonJS;
            if (node.readyState >= 3 || loadedNoReadyState) {
              playHtml5();
            } else {
              self2._playLock = true;
              self2._state = "loading";
              var listener = function() {
                self2._state = "loaded";
                playHtml5();
                node.removeEventListener(Howler7._canPlayEvent, listener, false);
              };
              node.addEventListener(Howler7._canPlayEvent, listener, false);
              self2._clearTimer(sound._id);
            }
          }
          return sound._id;
        },
        /**
         * Pause playback and save current position.
         * @param  {Number} id The sound ID (empty to pause all in group).
         * @return {Howl}
         */
        pause: function(id) {
          var self2 = this;
          if (self2._state !== "loaded" || self2._playLock) {
            self2._queue.push({
              event: "pause",
              action: function() {
                self2.pause(id);
              }
            });
            return self2;
          }
          var ids = self2._getSoundIds(id);
          for (var i = 0; i < ids.length; i++) {
            self2._clearTimer(ids[i]);
            var sound = self2._soundById(ids[i]);
            if (sound && !sound._paused) {
              sound._seek = self2.seek(ids[i]);
              sound._rateSeek = 0;
              sound._paused = true;
              self2._stopFade(ids[i]);
              if (sound._node) {
                if (self2._webAudio) {
                  if (!sound._node.bufferSource) {
                    continue;
                  }
                  if (typeof sound._node.bufferSource.stop === "undefined") {
                    sound._node.bufferSource.noteOff(0);
                  } else {
                    sound._node.bufferSource.stop(0);
                  }
                  self2._cleanBuffer(sound._node);
                } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
                  sound._node.pause();
                }
              }
            }
            if (!arguments[1]) {
              self2._emit("pause", sound ? sound._id : null);
            }
          }
          return self2;
        },
        /**
         * Stop playback and reset to start.
         * @param  {Number} id The sound ID (empty to stop all in group).
         * @param  {Boolean} internal Internal Use: true prevents event firing.
         * @return {Howl}
         */
        stop: function(id, internal) {
          var self2 = this;
          if (self2._state !== "loaded" || self2._playLock) {
            self2._queue.push({
              event: "stop",
              action: function() {
                self2.stop(id);
              }
            });
            return self2;
          }
          var ids = self2._getSoundIds(id);
          for (var i = 0; i < ids.length; i++) {
            self2._clearTimer(ids[i]);
            var sound = self2._soundById(ids[i]);
            if (sound) {
              sound._seek = sound._start || 0;
              sound._rateSeek = 0;
              sound._paused = true;
              sound._ended = true;
              self2._stopFade(ids[i]);
              if (sound._node) {
                if (self2._webAudio) {
                  if (sound._node.bufferSource) {
                    if (typeof sound._node.bufferSource.stop === "undefined") {
                      sound._node.bufferSource.noteOff(0);
                    } else {
                      sound._node.bufferSource.stop(0);
                    }
                    self2._cleanBuffer(sound._node);
                  }
                } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
                  sound._node.currentTime = sound._start || 0;
                  sound._node.pause();
                  if (sound._node.duration === Infinity) {
                    self2._clearSound(sound._node);
                  }
                }
              }
              if (!internal) {
                self2._emit("stop", sound._id);
              }
            }
          }
          return self2;
        },
        /**
         * Mute/unmute a single sound or all sounds in this Howl group.
         * @param  {Boolean} muted Set to true to mute and false to unmute.
         * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
         * @return {Howl}
         */
        mute: function(muted, id) {
          var self2 = this;
          if (self2._state !== "loaded" || self2._playLock) {
            self2._queue.push({
              event: "mute",
              action: function() {
                self2.mute(muted, id);
              }
            });
            return self2;
          }
          if (typeof id === "undefined") {
            if (typeof muted === "boolean") {
              self2._muted = muted;
            } else {
              return self2._muted;
            }
          }
          var ids = self2._getSoundIds(id);
          for (var i = 0; i < ids.length; i++) {
            var sound = self2._soundById(ids[i]);
            if (sound) {
              sound._muted = muted;
              if (sound._interval) {
                self2._stopFade(sound._id);
              }
              if (self2._webAudio && sound._node) {
                sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler7.ctx.currentTime);
              } else if (sound._node) {
                sound._node.muted = Howler7._muted ? true : muted;
              }
              self2._emit("mute", sound._id);
            }
          }
          return self2;
        },
        /**
         * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
         *   volume() -> Returns the group's volume value.
         *   volume(id) -> Returns the sound id's current volume.
         *   volume(vol) -> Sets the volume of all sounds in this Howl group.
         *   volume(vol, id) -> Sets the volume of passed sound id.
         * @return {Howl/Number} Returns self or current volume.
         */
        volume: function() {
          var self2 = this;
          var args = arguments;
          var vol, id;
          if (args.length === 0) {
            return self2._volume;
          } else if (args.length === 1 || args.length === 2 && typeof args[1] === "undefined") {
            var ids = self2._getSoundIds();
            var index = ids.indexOf(args[0]);
            if (index >= 0) {
              id = parseInt(args[0], 10);
            } else {
              vol = parseFloat(args[0]);
            }
          } else if (args.length >= 2) {
            vol = parseFloat(args[0]);
            id = parseInt(args[1], 10);
          }
          var sound;
          if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
            if (self2._state !== "loaded" || self2._playLock) {
              self2._queue.push({
                event: "volume",
                action: function() {
                  self2.volume.apply(self2, args);
                }
              });
              return self2;
            }
            if (typeof id === "undefined") {
              self2._volume = vol;
            }
            id = self2._getSoundIds(id);
            for (var i = 0; i < id.length; i++) {
              sound = self2._soundById(id[i]);
              if (sound) {
                sound._volume = vol;
                if (!args[2]) {
                  self2._stopFade(id[i]);
                }
                if (self2._webAudio && sound._node && !sound._muted) {
                  sound._node.gain.setValueAtTime(vol, Howler7.ctx.currentTime);
                } else if (sound._node && !sound._muted) {
                  sound._node.volume = vol * Howler7.volume();
                }
                self2._emit("volume", sound._id);
              }
            }
          } else {
            sound = id ? self2._soundById(id) : self2._sounds[0];
            return sound ? sound._volume : 0;
          }
          return self2;
        },
        /**
         * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
         * @param  {Number} from The value to fade from (0.0 to 1.0).
         * @param  {Number} to   The volume to fade to (0.0 to 1.0).
         * @param  {Number} len  Time in milliseconds to fade.
         * @param  {Number} id   The sound id (omit to fade all sounds).
         * @return {Howl}
         */
        fade: function(from, to, len6, id) {
          var self2 = this;
          if (self2._state !== "loaded" || self2._playLock) {
            self2._queue.push({
              event: "fade",
              action: function() {
                self2.fade(from, to, len6, id);
              }
            });
            return self2;
          }
          from = Math.min(Math.max(0, parseFloat(from)), 1);
          to = Math.min(Math.max(0, parseFloat(to)), 1);
          len6 = parseFloat(len6);
          self2.volume(from, id);
          var ids = self2._getSoundIds(id);
          for (var i = 0; i < ids.length; i++) {
            var sound = self2._soundById(ids[i]);
            if (sound) {
              if (!id) {
                self2._stopFade(ids[i]);
              }
              if (self2._webAudio && !sound._muted) {
                var currentTime = Howler7.ctx.currentTime;
                var end = currentTime + len6 / 1e3;
                sound._volume = from;
                sound._node.gain.setValueAtTime(from, currentTime);
                sound._node.gain.linearRampToValueAtTime(to, end);
              }
              self2._startFadeInterval(sound, from, to, len6, ids[i], typeof id === "undefined");
            }
          }
          return self2;
        },
        /**
         * Starts the internal interval to fade a sound.
         * @param  {Object} sound Reference to sound to fade.
         * @param  {Number} from The value to fade from (0.0 to 1.0).
         * @param  {Number} to   The volume to fade to (0.0 to 1.0).
         * @param  {Number} len  Time in milliseconds to fade.
         * @param  {Number} id   The sound id to fade.
         * @param  {Boolean} isGroup   If true, set the volume on the group.
         */
        _startFadeInterval: function(sound, from, to, len6, id, isGroup) {
          var self2 = this;
          var vol = from;
          var diff = to - from;
          var steps = Math.abs(diff / 0.01);
          var stepLen = Math.max(4, steps > 0 ? len6 / steps : len6);
          var lastTick = Date.now();
          sound._fadeTo = to;
          sound._interval = setInterval(function() {
            var tick = (Date.now() - lastTick) / len6;
            lastTick = Date.now();
            vol += diff * tick;
            vol = Math.round(vol * 100) / 100;
            if (diff < 0) {
              vol = Math.max(to, vol);
            } else {
              vol = Math.min(to, vol);
            }
            if (self2._webAudio) {
              sound._volume = vol;
            } else {
              self2.volume(vol, sound._id, true);
            }
            if (isGroup) {
              self2._volume = vol;
            }
            if (to < from && vol <= to || to > from && vol >= to) {
              clearInterval(sound._interval);
              sound._interval = null;
              sound._fadeTo = null;
              self2.volume(to, sound._id);
              self2._emit("fade", sound._id);
            }
          }, stepLen);
        },
        /**
         * Internal method that stops the currently playing fade when
         * a new fade starts, volume is changed or the sound is stopped.
         * @param  {Number} id The sound id.
         * @return {Howl}
         */
        _stopFade: function(id) {
          var self2 = this;
          var sound = self2._soundById(id);
          if (sound && sound._interval) {
            if (self2._webAudio) {
              sound._node.gain.cancelScheduledValues(Howler7.ctx.currentTime);
            }
            clearInterval(sound._interval);
            sound._interval = null;
            self2.volume(sound._fadeTo, id);
            sound._fadeTo = null;
            self2._emit("fade", id);
          }
          return self2;
        },
        /**
         * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
         *   loop() -> Returns the group's loop value.
         *   loop(id) -> Returns the sound id's loop value.
         *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
         *   loop(loop, id) -> Sets the loop value of passed sound id.
         * @return {Howl/Boolean} Returns self or current loop value.
         */
        loop: function() {
          var self2 = this;
          var args = arguments;
          var loop, id, sound;
          if (args.length === 0) {
            return self2._loop;
          } else if (args.length === 1) {
            if (typeof args[0] === "boolean") {
              loop = args[0];
              self2._loop = loop;
            } else {
              sound = self2._soundById(parseInt(args[0], 10));
              return sound ? sound._loop : false;
            }
          } else if (args.length === 2) {
            loop = args[0];
            id = parseInt(args[1], 10);
          }
          var ids = self2._getSoundIds(id);
          for (var i = 0; i < ids.length; i++) {
            sound = self2._soundById(ids[i]);
            if (sound) {
              sound._loop = loop;
              if (self2._webAudio && sound._node && sound._node.bufferSource) {
                sound._node.bufferSource.loop = loop;
                if (loop) {
                  sound._node.bufferSource.loopStart = sound._start || 0;
                  sound._node.bufferSource.loopEnd = sound._stop;
                  if (self2.playing(ids[i])) {
                    self2.pause(ids[i], true);
                    self2.play(ids[i], true);
                  }
                }
              }
            }
          }
          return self2;
        },
        /**
         * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
         *   rate() -> Returns the first sound node's current playback rate.
         *   rate(id) -> Returns the sound id's current playback rate.
         *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
         *   rate(rate, id) -> Sets the playback rate of passed sound id.
         * @return {Howl/Number} Returns self or the current playback rate.
         */
        rate: function() {
          var self2 = this;
          var args = arguments;
          var rate, id;
          if (args.length === 0) {
            id = self2._sounds[0]._id;
          } else if (args.length === 1) {
            var ids = self2._getSoundIds();
            var index = ids.indexOf(args[0]);
            if (index >= 0) {
              id = parseInt(args[0], 10);
            } else {
              rate = parseFloat(args[0]);
            }
          } else if (args.length === 2) {
            rate = parseFloat(args[0]);
            id = parseInt(args[1], 10);
          }
          var sound;
          if (typeof rate === "number") {
            if (self2._state !== "loaded" || self2._playLock) {
              self2._queue.push({
                event: "rate",
                action: function() {
                  self2.rate.apply(self2, args);
                }
              });
              return self2;
            }
            if (typeof id === "undefined") {
              self2._rate = rate;
            }
            id = self2._getSoundIds(id);
            for (var i = 0; i < id.length; i++) {
              sound = self2._soundById(id[i]);
              if (sound) {
                if (self2.playing(id[i])) {
                  sound._rateSeek = self2.seek(id[i]);
                  sound._playStart = self2._webAudio ? Howler7.ctx.currentTime : sound._playStart;
                }
                sound._rate = rate;
                if (self2._webAudio && sound._node && sound._node.bufferSource) {
                  sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler7.ctx.currentTime);
                } else if (sound._node) {
                  sound._node.playbackRate = rate;
                }
                var seek = self2.seek(id[i]);
                var duration = (self2._sprite[sound._sprite][0] + self2._sprite[sound._sprite][1]) / 1e3 - seek;
                var timeout2 = duration * 1e3 / Math.abs(sound._rate);
                if (self2._endTimers[id[i]] || !sound._paused) {
                  self2._clearTimer(id[i]);
                  self2._endTimers[id[i]] = setTimeout(self2._ended.bind(self2, sound), timeout2);
                }
                self2._emit("rate", sound._id);
              }
            }
          } else {
            sound = self2._soundById(id);
            return sound ? sound._rate : self2._rate;
          }
          return self2;
        },
        /**
         * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
         *   seek() -> Returns the first sound node's current seek position.
         *   seek(id) -> Returns the sound id's current seek position.
         *   seek(seek) -> Sets the seek position of the first sound node.
         *   seek(seek, id) -> Sets the seek position of passed sound id.
         * @return {Howl/Number} Returns self or the current seek position.
         */
        seek: function() {
          var self2 = this;
          var args = arguments;
          var seek, id;
          if (args.length === 0) {
            if (self2._sounds.length) {
              id = self2._sounds[0]._id;
            }
          } else if (args.length === 1) {
            var ids = self2._getSoundIds();
            var index = ids.indexOf(args[0]);
            if (index >= 0) {
              id = parseInt(args[0], 10);
            } else if (self2._sounds.length) {
              id = self2._sounds[0]._id;
              seek = parseFloat(args[0]);
            }
          } else if (args.length === 2) {
            seek = parseFloat(args[0]);
            id = parseInt(args[1], 10);
          }
          if (typeof id === "undefined") {
            return 0;
          }
          if (typeof seek === "number" && (self2._state !== "loaded" || self2._playLock)) {
            self2._queue.push({
              event: "seek",
              action: function() {
                self2.seek.apply(self2, args);
              }
            });
            return self2;
          }
          var sound = self2._soundById(id);
          if (sound) {
            if (typeof seek === "number" && seek >= 0) {
              var playing = self2.playing(id);
              if (playing) {
                self2.pause(id, true);
              }
              sound._seek = seek;
              sound._ended = false;
              self2._clearTimer(id);
              if (!self2._webAudio && sound._node && !isNaN(sound._node.duration)) {
                sound._node.currentTime = seek;
              }
              var seekAndEmit = function() {
                if (playing) {
                  self2.play(id, true);
                }
                self2._emit("seek", id);
              };
              if (playing && !self2._webAudio) {
                var emitSeek = function() {
                  if (!self2._playLock) {
                    seekAndEmit();
                  } else {
                    setTimeout(emitSeek, 0);
                  }
                };
                setTimeout(emitSeek, 0);
              } else {
                seekAndEmit();
              }
            } else {
              if (self2._webAudio) {
                var realTime = self2.playing(id) ? Howler7.ctx.currentTime - sound._playStart : 0;
                var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
                return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
              } else {
                return sound._node.currentTime;
              }
            }
          }
          return self2;
        },
        /**
         * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
         * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
         * @return {Boolean} True if playing and false if not.
         */
        playing: function(id) {
          var self2 = this;
          if (typeof id === "number") {
            var sound = self2._soundById(id);
            return sound ? !sound._paused : false;
          }
          for (var i = 0; i < self2._sounds.length; i++) {
            if (!self2._sounds[i]._paused) {
              return true;
            }
          }
          return false;
        },
        /**
         * Get the duration of this sound. Passing a sound id will return the sprite duration.
         * @param  {Number} id The sound id to check. If none is passed, return full source duration.
         * @return {Number} Audio duration in seconds.
         */
        duration: function(id) {
          var self2 = this;
          var duration = self2._duration;
          var sound = self2._soundById(id);
          if (sound) {
            duration = self2._sprite[sound._sprite][1] / 1e3;
          }
          return duration;
        },
        /**
         * Returns the current loaded state of this Howl.
         * @return {String} 'unloaded', 'loading', 'loaded'
         */
        state: function() {
          return this._state;
        },
        /**
         * Unload and destroy the current Howl object.
         * This will immediately stop all sound instances attached to this group.
         */
        unload: function() {
          var self2 = this;
          var sounds = self2._sounds;
          for (var i = 0; i < sounds.length; i++) {
            if (!sounds[i]._paused) {
              self2.stop(sounds[i]._id);
            }
            if (!self2._webAudio) {
              self2._clearSound(sounds[i]._node);
              sounds[i]._node.removeEventListener("error", sounds[i]._errorFn, false);
              sounds[i]._node.removeEventListener(Howler7._canPlayEvent, sounds[i]._loadFn, false);
              sounds[i]._node.removeEventListener("ended", sounds[i]._endFn, false);
              Howler7._releaseHtml5Audio(sounds[i]._node);
            }
            delete sounds[i]._node;
            self2._clearTimer(sounds[i]._id);
          }
          var index = Howler7._howls.indexOf(self2);
          if (index >= 0) {
            Howler7._howls.splice(index, 1);
          }
          var remCache = true;
          for (i = 0; i < Howler7._howls.length; i++) {
            if (Howler7._howls[i]._src === self2._src || self2._src.indexOf(Howler7._howls[i]._src) >= 0) {
              remCache = false;
              break;
            }
          }
          if (cache && remCache) {
            delete cache[self2._src];
          }
          Howler7.noAudio = false;
          self2._state = "unloaded";
          self2._sounds = [];
          self2 = null;
          return null;
        },
        /**
         * Listen to a custom event.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to call.
         * @param  {Number}   id    (optional) Only listen to events for this sound.
         * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
         * @return {Howl}
         */
        on: function(event, fn, id, once) {
          var self2 = this;
          var events = self2["_on" + event];
          if (typeof fn === "function") {
            events.push(once ? { id, fn, once } : { id, fn });
          }
          return self2;
        },
        /**
         * Remove a custom event. Call without parameters to remove all events.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to remove. Leave empty to remove all.
         * @param  {Number}   id    (optional) Only remove events for this sound.
         * @return {Howl}
         */
        off: function(event, fn, id) {
          var self2 = this;
          var events = self2["_on" + event];
          var i = 0;
          if (typeof fn === "number") {
            id = fn;
            fn = null;
          }
          if (fn || id) {
            for (i = 0; i < events.length; i++) {
              var isId = id === events[i].id;
              if (fn === events[i].fn && isId || !fn && isId) {
                events.splice(i, 1);
                break;
              }
            }
          } else if (event) {
            self2["_on" + event] = [];
          } else {
            var keys = Object.keys(self2);
            for (i = 0; i < keys.length; i++) {
              if (keys[i].indexOf("_on") === 0 && Array.isArray(self2[keys[i]])) {
                self2[keys[i]] = [];
              }
            }
          }
          return self2;
        },
        /**
         * Listen to a custom event and remove it once fired.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to call.
         * @param  {Number}   id    (optional) Only listen to events for this sound.
         * @return {Howl}
         */
        once: function(event, fn, id) {
          var self2 = this;
          self2.on(event, fn, id, 1);
          return self2;
        },
        /**
         * Emit all events of a specific type and pass the sound id.
         * @param  {String} event Event name.
         * @param  {Number} id    Sound ID.
         * @param  {Number} msg   Message to go with event.
         * @return {Howl}
         */
        _emit: function(event, id, msg) {
          var self2 = this;
          var events = self2["_on" + event];
          for (var i = events.length - 1; i >= 0; i--) {
            if (!events[i].id || events[i].id === id || event === "load") {
              setTimeout(function(fn) {
                fn.call(this, id, msg);
              }.bind(self2, events[i].fn), 0);
              if (events[i].once) {
                self2.off(event, events[i].fn, events[i].id);
              }
            }
          }
          self2._loadQueue(event);
          return self2;
        },
        /**
         * Queue of actions initiated before the sound has loaded.
         * These will be called in sequence, with the next only firing
         * after the previous has finished executing (even if async like play).
         * @return {Howl}
         */
        _loadQueue: function(event) {
          var self2 = this;
          if (self2._queue.length > 0) {
            var task = self2._queue[0];
            if (task.event === event) {
              self2._queue.shift();
              self2._loadQueue();
            }
            if (!event) {
              task.action();
            }
          }
          return self2;
        },
        /**
         * Fired when playback ends at the end of the duration.
         * @param  {Sound} sound The sound object to work with.
         * @return {Howl}
         */
        _ended: function(sound) {
          var self2 = this;
          var sprite = sound._sprite;
          if (!self2._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
            setTimeout(self2._ended.bind(self2, sound), 100);
            return self2;
          }
          var loop = !!(sound._loop || self2._sprite[sprite][2]);
          self2._emit("end", sound._id);
          if (!self2._webAudio && loop) {
            self2.stop(sound._id, true).play(sound._id);
          }
          if (self2._webAudio && loop) {
            self2._emit("play", sound._id);
            sound._seek = sound._start || 0;
            sound._rateSeek = 0;
            sound._playStart = Howler7.ctx.currentTime;
            var timeout2 = (sound._stop - sound._start) * 1e3 / Math.abs(sound._rate);
            self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout2);
          }
          if (self2._webAudio && !loop) {
            sound._paused = true;
            sound._ended = true;
            sound._seek = sound._start || 0;
            sound._rateSeek = 0;
            self2._clearTimer(sound._id);
            self2._cleanBuffer(sound._node);
            Howler7._autoSuspend();
          }
          if (!self2._webAudio && !loop) {
            self2.stop(sound._id, true);
          }
          return self2;
        },
        /**
         * Clear the end timer for a sound playback.
         * @param  {Number} id The sound ID.
         * @return {Howl}
         */
        _clearTimer: function(id) {
          var self2 = this;
          if (self2._endTimers[id]) {
            if (typeof self2._endTimers[id] !== "function") {
              clearTimeout(self2._endTimers[id]);
            } else {
              var sound = self2._soundById(id);
              if (sound && sound._node) {
                sound._node.removeEventListener("ended", self2._endTimers[id], false);
              }
            }
            delete self2._endTimers[id];
          }
          return self2;
        },
        /**
         * Return the sound identified by this ID, or return null.
         * @param  {Number} id Sound ID
         * @return {Object}    Sound object or null.
         */
        _soundById: function(id) {
          var self2 = this;
          for (var i = 0; i < self2._sounds.length; i++) {
            if (id === self2._sounds[i]._id) {
              return self2._sounds[i];
            }
          }
          return null;
        },
        /**
         * Return an inactive sound from the pool or create a new one.
         * @return {Sound} Sound playback object.
         */
        _inactiveSound: function() {
          var self2 = this;
          self2._drain();
          for (var i = 0; i < self2._sounds.length; i++) {
            if (self2._sounds[i]._ended) {
              return self2._sounds[i].reset();
            }
          }
          return new Sound2(self2);
        },
        /**
         * Drain excess inactive sounds from the pool.
         */
        _drain: function() {
          var self2 = this;
          var limit = self2._pool;
          var cnt = 0;
          var i = 0;
          if (self2._sounds.length < limit) {
            return;
          }
          for (i = 0; i < self2._sounds.length; i++) {
            if (self2._sounds[i]._ended) {
              cnt++;
            }
          }
          for (i = self2._sounds.length - 1; i >= 0; i--) {
            if (cnt <= limit) {
              return;
            }
            if (self2._sounds[i]._ended) {
              if (self2._webAudio && self2._sounds[i]._node) {
                self2._sounds[i]._node.disconnect(0);
              }
              self2._sounds.splice(i, 1);
              cnt--;
            }
          }
        },
        /**
         * Get all ID's from the sounds pool.
         * @param  {Number} id Only return one ID if one is passed.
         * @return {Array}    Array of IDs.
         */
        _getSoundIds: function(id) {
          var self2 = this;
          if (typeof id === "undefined") {
            var ids = [];
            for (var i = 0; i < self2._sounds.length; i++) {
              ids.push(self2._sounds[i]._id);
            }
            return ids;
          } else {
            return [id];
          }
        },
        /**
         * Load the sound back into the buffer source.
         * @param  {Sound} sound The sound object to work with.
         * @return {Howl}
         */
        _refreshBuffer: function(sound) {
          var self2 = this;
          sound._node.bufferSource = Howler7.ctx.createBufferSource();
          sound._node.bufferSource.buffer = cache[self2._src];
          if (sound._panner) {
            sound._node.bufferSource.connect(sound._panner);
          } else {
            sound._node.bufferSource.connect(sound._node);
          }
          sound._node.bufferSource.loop = sound._loop;
          if (sound._loop) {
            sound._node.bufferSource.loopStart = sound._start || 0;
            sound._node.bufferSource.loopEnd = sound._stop || 0;
          }
          sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler7.ctx.currentTime);
          return self2;
        },
        /**
         * Prevent memory leaks by cleaning up the buffer source after playback.
         * @param  {Object} node Sound's audio node containing the buffer source.
         * @return {Howl}
         */
        _cleanBuffer: function(node) {
          var self2 = this;
          var isIOS = Howler7._navigator && Howler7._navigator.vendor.indexOf("Apple") >= 0;
          if (!node.bufferSource) {
            return self2;
          }
          if (Howler7._scratchBuffer && node.bufferSource) {
            node.bufferSource.onended = null;
            node.bufferSource.disconnect(0);
            if (isIOS) {
              try {
                node.bufferSource.buffer = Howler7._scratchBuffer;
              } catch (e) {
              }
            }
          }
          node.bufferSource = null;
          return self2;
        },
        /**
         * Set the source to a 0-second silence to stop any downloading (except in IE).
         * @param  {Object} node Audio node to clear.
         */
        _clearSound: function(node) {
          var checkIE = /MSIE |Trident\//.test(Howler7._navigator && Howler7._navigator.userAgent);
          if (!checkIE) {
            node.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA";
          }
        }
      };
      var Sound2 = function(howl) {
        this._parent = howl;
        this.init();
      };
      Sound2.prototype = {
        /**
         * Initialize a new Sound object.
         * @return {Sound}
         */
        init: function() {
          var self2 = this;
          var parent = self2._parent;
          self2._muted = parent._muted;
          self2._loop = parent._loop;
          self2._volume = parent._volume;
          self2._rate = parent._rate;
          self2._seek = 0;
          self2._paused = true;
          self2._ended = true;
          self2._sprite = "__default";
          self2._id = ++Howler7._counter;
          parent._sounds.push(self2);
          self2.create();
          return self2;
        },
        /**
         * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
         * @return {Sound}
         */
        create: function() {
          var self2 = this;
          var parent = self2._parent;
          var volume = Howler7._muted || self2._muted || self2._parent._muted ? 0 : self2._volume;
          if (parent._webAudio) {
            self2._node = typeof Howler7.ctx.createGain === "undefined" ? Howler7.ctx.createGainNode() : Howler7.ctx.createGain();
            self2._node.gain.setValueAtTime(volume, Howler7.ctx.currentTime);
            self2._node.paused = true;
            self2._node.connect(Howler7.masterGain);
          } else if (!Howler7.noAudio) {
            self2._node = Howler7._obtainHtml5Audio();
            self2._errorFn = self2._errorListener.bind(self2);
            self2._node.addEventListener("error", self2._errorFn, false);
            self2._loadFn = self2._loadListener.bind(self2);
            self2._node.addEventListener(Howler7._canPlayEvent, self2._loadFn, false);
            self2._endFn = self2._endListener.bind(self2);
            self2._node.addEventListener("ended", self2._endFn, false);
            self2._node.src = parent._src;
            self2._node.preload = parent._preload === true ? "auto" : parent._preload;
            self2._node.volume = volume * Howler7.volume();
            self2._node.load();
          }
          return self2;
        },
        /**
         * Reset the parameters of this sound to the original state (for recycle).
         * @return {Sound}
         */
        reset: function() {
          var self2 = this;
          var parent = self2._parent;
          self2._muted = parent._muted;
          self2._loop = parent._loop;
          self2._volume = parent._volume;
          self2._rate = parent._rate;
          self2._seek = 0;
          self2._rateSeek = 0;
          self2._paused = true;
          self2._ended = true;
          self2._sprite = "__default";
          self2._id = ++Howler7._counter;
          return self2;
        },
        /**
         * HTML5 Audio error listener callback.
         */
        _errorListener: function() {
          var self2 = this;
          self2._parent._emit("loaderror", self2._id, self2._node.error ? self2._node.error.code : 0);
          self2._node.removeEventListener("error", self2._errorFn, false);
        },
        /**
         * HTML5 Audio canplaythrough listener callback.
         */
        _loadListener: function() {
          var self2 = this;
          var parent = self2._parent;
          parent._duration = Math.ceil(self2._node.duration * 10) / 10;
          if (Object.keys(parent._sprite).length === 0) {
            parent._sprite = { __default: [0, parent._duration * 1e3] };
          }
          if (parent._state !== "loaded") {
            parent._state = "loaded";
            parent._emit("load");
            parent._loadQueue();
          }
          self2._node.removeEventListener(Howler7._canPlayEvent, self2._loadFn, false);
        },
        /**
         * HTML5 Audio ended listener callback.
         */
        _endListener: function() {
          var self2 = this;
          var parent = self2._parent;
          if (parent._duration === Infinity) {
            parent._duration = Math.ceil(self2._node.duration * 10) / 10;
            if (parent._sprite.__default[1] === Infinity) {
              parent._sprite.__default[1] = parent._duration * 1e3;
            }
            parent._ended(self2);
          }
          self2._node.removeEventListener("ended", self2._endFn, false);
        }
      };
      var cache = {};
      var loadBuffer = function(self2) {
        var url = self2._src;
        if (cache[url]) {
          self2._duration = cache[url].duration;
          loadSound(self2);
          return;
        }
        if (/^data:[^;]+;base64,/.test(url)) {
          var data = atob(url.split(",")[1]);
          var dataView = new Uint8Array(data.length);
          for (var i = 0; i < data.length; ++i) {
            dataView[i] = data.charCodeAt(i);
          }
          decodeAudioData(dataView.buffer, self2);
        } else {
          var xhr = new XMLHttpRequest();
          xhr.open(self2._xhr.method, url, true);
          xhr.withCredentials = self2._xhr.withCredentials;
          xhr.responseType = "arraybuffer";
          if (self2._xhr.headers) {
            Object.keys(self2._xhr.headers).forEach(function(key) {
              xhr.setRequestHeader(key, self2._xhr.headers[key]);
            });
          }
          xhr.onload = function() {
            var code = (xhr.status + "")[0];
            if (code !== "0" && code !== "2" && code !== "3") {
              self2._emit("loaderror", null, "Failed loading audio file with status: " + xhr.status + ".");
              return;
            }
            decodeAudioData(xhr.response, self2);
          };
          xhr.onerror = function() {
            if (self2._webAudio) {
              self2._html5 = true;
              self2._webAudio = false;
              self2._sounds = [];
              delete cache[url];
              self2.load();
            }
          };
          safeXhrSend(xhr);
        }
      };
      var safeXhrSend = function(xhr) {
        try {
          xhr.send();
        } catch (e) {
          xhr.onerror();
        }
      };
      var decodeAudioData = function(arraybuffer, self2) {
        var error3 = function() {
          self2._emit("loaderror", null, "Decoding audio data failed.");
        };
        var success = function(buffer) {
          if (buffer && self2._sounds.length > 0) {
            cache[self2._src] = buffer;
            loadSound(self2, buffer);
          } else {
            error3();
          }
        };
        if (typeof Promise !== "undefined" && Howler7.ctx.decodeAudioData.length === 1) {
          Howler7.ctx.decodeAudioData(arraybuffer).then(success).catch(error3);
        } else {
          Howler7.ctx.decodeAudioData(arraybuffer, success, error3);
        }
      };
      var loadSound = function(self2, buffer) {
        if (buffer && !self2._duration) {
          self2._duration = buffer.duration;
        }
        if (Object.keys(self2._sprite).length === 0) {
          self2._sprite = { __default: [0, self2._duration * 1e3] };
        }
        if (self2._state !== "loaded") {
          self2._state = "loaded";
          self2._emit("load");
          self2._loadQueue();
        }
      };
      var setupAudioContext = function() {
        if (!Howler7.usingWebAudio) {
          return;
        }
        try {
          if (typeof AudioContext !== "undefined") {
            Howler7.ctx = new AudioContext();
          } else if (typeof webkitAudioContext !== "undefined") {
            Howler7.ctx = new webkitAudioContext();
          } else {
            Howler7.usingWebAudio = false;
          }
        } catch (e) {
          Howler7.usingWebAudio = false;
        }
        if (!Howler7.ctx) {
          Howler7.usingWebAudio = false;
        }
        var iOS = /iP(hone|od|ad)/.test(Howler7._navigator && Howler7._navigator.platform);
        var appVersion = Howler7._navigator && Howler7._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
        var version = appVersion ? parseInt(appVersion[1], 10) : null;
        if (iOS && version && version < 9) {
          var safari = /safari/.test(Howler7._navigator && Howler7._navigator.userAgent.toLowerCase());
          if (Howler7._navigator && !safari) {
            Howler7.usingWebAudio = false;
          }
        }
        if (Howler7.usingWebAudio) {
          Howler7.masterGain = typeof Howler7.ctx.createGain === "undefined" ? Howler7.ctx.createGainNode() : Howler7.ctx.createGain();
          Howler7.masterGain.gain.setValueAtTime(Howler7._muted ? 0 : Howler7._volume, Howler7.ctx.currentTime);
          Howler7.masterGain.connect(Howler7.ctx.destination);
        }
        Howler7._setup();
      };
      if (typeof define === "function" && define.amd) {
        define([], function() {
          return {
            Howler: Howler7,
            Howl: Howl3
          };
        });
      }
      if (typeof exports !== "undefined") {
        exports.Howler = Howler7;
        exports.Howl = Howl3;
      }
      if (typeof global !== "undefined") {
        global.HowlerGlobal = HowlerGlobal2;
        global.Howler = Howler7;
        global.Howl = Howl3;
        global.Sound = Sound2;
      } else if (typeof window !== "undefined") {
        window.HowlerGlobal = HowlerGlobal2;
        window.Howler = Howler7;
        window.Howl = Howl3;
        window.Sound = Sound2;
      }
    })();
    (function() {
      "use strict";
      HowlerGlobal.prototype._pos = [0, 0, 0];
      HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];
      HowlerGlobal.prototype.stereo = function(pan) {
        var self2 = this;
        if (!self2.ctx || !self2.ctx.listener) {
          return self2;
        }
        for (var i = self2._howls.length - 1; i >= 0; i--) {
          self2._howls[i].stereo(pan);
        }
        return self2;
      };
      HowlerGlobal.prototype.pos = function(x, y, z) {
        var self2 = this;
        if (!self2.ctx || !self2.ctx.listener) {
          return self2;
        }
        y = typeof y !== "number" ? self2._pos[1] : y;
        z = typeof z !== "number" ? self2._pos[2] : z;
        if (typeof x === "number") {
          self2._pos = [x, y, z];
          if (typeof self2.ctx.listener.positionX !== "undefined") {
            self2.ctx.listener.positionX.setTargetAtTime(self2._pos[0], Howler.ctx.currentTime, 0.1);
            self2.ctx.listener.positionY.setTargetAtTime(self2._pos[1], Howler.ctx.currentTime, 0.1);
            self2.ctx.listener.positionZ.setTargetAtTime(self2._pos[2], Howler.ctx.currentTime, 0.1);
          } else {
            self2.ctx.listener.setPosition(self2._pos[0], self2._pos[1], self2._pos[2]);
          }
        } else {
          return self2._pos;
        }
        return self2;
      };
      HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
        var self2 = this;
        if (!self2.ctx || !self2.ctx.listener) {
          return self2;
        }
        var or = self2._orientation;
        y = typeof y !== "number" ? or[1] : y;
        z = typeof z !== "number" ? or[2] : z;
        xUp = typeof xUp !== "number" ? or[3] : xUp;
        yUp = typeof yUp !== "number" ? or[4] : yUp;
        zUp = typeof zUp !== "number" ? or[5] : zUp;
        if (typeof x === "number") {
          self2._orientation = [x, y, z, xUp, yUp, zUp];
          if (typeof self2.ctx.listener.forwardX !== "undefined") {
            self2.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);
            self2.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);
            self2.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);
            self2.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
            self2.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
            self2.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
          } else {
            self2.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
          }
        } else {
          return or;
        }
        return self2;
      };
      Howl.prototype.init = function(_super) {
        return function(o) {
          var self2 = this;
          self2._orientation = o.orientation || [1, 0, 0];
          self2._stereo = o.stereo || null;
          self2._pos = o.pos || null;
          self2._pannerAttr = {
            coneInnerAngle: typeof o.coneInnerAngle !== "undefined" ? o.coneInnerAngle : 360,
            coneOuterAngle: typeof o.coneOuterAngle !== "undefined" ? o.coneOuterAngle : 360,
            coneOuterGain: typeof o.coneOuterGain !== "undefined" ? o.coneOuterGain : 0,
            distanceModel: typeof o.distanceModel !== "undefined" ? o.distanceModel : "inverse",
            maxDistance: typeof o.maxDistance !== "undefined" ? o.maxDistance : 1e4,
            panningModel: typeof o.panningModel !== "undefined" ? o.panningModel : "HRTF",
            refDistance: typeof o.refDistance !== "undefined" ? o.refDistance : 1,
            rolloffFactor: typeof o.rolloffFactor !== "undefined" ? o.rolloffFactor : 1
          };
          self2._onstereo = o.onstereo ? [{ fn: o.onstereo }] : [];
          self2._onpos = o.onpos ? [{ fn: o.onpos }] : [];
          self2._onorientation = o.onorientation ? [{ fn: o.onorientation }] : [];
          return _super.call(this, o);
        };
      }(Howl.prototype.init);
      Howl.prototype.stereo = function(pan, id) {
        var self2 = this;
        if (!self2._webAudio) {
          return self2;
        }
        if (self2._state !== "loaded") {
          self2._queue.push({
            event: "stereo",
            action: function() {
              self2.stereo(pan, id);
            }
          });
          return self2;
        }
        var pannerType = typeof Howler.ctx.createStereoPanner === "undefined" ? "spatial" : "stereo";
        if (typeof id === "undefined") {
          if (typeof pan === "number") {
            self2._stereo = pan;
            self2._pos = [pan, 0, 0];
          } else {
            return self2._stereo;
          }
        }
        var ids = self2._getSoundIds(id);
        for (var i = 0; i < ids.length; i++) {
          var sound = self2._soundById(ids[i]);
          if (sound) {
            if (typeof pan === "number") {
              sound._stereo = pan;
              sound._pos = [pan, 0, 0];
              if (sound._node) {
                sound._pannerAttr.panningModel = "equalpower";
                if (!sound._panner || !sound._panner.pan) {
                  setupPanner(sound, pannerType);
                }
                if (pannerType === "spatial") {
                  if (typeof sound._panner.positionX !== "undefined") {
                    sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
                    sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
                    sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
                  } else {
                    sound._panner.setPosition(pan, 0, 0);
                  }
                } else {
                  sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
                }
              }
              self2._emit("stereo", sound._id);
            } else {
              return sound._stereo;
            }
          }
        }
        return self2;
      };
      Howl.prototype.pos = function(x, y, z, id) {
        var self2 = this;
        if (!self2._webAudio) {
          return self2;
        }
        if (self2._state !== "loaded") {
          self2._queue.push({
            event: "pos",
            action: function() {
              self2.pos(x, y, z, id);
            }
          });
          return self2;
        }
        y = typeof y !== "number" ? 0 : y;
        z = typeof z !== "number" ? -0.5 : z;
        if (typeof id === "undefined") {
          if (typeof x === "number") {
            self2._pos = [x, y, z];
          } else {
            return self2._pos;
          }
        }
        var ids = self2._getSoundIds(id);
        for (var i = 0; i < ids.length; i++) {
          var sound = self2._soundById(ids[i]);
          if (sound) {
            if (typeof x === "number") {
              sound._pos = [x, y, z];
              if (sound._node) {
                if (!sound._panner || sound._panner.pan) {
                  setupPanner(sound, "spatial");
                }
                if (typeof sound._panner.positionX !== "undefined") {
                  sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);
                  sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);
                  sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);
                } else {
                  sound._panner.setPosition(x, y, z);
                }
              }
              self2._emit("pos", sound._id);
            } else {
              return sound._pos;
            }
          }
        }
        return self2;
      };
      Howl.prototype.orientation = function(x, y, z, id) {
        var self2 = this;
        if (!self2._webAudio) {
          return self2;
        }
        if (self2._state !== "loaded") {
          self2._queue.push({
            event: "orientation",
            action: function() {
              self2.orientation(x, y, z, id);
            }
          });
          return self2;
        }
        y = typeof y !== "number" ? self2._orientation[1] : y;
        z = typeof z !== "number" ? self2._orientation[2] : z;
        if (typeof id === "undefined") {
          if (typeof x === "number") {
            self2._orientation = [x, y, z];
          } else {
            return self2._orientation;
          }
        }
        var ids = self2._getSoundIds(id);
        for (var i = 0; i < ids.length; i++) {
          var sound = self2._soundById(ids[i]);
          if (sound) {
            if (typeof x === "number") {
              sound._orientation = [x, y, z];
              if (sound._node) {
                if (!sound._panner) {
                  if (!sound._pos) {
                    sound._pos = self2._pos || [0, 0, -0.5];
                  }
                  setupPanner(sound, "spatial");
                }
                if (typeof sound._panner.orientationX !== "undefined") {
                  sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);
                  sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);
                  sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);
                } else {
                  sound._panner.setOrientation(x, y, z);
                }
              }
              self2._emit("orientation", sound._id);
            } else {
              return sound._orientation;
            }
          }
        }
        return self2;
      };
      Howl.prototype.pannerAttr = function() {
        var self2 = this;
        var args = arguments;
        var o, id, sound;
        if (!self2._webAudio) {
          return self2;
        }
        if (args.length === 0) {
          return self2._pannerAttr;
        } else if (args.length === 1) {
          if (typeof args[0] === "object") {
            o = args[0];
            if (typeof id === "undefined") {
              if (!o.pannerAttr) {
                o.pannerAttr = {
                  coneInnerAngle: o.coneInnerAngle,
                  coneOuterAngle: o.coneOuterAngle,
                  coneOuterGain: o.coneOuterGain,
                  distanceModel: o.distanceModel,
                  maxDistance: o.maxDistance,
                  refDistance: o.refDistance,
                  rolloffFactor: o.rolloffFactor,
                  panningModel: o.panningModel
                };
              }
              self2._pannerAttr = {
                coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== "undefined" ? o.pannerAttr.coneInnerAngle : self2._coneInnerAngle,
                coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== "undefined" ? o.pannerAttr.coneOuterAngle : self2._coneOuterAngle,
                coneOuterGain: typeof o.pannerAttr.coneOuterGain !== "undefined" ? o.pannerAttr.coneOuterGain : self2._coneOuterGain,
                distanceModel: typeof o.pannerAttr.distanceModel !== "undefined" ? o.pannerAttr.distanceModel : self2._distanceModel,
                maxDistance: typeof o.pannerAttr.maxDistance !== "undefined" ? o.pannerAttr.maxDistance : self2._maxDistance,
                refDistance: typeof o.pannerAttr.refDistance !== "undefined" ? o.pannerAttr.refDistance : self2._refDistance,
                rolloffFactor: typeof o.pannerAttr.rolloffFactor !== "undefined" ? o.pannerAttr.rolloffFactor : self2._rolloffFactor,
                panningModel: typeof o.pannerAttr.panningModel !== "undefined" ? o.pannerAttr.panningModel : self2._panningModel
              };
            }
          } else {
            sound = self2._soundById(parseInt(args[0], 10));
            return sound ? sound._pannerAttr : self2._pannerAttr;
          }
        } else if (args.length === 2) {
          o = args[0];
          id = parseInt(args[1], 10);
        }
        var ids = self2._getSoundIds(id);
        for (var i = 0; i < ids.length; i++) {
          sound = self2._soundById(ids[i]);
          if (sound) {
            var pa = sound._pannerAttr;
            pa = {
              coneInnerAngle: typeof o.coneInnerAngle !== "undefined" ? o.coneInnerAngle : pa.coneInnerAngle,
              coneOuterAngle: typeof o.coneOuterAngle !== "undefined" ? o.coneOuterAngle : pa.coneOuterAngle,
              coneOuterGain: typeof o.coneOuterGain !== "undefined" ? o.coneOuterGain : pa.coneOuterGain,
              distanceModel: typeof o.distanceModel !== "undefined" ? o.distanceModel : pa.distanceModel,
              maxDistance: typeof o.maxDistance !== "undefined" ? o.maxDistance : pa.maxDistance,
              refDistance: typeof o.refDistance !== "undefined" ? o.refDistance : pa.refDistance,
              rolloffFactor: typeof o.rolloffFactor !== "undefined" ? o.rolloffFactor : pa.rolloffFactor,
              panningModel: typeof o.panningModel !== "undefined" ? o.panningModel : pa.panningModel
            };
            var panner = sound._panner;
            if (!panner) {
              if (!sound._pos) {
                sound._pos = self2._pos || [0, 0, -0.5];
              }
              setupPanner(sound, "spatial");
              panner = sound._panner;
            }
            panner.coneInnerAngle = pa.coneInnerAngle;
            panner.coneOuterAngle = pa.coneOuterAngle;
            panner.coneOuterGain = pa.coneOuterGain;
            panner.distanceModel = pa.distanceModel;
            panner.maxDistance = pa.maxDistance;
            panner.refDistance = pa.refDistance;
            panner.rolloffFactor = pa.rolloffFactor;
            panner.panningModel = pa.panningModel;
          }
        }
        return self2;
      };
      Sound.prototype.init = function(_super) {
        return function() {
          var self2 = this;
          var parent = self2._parent;
          self2._orientation = parent._orientation;
          self2._stereo = parent._stereo;
          self2._pos = parent._pos;
          self2._pannerAttr = parent._pannerAttr;
          _super.call(this);
          if (self2._stereo) {
            parent.stereo(self2._stereo);
          } else if (self2._pos) {
            parent.pos(self2._pos[0], self2._pos[1], self2._pos[2], self2._id);
          }
        };
      }(Sound.prototype.init);
      Sound.prototype.reset = function(_super) {
        return function() {
          var self2 = this;
          var parent = self2._parent;
          self2._orientation = parent._orientation;
          self2._stereo = parent._stereo;
          self2._pos = parent._pos;
          self2._pannerAttr = parent._pannerAttr;
          if (self2._stereo) {
            parent.stereo(self2._stereo);
          } else if (self2._pos) {
            parent.pos(self2._pos[0], self2._pos[1], self2._pos[2], self2._id);
          } else if (self2._panner) {
            self2._panner.disconnect(0);
            self2._panner = void 0;
            parent._refreshBuffer(self2);
          }
          return _super.call(this);
        };
      }(Sound.prototype.reset);
      var setupPanner = function(sound, type) {
        type = type || "spatial";
        if (type === "spatial") {
          sound._panner = Howler.ctx.createPanner();
          sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
          sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
          sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
          sound._panner.distanceModel = sound._pannerAttr.distanceModel;
          sound._panner.maxDistance = sound._pannerAttr.maxDistance;
          sound._panner.refDistance = sound._pannerAttr.refDistance;
          sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
          sound._panner.panningModel = sound._pannerAttr.panningModel;
          if (typeof sound._panner.positionX !== "undefined") {
            sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);
            sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);
            sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);
          } else {
            sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
          }
          if (typeof sound._panner.orientationX !== "undefined") {
            sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);
            sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);
            sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);
          } else {
            sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
          }
        } else {
          sound._panner = Howler.ctx.createStereoPanner();
          sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);
        }
        sound._panner.connect(sound._node);
        if (!sound._paused) {
          sound._parent.pause(sound._id, true).play(sound._id, true);
        }
      };
    })();
  }
});

// node_modules/earcut/src/earcut.js
var require_earcut = __commonJS({
  "node_modules/earcut/src/earcut.js"(exports, module) {
    "use strict";
    module.exports = earcut2;
    module.exports.default = earcut2;
    function earcut2(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev)
        return triangles;
      var minX, minY, maxX, maxY, x, y, invSize;
      if (hasHoles)
        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i = dim; i < outerLen; i += dim) {
          x = data[i];
          y = data[i + 1];
          if (x < minX)
            minX = x;
          if (y < minY)
            minY = y;
          if (x > maxX)
            maxX = x;
          if (y > maxY)
            maxY = y;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
      return triangles;
    }
    function linkedList(data, start, end, dim, clockwise) {
      var i, last2;
      if (clockwise === signedArea(data, start, end, dim) > 0) {
        for (i = start; i < end; i += dim)
          last2 = insertNode(i, data[i], data[i + 1], last2);
      } else {
        for (i = end - dim; i >= start; i -= dim)
          last2 = insertNode(i, data[i], data[i + 1], last2);
      }
      if (last2 && equals12(last2, last2.next)) {
        removeNode(last2);
        last2 = last2.next;
      }
      return last2;
    }
    function filterPoints(start, end) {
      if (!start)
        return start;
      if (!end)
        end = start;
      var p = start, again;
      do {
        again = false;
        if (!p.steiner && (equals12(p, p.next) || area(p.prev, p, p.next) === 0)) {
          removeNode(p);
          p = end = p.prev;
          if (p === p.next)
            break;
          again = true;
        } else {
          p = p.next;
        }
      } while (again || p !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear)
        return;
      if (!pass && invSize)
        indexCurve(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev.i / dim | 0);
          triangles.push(ear.i / dim | 0);
          triangles.push(next.i / dim | 0);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0)
        return false;
      var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var p = c.next;
      while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0)
        return false;
      var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
      var p = ear.prevZ, n = ear.nextZ;
      while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.prevZ;
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
          return false;
        n = n.nextZ;
      }
      while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.prevZ;
      }
      while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
          return false;
        n = n.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      var p = start;
      do {
        var a = p.prev, b = p.next.next;
        if (!equals12(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
          triangles.push(a.i / dim | 0);
          triangles.push(p.i / dim | 0);
          triangles.push(b.i / dim | 0);
          removeNode(p);
          removeNode(p.next);
          p = start = b;
        }
        p = p.next;
      } while (p !== start);
      return filterPoints(p);
    }
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
      var a = start;
      do {
        var b = a.next.next;
        while (b !== a.prev) {
          if (a.i !== b.i && isValidDiagonal(a, b)) {
            var c = splitPolygon(a, b);
            a = filterPoints(a, a.next);
            c = filterPoints(c, c.next);
            earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
            earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
            return;
          }
          b = b.next;
        }
        a = a.next;
      } while (a !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [], i, len6, start, end, list;
      for (i = 0, len6 = holeIndices.length; i < len6; i++) {
        start = holeIndices[i] * dim;
        end = i < len6 - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next)
          list.steiner = true;
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
      }
      return outerNode;
    }
    function compareX(a, b) {
      return a.x - b.x;
    }
    function eliminateHole(hole, outerNode) {
      var bridge = findHoleBridge(hole, outerNode);
      if (!bridge) {
        return outerNode;
      }
      var bridgeReverse = splitPolygon(bridge, hole);
      filterPoints(bridgeReverse, bridgeReverse.next);
      return filterPoints(bridge, bridge.next);
    }
    function findHoleBridge(hole, outerNode) {
      var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
      do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
          var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
          if (x <= hx && x > qx) {
            qx = x;
            m = p.x < p.next.x ? p : p.next;
            if (x === hx)
              return m;
          }
        }
        p = p.next;
      } while (p !== outerNode);
      if (!m)
        return null;
      var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
      p = m;
      do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
          tan = Math.abs(hy - p.y) / (hx - p.x);
          if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
            m = p;
            tanMin = tan;
          }
        }
        p = p.next;
      } while (p !== stop);
      return m;
    }
    function sectorContainsSector(m, p) {
      return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
    }
    function indexCurve(start, minX, minY, invSize) {
      var p = start;
      do {
        if (p.z === 0)
          p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
      } while (p !== start);
      p.prevZ.nextZ = null;
      p.prevZ = null;
      sortLinked(p);
    }
    function sortLinked(list) {
      var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p) {
          numMerges++;
          q = p;
          pSize = 0;
          for (i = 0; i < inSize; i++) {
            pSize++;
            q = q.nextZ;
            if (!q)
              break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q) {
            if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
              e = p;
              p = p.nextZ;
              pSize--;
            } else {
              e = q;
              q = q.nextZ;
              qSize--;
            }
            if (tail)
              tail.nextZ = e;
            else
              list = e;
            e.prevZ = tail;
            tail = e;
          }
          p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x, y, minX, minY, invSize) {
      x = (x - minX) * invSize | 0;
      y = (y - minY) * invSize | 0;
      x = (x | x << 8) & 16711935;
      x = (x | x << 4) & 252645135;
      x = (x | x << 2) & 858993459;
      x = (x | x << 1) & 1431655765;
      y = (y | y << 8) & 16711935;
      y = (y | y << 4) & 252645135;
      y = (y | y << 2) & 858993459;
      y = (y | y << 1) & 1431655765;
      return x | y << 1;
    }
    function getLeftmost(start) {
      var p = start, leftmost = start;
      do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
          leftmost = p;
        p = p.next;
      } while (p !== start);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }
    function isValidDiagonal(a, b) {
      return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
      (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
      (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
      equals12(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
    }
    function area(p, q, r) {
      return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    function equals12(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      var o1 = sign2(area(p1, q1, p2));
      var o2 = sign2(area(p1, q1, q2));
      var o3 = sign2(area(p2, q2, p1));
      var o4 = sign2(area(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4)
        return true;
      if (o1 === 0 && onSegment(p1, p2, q1))
        return true;
      if (o2 === 0 && onSegment(p1, q2, q1))
        return true;
      if (o3 === 0 && onSegment(p2, p1, q2))
        return true;
      if (o4 === 0 && onSegment(p2, q1, q2))
        return true;
      return false;
    }
    function onSegment(p, q, r) {
      return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
    }
    function sign2(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon(a, b) {
      var p = a;
      do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
          return true;
        p = p.next;
      } while (p !== a);
      return false;
    }
    function locallyInside(a, b) {
      return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    function middleInside(a, b) {
      var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
      do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
          inside = !inside;
        p = p.next;
      } while (p !== a);
      return inside;
    }
    function splitPolygon(a, b) {
      var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
      a.next = b;
      b.prev = a;
      a2.next = an;
      an.prev = a2;
      b2.next = a2;
      a2.prev = b2;
      bp.next = b2;
      b2.prev = bp;
      return b2;
    }
    function insertNode(i, x, y, last2) {
      var p = new Node(i, x, y);
      if (!last2) {
        p.prev = p;
        p.next = p;
      } else {
        p.next = last2.next;
        p.prev = last2;
        last2.next.prev = p;
        last2.next = p;
      }
      return p;
    }
    function removeNode(p) {
      p.next.prev = p.prev;
      p.prev.next = p.next;
      if (p.prevZ)
        p.prevZ.nextZ = p.nextZ;
      if (p.nextZ)
        p.nextZ.prevZ = p.prevZ;
    }
    function Node(i, x, y) {
      this.i = i;
      this.x = x;
      this.y = y;
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut2.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) {
        for (var i = 0, len6 = holeIndices.length; i < len6; i++) {
          var start = holeIndices[i] * dim;
          var end = i < len6 - 1 ? holeIndices[i + 1] * dim : data.length;
          polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
      }
      var trianglesArea = 0;
      for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
          (data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1])
        );
      }
      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data, start, end, dim) {
      var sum = 0;
      for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
      }
      return sum;
    }
    earcut2.flatten = function(data) {
      var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
          for (var d = 0; d < dim; d++)
            result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
          holeIndex += data[i - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  }
});

// node_modules/@wonderlandengine/components/dist/index.js
var dist_exports2 = {};
__export(dist_exports2, {
  ARCamera8thwall: () => ARCamera8thwall,
  Anchor: () => Anchor,
  Cursor: () => Cursor,
  CursorTarget: () => CursorTarget,
  DebugObject: () => DebugObject,
  DeviceOrientationLook: () => DeviceOrientationLook,
  FingerCursor: () => FingerCursor,
  FixedFoveation: () => FixedFoveation,
  HandTracking: () => HandTracking,
  HitTestLocation: () => HitTestLocation,
  HowlerAudioListener: () => HowlerAudioListener,
  HowlerAudioSource: () => HowlerAudioSource,
  ImageTexture: () => ImageTexture,
  MouseLookComponent: () => MouseLookComponent,
  PlaneDetection: () => PlaneDetection,
  PlayerHeight: () => PlayerHeight,
  TargetFramerate: () => TargetFramerate,
  TeleportComponent: () => TeleportComponent,
  Trail: () => Trail,
  TwoJointIkSolver: () => TwoJointIkSolver,
  VideoTexture: () => VideoTexture,
  VrModeActiveSwitch: () => VrModeActiveSwitch,
  Vrm: () => Vrm,
  WasdControlsComponent: () => WasdControlsComponent,
  isPointLocalOnXRPlanePolygon: () => isPointLocalOnXRPlanePolygon,
  isPointWorldOnXRPlanePolygon: () => isPointWorldOnXRPlanePolygon
});

// node_modules/@wonderlandengine/api/dist/index.js
var dist_exports = {};
__export(dist_exports, {
  APIVersion: () => APIVersion,
  Alignment: () => Alignment,
  Animation: () => Animation,
  AnimationComponent: () => AnimationComponent,
  AnimationState: () => AnimationState,
  BitSet: () => BitSet,
  BrokenComponent: () => BrokenComponent,
  Collider: () => Collider,
  CollisionComponent: () => CollisionComponent,
  CollisionEventType: () => CollisionEventType,
  Component: () => Component,
  DestroyedComponentInstance: () => DestroyedComponentInstance,
  DestroyedObjectInstance: () => DestroyedObjectInstance,
  DestroyedTextureInstance: () => DestroyedTextureInstance,
  Emitter: () => Emitter,
  ForceMode: () => ForceMode,
  I18N: () => I18N,
  InputComponent: () => InputComponent,
  InputType: () => InputType,
  Justification: () => Justification,
  LightComponent: () => LightComponent,
  LightType: () => LightType,
  LockAxis: () => LockAxis,
  LogLevel: () => LogLevel,
  LogTag: () => LogTag,
  Logger: () => Logger,
  Material: () => Material,
  MaterialParamType: () => MaterialParamType,
  Mesh: () => Mesh,
  MeshAttribute: () => MeshAttribute,
  MeshAttributeAccessor: () => MeshAttributeAccessor,
  MeshComponent: () => MeshComponent,
  MeshIndexType: () => MeshIndexType,
  MeshSkinningType: () => MeshSkinningType,
  Object: () => Object3D,
  Object3D: () => Object3D,
  PhysXComponent: () => PhysXComponent,
  Physics: () => Physics,
  Property: () => Property,
  RayHit: () => RayHit,
  RetainEmitter: () => RetainEmitter,
  Scene: () => Scene,
  Shape: () => Shape,
  Skin: () => Skin,
  TextComponent: () => TextComponent,
  TextEffect: () => TextEffect,
  Texture: () => Texture,
  TextureManager: () => TextureManager,
  Type: () => Type,
  ViewComponent: () => ViewComponent,
  WASM: () => WASM,
  WonderlandEngine: () => WonderlandEngine,
  XR: () => XR,
  checkRuntimeCompatibility: () => checkRuntimeCompatibility,
  inheritProperties: () => inheritProperties,
  loadRuntime: () => loadRuntime,
  math: () => math
});

// node_modules/wasm-feature-detect/dist/esm/index.js
var simd = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]));
var threads = () => (async (e) => {
  try {
    return "undefined" != typeof MessageChannel && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(e);
  } catch (e2) {
    return false;
  }
})(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11]));

// node_modules/@wonderlandengine/api/dist/property.js
var Type;
(function(Type2) {
  Type2[Type2["Native"] = 1] = "Native";
  Type2[Type2["Bool"] = 2] = "Bool";
  Type2[Type2["Int"] = 4] = "Int";
  Type2[Type2["Float"] = 8] = "Float";
  Type2[Type2["String"] = 16] = "String";
  Type2[Type2["Enum"] = 32] = "Enum";
  Type2[Type2["Object"] = 64] = "Object";
  Type2[Type2["Mesh"] = 128] = "Mesh";
  Type2[Type2["Texture"] = 256] = "Texture";
  Type2[Type2["Material"] = 512] = "Material";
  Type2[Type2["Animation"] = 1024] = "Animation";
  Type2[Type2["Skin"] = 2048] = "Skin";
  Type2[Type2["Color"] = 4096] = "Color";
})(Type || (Type = {}));
var Property = {
  /**
   * Create an boolean property.
   *
   * @param defaultValue The default value. If not provided, defaults to `false`.
   */
  bool(defaultValue = false) {
    return { type: Type.Bool, default: defaultValue };
  },
  /**
   * Create an integer property.
   *
   * @param defaultValue The default value. If not provided, defaults to `0`.
   */
  int(defaultValue = 0) {
    return { type: Type.Int, default: defaultValue };
  },
  /**
   * Create an float property.
   *
   * @param defaultValue The default value. If not provided, defaults to `0.0`.
   */
  float(defaultValue = 0) {
    return { type: Type.Float, default: defaultValue };
  },
  /**
   * Create an string property.
   *
   * @param defaultValue The default value. If not provided, defaults to `''`.
   */
  string(defaultValue = "") {
    return { type: Type.String, default: defaultValue };
  },
  /**
   * Create an enumeration property.
   *
   * @param values The list of values.
   * @param defaultValue The default value. Can be a string or an index into
   *     `values`. If not provided, defaults to the first element.
   */
  enum(values, defaultValue) {
    return { type: Type.Enum, values, default: defaultValue };
  },
  /** Create an {@link Object3D} reference property. */
  object(opts) {
    return { type: Type.Object, default: null, required: opts?.required ?? false };
  },
  /** Create a {@link Mesh} reference property. */
  mesh(opts) {
    return { type: Type.Mesh, default: null, required: opts?.required ?? false };
  },
  /** Create a {@link Texture} reference property. */
  texture(opts) {
    return { type: Type.Texture, default: null, required: opts?.required ?? false };
  },
  /** Create a {@link Material} reference property. */
  material(opts) {
    return { type: Type.Material, default: null, required: opts?.required ?? false };
  },
  /** Create an {@link Animation} reference property. */
  animation(opts) {
    return { type: Type.Animation, default: null, required: opts?.required ?? false };
  },
  /** Create a {@link Skin} reference property. */
  skin(opts) {
    return { type: Type.Skin, default: null, required: opts?.required ?? false };
  },
  /**
   * Create a color property.
   *
   * @param r The red component, in the range [0; 1].
   * @param g The green component, in the range [0; 1].
   * @param b The blue component, in the range [0; 1].
   * @param a The alpha component, in the range [0; 1].
   */
  color(r = 0, g = 0, b = 0, a = 1) {
    return { type: Type.Color, default: [r, g, b, a] };
  }
};

// node_modules/@wonderlandengine/api/dist/decorators.js
function propertyDecorator(data) {
  return function(target, propertyKey) {
    const ctor = target.constructor;
    ctor.Properties = ctor.hasOwnProperty("Properties") ? ctor.Properties : {};
    ctor.Properties[propertyKey] = data;
  };
}
function enumerable() {
  return function(_, __, descriptor) {
    descriptor.enumerable = true;
  };
}
function nativeProperty() {
  return function(target, propertyKey, descriptor) {
    enumerable()(target, propertyKey, descriptor);
    propertyDecorator({ type: Type.Native })(target, propertyKey);
  };
}
var property = {};
for (const name in Property) {
  property[name] = (...args) => {
    const functor = Property[name];
    return propertyDecorator(functor(...args));
  };
}

// node_modules/@wonderlandengine/api/dist/utils/object.js
function isString(value) {
  if (value === "")
    return true;
  return value && (typeof value === "string" || value.constructor === String);
}
function isNumber(value) {
  if (value === null || value === void 0)
    return false;
  return typeof value === "number" || value.constructor === Number;
}

// node_modules/@wonderlandengine/api/dist/utils/event.js
var TransactionType;
(function(TransactionType2) {
  TransactionType2[TransactionType2["Addition"] = 1] = "Addition";
  TransactionType2[TransactionType2["Removal"] = 2] = "Removal";
})(TransactionType || (TransactionType = {}));
var Emitter = class {
  /**
   * List of listeners to trigger when `notify` is called.
   *
   * @hidden
   */
  _listeners = [];
  /**
   * `true` if the emitter is currently notifying listeners. This
   * is used to defer addition and removal.
   *
   * @hidden
   */
  _notifying = false;
  /**
   * Pending additions / removals, performed during a notification.
   *
   * @hidden
   */
  _transactions = [];
  /**
   * Register a new listener to be triggered on {@link Emitter.notify}.
   *
   * Basic usage:
   *
   * ```js
   * emitter.add((data) => {
   *     console.log('event received!');
   *     console.log(data);
   * });
   * ```
   *
   * Automatically remove the listener when an event is received:
   *
   * ```js
   * emitter.add((data) => {
   *     console.log('event received!');
   *     console.log(data);
   * }, {once: true});
   * ```
   *
   * @param listener The callback to register.
   * @param opts The listener options. For more information, please have a look
   *     at the {@link ListenerOptions} interface.
   *
   * @returns Reference to self (for method chaining)
   */
  add(listener, opts = {}) {
    const { once = false, id = void 0 } = opts;
    const data = { id, once, callback: listener };
    if (this._notifying) {
      this._transactions.push({ type: TransactionType.Addition, data });
      return this;
    }
    this._listeners.push(data);
    return this;
  }
  /**
   * Equivalent to {@link Emitter.add}.
   *
   * @param listeners The callback(s) to register.
   * @returns Reference to self (for method chaining).
   *
   * @deprecated Please use {@link Emitter.add} instead.
   */
  push(...listeners) {
    for (const cb of listeners)
      this.add(cb);
    return this;
  }
  /**
   * Register a new listener to be triggered on {@link Emitter.notify}.
   *
   * Once notified, the listener will be automatically removed.
   *
   * The method is equivalent to calling {@link Emitter.add} with:
   *
   * ```js
   * emitter.add(listener, {once: true});
   * ```
   *
   * @param listener The callback to register.
   *
   * @returns Reference to self (for method chaining).
   */
  once(listener) {
    return this.add(listener, { once: true });
  }
  /**
   * Remove a registered listener.
   *
   * Usage with a callback:
   *
   * ```js
   * const listener = (data) => console.log(data);
   * emitter.add(listener);
   *
   * // Remove using the callback reference:
   * emitter.remove(listener);
   * ```
   *
   * Usage with an id:
   *
   * ```js
   * emitter.add((data) => console.log(data), {id: 'my-callback'});
   *
   * // Remove using the id:
   * emitter.remove('my-callback');
   * ```
   *
   * Using identifiers, you will need to ensure your value is unique to avoid
   * removing listeners from other libraries, e.g.,:
   *
   * ```js
   * emitter.add((data) => console.log(data), {id: 'non-unique'});
   * // This second listener could be added by a third-party library.
   * emitter.add((data) => console.log('Hello From Library!'), {id: 'non-unique'});
   *
   * // Ho Snap! This also removed the library listener!
   * emitter.remove('non-unique');
   * ```
   *
   * The identifier can be any type. However, remember that the comparison will be
   * by-value for primitive types (string, number), but by reference for objects.
   *
   * Example:
   *
   * ```js
   * emitter.add(() => console.log('Hello'), {id: {value: 42}});
   * emitter.add(() => console.log('World!'), {id: {value: 42}});
   * emitter.remove({value: 42}); // None of the above listeners match!
   * emitter.notify(); // Prints 'Hello' and 'World!'.
   * ```
   *
   * Here, both emitters have id `{value: 42}`, but the comparison is made by reference. Thus,
   * the `remove()` call has no effect. We can make it work by doing:
   *
   * ```js
   * const id = {value: 42};
   * emitter.add(() => console.log('Hello'), {id});
   * emitter.add(() => console.log('World!'), {id});
   * emitter.remove(id); // Same reference, it works!
   * emitter.notify(); // Doesn't print.
   * ```
   *
   * @param listener The registered callback or a value representing the `id`.
   *
   * @returns Reference to self (for method chaining)
   */
  remove(listener) {
    if (this._notifying) {
      this._transactions.push({ type: TransactionType.Removal, data: listener });
      return this;
    }
    const listeners = this._listeners;
    for (let i = 0; i < listeners.length; ++i) {
      const target = listeners[i];
      if (target.callback === listener || target.id === listener) {
        listeners.splice(i--, 1);
      }
    }
    return this;
  }
  /**
   * Check whether the listener is registered.
   *
   * @note This method performs a linear search.
   *
   * * @note Doesn't account for pending listeners, i.e.,
   * listeners added / removed during a notification.
   *
   * @param listener The registered callback or a value representing the `id`.
   * @returns `true` if the handle is found, `false` otherwise.
   */
  has(listener) {
    const listeners = this._listeners;
    for (let i = 0; i < listeners.length; ++i) {
      const target = listeners[i];
      if (target.callback === listener || target.id === listener)
        return true;
    }
    return false;
  }
  /**
   * Notify listeners with the given data object.
   *
   * @note This method ensures all listeners are called even if
   * an exception is thrown. For (possibly) faster notification,
   * please use {@link Emitter.notifyUnsafe}.
   *
   * @param data The data to pass to listener when invoked.
   */
  notify(...data) {
    const listeners = this._listeners;
    this._notifying = true;
    for (let i = 0; i < listeners.length; ++i) {
      const listener = listeners[i];
      if (listener.once)
        listeners.splice(i--, 1);
      try {
        listener.callback(...data);
      } catch (e) {
        console.error(e);
      }
    }
    this._notifying = false;
    this._flushTransactions();
  }
  /**
   * Notify listeners with the given data object.
   *
   * @note Because this method doesn't catch exceptions, some listeners
   * will be skipped on a throw. Please use {@link Emitter.notify} for safe
   * notification.
   *
   * @param data The data to pass to listener when invoked.
   */
  notifyUnsafe(...data) {
    const listeners = this._listeners;
    for (let i = 0; i < listeners.length; ++i) {
      const listener = listeners[i];
      if (listener.once)
        listeners.splice(i--, 1);
      listener.callback(...data);
    }
    this._flushTransactions();
  }
  /**
   * Return a promise that will resolve on the next event.
   *
   * @note The promise might never resolve if no event is sent.
   *
   * @returns A promise that resolves with the data passed to
   *     {@link Emitter.notify}.
   */
  promise() {
    return new Promise((res, _) => {
      this.once((...args) => {
        if (args.length > 1) {
          res(args);
        } else {
          res(args[0]);
        }
      });
    });
  }
  /**
   * Number of listeners.
   *
   * @note Doesn't account for pending listeners, i.e.,
   * listeners added / removed during a notification.
   */
  get listenerCount() {
    return this._listeners.length;
  }
  /** `true` if it has no listeners, `false` otherwise. */
  get isEmpty() {
    return this.listenerCount === 0;
  }
  /**
   * Flush all pending transactions.
   *
   * @hidden
   */
  _flushTransactions() {
    const listeners = this._listeners;
    for (const transaction of this._transactions) {
      if (transaction.type === TransactionType.Addition) {
        listeners.push(transaction.data);
      } else {
        this.remove(transaction.data);
      }
    }
    this._transactions.length = 0;
  }
};
var RetainEmitterUndefined = {};
var RetainEmitter = class extends Emitter {
  /** Pre-resolved data. @hidden */
  _event = RetainEmitterUndefined;
  /**
   * Emitter target used to reset the state of this emitter.
   *
   * @hidden
   */
  _reset;
  /** @override */
  add(listener, opts) {
    const immediate = opts?.immediate ?? true;
    if (this._event !== RetainEmitterUndefined && immediate) {
      listener(...this._event);
    }
    super.add(listener, opts);
    return this;
  }
  /**
   * @override
   *
   * @param listener The callback to register.
   * @param immediate If `true`, directly resolves if the emitter retains a value.
   *
   * @returns Reference to self (for method chaining).
   */
  once(listener, immediate) {
    return this.add(listener, { once: true, immediate });
  }
  /** @override */
  notify(...data) {
    this._event = data;
    super.notify(...data);
  }
  /** @override */
  notifyUnsafe(...data) {
    this._event = data;
    super.notifyUnsafe(...data);
  }
  /**
   * Reset the state of the emitter.
   *
   * Further call to {@link Emitter.add} will not automatically resolve,
   * until a new call to {@link Emitter.notify} is performed.
   *
   * @returns Reference to self (for method chaining)
   */
  reset() {
    this._event = RetainEmitterUndefined;
    return this;
  }
  /** Returns the retained data, or `undefined` if no data was retained. */
  get data() {
    return this.isDataRetained ? this._event : void 0;
  }
  /** `true` if data is retained from the last event, `false` otherwise. */
  get isDataRetained() {
    return this._event !== RetainEmitterUndefined;
  }
};

// node_modules/@wonderlandengine/api/dist/wonderland.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var LogTag;
(function(LogTag2) {
  LogTag2[LogTag2["Engine"] = 0] = "Engine";
  LogTag2[LogTag2["Scene"] = 1] = "Scene";
  LogTag2[LogTag2["Component"] = 2] = "Component";
})(LogTag || (LogTag = {}));
var Collider;
(function(Collider2) {
  Collider2[Collider2["Sphere"] = 0] = "Sphere";
  Collider2[Collider2["AxisAlignedBox"] = 1] = "AxisAlignedBox";
  Collider2[Collider2["Box"] = 2] = "Box";
})(Collider || (Collider = {}));
var Alignment;
(function(Alignment2) {
  Alignment2[Alignment2["Left"] = 0] = "Left";
  Alignment2[Alignment2["Center"] = 1] = "Center";
  Alignment2[Alignment2["Right"] = 2] = "Right";
})(Alignment || (Alignment = {}));
var Justification;
(function(Justification2) {
  Justification2[Justification2["Line"] = 0] = "Line";
  Justification2[Justification2["Middle"] = 1] = "Middle";
  Justification2[Justification2["Top"] = 2] = "Top";
  Justification2[Justification2["Bottom"] = 3] = "Bottom";
})(Justification || (Justification = {}));
var TextEffect;
(function(TextEffect2) {
  TextEffect2[TextEffect2["None"] = 0] = "None";
  TextEffect2[TextEffect2["Outline"] = 1] = "Outline";
})(TextEffect || (TextEffect = {}));
var InputType;
(function(InputType2) {
  InputType2[InputType2["Head"] = 0] = "Head";
  InputType2[InputType2["EyeLeft"] = 1] = "EyeLeft";
  InputType2[InputType2["EyeRight"] = 2] = "EyeRight";
  InputType2[InputType2["ControllerLeft"] = 3] = "ControllerLeft";
  InputType2[InputType2["ControllerRight"] = 4] = "ControllerRight";
  InputType2[InputType2["RayLeft"] = 5] = "RayLeft";
  InputType2[InputType2["RayRight"] = 6] = "RayRight";
})(InputType || (InputType = {}));
var LightType;
(function(LightType2) {
  LightType2[LightType2["Point"] = 0] = "Point";
  LightType2[LightType2["Spot"] = 1] = "Spot";
  LightType2[LightType2["Sun"] = 2] = "Sun";
})(LightType || (LightType = {}));
var AnimationState;
(function(AnimationState2) {
  AnimationState2[AnimationState2["Playing"] = 0] = "Playing";
  AnimationState2[AnimationState2["Paused"] = 1] = "Paused";
  AnimationState2[AnimationState2["Stopped"] = 2] = "Stopped";
})(AnimationState || (AnimationState = {}));
var ForceMode;
(function(ForceMode2) {
  ForceMode2[ForceMode2["Force"] = 0] = "Force";
  ForceMode2[ForceMode2["Impulse"] = 1] = "Impulse";
  ForceMode2[ForceMode2["VelocityChange"] = 2] = "VelocityChange";
  ForceMode2[ForceMode2["Acceleration"] = 3] = "Acceleration";
})(ForceMode || (ForceMode = {}));
var CollisionEventType;
(function(CollisionEventType2) {
  CollisionEventType2[CollisionEventType2["Touch"] = 0] = "Touch";
  CollisionEventType2[CollisionEventType2["TouchLost"] = 1] = "TouchLost";
  CollisionEventType2[CollisionEventType2["TriggerTouch"] = 2] = "TriggerTouch";
  CollisionEventType2[CollisionEventType2["TriggerTouchLost"] = 3] = "TriggerTouchLost";
})(CollisionEventType || (CollisionEventType = {}));
var Shape;
(function(Shape2) {
  Shape2[Shape2["None"] = 0] = "None";
  Shape2[Shape2["Sphere"] = 1] = "Sphere";
  Shape2[Shape2["Capsule"] = 2] = "Capsule";
  Shape2[Shape2["Box"] = 3] = "Box";
  Shape2[Shape2["Plane"] = 4] = "Plane";
  Shape2[Shape2["ConvexMesh"] = 5] = "ConvexMesh";
  Shape2[Shape2["TriangleMesh"] = 6] = "TriangleMesh";
})(Shape || (Shape = {}));
var MeshAttribute;
(function(MeshAttribute2) {
  MeshAttribute2[MeshAttribute2["Position"] = 0] = "Position";
  MeshAttribute2[MeshAttribute2["Tangent"] = 1] = "Tangent";
  MeshAttribute2[MeshAttribute2["Normal"] = 2] = "Normal";
  MeshAttribute2[MeshAttribute2["TextureCoordinate"] = 3] = "TextureCoordinate";
  MeshAttribute2[MeshAttribute2["Color"] = 4] = "Color";
  MeshAttribute2[MeshAttribute2["JointId"] = 5] = "JointId";
  MeshAttribute2[MeshAttribute2["JointWeight"] = 6] = "JointWeight";
})(MeshAttribute || (MeshAttribute = {}));
var MaterialParamType;
(function(MaterialParamType2) {
  MaterialParamType2[MaterialParamType2["UnsignedInt"] = 0] = "UnsignedInt";
  MaterialParamType2[MaterialParamType2["Int"] = 1] = "Int";
  MaterialParamType2[MaterialParamType2["Float"] = 2] = "Float";
  MaterialParamType2[MaterialParamType2["Sampler"] = 3] = "Sampler";
  MaterialParamType2[MaterialParamType2["Font"] = 4] = "Font";
})(MaterialParamType || (MaterialParamType = {}));
function createDestroyedProxy(type) {
  return new Proxy({}, {
    get(_, param) {
      if (param === "isDestroyed")
        return true;
      throw new Error(`Canno't read '${param}' of destroyed ${type}`);
    },
    set(_, param) {
      throw new Error(`Canno't write '${param}' of destroyed ${type}`);
    }
  });
}
var DestroyedObjectInstance = createDestroyedProxy("object");
var DestroyedComponentInstance = createDestroyedProxy("component");
var DestroyedTextureInstance = createDestroyedProxy("texture");
function isMeshShape(shape) {
  return shape === Shape.ConvexMesh || shape === Shape.TriangleMesh;
}
function isBaseComponentClass(value) {
  return !!value && value.hasOwnProperty("_isBaseComponent") && value._isBaseComponent;
}
var UP_VECTOR = [0, 1, 0];
var SQRT_3 = Math.sqrt(3);
var Component = class {
  /**
   * Allows to inherit properties directly inside the editor.
   *
   * @note Do not use directly, prefer using {@link inheritProperties}.
   *
   * @hidden
   */
  static _inheritProperties() {
    inheritProperties(this);
  }
  /** Manager index. @hidden */
  _manager;
  /** Instance index. @hidden */
  _id;
  /**
   * Object containing this object.
   *
   * **Note**: This is cached for faster retrieval.
   *
   * @hidden
   */
  _object;
  /** Wonderland Engine instance. @hidden */
  _engine;
  /**
   * Create a new instance
   *
   * @param engine The engine instance.
   * @param manager Index of the manager.
   * @param id WASM component instance index.
   *
   * @hidden
   */
  constructor(engine2, manager = -1, id = -1) {
    this._engine = engine2;
    this._manager = manager;
    this._id = id;
    this._object = null;
  }
  /** Hosting engine instance. */
  get engine() {
    return this._engine;
  }
  /** The name of this component's type */
  get type() {
    const ctor = this.constructor;
    return ctor.TypeName ?? this._engine.wasm._typeNameFor(this._manager);
  }
  /** The object this component is attached to. */
  get object() {
    if (!this._object) {
      const objectId = this._engine.wasm._wl_component_get_object(this._manager, this._id);
      this._object = this._engine.wrapObject(objectId);
    }
    return this._object;
  }
  /**
   * Set whether this component is active.
   *
   * Activating/deactivating a component comes at a small cost of reordering
   * components in the respective component manager. This function therefore
   * is not a trivial assignment.
   *
   * Does nothing if the component is already activated/deactivated.
   *
   * @param active New active state.
   */
  set active(active) {
    this._engine.wasm._wl_component_setActive(this._manager, this._id, active);
  }
  /**
   * Whether this component is active
   */
  get active() {
    return this._engine.wasm._wl_component_isActive(this._manager, this._id) != 0;
  }
  /**
   * Copy all the properties from `src` into this instance.
   *
   * @note Only properties are copied. If a component needs to
   * copy extra data, it needs to override this method.
   *
   * #### Example
   *
   * ```js
   * class MyComponent extends Component {
   *     nonPropertyData = 'Hello World';
   *
   *     copy(src) {
   *         super.copy(src);
   *         this.nonPropertyData = src.nonPropertyData;
   *         return this;
   *     }
   * }
   * ```
   *
   * @note This method is called by {@link Object3D.clone}. Do not attempt to:
   *     - Create new component
   *     - Read references to other objects
   *
   * When cloning via {@link Object3D.clone}, this method will be called before
   * {@link Component.start}.
   *
   * @note JavaScript component properties aren't retargeted. Thus, references
   * inside the source object will not be retargeted to the destination object,
   * at the exception of the skin data on {@link MeshComponent} and {@link AnimationComponent}.
   *
   * @param src The source component to copy from.
   *
   * @returns Reference to self (for method chaining).
   */
  copy(src) {
    const ctor = this.constructor;
    for (const name in ctor.Properties) {
      const value = src[name];
      if (value !== void 0) {
        this[name] = value;
      }
    }
    return this;
  }
  /**
   * Remove this component from its objects and destroy it.
   *
   * It is best practice to set the component to `null` after,
   * to ensure it does not get used later.
   *
   * ```js
   *    c.destroy();
   *    c = null;
   * ```
   * @since 0.9.0
   */
  destroy() {
    const manager = this._manager;
    if (manager < 0 || this._id < 0)
      return;
    const jsManager = this.engine.wasm._jsManagerIndex;
    this._engine.wasm._wl_component_remove(manager, this._id);
    if (manager !== jsManager)
      this._triggerOnDestroy();
  }
  /**
   * Checks equality by comparing whether the wrapped native component ids
   * and component manager types are equal.
   *
   * @param otherComponent Component to check equality with.
   * @returns Whether this component equals the given component.
   */
  equals(otherComponent) {
    if (!otherComponent)
      return false;
    return this._manager == otherComponent._manager && this._id == otherComponent._id;
  }
  /**
   * Reset the component properties to default.
   *
   * @note This is automatically called during the component instantiation.
   *
   * @returns Reference to self (for method chaining).
   */
  resetProperties() {
    const ctor = this.constructor;
    const properties = ctor.Properties;
    if (!properties)
      return this;
    for (const name in properties) {
      this[name] = properties[name].default;
    }
    return this;
  }
  /** @deprecated Use {@link Component.resetProperties} instead. */
  reset() {
    return this.resetProperties();
  }
  /**
   * Validate the properties on this instance.
   *
   * @throws If any of the required properties isn't initialized
   * on this instance.
   */
  validateProperties() {
    const ctor = this.constructor;
    if (!ctor.Properties)
      return;
    for (const name in ctor.Properties) {
      if (!ctor.Properties[name].required)
        continue;
      if (!this[name]) {
        throw new Error(`Property '${name}' is required but was not initialized`);
      }
    }
  }
  /**
   * `true` if the component is destroyed, `false` otherwise.
   *
   * If {@link WonderlandEngine.erasePrototypeOnDestroy} is `true`,
   * reading a custom property will not work:
   *
   * ```js
   * engine.erasePrototypeOnDestroy = true;
   *
   * const comp = obj.addComponent('mesh');
   * comp.customParam = 'Hello World!';
   *
   * console.log(comp.isDestroyed); // Prints `false`
   * comp.destroy();
   * console.log(comp.isDestroyed); // Prints `true`
   * console.log(comp.customParam); // Throws an error
   * ```
   *
   * @since 1.1.1
   */
  get isDestroyed() {
    return this._id < 0;
  }
  /**
   * Trigger the component {@link Component.init} method.
   *
   * @note Use this method instead of directly calling {@link Component.init},
   * because this method creates an handler for the {@link Component.start}.
   *
   * @note This api is meant to be used internally.
   *
   * @hidden
   */
  _triggerInit() {
    if (this.init) {
      try {
        this.init();
      } catch (e) {
        this.engine.log.error(LogTag.Component, `Exception during ${this.type} init() on object ${this.object.name}`);
        this.engine.log.error(LogTag.Component, e);
      }
    }
    const oldActivate = this.onActivate;
    this.onActivate = function() {
      this.onActivate = oldActivate;
      let failed = false;
      try {
        this.validateProperties();
      } catch (e) {
        this.engine.log.error(LogTag.Component, `Exception during ${this.type} validateProperties() on object ${this.object.name}`);
        this.engine.log.error(LogTag.Component, e);
        failed = true;
      }
      try {
        this.start?.();
      } catch (e) {
        this.engine.log.error(LogTag.Component, `Exception during ${this.type} start() on object ${this.object.name}`);
        this.engine.log.error(LogTag.Component, e);
        failed = true;
      }
      if (failed) {
        this.active = false;
        return;
      }
      if (!this.onActivate)
        return;
      try {
        this.onActivate();
      } catch (e) {
        this.engine.log.error(LogTag.Component, `Exception during ${this.type} onActivate() on object ${this.object.name}`);
        this.engine.log.error(LogTag.Component, e);
      }
    };
  }
  /**
   * Trigger the component {@link Component.update} method.
   *
   * @note This api is meant to be used internally.
   *
   * @hidden
   */
  _triggerUpdate(dt) {
    if (!this.update)
      return;
    try {
      this.update(dt);
    } catch (e) {
      this.engine.log.error(LogTag.Component, `Exception during ${this.type} update() on object ${this.object.name}`);
      this.engine.log.error(LogTag.Component, e);
      if (this._engine.wasm._deactivate_component_on_error) {
        this.active = false;
      }
    }
  }
  /**
   * Trigger the component {@link Component.onActivate} method.
   *
   * @note This api is meant to be used internally.
   *
   * @hidden
   */
  _triggerOnActivate() {
    if (!this.onActivate)
      return;
    try {
      this.onActivate();
    } catch (e) {
      this.engine.log.error(LogTag.Component, `Exception during ${this.type} onActivate() on object ${this.object.name}`);
      this.engine.log.error(LogTag.Component, e);
    }
  }
  /**
   * Trigger the component {@link Component.onDeactivate} method.
   *
   * @note This api is meant to be used internally.
   *
   * @hidden
   */
  _triggerOnDeactivate() {
    if (!this.onDeactivate)
      return;
    try {
      this.onDeactivate();
    } catch (e) {
      this.engine.log.error(LogTag.Component, `Exception during ${this.type} onDeactivate() on object ${this.object.name}`);
      this.engine.log.error(LogTag.Component, e);
    }
  }
  /**
   * Trigger the component {@link Component.onDestroy} method.
   *
   * @note This api is meant to be used internally.
   *
   * @hidden
   */
  _triggerOnDestroy() {
    try {
      if (this.onDestroy)
        this.onDestroy();
    } catch (e) {
      this.engine.log.error(LogTag.Component, `Exception during ${this.type} onDestroy() on object ${this.object.name}`);
      this.engine.log.error(LogTag.Component, e);
    }
    this._engine._destroyComponent(this);
  }
};
/**
 * `true` for every class inheriting from this class.
 *
 * @note This is a workaround for `instanceof` to prevent issues
 * that could arise when an application ends up using multiple API versions.
 *
 * @hidden
 */
__publicField(Component, "_isBaseComponent", true);
/**
 * Unique identifier for this component class.
 *
 * This is used to register, add, and retrieve components of a given type.
 */
__publicField(Component, "TypeName");
/**
 * Properties of this component class.
 *
 * Properties are public attributes that can be configured via the
 * Wonderland Editor.
 *
 * Example:
 *
 * ```js
 * import { Component, Type } from '@wonderlandengine/api';
 * class MyComponent extends Component {
 *     static TypeName = 'my-component';
 *     static Properties = {
 *         myBoolean: { type: Type.Boolean, default: false },
 *         myFloat: { type: Type.Float, default: false },
 *         myTexture: { type: Type.Texture, default: null },
 *     };
 * }
 * ```
 *
 * Properties are automatically added to each component instance, and are
 * accessible like any JS attribute:
 *
 * ```js
 * // Creates a new component and set each properties value:
 * const myComponent = object.addComponent(MyComponent, {
 *     myBoolean: true,
 *     myFloat: 42.0,
 *     myTexture: null
 * });
 *
 * // You can also override the properties on the instance:
 * myComponent.myBoolean = false;
 * myComponent.myFloat = -42.0;
 * ```
 *
 * #### References
 *
 * Reference types (i.e., mesh, object, etc...) can also be listed as **required**:
 *
 * ```js
 * import {Component, Property} from '@wonderlandengine/api';
 *
 * class MyComponent extends Component {
 *     static Properties = {
 *         myObject: Property.object({required: true}),
 *         myAnimation: Property.animation({required: true}),
 *         myTexture: Property.texture({required: true}),
 *         myMesh: Property.mesh({required: true}),
 *     }
 * }
 * ```
 *
 * Please note that references are validated **once** before the call to {@link Component.start} only,
 * via the {@link Component.validateProperties} method.
 */
__publicField(Component, "Properties");
/**
 * When set to `true`, the child class inherits from the parent
 * properties, as shown in the following example:
 *
 * ```js
 * import {Component, Property} from '@wonderlandengine/api';
 *
 * class Parent extends Component {
 *     static TypeName = 'parent';
 *     static Properties = {parentName: Property.string('parent')}
 * }
 *
 * class Child extends Parent {
 *     static TypeName = 'child';
 *     static Properties = {name: Property.string('child')}
 *     static InheritProperties = true;
 *
 *     start() {
 *         // Works because `InheritProperties` is `true`.
 *         console.log(`${this.name} inherits from ${this.parentName}`);
 *     }
 * }
 * ```
 *
 * @note Properties defined in descendant classes will override properties
 * with the same name defined in ancestor classes.
 *
 * Defaults to `true`.
 */
__publicField(Component, "InheritProperties");
/**
 * Called when this component class is registered.
 *
 * @example
 *
 * This callback can be used to register dependencies of a component,
 * e.g., component classes that need to be registered in order to add
 * them at runtime with {@link Object3D.addComponent}, independent of whether
 * they are used in the editor.
 *
 * ```js
 * class Spawner extends Component {
 *     static TypeName = 'spawner';
 *
 *     static onRegister(engine) {
 *         engine.registerComponent(SpawnedComponent);
 *     }
 *
 *     // You can now use addComponent with SpawnedComponent
 * }
 * ```
 *
 * @example
 *
 * This callback can be used to register different implementations of a
 * component depending on client features or API versions.
 *
 * ```js
 * // Properties need to be the same for all implementations!
 * const SharedProperties = {};
 *
 * class Anchor extends Component {
 *     static TypeName = 'spawner';
 *     static Properties = SharedProperties;
 *
 *     static onRegister(engine) {
 *         if(navigator.xr === undefined) {
 *             /* WebXR unsupported, keep this dummy component *\/
 *             return;
 *         }
 *         /* WebXR supported! Override already registered dummy implementation
 *          * with one depending on hit-test API support *\/
 *         engine.registerComponent(window.HitTestSource === undefined ?
 *             AnchorWithoutHitTest : AnchorWithHitTest);
 *     }
 *
 *     // This one implements no functions
 * }
 * ```
 */
__publicField(Component, "onRegister");
var BrokenComponent = class extends Component {
};
__publicField(BrokenComponent, "TypeName", "__broken-component__");
function inheritProperties(target) {
  if (!target.TypeName)
    return;
  const chain = [];
  let curr = target;
  while (curr && !isBaseComponentClass(curr)) {
    const comp = curr;
    const needsMerge = comp.hasOwnProperty("InheritProperties") ? comp.InheritProperties : true;
    if (!needsMerge)
      break;
    if (comp.TypeName && comp.hasOwnProperty("Properties")) {
      chain.push(comp.Properties);
    }
    curr = Object.getPrototypeOf(curr);
  }
  if (chain.length <= 1)
    return;
  const merged = {};
  for (let i = chain.length - 1; i >= 0; --i) {
    Object.assign(merged, chain[i]);
  }
  target.Properties = merged;
}
var _CollisionComponent = class extends Component {
  /** Collision component collider */
  get collider() {
    return this._engine.wasm._wl_collision_component_get_collider(this._id);
  }
  /**
   * Set collision component collider.
   *
   * @param collider Collider of the collision component.
   */
  set collider(collider) {
    this._engine.wasm._wl_collision_component_set_collider(this._id, collider);
  }
  /**
   * Collision component extents.
   *
   * If {@link collider} returns {@link Collider.Sphere}, only the first
   * component of the returned vector is used.
   */
  get extents() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_collision_component_get_extents(this._id), 3);
  }
  /**
   * Set collision component extents.
   *
   * If {@link collider} returns {@link Collider.Sphere}, only the first
   * component of the passed vector is used.
   *
   * Example:
   *
   * ```js
   * // Spans 1 unit on the x-axis, 2 on the y-axis, 3 on the z-axis.
   * collision.extent = [1, 2, 3];
   * ```
   *
   * @param extents Extents of the collision component, expects a
   *      3 component array.
   */
  set extents(extents) {
    this.extents.set(extents);
  }
  /**
   * Get collision component radius.
   *
   * @note If {@link collider} is not {@link Collider.Sphere}, the returned value
   * corresponds to the radius of a sphere enclosing the shape.
   *
   * Example:
   *
   * ```js
   * sphere.radius = 3.0;
   * console.log(sphere.radius); // 3.0
   *
   * box.extents = [2.0, 2.0, 2.0];
   * console.log(box.radius); // 1.732...
   * ```
   *
   */
  get radius() {
    const wasm = this._engine.wasm;
    if (this.collider === Collider.Sphere)
      return wasm.HEAPF32[wasm._wl_collision_component_get_extents(this._id) >> 2];
    const extents = new Float32Array(wasm.HEAPF32.buffer, wasm._wl_collision_component_get_extents(this._id), 3);
    const x2 = extents[0] * extents[0];
    const y2 = extents[1] * extents[1];
    const z2 = extents[2] * extents[2];
    return Math.sqrt(x2 + y2 + z2) / 2;
  }
  /**
   * Set collision component radius.
   *
   * @param radius Radius of the collision component
   *
   * @note If {@link collider} is not {@link Collider.Sphere},
   * the extents are set to form a square that fits a sphere with the provided radius.
   *
   * Example:
   *
   * ```js
   * aabbCollision.radius = 2.0; // AABB fits a sphere of radius 2.0
   * boxCollision.radius = 3.0; // Box now fits a sphere of radius 3.0, keeping orientation
   * ```
   *
   */
  set radius(radius) {
    const length10 = this.collider === Collider.Sphere ? radius : 2 * radius / SQRT_3;
    this.extents.set([length10, length10, length10]);
  }
  /**
   * Collision component group.
   *
   * The groups is a bitmask that is compared to other components in {@link CollisionComponent#queryOverlaps}
   * or the group in {@link Scene#rayCast}.
   *
   * Colliders that have no common groups will not overlap with each other. If a collider
   * has none of the groups set for {@link Scene#rayCast}, the ray will not hit it.
   *
   * Each bit represents belonging to a group, see example.
   *
   * ```js
   *    // c belongs to group 2
   *    c.group = (1 << 2);
   *
   *    // c belongs to group 0
   *    c.group = (1 << 0);
   *
   *    // c belongs to group 0 *and* 2
   *    c.group = (1 << 0) | (1 << 2);
   *
   *    (c.group & (1 << 2)) != 0; // true
   *    (c.group & (1 << 7)) != 0; // false
   * ```
   */
  get group() {
    return this._engine.wasm._wl_collision_component_get_group(this._id);
  }
  /**
   * Set collision component group.
   *
   * @param group Group mask of the collision component.
   */
  set group(group) {
    this._engine.wasm._wl_collision_component_set_group(this._id, group);
  }
  /**
   * Query overlapping objects.
   *
   * Usage:
   *
   * ```js
   * const collision = object.getComponent('collision');
   * const overlaps = collision.queryOverlaps();
   * for(const otherCollision of overlaps) {
   *     const otherObject = otherCollision.object;
   *     console.log(`Collision with object ${otherObject.objectId}`);
   * }
   * ```
   *
   * @returns Collision components overlapping this collider.
   */
  queryOverlaps() {
    const count = this._engine.wasm._wl_collision_component_query_overlaps(this._id, this._engine.wasm._tempMem, this._engine.wasm._tempMemSize >> 1);
    const overlaps = new Array(count);
    for (let i = 0; i < count; ++i) {
      overlaps[i] = new _CollisionComponent(this._engine, this._manager, this._engine.wasm._tempMemUint16[i]);
    }
    return overlaps;
  }
};
var CollisionComponent = _CollisionComponent;
/** @override */
__publicField(CollisionComponent, "TypeName", "collision");
__decorate([
  nativeProperty()
], CollisionComponent.prototype, "collider", null);
__decorate([
  nativeProperty()
], CollisionComponent.prototype, "extents", null);
__decorate([
  nativeProperty()
], CollisionComponent.prototype, "group", null);
var TextComponent = class extends Component {
  /** Text component alignment. */
  get alignment() {
    return this._engine.wasm._wl_text_component_get_horizontal_alignment(this._id);
  }
  /**
   * Set text component alignment.
   *
   * @param alignment Alignment for the text component.
   */
  set alignment(alignment) {
    this._engine.wasm._wl_text_component_set_horizontal_alignment(this._id, alignment);
  }
  /** Text component justification. */
  get justification() {
    return this._engine.wasm._wl_text_component_get_vertical_alignment(this._id);
  }
  /**
   * Set text component justification.
   *
   * @param justification Justification for the text component.
   */
  set justification(justification) {
    this._engine.wasm._wl_text_component_set_vertical_alignment(this._id, justification);
  }
  /** Text component character spacing. */
  get characterSpacing() {
    return this._engine.wasm._wl_text_component_get_character_spacing(this._id);
  }
  /**
   * Set text component character spacing.
   *
   * @param spacing Character spacing for the text component.
   */
  set characterSpacing(spacing) {
    this._engine.wasm._wl_text_component_set_character_spacing(this._id, spacing);
  }
  /** Text component line spacing. */
  get lineSpacing() {
    return this._engine.wasm._wl_text_component_get_line_spacing(this._id);
  }
  /**
   * Set text component line spacing
   *
   * @param spacing Line spacing for the text component
   */
  set lineSpacing(spacing) {
    this._engine.wasm._wl_text_component_set_line_spacing(this._id, spacing);
  }
  /** Text component effect. */
  get effect() {
    return this._engine.wasm._wl_text_component_get_effect(this._id);
  }
  /**
   * Set text component effect
   *
   * @param effect Effect for the text component
   */
  set effect(effect) {
    this._engine.wasm._wl_text_component_set_effect(this._id, effect);
  }
  /** Text component text. */
  get text() {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_text_component_get_text(this._id);
    return wasm.UTF8ToString(ptr);
  }
  /**
   * Set text component text.
   *
   * @param text Text of the text component.
   */
  set text(text) {
    const wasm = this._engine.wasm;
    wasm._wl_text_component_set_text(this._id, wasm.tempUTF8(text.toString()));
  }
  /**
   * Set material to render the text with.
   *
   * @param material New material.
   */
  set material(material) {
    const matIndex = material ? material._index : 0;
    this._engine.wasm._wl_text_component_set_material(this._id, matIndex);
  }
  /** Material used to render the text. */
  get material() {
    const id = this._engine.wasm._wl_text_component_get_material(this._id);
    return id > 0 ? new Material(this._engine, id) : null;
  }
};
/** @override */
__publicField(TextComponent, "TypeName", "text");
__decorate([
  nativeProperty()
], TextComponent.prototype, "alignment", null);
__decorate([
  nativeProperty()
], TextComponent.prototype, "justification", null);
__decorate([
  nativeProperty()
], TextComponent.prototype, "characterSpacing", null);
__decorate([
  nativeProperty()
], TextComponent.prototype, "lineSpacing", null);
__decorate([
  nativeProperty()
], TextComponent.prototype, "effect", null);
__decorate([
  nativeProperty()
], TextComponent.prototype, "text", null);
__decorate([
  nativeProperty()
], TextComponent.prototype, "material", null);
var ViewComponent = class extends Component {
  /** Projection matrix. */
  get projectionMatrix() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_view_component_get_projection_matrix(this._id), 16);
  }
  /** ViewComponent near clipping plane value. */
  get near() {
    return this._engine.wasm._wl_view_component_get_near(this._id);
  }
  /**
   * Set near clipping plane distance for the view.
   *
   * If an XR session is active, the change will apply in the
   * following frame, otherwise the change is immediate.
   *
   * @param near Near depth value.
   */
  set near(near) {
    this._engine.wasm._wl_view_component_set_near(this._id, near);
  }
  /** Far clipping plane value. */
  get far() {
    return this._engine.wasm._wl_view_component_get_far(this._id);
  }
  /**
   * Set far clipping plane distance for the view.
   *
   * If an XR session is active, the change will apply in the
   * following frame, otherwise the change is immediate.
   *
   * @param far Near depth value.
   */
  set far(far) {
    this._engine.wasm._wl_view_component_set_far(this._id, far);
  }
  /**
   * Get the horizontal field of view for the view, **in degrees**.
   *
   * If an XR session is active, this returns the field of view reported by
   * the device, regardless of the fov that was set.
   */
  get fov() {
    return this._engine.wasm._wl_view_component_get_fov(this._id);
  }
  /**
   * Set the horizontal field of view for the view, **in degrees**.
   *
   * If an XR session is active, the field of view reported by the device is
   * used and this value is ignored. After the XR session ends, the new value
   * is applied.
   *
   * @param fov Horizontal field of view, **in degrees**.
   */
  set fov(fov) {
    this._engine.wasm._wl_view_component_set_fov(this._id, fov);
  }
};
/** @override */
__publicField(ViewComponent, "TypeName", "view");
__decorate([
  enumerable()
], ViewComponent.prototype, "projectionMatrix", null);
__decorate([
  nativeProperty()
], ViewComponent.prototype, "near", null);
__decorate([
  nativeProperty()
], ViewComponent.prototype, "far", null);
__decorate([
  nativeProperty()
], ViewComponent.prototype, "fov", null);
var InputComponent = class extends Component {
  /** Input component type */
  get inputType() {
    return this._engine.wasm._wl_input_component_get_type(this._id);
  }
  /**
   * Set input component type.
   *
   * @params New input component type.
   */
  set inputType(type) {
    this._engine.wasm._wl_input_component_set_type(this._id, type);
  }
  /**
   * WebXR Device API input source associated with this input component,
   * if type {@link InputType.ControllerLeft} or {@link InputType.ControllerRight}.
   */
  get xrInputSource() {
    const xr = this._engine.xr;
    if (!xr)
      return null;
    for (let inputSource of xr.session.inputSources) {
      if (inputSource.handedness == this.handedness) {
        return inputSource;
      }
    }
    return null;
  }
  /**
   * 'left', 'right' or `null` depending on the {@link InputComponent#inputType}.
   */
  get handedness() {
    const inputType = this.inputType;
    if (inputType == InputType.ControllerRight || inputType == InputType.RayRight || inputType == InputType.EyeRight)
      return "right";
    if (inputType == InputType.ControllerLeft || inputType == InputType.RayLeft || inputType == InputType.EyeLeft)
      return "left";
    return null;
  }
};
/** @override */
__publicField(InputComponent, "TypeName", "input");
__decorate([
  nativeProperty()
], InputComponent.prototype, "inputType", null);
__decorate([
  enumerable()
], InputComponent.prototype, "xrInputSource", null);
__decorate([
  enumerable()
], InputComponent.prototype, "handedness", null);
var LightComponent = class extends Component {
  getColor(out = new Float32Array(3)) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_light_component_get_color(this._id) / 4;
    out[0] = wasm.HEAPF32[ptr];
    out[1] = wasm.HEAPF32[ptr + 1];
    out[2] = wasm.HEAPF32[ptr + 2];
    return out;
  }
  /**
   * Set light color.
   *
   * @param c New color array/vector, expected to have at least 3 elements.
   * @since 1.0.0
   */
  setColor(c) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_light_component_get_color(this._id) / 4;
    wasm.HEAPF32[ptr] = c[0];
    wasm.HEAPF32[ptr + 1] = c[1];
    wasm.HEAPF32[ptr + 2] = c[2];
  }
  /**
   * View on the light color.
   *
   * @note Prefer to use {@link getColor} in performance-critical code.
   */
  get color() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_light_component_get_color(this._id), 3);
  }
  /**
   * Set light color.
   *
   * @param c Color of the light component.
   *
   * @note Prefer to use {@link setColor} in performance-critical code.
   */
  set color(c) {
    this.color.set(c);
  }
  /** Light type. */
  get lightType() {
    return this._engine.wasm._wl_light_component_get_type(this._id);
  }
  /**
   * Set light type.
   *
   * @param lightType Type of the light component.
   */
  set lightType(t) {
    this._engine.wasm._wl_light_component_set_type(this._id, t);
  }
  /**
   * Light intensity.
   * @since 1.0.0
   */
  get intensity() {
    return this._engine.wasm._wl_light_component_get_intensity(this._id);
  }
  /**
   * Set light intensity.
   *
   * @param intensity Intensity of the light component.
   * @since 1.0.0
   */
  set intensity(intensity) {
    this._engine.wasm._wl_light_component_set_intensity(this._id, intensity);
  }
  /**
   * Outer angle for spot lights, in degrees.
   * @since 1.0.0
   */
  get outerAngle() {
    return this._engine.wasm._wl_light_component_get_outerAngle(this._id);
  }
  /**
   * Set outer angle for spot lights.
   *
   * @param angle Outer angle, in degrees.
   * @since 1.0.0
   */
  set outerAngle(angle4) {
    this._engine.wasm._wl_light_component_set_outerAngle(this._id, angle4);
  }
  /**
   * Inner angle for spot lights, in degrees.
   * @since 1.0.0
   */
  get innerAngle() {
    return this._engine.wasm._wl_light_component_get_innerAngle(this._id);
  }
  /**
   * Set inner angle for spot lights.
   *
   * @param angle Inner angle, in degrees.
   * @since 1.0.0
   */
  set innerAngle(angle4) {
    this._engine.wasm._wl_light_component_set_innerAngle(this._id, angle4);
  }
  /**
   * Whether the light casts shadows.
   * @since 1.0.0
   */
  get shadows() {
    return !!this._engine.wasm._wl_light_component_get_shadows(this._id);
  }
  /**
   * Set whether the light casts shadows.
   *
   * @param b Whether the light casts shadows.
   * @since 1.0.0
   */
  set shadows(b) {
    this._engine.wasm._wl_light_component_set_shadows(this._id, b);
  }
  /**
   * Range for shadows.
   * @since 1.0.0
   */
  get shadowRange() {
    return this._engine.wasm._wl_light_component_get_shadowRange(this._id);
  }
  /**
   * Set range for shadows.
   *
   * @param range Range for shadows.
   * @since 1.0.0
   */
  set shadowRange(range) {
    this._engine.wasm._wl_light_component_set_shadowRange(this._id, range);
  }
  /**
   * Bias value for shadows.
   * @since 1.0.0
   */
  get shadowBias() {
    return this._engine.wasm._wl_light_component_get_shadowBias(this._id);
  }
  /**
   * Set bias value for shadows.
   *
   * @param bias Bias for shadows.
   * @since 1.0.0
   */
  set shadowBias(bias) {
    this._engine.wasm._wl_light_component_set_shadowBias(this._id, bias);
  }
  /**
   * Normal bias value for shadows.
   * @since 1.0.0
   */
  get shadowNormalBias() {
    return this._engine.wasm._wl_light_component_get_shadowNormalBias(this._id);
  }
  /**
   * Set normal bias value for shadows.
   *
   * @param bias Normal bias for shadows.
   * @since 1.0.0
   */
  set shadowNormalBias(bias) {
    this._engine.wasm._wl_light_component_set_shadowNormalBias(this._id, bias);
  }
  /**
   * Texel size for shadows.
   * @since 1.0.0
   */
  get shadowTexelSize() {
    return this._engine.wasm._wl_light_component_get_shadowTexelSize(this._id);
  }
  /**
   * Set texel size for shadows.
   *
   * @param size Texel size for shadows.
   * @since 1.0.0
   */
  set shadowTexelSize(size) {
    this._engine.wasm._wl_light_component_set_shadowTexelSize(this._id, size);
  }
  /**
   * Cascade count for {@link LightType.Sun} shadows.
   * @since 1.0.0
   */
  get cascadeCount() {
    return this._engine.wasm._wl_light_component_get_cascadeCount(this._id);
  }
  /**
   * Set cascade count for {@link LightType.Sun} shadows.
   *
   * @param count Cascade count.
   * @since 1.0.0
   */
  set cascadeCount(count) {
    this._engine.wasm._wl_light_component_set_cascadeCount(this._id, count);
  }
};
/** @override */
__publicField(LightComponent, "TypeName", "light");
__decorate([
  nativeProperty()
], LightComponent.prototype, "color", null);
__decorate([
  nativeProperty()
], LightComponent.prototype, "lightType", null);
__decorate([
  nativeProperty()
], LightComponent.prototype, "intensity", null);
__decorate([
  nativeProperty()
], LightComponent.prototype, "outerAngle", null);
__decorate([
  nativeProperty()
], LightComponent.prototype, "innerAngle", null);
__decorate([
  nativeProperty()
], LightComponent.prototype, "shadows", null);
__decorate([
  nativeProperty()
], LightComponent.prototype, "shadowRange", null);
__decorate([
  nativeProperty()
], LightComponent.prototype, "shadowBias", null);
__decorate([
  nativeProperty()
], LightComponent.prototype, "shadowNormalBias", null);
__decorate([
  nativeProperty()
], LightComponent.prototype, "shadowTexelSize", null);
__decorate([
  nativeProperty()
], LightComponent.prototype, "cascadeCount", null);
var AnimationComponent = class extends Component {
  /**
   * Set animation to play.
   *
   * Make sure to {@link Animation#retarget} the animation to affect the
   * right objects.
   *
   * @param anim Animation to play.
   */
  set animation(anim) {
    this._engine.wasm._wl_animation_component_set_animation(this._id, anim ? anim._index : 0);
  }
  /** Animation set for this component */
  get animation() {
    const id = this._engine.wasm._wl_animation_component_get_animation(this._id);
    return id > 0 ? new Animation(this._engine, id) : null;
  }
  /**
   * Set play count. Set to `0` to loop indefinitely.
   *
   * @param playCount Number of times to repeat the animation.
   */
  set playCount(playCount) {
    this._engine.wasm._wl_animation_component_set_playCount(this._id, playCount);
  }
  /** Number of times the animation is played. */
  get playCount() {
    return this._engine.wasm._wl_animation_component_get_playCount(this._id);
  }
  /**
   * Set speed. Set to negative values to run the animation backwards.
   *
   * Setting speed has an immediate effect for the current frame's update
   * and will continue with the speed from the current point in the animation.
   *
   * @param speed New speed at which to play the animation.
   * @since 0.8.10
   */
  set speed(speed) {
    this._engine.wasm._wl_animation_component_set_speed(this._id, speed);
  }
  /**
   * Speed factor at which the animation is played.
   *
   * @since 0.8.10
   */
  get speed() {
    return this._engine.wasm._wl_animation_component_get_speed(this._id);
  }
  /** Current playing state of the animation */
  get state() {
    return this._engine.wasm._wl_animation_component_state(this._id);
  }
  /**
   * Play animation.
   *
   * If the animation is currently paused, resumes from that position. If the
   * animation is already playing, does nothing.
   *
   * To restart the animation, {@link AnimationComponent#stop} it first.
   */
  play() {
    this._engine.wasm._wl_animation_component_play(this._id);
  }
  /** Stop animation. */
  stop() {
    this._engine.wasm._wl_animation_component_stop(this._id);
  }
  /** Pause animation. */
  pause() {
    this._engine.wasm._wl_animation_component_pause(this._id);
  }
};
/** @override */
__publicField(AnimationComponent, "TypeName", "animation");
__decorate([
  nativeProperty()
], AnimationComponent.prototype, "animation", null);
__decorate([
  nativeProperty()
], AnimationComponent.prototype, "playCount", null);
__decorate([
  nativeProperty()
], AnimationComponent.prototype, "speed", null);
__decorate([
  enumerable()
], AnimationComponent.prototype, "state", null);
var MeshComponent = class extends Component {
  /**
   * Set material to render the mesh with.
   *
   * @param material Material to render the mesh with.
   */
  set material(material) {
    this._engine.wasm._wl_mesh_component_set_material(this._id, material ? material._index : 0);
  }
  /** Material used to render the mesh. */
  get material() {
    const id = this._engine.wasm._wl_mesh_component_get_material(this._id);
    return id > 0 ? new Material(this._engine, id) : null;
  }
  /** Mesh rendered by this component. */
  get mesh() {
    const id = this._engine.wasm._wl_mesh_component_get_mesh(this._id);
    return id > 0 ? new Mesh(this._engine, id) : null;
  }
  /**
   * Set mesh to rendered with this component.
   *
   * @param mesh Mesh rendered by this component.
   */
  set mesh(mesh) {
    this._engine.wasm._wl_mesh_component_set_mesh(this._id, mesh ? mesh._index : 0);
  }
  /** Skin for this mesh component. */
  get skin() {
    const id = this._engine.wasm._wl_mesh_component_get_skin(this._id);
    return id > 0 ? new Skin(this._engine, id) : null;
  }
  /**
   * Set skin to transform this mesh component.
   *
   * @param skin Skin to use for rendering skinned meshes.
   */
  set skin(skin) {
    this._engine.wasm._wl_mesh_component_set_skin(this._id, skin ? skin._index : 0);
  }
};
/** @override */
__publicField(MeshComponent, "TypeName", "mesh");
__decorate([
  nativeProperty()
], MeshComponent.prototype, "material", null);
__decorate([
  nativeProperty()
], MeshComponent.prototype, "mesh", null);
__decorate([
  nativeProperty()
], MeshComponent.prototype, "skin", null);
var LockAxis;
(function(LockAxis2) {
  LockAxis2[LockAxis2["None"] = 0] = "None";
  LockAxis2[LockAxis2["X"] = 1] = "X";
  LockAxis2[LockAxis2["Y"] = 2] = "Y";
  LockAxis2[LockAxis2["Z"] = 4] = "Z";
})(LockAxis || (LockAxis = {}));
var PhysXComponent = class extends Component {
  getTranslationOffset(out = new Float32Array(3)) {
    const wasm = this._engine.wasm;
    wasm._wl_physx_component_get_offsetTranslation(this._id, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    return out;
  }
  getRotationOffset(out = new Float32Array(4)) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_physx_component_get_offsetTransform(this._id) >> 2;
    out[0] = wasm.HEAPF32[ptr];
    out[1] = wasm.HEAPF32[ptr + 1];
    out[2] = wasm.HEAPF32[ptr + 2];
    out[3] = wasm.HEAPF32[ptr + 3];
    return out;
  }
  /**
   * Set whether this rigid body is static.
   *
   * Setting this property only takes effect once the component
   * switches from inactive to active.
   *
   * @param b Whether the rigid body should be static.
   */
  set static(b) {
    this._engine.wasm._wl_physx_component_set_static(this._id, b);
  }
  /**
   * Whether this rigid body is static.
   *
   * This property returns whether the rigid body is *effectively*
   * static. If static property was set while the rigid body was
   * active, it will not take effect until the rigid body is set
   * inactive and active again. Until the component is set inactive,
   * this getter will return whether the rigid body is actually
   * static.
   */
  get static() {
    return !!this._engine.wasm._wl_physx_component_get_static(this._id);
  }
  /**
   * Equivalent to {@link PhysXComponent.getTranslationOffset}.
   *
   * Gives a quick view of the offset in a debugger.
   *
   * @note Prefer to use {@link PhysXComponent.getTranslationOffset} for performance.
   *
   * @since 1.1.1
   */
  get translationOffset() {
    return this.getTranslationOffset();
  }
  /**
   * Set the offset translation.
   *
   * The array must be a vector of at least **3** elements.
   *
   * @note The component must be re-activated to apply the change.
   *
   * @since 1.1.1
   */
  set translationOffset(offset2) {
    const wasm = this._engine.wasm;
    wasm._wl_physx_component_set_offsetTranslation(this._id, offset2[0], offset2[1], offset2[2]);
  }
  /**
   * Equivalent to {@link PhysXComponent.getRotationOffset}.
   *
   * Gives a quick view of the offset in a debugger.
   *
   * @note Prefer to use {@link PhysXComponent.getRotationOffset} for performance.
   *
   * @since 1.1.1
   */
  get rotationOffset() {
    return this.getRotationOffset();
  }
  /**
   * Set the offset rotation.
   *
   * The array must be a quaternion of at least **4** elements.
   *
   * @note The component must be re-activated to apply the change.
   *
   * @since 1.1.1
   */
  set rotationOffset(offset2) {
    const wasm = this._engine.wasm;
    wasm._wl_physx_component_set_offsetRotation(this._id, offset2[0], offset2[1], offset2[2], offset2[3]);
  }
  /**
   * Set whether this rigid body is kinematic.
   *
   * @param b Whether the rigid body should be kinematic.
   */
  set kinematic(b) {
    this._engine.wasm._wl_physx_component_set_kinematic(this._id, b);
  }
  /**
   * Whether this rigid body is kinematic.
   */
  get kinematic() {
    return !!this._engine.wasm._wl_physx_component_get_kinematic(this._id);
  }
  /**
   * Set whether this rigid body's gravity is enabled.
   *
   * @param b Whether the rigid body's gravity should be enabled.
   */
  set gravity(b) {
    this._engine.wasm._wl_physx_component_set_gravity(this._id, b);
  }
  /**
   * Whether this rigid body's gravity flag is enabled.
   */
  get gravity() {
    return !!this._engine.wasm._wl_physx_component_get_gravity(this._id);
  }
  /**
   * Set whether this rigid body's simulate flag is enabled.
   *
   * @param b Whether the rigid body's simulate flag should be enabled.
   */
  set simulate(b) {
    this._engine.wasm._wl_physx_component_set_simulate(this._id, b);
  }
  /**
   * Whether this rigid body's simulate flag is enabled.
   */
  get simulate() {
    return !!this._engine.wasm._wl_physx_component_get_simulate(this._id);
  }
  /**
   * Set whether to allow simulation of this rigid body.
   *
   * {@link allowSimulation} and {@link trigger} can not be enabled at the
   * same time. Enabling {@link allowSimulation} while {@link trigger} is enabled
   * will disable {@link trigger}.
   *
   * @param b Whether to allow simulation of this rigid body.
   */
  set allowSimulation(b) {
    this._engine.wasm._wl_physx_component_set_allowSimulation(this._id, b);
  }
  /**
   * Whether to allow simulation of this rigid body.
   */
  get allowSimulation() {
    return !!this._engine.wasm._wl_physx_component_get_allowSimulation(this._id);
  }
  /**
   * Set whether this rigid body may be queried in ray casts.
   *
   * @param b Whether this rigid body may be queried in ray casts.
   */
  set allowQuery(b) {
    this._engine.wasm._wl_physx_component_set_allowQuery(this._id, b);
  }
  /**
   * Whether this rigid body may be queried in ray casts.
   */
  get allowQuery() {
    return !!this._engine.wasm._wl_physx_component_get_allowQuery(this._id);
  }
  /**
   * Set whether this physics body is a trigger.
   *
   * {@link allowSimulation} and {@link trigger} can not be enabled at the
   * same time. Enabling trigger while {@link allowSimulation} is enabled,
   * will disable {@link allowSimulation}.
   *
   * @param b Whether this physics body is a trigger.
   */
  set trigger(b) {
    this._engine.wasm._wl_physx_component_set_trigger(this._id, b);
  }
  /**
   * Whether this physics body is a trigger.
   */
  get trigger() {
    return !!this._engine.wasm._wl_physx_component_get_trigger(this._id);
  }
  /**
   * Set the shape for collision detection.
   *
   * @param s New shape.
   * @since 0.8.5
   */
  set shape(s) {
    this._engine.wasm._wl_physx_component_set_shape(this._id, s);
  }
  /** The shape for collision detection. */
  get shape() {
    return this._engine.wasm._wl_physx_component_get_shape(this._id);
  }
  /**
   * Set additional data for the shape.
   *
   * Retrieved only from {@link PhysXComponent#shapeData}.
   * @since 0.8.10
   */
  set shapeData(d) {
    if (d == null || !isMeshShape(this.shape))
      return;
    this._engine.wasm._wl_physx_component_set_shape_data(this._id, d.index);
  }
  /**
   * Additional data for the shape.
   *
   * `null` for {@link Shape} values: `None`, `Sphere`, `Capsule`, `Box`, `Plane`.
   * `{index: n}` for `TriangleMesh` and `ConvexHull`.
   *
   * This data is currently only for passing onto or creating other {@link PhysXComponent}.
   * @since 0.8.10
   */
  get shapeData() {
    if (!isMeshShape(this.shape))
      return null;
    return {
      index: this._engine.wasm._wl_physx_component_get_shape_data(this._id)
    };
  }
  /**
   * Set the shape extents for collision detection.
   *
   * @param e New extents for the shape.
   * @since 0.8.5
   */
  set extents(e) {
    this.extents.set(e);
  }
  /**
   * The shape extents for collision detection.
   */
  get extents() {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_physx_component_get_extents(this._id);
    return new Float32Array(wasm.HEAPF32.buffer, ptr, 3);
  }
  /**
   * Get staticFriction.
   */
  get staticFriction() {
    return this._engine.wasm._wl_physx_component_get_staticFriction(this._id);
  }
  /**
   * Set staticFriction.
   * @param v New staticFriction.
   */
  set staticFriction(v) {
    this._engine.wasm._wl_physx_component_set_staticFriction(this._id, v);
  }
  /**
   * Get dynamicFriction.
   */
  get dynamicFriction() {
    return this._engine.wasm._wl_physx_component_get_dynamicFriction(this._id);
  }
  /**
   * Set dynamicFriction
   * @param v New dynamicDamping.
   */
  set dynamicFriction(v) {
    this._engine.wasm._wl_physx_component_set_dynamicFriction(this._id, v);
  }
  /**
   * Get bounciness.
   * @since 0.9.0
   */
  get bounciness() {
    return this._engine.wasm._wl_physx_component_get_bounciness(this._id);
  }
  /**
   * Set bounciness.
   * @param v New bounciness.
   * @since 0.9.0
   */
  set bounciness(v) {
    this._engine.wasm._wl_physx_component_set_bounciness(this._id, v);
  }
  /**
   * Get linearDamping/
   */
  get linearDamping() {
    return this._engine.wasm._wl_physx_component_get_linearDamping(this._id);
  }
  /**
   * Set linearDamping.
   * @param v New linearDamping.
   */
  set linearDamping(v) {
    this._engine.wasm._wl_physx_component_set_linearDamping(this._id, v);
  }
  /** Get angularDamping. */
  get angularDamping() {
    return this._engine.wasm._wl_physx_component_get_angularDamping(this._id);
  }
  /**
   * Set angularDamping.
   * @param v New angularDamping.
   */
  set angularDamping(v) {
    this._engine.wasm._wl_physx_component_set_angularDamping(this._id, v);
  }
  /**
   * Set linear velocity.
   *
   * [PhysX Manual - "Velocity"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#velocity)
   *
   * Has no effect, if the component is not active.
   *
   * @param v New linear velocity.
   */
  set linearVelocity(v) {
    this._engine.wasm._wl_physx_component_set_linearVelocity(this._id, v[0], v[1], v[2]);
  }
  /** Linear velocity or `[0, 0, 0]` if the component is not active. */
  get linearVelocity() {
    const wasm = this._engine.wasm;
    wasm._wl_physx_component_get_linearVelocity(this._id, wasm._tempMem);
    return new Float32Array(wasm.HEAPF32.buffer, wasm._tempMem, 3);
  }
  /**
   * Set angular velocity
   *
   * [PhysX Manual - "Velocity"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#velocity)
   *
   * Has no effect, if the component is not active.
   *
   * @param v New angular velocity
   */
  set angularVelocity(v) {
    this._engine.wasm._wl_physx_component_set_angularVelocity(this._id, v[0], v[1], v[2]);
  }
  /** Angular velocity or `[0, 0, 0]` if the component is not active. */
  get angularVelocity() {
    const wasm = this._engine.wasm;
    wasm._wl_physx_component_get_angularVelocity(this._id, wasm._tempMem);
    return new Float32Array(wasm.HEAPF32.buffer, wasm._tempMem, 3);
  }
  /**
   * Set the components groups mask.
   *
   * @param flags New flags that need to be set.
   */
  set groupsMask(flags) {
    this._engine.wasm._wl_physx_component_set_groupsMask(this._id, flags);
  }
  /**
   * Get the components groups mask flags.
   *
   * Each bit represents membership to group, see example.
   *
   * ```js
   * // Assign c to group 2
   * c.groupsMask = (1 << 2);
   *
   * // Assign c to group 0
   * c.groupsMask  = (1 << 0);
   *
   * // Assign c to group 0 and 2
   * c.groupsMask = (1 << 0) | (1 << 2);
   *
   * (c.groupsMask & (1 << 2)) != 0; // true
   * (c.groupsMask & (1 << 7)) != 0; // false
   * ```
   */
  get groupsMask() {
    return this._engine.wasm._wl_physx_component_get_groupsMask(this._id);
  }
  /**
   * Set the components blocks mask.
   *
   * @param flags New flags that need to be set.
   */
  set blocksMask(flags) {
    this._engine.wasm._wl_physx_component_set_blocksMask(this._id, flags);
  }
  /**
   * Get the components blocks mask flags.
   *
   * Each bit represents membership to the block, see example.
   *
   * ```js
   * // Block overlap with any objects in group 2
   * c.blocksMask = (1 << 2);
   *
   * // Block overlap with any objects in group 0
   * c.blocksMask  = (1 << 0)
   *
   * // Block overlap with any objects in group 0 and 2
   * c.blocksMask = (1 << 0) | (1 << 2);
   *
   * (c.blocksMask & (1 << 2)) != 0; // true
   * (c.blocksMask & (1 << 7)) != 0; // false
   * ```
   */
  get blocksMask() {
    return this._engine.wasm._wl_physx_component_get_blocksMask(this._id);
  }
  /**
   * Set axes to lock for linear velocity.
   *
   * @param lock The Axis that needs to be set.
   *
   * Combine flags with Bitwise OR:
   *
   * ```js
   * body.linearLockAxis = LockAxis.X | LockAxis.Y; // x and y set
   * body.linearLockAxis = LockAxis.X; // y unset
   * ```
   *
   * @note This has no effect if the component is static.
   */
  set linearLockAxis(lock) {
    this._engine.wasm._wl_physx_component_set_linearLockAxis(this._id, lock);
  }
  /**
   * Get the linear lock axes flags.
   *
   * To get the state of a specific flag, Bitwise AND with the LockAxis needed.
   *
   * ```js
   * if(body.linearLockAxis & LockAxis.Y) {
   *     console.log("The Y flag was set!");
   * }
   * ```
   *
   * @return axes that are currently locked for linear movement.
   */
  get linearLockAxis() {
    return this._engine.wasm._wl_physx_component_get_linearLockAxis(this._id);
  }
  /**
   * Set axes to lock for angular velocity.
   *
   * @param lock The Axis that needs to be set.
   *
   * ```js
   * body.angularLockAxis = LockAxis.X | LockAxis.Y; // x and y set
   * body.angularLockAxis = LockAxis.X; // y unset
   * ```
   *
   * @note This has no effect if the component is static.
   */
  set angularLockAxis(lock) {
    this._engine.wasm._wl_physx_component_set_angularLockAxis(this._id, lock);
  }
  /**
   * Get the angular lock axes flags.
   *
   * To get the state of a specific flag, Bitwise AND with the LockAxis needed:
   *
   * ```js
   * if(body.angularLockAxis & LockAxis.Y) {
   *     console.log("The Y flag was set!");
   * }
   * ```
   *
   * @return axes that are currently locked for angular movement.
   */
  get angularLockAxis() {
    return this._engine.wasm._wl_physx_component_get_angularLockAxis(this._id);
  }
  /**
   * Set mass.
   *
   * [PhysX Manual - "Mass Properties"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#mass-properties)
   *
   * @param m New mass.
   */
  set mass(m) {
    this._engine.wasm._wl_physx_component_set_mass(this._id, m);
  }
  /** Mass */
  get mass() {
    return this._engine.wasm._wl_physx_component_get_mass(this._id);
  }
  /**
   * Set mass space interia tensor.
   *
   * [PhysX Manual - "Mass Properties"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#mass-properties)
   *
   * Has no effect, if the component is not active.
   *
   * @param v New mass space interatia tensor.
   */
  set massSpaceInteriaTensor(v) {
    this._engine.wasm._wl_physx_component_set_massSpaceInertiaTensor(this._id, v[0], v[1], v[2]);
  }
  /**
   * Set the rigid body to sleep upon activation.
   *
   * When asleep, the rigid body will not be simulated until the next contact.
   *
   * @param flag `true` to sleep upon activation.
   *
   * @since 1.1.5
   */
  set sleepOnActivate(flag) {
    this._engine.wasm._wl_physx_component_set_sleepOnActivate(this._id, flag);
  }
  /**
   * `true` if the rigid body is set to sleep upon activation, `false` otherwise.
   *
   * @since 1.1.5
   */
  get sleepOnActivate() {
    return !!this._engine.wasm._wl_physx_component_get_sleepOnActivate(this._id);
  }
  /**
   * Apply a force.
   *
   * [PhysX Manual - "Applying Forces and Torques"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#applying-forces-and-torques)
   *
   * Has no effect, if the component is not active.
   *
   * @param f Force vector.
   * @param m Force mode, see {@link ForceMode}, default `Force`.
   * @param localForce Whether the force vector is in local space, default `false`.
   * @param p Position to apply force at, default is center of mass.
   * @param local Whether position is in local space, default `false`.
   */
  addForce(f, m = ForceMode.Force, localForce = false, p, local = false) {
    const wasm = this._engine.wasm;
    if (!p) {
      wasm._wl_physx_component_addForce(this._id, f[0], f[1], f[2], m, localForce);
      return;
    }
    wasm._wl_physx_component_addForceAt(this._id, f[0], f[1], f[2], m, localForce, p[0], p[1], p[2], local);
  }
  /**
   * Apply torque.
   *
   * [PhysX Manual - "Applying Forces and Torques"](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/RigidBodyDynamics.html#applying-forces-and-torques)
   *
   * Has no effect, if the component is not active.
   *
   * @param f Force vector.
   * @param m Force mode, see {@link ForceMode}, default `Force`.
   */
  addTorque(f, m = ForceMode.Force) {
    this._engine.wasm._wl_physx_component_addTorque(this._id, f[0], f[1], f[2], m);
  }
  /**
   * Add on collision callback.
   *
   * @param callback Function to call when this rigid body (un)collides with any other.
   *
   * ```js
   *  let rigidBody = this.object.getComponent('physx');
   *  rigidBody.onCollision(function(type, other) {
   *      // Ignore uncollides
   *      if(type == CollisionEventType.TouchLost) return;
   *
   *      // Take damage on collision with enemies
   *      if(other.object.name.startsWith("enemy-")) {
   *          this.applyDamage(10);
   *      }
   *  }.bind(this));
   * ```
   *
   * @returns Id of the new callback for use with {@link PhysXComponent#removeCollisionCallback}.
   */
  onCollision(callback) {
    return this.onCollisionWith(this, callback);
  }
  /**
   * Add filtered on collision callback.
   *
   * @param otherComp Component for which callbacks will
   *        be triggered. If you pass this component, the method is equivalent to.
   *        {@link PhysXComponent#onCollision}.
   * @param callback Function to call when this rigid body
   *        (un)collides with `otherComp`.
   * @returns Id of the new callback for use with {@link PhysXComponent#removeCollisionCallback}.
   */
  onCollisionWith(otherComp, callback) {
    const physics = this._engine.physics;
    physics._callbacks[this._id] = physics._callbacks[this._id] || [];
    physics._callbacks[this._id].push(callback);
    return this._engine.wasm._wl_physx_component_addCallback(this._id, otherComp._id || this._id);
  }
  /**
   * Remove a collision callback added with {@link PhysXComponent#onCollision} or {@link PhysXComponent#onCollisionWith}.
   *
   * @param callbackId Callback id as returned by {@link PhysXComponent#onCollision} or {@link PhysXComponent#onCollisionWith}.
   * @throws When the callback does not belong to the component.
   * @throws When the callback does not exist.
   */
  removeCollisionCallback(callbackId) {
    const physics = this._engine.physics;
    const r = this._engine.wasm._wl_physx_component_removeCallback(this._id, callbackId);
    if (r)
      physics._callbacks[this._id].splice(-r);
  }
};
/** @override */
__publicField(PhysXComponent, "TypeName", "physx");
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "static", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "translationOffset", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "rotationOffset", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "kinematic", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "gravity", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "simulate", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "allowSimulation", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "allowQuery", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "trigger", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "shape", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "shapeData", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "extents", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "staticFriction", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "dynamicFriction", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "bounciness", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "linearDamping", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "angularDamping", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "linearVelocity", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "angularVelocity", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "groupsMask", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "blocksMask", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "linearLockAxis", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "angularLockAxis", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "mass", null);
__decorate([
  nativeProperty()
], PhysXComponent.prototype, "sleepOnActivate", null);
var Physics = class {
  /**
   * @hidden
   *
   * **Note**: This is public to emulate a `friend` accessor.
   */
  _callbacks;
  /** Wonderland Engine instance */
  _engine;
  /** Ray Hit */
  _rayHit;
  /** Hit. */
  _hit;
  constructor(engine2) {
    this._engine = engine2;
    this._rayHit = engine2.wasm._malloc(4 * (3 * 4 + 3 * 4 + 4 + 2) + 4);
    this._hit = new RayHit(this._engine, this._rayHit);
    this._callbacks = {};
  }
  /**
   * Cast a ray through the physics scene and find intersecting objects.
   *
   * The resulting ray hit will contain **up to 4** closest ray hits,
   * sorted by increasing distance.
   *
   * @param o Ray origin.
   * @param d Ray direction.
   * @param group Collision group to filter by: only objects that are
   *        part of given group are considered for raycast.
   * @param maxDistance Maximum ray distance, default `100.0`.
   *
   * @returns The RayHit instance, belonging to this class.
   *
   * @note The returned {@link RayHit} object is owned by the Physics instance and
   *       will be reused with the next {@link Physics#rayCast} call.
   */
  rayCast(o, d, group, maxDistance = 100) {
    this._engine.wasm._wl_physx_ray_cast(o[0], o[1], o[2], d[0], d[1], d[2], group, maxDistance, this._rayHit);
    return this._hit;
  }
};
var MeshIndexType;
(function(MeshIndexType2) {
  MeshIndexType2[MeshIndexType2["UnsignedByte"] = 1] = "UnsignedByte";
  MeshIndexType2[MeshIndexType2["UnsignedShort"] = 2] = "UnsignedShort";
  MeshIndexType2[MeshIndexType2["UnsignedInt"] = 4] = "UnsignedInt";
})(MeshIndexType || (MeshIndexType = {}));
var MeshSkinningType;
(function(MeshSkinningType2) {
  MeshSkinningType2[MeshSkinningType2["None"] = 0] = "None";
  MeshSkinningType2[MeshSkinningType2["FourJoints"] = 1] = "FourJoints";
  MeshSkinningType2[MeshSkinningType2["EightJoints"] = 2] = "EightJoints";
})(MeshSkinningType || (MeshSkinningType = {}));
var Mesh = class {
  /**
   * Index of the mesh in the manager.
   *
   * @hidden
   */
  _index = -1;
  /** Wonderland Engine instance. @hidden */
  _engine;
  /**
   * Create a new instance.
   *
   * @param params Either a mesh index to wrap or set of parameters to create a new mesh.
   *    For more information, please have a look at the {@link MeshParameters} interface.
   */
  constructor(engine2, params) {
    this._engine = engine2 ?? WL;
    this._index = -1;
    if (isNumber(params)) {
      this._index = params;
      return;
    }
    if (!params.vertexCount)
      throw new Error("Missing parameter 'vertexCount'");
    const wasm = this._engine.wasm;
    let indexData = 0;
    let indexType = 0;
    let indexDataSize = 0;
    if (params.indexData) {
      indexType = params.indexType || MeshIndexType.UnsignedShort;
      indexDataSize = params.indexData.length * indexType;
      indexData = wasm._malloc(indexDataSize);
      switch (indexType) {
        case MeshIndexType.UnsignedByte:
          wasm.HEAPU8.set(params.indexData, indexData);
          break;
        case MeshIndexType.UnsignedShort:
          wasm.HEAPU16.set(params.indexData, indexData >> 1);
          break;
        case MeshIndexType.UnsignedInt:
          wasm.HEAPU32.set(params.indexData, indexData >> 2);
          break;
      }
    }
    const { skinningType = MeshSkinningType.None } = params;
    this._index = wasm._wl_mesh_create(indexData, indexDataSize, indexType, params.vertexCount, skinningType);
  }
  /** Number of vertices in this mesh. */
  get vertexCount() {
    return this._engine.wasm._wl_mesh_get_vertexCount(this._index);
  }
  /** Index data (read-only) or `null` if the mesh is not indexed. */
  get indexData() {
    const wasm = this._engine.wasm;
    const tempMem = wasm._tempMem;
    const ptr = wasm._wl_mesh_get_indexData(this._index, tempMem, tempMem + 4);
    if (ptr === null)
      return null;
    const indexCount = wasm.HEAPU32[tempMem / 4];
    const indexSize = wasm.HEAPU32[tempMem / 4 + 1];
    switch (indexSize) {
      case MeshIndexType.UnsignedByte:
        return new Uint8Array(wasm.HEAPU8.buffer, ptr, indexCount);
      case MeshIndexType.UnsignedShort:
        return new Uint16Array(wasm.HEAPU16.buffer, ptr, indexCount);
      case MeshIndexType.UnsignedInt:
        return new Uint32Array(wasm.HEAPU32.buffer, ptr, indexCount);
    }
    return null;
  }
  /** Hosting engine instance. */
  get engine() {
    return this._engine;
  }
  /**
   * Apply changes to {@link attribute | vertex attributes}.
   *
   * Uploads the updated vertex attributes to the GPU and updates the bounding
   * sphere to match the new vertex positions.
   *
   * Since this is an expensive operation, call it only once you have performed
   * all modifications on a mesh and avoid calling if you did not perform any
   * modifications at all.
   */
  update() {
    this._engine.wasm._wl_mesh_update(this._index);
  }
  getBoundingSphere(out = new Float32Array(4)) {
    const tempMemFloat = this._engine.wasm._tempMemFloat;
    this._engine.wasm._wl_mesh_get_boundingSphere(this._index, this._engine.wasm._tempMem);
    out[0] = tempMemFloat[0];
    out[1] = tempMemFloat[1];
    out[2] = tempMemFloat[2];
    out[3] = tempMemFloat[3];
    return out;
  }
  attribute(attr) {
    if (typeof attr != "number")
      throw new TypeError("Expected number, but got " + typeof attr);
    const tempMemUint32 = this._engine.wasm._tempMemUint32;
    this._engine.wasm._wl_mesh_get_attribute(this._index, attr, this._engine.wasm._tempMem);
    if (tempMemUint32[0] == 255)
      return null;
    const arraySize = tempMemUint32[5];
    return new MeshAttributeAccessor(this._engine, {
      attribute: tempMemUint32[0],
      offset: tempMemUint32[1],
      stride: tempMemUint32[2],
      formatSize: tempMemUint32[3],
      componentCount: tempMemUint32[4],
      /* The WASM API returns `0` for a scalar value. We clamp it to 1 as we strictly use it as a multiplier for get/set operations */
      arraySize: arraySize ? arraySize : 1,
      length: this.vertexCount,
      bufferType: attr !== MeshAttribute.JointId ? Float32Array : Uint16Array
    });
  }
  /**
   * Destroy and free the meshes memory.
   *
   * It is best practice to set the mesh variable to `null` after calling
   * destroy to prevent accidental use:
   *
   * ```js
   *   mesh.destroy();
   *   mesh = null;
   * ```
   *
   * Accessing the mesh after destruction behaves like accessing an empty
   * mesh.
   *
   * @since 0.9.0
   */
  destroy() {
    this._engine.wasm._wl_mesh_destroy(this._index);
  }
  /**
   * Checks equality by comparing whether the wrapped native mesh ids are
   * equal.
   *
   * @param otherMesh Mesh to check equality with.
   * @returns Whether this mesh equals the given mesh.
   *
   * @since 1.0.0
   */
  equals(otherMesh) {
    if (!otherMesh)
      return false;
    return this._index === otherMesh._index;
  }
};
var MeshAttributeAccessor = class {
  /** Max number of elements. */
  length = 0;
  /** Wonderland Engine instance. @hidden */
  _engine;
  /** Attribute index. @hidden */
  _attribute = -1;
  /** Attribute offset. @hidden */
  _offset = 0;
  /** Attribute stride. @hidden */
  _stride = 0;
  /** Format size native enum. @hidden */
  _formatSize = 0;
  /** Number of components per vertex. @hidden */
  _componentCount = 0;
  /** Number of values per vertex. @hidden */
  _arraySize = 1;
  /**
   * Class to instantiate an ArrayBuffer to get/set values.
   */
  _bufferType;
  /**
   * Function to allocate temporary WASM memory. It is cached in the accessor to avoid
   * conditionals during get/set.
   */
  _tempBufferGetter;
  /**
   * Create a new instance.
   *
   * @note Please use {@link Mesh.attribute} to create a new instance.
   *
   * @param options Contains information about how to read the data.
   * @note Do not use this constructor. Instead, please use the {@link Mesh.attribute} method.
   *
   * @hidden
   */
  constructor(engine2, options) {
    this._engine = engine2;
    const wasm = this._engine.wasm;
    this._attribute = options.attribute;
    this._offset = options.offset;
    this._stride = options.stride;
    this._formatSize = options.formatSize;
    this._componentCount = options.componentCount;
    this._arraySize = options.arraySize;
    this._bufferType = options.bufferType;
    this.length = options.length;
    this._tempBufferGetter = this._bufferType === Float32Array ? wasm.getTempBufferF32.bind(wasm) : wasm.getTempBufferU16.bind(wasm);
  }
  /**
   * Create a new TypedArray to hold this attribute's values.
   *
   * This method is useful to create a view to hold the data to
   * pass to {@link get} and {@link set}
   *
   * Example:
   *
   * ```js
   * const vertexCount = 4;
   * const positionAttribute = mesh.attribute(MeshAttribute.Position);
   *
   * // A position has 3 floats per vertex. Thus, positions has length 3 * 4.
   * const positions = positionAttribute.createArray(vertexCount);
   * ```
   *
   * @param count The number of **vertices** expected.
   * @returns A TypedArray with the appropriate format to access the data
   */
  createArray(count = 1) {
    count = count > this.length ? this.length : count;
    return new this._bufferType(count * this._componentCount * this._arraySize);
  }
  get(index, out = this.createArray()) {
    if (out.length % this._componentCount !== 0) {
      throw new Error(`out.length, ${out.length} is not a multiple of the attribute vector components, ${this._componentCount}`);
    }
    const dest = this._tempBufferGetter(out.length);
    const elementSize = this._bufferType.BYTES_PER_ELEMENT;
    const destSize = elementSize * out.length;
    const srcFormatSize = this._formatSize * this._arraySize;
    const destFormatSize = this._componentCount * elementSize * this._arraySize;
    this._engine.wasm._wl_mesh_get_attribute_values(this._attribute, srcFormatSize, this._offset + index * this._stride, this._stride, destFormatSize, dest.byteOffset, destSize);
    for (let i = 0; i < out.length; ++i)
      out[i] = dest[i];
    return out;
  }
  /**
   * Set attribute element.
   *
   * @param i Index
   * @param v Value to set the element to
   *
   * `v.length` needs to be a multiple of the attributes component count, see
   * {@link MeshAttribute}. If `v.length` is more than one multiple, it will be
   * filled with the next n attribute elements, which can reduce overhead
   * of this call.
   *
   * @returns Reference to self (for method chaining)
   */
  set(i, v) {
    if (v.length % this._componentCount !== 0)
      throw new Error(`out.length, ${v.length} is not a multiple of the attribute vector components, ${this._componentCount}`);
    const elementSize = this._bufferType.BYTES_PER_ELEMENT;
    const srcSize = elementSize * v.length;
    const srcFormatSize = this._componentCount * elementSize * this._arraySize;
    const destFormatSize = this._formatSize * this._arraySize;
    const wasm = this._engine.wasm;
    if (v.buffer != wasm.HEAPU8.buffer) {
      const dest = this._tempBufferGetter(v.length);
      dest.set(v);
      v = dest;
    }
    wasm._wl_mesh_set_attribute_values(this._attribute, srcFormatSize, v.byteOffset, srcSize, destFormatSize, this._offset + i * this._stride, this._stride);
    return this;
  }
};
var Material = class {
  /**
   * Index of this material in the manager.
   *
   * @hidden
   */
  _index;
  /**
   * Material definition index in the scene.
   *
   * @hidden
   */
  _definition;
  /** Wonderland Engine instance. @hidden */
  _engine;
  /**
   * Create a new Material.
   *
   * @note Creating material is expensive. Please use {@link Material#clone} to clone a material.
   * @note Do not use this constructor directly with an index, this is reserved for internal purposes.
   */
  constructor(engine2, params) {
    this._engine = engine2;
    if (typeof params !== "number") {
      if (!params?.pipeline)
        throw new Error("Missing parameter 'pipeline'");
      const wasm = this._engine.wasm;
      const pipeline = params.pipeline;
      this._index = wasm._wl_material_create(wasm.tempUTF8(pipeline));
      if (this._index < 0)
        throw new Error(`No such pipeline '${pipeline}'`);
    } else {
      this._index = params;
    }
    this._definition = this._engine.wasm._wl_material_get_definition(this._index);
    if (!this._engine.wasm._materialDefinitions[this._definition])
      throw new Error(`Material Definition ${this._definition} not found for material with index ${this._index}`);
    return new Proxy(this, {
      get(target, prop) {
        const wasm = engine2.wasm;
        const definition = wasm._materialDefinitions[target._definition];
        const param = definition.get(prop);
        if (!param)
          return target[prop];
        if (wasm._wl_material_get_param_value(target._index, param.index, wasm._tempMem)) {
          const type = param.type;
          switch (type.type) {
            case MaterialParamType.UnsignedInt:
              return type.componentCount == 1 ? wasm._tempMemUint32[0] : new Uint32Array(wasm.HEAPU32.buffer, wasm._tempMem, type.componentCount);
            case MaterialParamType.Int:
              return type.componentCount == 1 ? wasm._tempMemInt[0] : new Int32Array(wasm.HEAP32.buffer, wasm._tempMem, type.componentCount);
            case MaterialParamType.Float:
              return type.componentCount == 1 ? wasm._tempMemFloat[0] : new Float32Array(wasm.HEAPF32.buffer, wasm._tempMem, type.componentCount);
            case MaterialParamType.Sampler:
              return engine2.textures.wrap(wasm._tempMemInt[0]);
            default:
              throw new Error(`Invalid type ${type.type} on parameter ${param.index} for material ${target._index}`);
          }
        }
      },
      set(target, prop, value) {
        const wasm = engine2.wasm;
        const definition = wasm._materialDefinitions[target._definition];
        const param = definition.get(prop);
        if (!param) {
          target[prop] = value;
          return true;
        }
        const type = param.type;
        switch (type.type) {
          case MaterialParamType.UnsignedInt:
          case MaterialParamType.Int:
          case MaterialParamType.Sampler:
            const v = value.id ?? value;
            wasm._wl_material_set_param_value_uint(target._index, param.index, v);
            break;
          case MaterialParamType.Float:
            let count = 1;
            if (typeof value === "number") {
              wasm._tempMemFloat[0] = value;
            } else {
              count = value.length;
              for (let i = 0; i < count; ++i)
                wasm._tempMemFloat[i] = value[i];
            }
            wasm._wl_material_set_param_value_float(target._index, param.index, wasm._tempMem, count);
            break;
          case MaterialParamType.Font:
            throw new Error("Setting font properties is currently unsupported.");
        }
        return true;
      }
    });
  }
  /** @deprecated Use {@link #pipeline} instead. */
  get shader() {
    return this.pipeline;
  }
  /** Name of the pipeline used by this material. */
  get pipeline() {
    const wasm = this._engine.wasm;
    return wasm.UTF8ToString(wasm._wl_material_get_pipeline(this._index));
  }
  /** Hosting engine instance. */
  get engine() {
    return this._engine;
  }
  /**
   * Create a copy of the underlying native material.
   *
   * @returns Material clone.
   */
  clone() {
    const id = this._engine.wasm._wl_material_clone(this._index);
    return id > 0 ? new Material(this._engine, id) : null;
  }
  /**
   * Checks equality by comparing whether the wrapped native material ids are
   * equal.
   *
   * @param otherMaterial Material to check equality with.
   * @returns Whether this material equals the given material.
   *
   * @since 1.0.0
   */
  equals(otherMaterial) {
    if (!otherMaterial)
      return false;
    return this._index === otherMaterial._index;
  }
  /**
   * Wrap a native material index.
   *
   * @param engine Engine instance.
   * @param index The index.
   * @returns Material instance or `null` if index <= 0.
   *
   * @deprecated Please use `new Material()` instead.
   */
  static wrap(engine2, index) {
    return index > 0 ? new Material(engine2, index) : null;
  }
};
var temp2d = null;
var Texture = class {
  /** Wonderland Engine instance. @hidden */
  _engine;
  /** Index in the manager. @hidden */
  _id = 0;
  /** HTML image index. @hidden */
  _imageIndex = null;
  /**
   * @param engine The engine instance
   * @param param HTML media element to create texture from or texture id to wrap.
   */
  constructor(engine2, param) {
    this._engine = engine2 ?? WL;
    const wasm = engine2.wasm;
    if (param instanceof HTMLImageElement || param instanceof HTMLVideoElement || param instanceof HTMLCanvasElement) {
      const index = wasm._images.length;
      wasm._images.push(param);
      this._imageIndex = index;
      this._id = this._engine.wasm._wl_renderer_addImage(index);
    } else {
      this._id = param;
    }
    this._engine.textures._set(this);
  }
  /** Whether this texture is valid. */
  get valid() {
    return this._id >= 0;
  }
  /** Index in this manager. */
  get id() {
    return this._id;
  }
  /** Update the texture to match the HTML element (e.g. reflect the current frame of a video). */
  update() {
    if (!this.valid || this._imageIndex === null)
      return;
    this._engine.wasm._wl_renderer_updateImage(this._id, this._imageIndex);
  }
  /** Width of the texture. */
  get width() {
    return this._engine.wasm._wl_texture_width(this._id);
  }
  /** Height of the texture. */
  get height() {
    return this._engine.wasm._wl_texture_height(this._id);
  }
  /** Hosting engine instance. */
  get engine() {
    return this._engine;
  }
  /**
   * Update a subrange on the texture to match the HTML element (e.g. reflect the current frame of a video).
   *
   * Usage:
   *
   * ```js
   * // Copies rectangle of pixel starting from (10, 20)
   * texture.updateSubImage(10, 20, 600, 400);
   * ```
   *
   * @param x x offset
   * @param y y offset
   * @param w width
   * @param h height
   */
  updateSubImage(x, y, w, h) {
    if (!this.valid || this._imageIndex === null)
      return;
    if (!temp2d) {
      const canvas2 = document.createElement("canvas");
      const ctx = canvas2.getContext("2d");
      if (!ctx) {
        throw new Error("Texture.updateSubImage(): Failed to obtain CanvasRenderingContext2D.");
      }
      temp2d = {
        canvas: canvas2,
        ctx
      };
    }
    const wasm = this._engine.wasm;
    const img = wasm._images[this._imageIndex];
    if (!img)
      return;
    temp2d.canvas.width = w;
    temp2d.canvas.height = h;
    temp2d.ctx.drawImage(img, x, y, w, h, 0, 0, w, h);
    const yOffset = (img.videoHeight ?? img.height) - y - h;
    wasm._images[this._imageIndex] = temp2d.canvas;
    wasm._wl_renderer_updateImage(this._id, this._imageIndex, x, yOffset);
    wasm._images[this._imageIndex] = img;
  }
  /**
   * Destroy and free the texture's texture altas space and memory.
   *
   * It is best practice to set the texture variable to `null` after calling
   * destroy to prevent accidental use of the invalid texture:
   *
   * ```js
   *   texture.destroy();
   *   texture = null;
   * ```
   *
   * @since 0.9.0
   */
  destroy() {
    this.engine._destroyTexture(this);
    this._id = -1;
    this._imageIndex = null;
  }
  /**
   * Checks equality by comparing whether the wrapped native texture ids are
   * equal.
   *
   * @param otherTexture Texture to check equality with.
   * @returns Whether this texture equals the given texture.
   *
   * @since 1.0.0
   */
  equals(otherTexture) {
    if (!otherTexture)
      return false;
    return this._id === otherTexture._id;
  }
};
var Animation = class {
  /** Index of the mesh in the manager. @hidden */
  _index;
  /** Wonderland Engine instance. @hidden */
  _engine;
  /**
   * @param index Index in the manager
   */
  constructor(engine2 = WL, index) {
    this._engine = engine2;
    this._index = index;
  }
  /** Duration of this animation. */
  get duration() {
    return this._engine.wasm._wl_animation_get_duration(this._index);
  }
  /** Number of tracks in this animation. */
  get trackCount() {
    return this._engine.wasm._wl_animation_get_trackCount(this._index);
  }
  /**
   * Clone this animation retargeted to a new set of objects.
   *
   * The clone shares most of the data with the original and is therefore
   * light-weight.
   *
   * **Experimental:** This API might change in upcoming versions.
   *
   * If retargeting to {@link Skin}, the join names will be used to determine a mapping
   * from the previous skin to the new skin. The source skin will be retrieved from
   * the first track in the animation that targets a joint.
   *
   * @param newTargets New targets per track. Expected to have
   *      {@link Animation#trackCount} elements or to be a {@link Skin}.
   * @returns The retargeted clone of this animation.
   */
  retarget(newTargets) {
    const wasm = this._engine.wasm;
    if (newTargets instanceof Skin) {
      const animId2 = wasm._wl_animation_retargetToSkin(this._index, newTargets._index);
      return new Animation(this._engine, animId2);
    }
    if (newTargets.length != this.trackCount) {
      throw Error("Expected " + this.trackCount.toString() + " targets, but got " + newTargets.length.toString());
    }
    const ptr = wasm._malloc(2 * newTargets.length);
    for (let i = 0; i < newTargets.length; ++i) {
      wasm.HEAPU16[ptr >> 1 + i] = newTargets[i].objectId;
    }
    const animId = wasm._wl_animation_retarget(this._index, ptr);
    wasm._free(ptr);
    return new Animation(this._engine, animId);
  }
  /**
   * Checks equality by comparing whether the wrapped native animation ids
   * are equal.
   *
   * @param otherAnimation Animation to check equality with.
   * @returns Whether this animation equals the given animation.
   *
   * @since 1.0.0
   */
  equals(otherAnimation) {
    if (!otherAnimation)
      return false;
    return this._index === otherAnimation._index;
  }
};
var Object3D = class {
  /**
   * Object index in the manager.
   *
   * @hidden
   */
  _objectId = -1;
  /** Wonderland Engine instance. @hidden */
  _engine;
  /**
   * @param o Object id to wrap
   *
   * For performance reasons, please use {@link WonderlandEngine.wrapObject}
   */
  constructor(engine2, o) {
    this._objectId = o;
    this._engine = engine2;
  }
  /**
   * Name of the object.
   *
   * Useful for identifying objects during debugging.
   */
  get name() {
    const wasm = this._engine.wasm;
    return wasm.UTF8ToString(wasm._wl_object_name(this.objectId));
  }
  /**
   * Set the object's name.
   *
   * @param newName The new name to set.
   */
  set name(newName) {
    const wasm = this._engine.wasm;
    wasm._wl_object_set_name(this.objectId, wasm.tempUTF8(newName));
  }
  /**
   * Parent of this object or `null` if parented to root.
   */
  get parent() {
    const p = this._engine.wasm._wl_object_parent(this.objectId);
    return p === 0 ? null : this._engine.wrapObject(p);
  }
  /**
   * Children of this object.
   *
   * @note Child order is **undefined**. No assumptions should be made
   * about the index of a specific object.
   *
   * If you need to access a specific child of this object, you can
   * use {@link Object3D.findByName}.
   *
   * When the object exists in the scene at editor time, prefer passing it as
   * a component property.
   */
  get children() {
    const childrenCount = this._engine.wasm._wl_object_get_children_count(this.objectId);
    if (childrenCount === 0)
      return [];
    const wasm = this._engine.wasm;
    wasm.requireTempMem(childrenCount * 2);
    this._engine.wasm._wl_object_get_children(this.objectId, wasm._tempMem, wasm._tempMemSize >> 1);
    const children = new Array(childrenCount);
    for (let i = 0; i < childrenCount; ++i) {
      children[i] = this._engine.wrapObject(wasm._tempMemUint16[i]);
    }
    return children;
  }
  /**
   * Reparent object to given object.
   *
   * @note Reparenting is not trivial and might have a noticeable performance impact.
   *
   * @param newParent New parent or `null` to parent to root
   */
  set parent(newParent) {
    this._engine.wasm._wl_object_set_parent(this.objectId, newParent == null ? 0 : newParent.objectId);
  }
  /** Object index in the manager. */
  get objectId() {
    return this._objectId;
  }
  /** Hosting engine instance. */
  get engine() {
    return this._engine;
  }
  /**
   * Clone this hierarchy into a new one.
   *
   * Cloning copies the hierarchy structure, object names,
   * as well as components.
   *
   * JavaScript components are cloned using {@link Component.copy}. You can
   * override this method in your components.
   *
   * @param parent The parent for the cloned hierarchy or `null` to clone
   *     into the scene root. Defaults to `null`.
   *
   * @returns The clone of this object.
   */
  clone(parent = null) {
    const engine2 = this._engine;
    const id = engine2.wasm._wl_object_clone(this._objectId, parent ? parent._objectId : 0);
    return engine2.wrapObject(id);
  }
  /**
   * Reset local transformation (translation, rotation and scaling) to identity.
   *
   * @returns Reference to self (for method chaining).
   */
  resetTransform() {
    this._engine.wasm._wl_object_reset_translation_rotation(this.objectId);
    this._engine.wasm._wl_object_reset_scaling(this.objectId);
    return this;
  }
  /**
   * Reset local position and rotation to identity.
   *
   * @returns Reference to self (for method chaining).
   */
  resetPositionRotation() {
    this._engine.wasm._wl_object_reset_translation_rotation(this.objectId);
    return this;
  }
  /** @deprecated Please use {@link Object3D.resetPositionRotation} instead. */
  resetTranslationRotation() {
    return this.resetPositionRotation();
  }
  /**
   * Reset local rotation, keep translation.
   *
   * @note To reset both rotation and translation, prefer
   *       {@link resetTranslationRotation}.
   *
   * @returns Reference to self (for method chaining).
   */
  resetRotation() {
    this._engine.wasm._wl_object_reset_rotation(this.objectId);
    return this;
  }
  /**
   * Reset local translation, keep rotation.
   *
   * @note To reset both rotation and translation, prefer
   *       {@link resetTranslationRotation}.
   *
   * @returns Reference to self (for method chaining).
   */
  resetPosition() {
    this._engine.wasm._wl_object_reset_translation(this.objectId);
    return this;
  }
  /** @deprecated Please use {@link Object3D.resetPosition} instead. */
  resetTranslation() {
    return this.resetPosition();
  }
  /**
   * Reset local scaling to identity (``[1.0, 1.0, 1.0]``).
   *
   * @returns Reference to self (for method chaining).
   */
  resetScaling() {
    this._engine.wasm._wl_object_reset_scaling(this.objectId);
    return this;
  }
  /** @deprecated Please use {@link Object3D.translateLocal} instead. */
  translate(v) {
    return this.translateLocal(v);
  }
  /**
   * Translate object by a vector in the parent's space.
   *
   * @param v Vector to translate by.
   *
   * @returns Reference to self (for method chaining).
   */
  translateLocal(v) {
    this._engine.wasm._wl_object_translate(this.objectId, v[0], v[1], v[2]);
    return this;
  }
  /**
   * Translate object by a vector in object space.
   *
   * @param v Vector to translate by.
   *
   * @returns Reference to self (for method chaining).
   */
  translateObject(v) {
    this._engine.wasm._wl_object_translate_obj(this.objectId, v[0], v[1], v[2]);
    return this;
  }
  /**
   * Translate object by a vector in world space.
   *
   * @param v Vector to translate by.
   *
   * @returns Reference to self (for method chaining).
   */
  translateWorld(v) {
    this._engine.wasm._wl_object_translate_world(this.objectId, v[0], v[1], v[2]);
    return this;
  }
  /** @deprecated Please use {@link Object3D.rotateAxisAngleDegLocal} instead. */
  rotateAxisAngleDeg(a, d) {
    this.rotateAxisAngleDegLocal(a, d);
    return this;
  }
  /**
   * Rotate around given axis by given angle (degrees) in local space.
   *
   * @param a Vector representing the rotation axis.
   * @param d Angle in degrees.
   *
   * @note If the object is translated the rotation will be around
   *     the parent. To rotate around the object origin, use
   *     {@link rotateAxisAngleDegObject}
   *
   * @see {@link rotateAxisAngleRad}
   *
   * @returns Reference to self (for method chaining).
   */
  rotateAxisAngleDegLocal(a, d) {
    this._engine.wasm._wl_object_rotate_axis_angle(this.objectId, a[0], a[1], a[2], d);
    return this;
  }
  /** @deprecated Please use {@link Object3D.rotateAxisAngleRadLocal} instead. */
  rotateAxisAngleRad(a, d) {
    return this.rotateAxisAngleRadLocal(a, d);
  }
  /**
   * Rotate around given axis by given angle (radians) in local space.
   *
   * @param a Vector representing the rotation axis.
   * @param d Angle in radians.
   *
   * @note If the object is translated the rotation will be around
   *     the parent. To rotate around the object origin, use
   *     {@link rotateAxisAngleDegObject}
   *
   * @see {@link rotateAxisAngleDeg}
   *
   * @returns Reference to self (for method chaining).
   */
  rotateAxisAngleRadLocal(a, d) {
    this._engine.wasm._wl_object_rotate_axis_angle_rad(this.objectId, a[0], a[1], a[2], d);
    return this;
  }
  /**
   * Rotate around given axis by given angle (degrees) in object space.
   *
   * @param a Vector representing the rotation axis.
   * @param d Angle in degrees.
   *
   * Equivalent to prepending a rotation quaternion to the object's
   * local transformation.
   *
   * @see {@link rotateAxisAngleRadObject}
   *
   * @returns Reference to self (for method chaining).
   */
  rotateAxisAngleDegObject(a, d) {
    this._engine.wasm._wl_object_rotate_axis_angle_obj(this.objectId, a[0], a[1], a[2], d);
    return this;
  }
  /**
   * Rotate around given axis by given angle (radians) in object space
   * Equivalent to prepending a rotation quaternion to the object's
   * local transformation.
   *
   * @param a Vector representing the rotation axis
   * @param d Angle in degrees
   *
   * @see {@link rotateAxisAngleDegObject}
   *
   * @returns Reference to self (for method chaining).
   */
  rotateAxisAngleRadObject(a, d) {
    this._engine.wasm._wl_object_rotate_axis_angle_rad_obj(this.objectId, a[0], a[1], a[2], d);
    return this;
  }
  /** @deprecated Please use {@link Object3D.rotateLocal} instead. */
  rotate(q) {
    this.rotateLocal(q);
    return this;
  }
  /**
   * Rotate by a quaternion.
   *
   * @param q the Quaternion to rotate by.
   *
   * @returns Reference to self (for method chaining).
   */
  rotateLocal(q) {
    this._engine.wasm._wl_object_rotate_quat(this.objectId, q[0], q[1], q[2], q[3]);
    return this;
  }
  /**
   * Rotate by a quaternion in object space.
   *
   * Equivalent to prepending a rotation quaternion to the object's
   * local transformation.
   *
   * @param q the Quaternion to rotate by.
   *
   * @returns Reference to self (for method chaining).
   */
  rotateObject(q) {
    this._engine.wasm._wl_object_rotate_quat_obj(this.objectId, q[0], q[1], q[2], q[3]);
    return this;
  }
  /** @deprecated Please use {@link Object3D.scaleLocal} instead. */
  scale(v) {
    this.scaleLocal(v);
    return this;
  }
  /**
   * Scale object by a vector in object space.
   *
   * @param v Vector to scale by.
   *
   * @returns Reference to self (for method chaining).
   */
  scaleLocal(v) {
    this._engine.wasm._wl_object_scale(this.objectId, v[0], v[1], v[2]);
    return this;
  }
  getPositionLocal(out = new Float32Array(3)) {
    const wasm = this._engine.wasm;
    wasm._wl_object_get_translation_local(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    return out;
  }
  getTranslationLocal(out = new Float32Array(3)) {
    return this.getPositionLocal(out);
  }
  getPositionWorld(out = new Float32Array(3)) {
    const wasm = this._engine.wasm;
    wasm._wl_object_get_translation_world(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    return out;
  }
  getTranslationWorld(out = new Float32Array(3)) {
    return this.getPositionWorld(out);
  }
  /**
   * Set local / object space position.
   *
   * Concatenates a new translation dual quaternion onto the existing rotation.
   *
   * @param v New local position array/vector, expected to have at least 3 elements.
   *
   * @returns Reference to self (for method chaining).
   */
  setPositionLocal(v) {
    this._engine.wasm._wl_object_set_translation_local(this.objectId, v[0], v[1], v[2]);
    return this;
  }
  /** @deprecated Please use {@link Object3D.setPositionLocal} instead. */
  setTranslationLocal(v) {
    return this.setPositionLocal(v);
  }
  /**
   * Set world space position.
   *
   * Applies the inverse parent transform with a new translation dual quaternion
   * which is concatenated onto the existing rotation.
   *
   * @param v New world position array/vector, expected to have at least 3 elements.
   *
   * @returns Reference to self (for method chaining).
   */
  setPositionWorld(v) {
    this._engine.wasm._wl_object_set_translation_world(this.objectId, v[0], v[1], v[2]);
    return this;
  }
  /** @deprecated Please use {@link Object3D.setPositionWorld} instead. */
  setTranslationWorld(v) {
    return this.setPositionWorld(v);
  }
  getScalingLocal(out = new Float32Array(3)) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_object_scaling_local(this.objectId) / 4;
    out[0] = wasm.HEAPF32[ptr];
    out[1] = wasm.HEAPF32[ptr + 1];
    out[2] = wasm.HEAPF32[ptr + 2];
    return out;
  }
  /**
   * Set local / object space scaling.
   *
   * @param v New local scaling array/vector, expected to have at least 3 elements.
   *
   * @returns Reference to self (for method chaining).
   */
  setScalingLocal(v) {
    this._engine.wasm._wl_object_set_scaling_local(this.objectId, v[0], v[1], v[2]);
    return this;
  }
  getScalingWorld(out = new Float32Array(3)) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_object_scaling_world(this.objectId) / 4;
    out[0] = wasm.HEAPF32[ptr];
    out[1] = wasm.HEAPF32[ptr + 1];
    out[2] = wasm.HEAPF32[ptr + 2];
    return out;
  }
  /**
   * Set World space scaling.
   *
   * @param v New world scaling array/vector, expected to have at least 3 elements.
   *
   * @returns Reference to self (for method chaining).
   */
  setScalingWorld(v) {
    this._engine.wasm._wl_object_set_scaling_world(this.objectId, v[0], v[1], v[2]);
    return this;
  }
  getRotationLocal(out = new Float32Array(4)) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_object_trans_local(this.objectId) / 4;
    out[0] = wasm.HEAPF32[ptr];
    out[1] = wasm.HEAPF32[ptr + 1];
    out[2] = wasm.HEAPF32[ptr + 2];
    out[3] = wasm.HEAPF32[ptr + 3];
    return out;
  }
  /**
   * Set local space rotation.
   *
   * @param v New world rotation array/vector, expected to have at least 4 elements.
   *
   * @returns Reference to self (for method chaining).
   */
  setRotationLocal(v) {
    this._engine.wasm._wl_object_set_rotation_local(this.objectId, v[0], v[1], v[2], v[3]);
    return this;
  }
  getRotationWorld(out = new Float32Array(4)) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_object_trans_world(this.objectId) / 4;
    out[0] = wasm.HEAPF32[ptr];
    out[1] = wasm.HEAPF32[ptr + 1];
    out[2] = wasm.HEAPF32[ptr + 2];
    out[3] = wasm.HEAPF32[ptr + 3];
    return out;
  }
  /**
   * Set local space rotation.
   *
   * @param v New world rotation array/vector, expected to have at least 4 elements.
   *
   * @returns Reference to self (for method chaining).
   */
  setRotationWorld(v) {
    this._engine.wasm._wl_object_set_rotation_world(this.objectId, v[0], v[1], v[2], v[3]);
    return this;
  }
  getTransformLocal(out = new Float32Array(8)) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_object_trans_local(this.objectId) / 4;
    out[0] = wasm.HEAPF32[ptr];
    out[1] = wasm.HEAPF32[ptr + 1];
    out[2] = wasm.HEAPF32[ptr + 2];
    out[3] = wasm.HEAPF32[ptr + 3];
    out[4] = wasm.HEAPF32[ptr + 4];
    out[5] = wasm.HEAPF32[ptr + 5];
    out[6] = wasm.HEAPF32[ptr + 6];
    out[7] = wasm.HEAPF32[ptr + 7];
    return out;
  }
  /**
   * Set local space rotation.
   *
   * @param v New local transform array, expected to have at least 8 elements.
   *
   * @returns Reference to self (for method chaining).
   */
  setTransformLocal(v) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_object_trans_local(this.objectId) / 4;
    wasm.HEAPF32[ptr] = v[0];
    wasm.HEAPF32[ptr + 1] = v[1];
    wasm.HEAPF32[ptr + 2] = v[2];
    wasm.HEAPF32[ptr + 3] = v[3];
    wasm.HEAPF32[ptr + 4] = v[4];
    wasm.HEAPF32[ptr + 5] = v[5];
    wasm.HEAPF32[ptr + 6] = v[6];
    wasm.HEAPF32[ptr + 7] = v[7];
    this.setDirty();
    return this;
  }
  getTransformWorld(out = new Float32Array(8)) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_object_trans_world(this.objectId) / 4;
    out[0] = wasm.HEAPF32[ptr];
    out[1] = wasm.HEAPF32[ptr + 1];
    out[2] = wasm.HEAPF32[ptr + 2];
    out[3] = wasm.HEAPF32[ptr + 3];
    out[4] = wasm.HEAPF32[ptr + 4];
    out[5] = wasm.HEAPF32[ptr + 5];
    out[6] = wasm.HEAPF32[ptr + 6];
    out[7] = wasm.HEAPF32[ptr + 7];
    return out;
  }
  /**
   * Set world space rotation.
   *
   * @param v New world transform array, expected to have at least 8 elements.
   *
   * @returns Reference to self (for method chaining).
   */
  setTransformWorld(v) {
    const wasm = this._engine.wasm;
    const ptr = wasm._wl_object_trans_world(this.objectId) / 4;
    wasm.HEAPF32[ptr] = v[0];
    wasm.HEAPF32[ptr + 1] = v[1];
    wasm.HEAPF32[ptr + 2] = v[2];
    wasm.HEAPF32[ptr + 3] = v[3];
    wasm.HEAPF32[ptr + 4] = v[4];
    wasm.HEAPF32[ptr + 5] = v[5];
    wasm.HEAPF32[ptr + 6] = v[6];
    wasm.HEAPF32[ptr + 7] = v[7];
    this._engine.wasm._wl_object_trans_world_to_local(this.objectId);
    return this;
  }
  /**
   * Local space transformation.
   *
   * @deprecated Please use {@link Object3D.setTransformLocal} and
   * {@link Object3D.getTransformLocal} instead.
   */
  get transformLocal() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_object_trans_local(this.objectId), 8);
  }
  /**
   * Set local transform.
   *
   * @param t Local space transformation.
   *
   * @since 0.8.5
   *
   * @deprecated Please use {@link Object3D.setTransformLocal} and
   * {@link Object3D.getTransformLocal} instead.
   */
  set transformLocal(t) {
    this.transformLocal.set(t);
    this.setDirty();
  }
  /**
   * Global / world space transformation.
   *
   * May recompute transformations of the hierarchy of this object,
   * if they were changed by JavaScript components this frame.
   *
   * @deprecated Please use {@link Object3D.setTransformWorld} and
   * {@link Object3D.getTransformWorld} instead.
   */
  get transformWorld() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_object_trans_world(this.objectId), 8);
  }
  /**
   * Set world transform.
   *
   * @param t Global / world space transformation.
   *
   * @since 0.8.5
   *
   * @deprecated Please use {@link Object3D.setTransformWorld} and
   * {@link Object3D.getTransformWorld} instead.
   */
  set transformWorld(t) {
    this.transformWorld.set(t);
    this._engine.wasm._wl_object_trans_world_to_local(this.objectId);
  }
  /**
   * Local / object space scaling.
   *
   * @deprecated Please use {@link Object3D.setScalingLocal} and
   * {@link Object3D.getScalingLocal} instead.
   */
  get scalingLocal() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_object_scaling_local(this.objectId), 3);
  }
  /**
   * Set local space scaling.
   *
   * @param s Local space scaling.
   *
   * @since 0.8.7
   *
   * @deprecated Please use {@link Object3D.setScalingLocal} and
   * {@link Object3D.getScalingLocal} instead.
   */
  set scalingLocal(s) {
    this.scalingLocal.set(s);
    this.setDirty();
  }
  /**
   * Global / world space scaling.
   *
   * May recompute transformations of the hierarchy of this object,
   * if they were changed by JavaScript components this frame.
   *
   * @deprecated Please use {@link Object3D.setScalingWorld} and
   * {@link Object3D.getScalingWorld} instead.
   */
  get scalingWorld() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_object_scaling_world(this.objectId), 3);
  }
  /**
   * Set world space scaling.
   *
   * @param t World space scaling.
   *
   * @since 0.8.7
   *
   * @deprecated Please use {@link Object3D.setScalingWorld} and
   * {@link Object3D.getScalingWorld} instead.
   */
  set scalingWorld(s) {
    this.scalingWorld.set(s);
    this._engine.wasm._wl_object_scaling_world_to_local(this.objectId);
  }
  /**
   * Local space rotation.
   *
   * @since 0.8.7
   *
   * @deprecated Please use {@link Object3D.getRotationLocal} and
   * {@link Object3D.setRotationLocal} instead.
   */
  get rotationLocal() {
    return this.transformLocal.subarray(0, 4);
  }
  /**
   * Global / world space rotation
   *
   * @since 0.8.7
   *
   * @deprecated Please use {@link Object3D.getRotationWorld} and
   * {@link Object3D.setRotationWorld} instead.
   */
  get rotationWorld() {
    return this.transformWorld.subarray(0, 4);
  }
  /**
   * Set local space rotation.
   *
   * @param r Local space rotation
   *
   * @since 0.8.7
   *
   * @deprecated Please use {@link Object3D.getRotationLocal} and
   * {@link Object3D.setRotationLocal} instead.
   */
  set rotationLocal(r) {
    this._engine.wasm._wl_object_set_rotation_local(this.objectId, r[0], r[1], r[2], r[3]);
  }
  /**
   * Set world space rotation.
   *
   * @param r Global / world space rotation.
   *
   * @since 0.8.7
   *
   * @deprecated Please use {@link Object3D.getRotationWorld} and
   * {@link Object3D.setRotationWorld} instead.
   */
  set rotationWorld(r) {
    this._engine.wasm._wl_object_set_rotation_world(this.objectId, r[0], r[1], r[2], r[3]);
  }
  /** @deprecated Please use {@link Object3D.getForwardWorld} instead. */
  getForward(out) {
    return this.getForwardWorld(out);
  }
  /**
   * Compute the object's forward facing world space vector.
   *
   * The forward vector in object space is along the negative z-axis, i.e.,
   * `[0, 0, -1]`.
   *
   * @param out Destination array/vector, expected to have at least 3 elements.
   * @return The `out` parameter.
   */
  getForwardWorld(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = -1;
    this.transformVectorWorld(out);
    return out;
  }
  /** @deprecated Please use {@link Object3D.getUpWorld} instead. */
  getUp(out) {
    return this.getUpWorld(out);
  }
  /**
   * Compute the object's up facing world space vector.
   *
   * @param out Destination array/vector, expected to have at least 3 elements.
   * @return The `out` parameter.
   */
  getUpWorld(out) {
    out[0] = 0;
    out[1] = 1;
    out[2] = 0;
    this.transformVectorWorld(out);
    return out;
  }
  /** @deprecated Please use {@link Object3D.getRightWorld} instead. */
  getRight(out) {
    return this.getRightWorld(out);
  }
  /**
   * Compute the object's right facing world space vector.
   *
   * @param out Destination array/vector, expected to have at least 3 elements.
   * @return The `out` parameter.
   */
  getRightWorld(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    this.transformVectorWorld(out);
    return out;
  }
  /**
   * Transform a vector by this object's world transform.
   *
   * @param out Out vector
   * @param v Vector to transform, default `out`
   * @return The `out` parameter.
   *
   * @since 0.8.7
   */
  transformVectorWorld(out, v = out) {
    const wasm = this._engine.wasm;
    wasm._tempMemFloat[0] = v[0];
    wasm._tempMemFloat[1] = v[1];
    wasm._tempMemFloat[2] = v[2];
    wasm._wl_object_transformVectorWorld(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    return out;
  }
  /**
   * Transform a vector by this object's local transform.
   *
   * @param out Out vector
   * @param v Vector to transform, default `out`
   * @return The `out` parameter.
   *
   * @since 0.8.7
   */
  transformVectorLocal(out, v = out) {
    const wasm = this._engine.wasm;
    wasm._tempMemFloat[0] = v[0];
    wasm._tempMemFloat[1] = v[1];
    wasm._tempMemFloat[2] = v[2];
    wasm._wl_object_transformVectorLocal(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    return out;
  }
  /**
   * Transform a point by this object's world transform.
   *
   * @param out Out point.
   * @param p Point to transform, default `out`.
   * @return The `out` parameter.
   *
   * @since 0.8.7
   */
  transformPointWorld(out, p = out) {
    const wasm = this._engine.wasm;
    wasm._tempMemFloat[0] = p[0];
    wasm._tempMemFloat[1] = p[1];
    wasm._tempMemFloat[2] = p[2];
    wasm._wl_object_transformPointWorld(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    return out;
  }
  /**
   * Transform a point by this object's local transform.
   *
   * @param out Out point.
   * @param p Point to transform, default `out`.
   * @return The `out` parameter.
   *
   * @since 0.8.7
   */
  transformPointLocal(out, p = out) {
    const wasm = this._engine.wasm;
    wasm._tempMemFloat[0] = p[0];
    wasm._tempMemFloat[1] = p[1];
    wasm._tempMemFloat[2] = p[2];
    wasm._wl_object_transformPointLocal(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    return out;
  }
  /**
   * Transform a vector by this object's inverse world transform.
   *
   * @param out Out vector.
   * @param v Vector to transform, default `out`.
   * @return The `out` parameter.
   *
   * @since 0.8.7
   */
  transformVectorInverseWorld(out, v = out) {
    const wasm = this._engine.wasm;
    wasm._tempMemFloat[0] = v[0];
    wasm._tempMemFloat[1] = v[1];
    wasm._tempMemFloat[2] = v[2];
    wasm._wl_object_transformVectorInverseWorld(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    return out;
  }
  /**
   * Transform a vector by this object's inverse local transform.
   *
   * @param out Out vector
   * @param v Vector to transform, default `out`
   * @return The `out` parameter.
   *
   * @since 0.8.7
   */
  transformVectorInverseLocal(out, v = out) {
    const wasm = this._engine.wasm;
    wasm._tempMemFloat[0] = v[0];
    wasm._tempMemFloat[1] = v[1];
    wasm._tempMemFloat[2] = v[2];
    wasm._wl_object_transformVectorInverseLocal(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    return out;
  }
  /**
   * Transform a point by this object's inverse world transform.
   *
   * @param out Out point.
   * @param p Point to transform, default `out`.
   * @return The `out` parameter.
   *
   * @since 0.8.7
   */
  transformPointInverseWorld(out, p = out) {
    const wasm = this._engine.wasm;
    wasm._tempMemFloat[0] = p[0];
    wasm._tempMemFloat[1] = p[1];
    wasm._tempMemFloat[2] = p[2];
    wasm._wl_object_transformPointInverseWorld(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    return out;
  }
  /**
   * Transform a point by this object's inverse local transform.
   *
   * @param out Out point.
   * @param p Point to transform, default `out`.
   * @return The `out` parameter.
   *
   * @since 0.8.7
   */
  transformPointInverseLocal(out, p = out) {
    const wasm = this._engine.wasm;
    wasm._tempMemFloat.set(p);
    wasm._wl_object_transformPointInverseLocal(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    return out;
  }
  /**
   * Transform an object space dual quaternion into world space.
   *
   * @param out Out transformation.
   * @param q Local space transformation, default `out`.
   * @return The `out` parameter.
   *
   * @since 0.8.7
   */
  toWorldSpaceTransform(out, q = out) {
    const wasm = this._engine.wasm;
    wasm._tempMemFloat.set(q);
    wasm._wl_object_toWorldSpaceTransform(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    out[3] = wasm._tempMemFloat[3];
    out[4] = wasm._tempMemFloat[4];
    out[5] = wasm._tempMemFloat[5];
    out[6] = wasm._tempMemFloat[6];
    out[7] = wasm._tempMemFloat[7];
    return out;
  }
  /**
   * Transform a world space dual quaternion into local space.
   *
   * @param out Out transformation
   * @param q World space transformation, default `out`
   * @return The `out` parameter.
   *
   * @since 0.8.7
   */
  toLocalSpaceTransform(out, q = out) {
    const p = this.parent;
    if (p) {
      p.toObjectSpaceTransform(out, q);
      return out;
    }
    if (out !== q) {
      out[0] = q[0];
      out[1] = q[1];
      out[2] = q[2];
      out[3] = q[3];
      out[4] = q[4];
      out[5] = q[5];
      out[6] = q[6];
      out[7] = q[7];
    }
    return out;
  }
  /**
   * Transform a world space dual quaternion into object space.
   *
   * @param out Out transformation.
   * @param q World space transformation, default `out`
   * @return The `out` parameter.
   *
   * @since 0.8.7
   */
  toObjectSpaceTransform(out, q = out) {
    const wasm = this._engine.wasm;
    wasm._tempMemFloat.set(q);
    wasm._wl_object_toObjectSpaceTransform(this.objectId, wasm._tempMem);
    out[0] = wasm._tempMemFloat[0];
    out[1] = wasm._tempMemFloat[1];
    out[2] = wasm._tempMemFloat[2];
    out[3] = wasm._tempMemFloat[3];
    out[4] = wasm._tempMemFloat[4];
    out[5] = wasm._tempMemFloat[5];
    out[6] = wasm._tempMemFloat[6];
    out[7] = wasm._tempMemFloat[7];
    return out;
  }
  /**
   * Turn towards / look at target.
   *
   * Rotates the object so that its forward vector faces towards the target
   * position. The `up` vector acts as a hint to uniquely orient the object's
   * up direction. When orienting a view component, the projected `up` vector
   * faces upwards on the viewing plane.
   *
   * @param p Target position to turn towards, in world space.
   * @param up Up vector to align object with, in world space. Default is `[0, 1, 0]`.
   *
   * @returns Reference to self (for method chaining).
   */
  lookAt(p, up = UP_VECTOR) {
    this._engine.wasm._wl_object_lookAt(this.objectId, p[0], p[1], p[2], up[0], up[1], up[2]);
    return this;
  }
  /** Destroy the object with all of its components and remove it from the scene */
  destroy() {
    if (this._objectId < 0)
      return;
    this.engine.wasm._wl_scene_remove_object(this._objectId);
    this.engine._destroyObject(this);
  }
  /**
   * Mark transformation dirty.
   *
   * Causes an eventual recalculation of {@link transformWorld}, either
   * on next {@link getTranslationWorld}, {@link transformWorld} or
   * {@link scalingWorld} or the beginning of next frame, whichever
   * happens first.
   */
  setDirty() {
    this._engine.wasm._wl_object_set_dirty(this.objectId);
  }
  /**
   * Disable/enable all components of this object.
   *
   * @param b New state for the components.
   *
   * @since 0.8.5
   */
  set active(b) {
    const comps = this.getComponents();
    for (let c of comps) {
      c.active = b;
    }
  }
  getComponent(typeOrClass, index = 0) {
    const type = isString(typeOrClass) ? typeOrClass : typeOrClass.TypeName;
    const wasm = this._engine.wasm;
    const componentType = wasm._wl_get_component_manager_index(wasm.tempUTF8(type));
    if (componentType < 0) {
      const typeIndex = wasm._componentTypeIndices[type];
      if (typeIndex === void 0)
        return null;
      const jsIndex = wasm._wl_get_js_component_index(this.objectId, typeIndex, index);
      if (jsIndex < 0)
        return null;
      const component = this._engine.wasm._components[jsIndex];
      return component.constructor !== BrokenComponent ? component : null;
    }
    const componentId = this._engine.wasm._wl_get_component_id(this.objectId, componentType, index);
    return this._engine._wrapComponent(type, componentType, componentId);
  }
  getComponents(typeOrClass) {
    const wasm = this._engine.wasm;
    let componentType = null;
    let type = null;
    if (typeOrClass) {
      type = isString(typeOrClass) ? typeOrClass : typeOrClass.TypeName;
      componentType = wasm._typeIndexFor(type);
    }
    const components = [];
    const maxComps = Math.floor(wasm._tempMemSize / 3 * 2);
    const componentsCount = wasm._wl_object_get_components(this.objectId, wasm._tempMem, maxComps);
    const offset2 = 2 * componentsCount;
    wasm._wl_object_get_component_types(this.objectId, wasm._tempMem + offset2, maxComps);
    const jsManagerIndex = wasm._jsManagerIndex;
    for (let i = 0; i < componentsCount; ++i) {
      const t = wasm._tempMemUint8[i + offset2];
      const componentId = wasm._tempMemUint16[i];
      if (t == jsManagerIndex) {
        const typeIndex = wasm._wl_get_js_component_index_for_id(componentId);
        const comp = wasm._components[typeIndex];
        const matches = componentType === null || comp.type == type;
        if (comp.constructor !== BrokenComponent && matches) {
          components.push(comp);
        }
        continue;
      }
      if (componentType === null) {
        const managerName = wasm._typeNameFor(t);
        components.push(this._engine._wrapComponent(managerName, t, componentId));
      } else if (t == componentType) {
        components.push(this._engine._wrapComponent(type, componentType, componentId));
      }
    }
    return components;
  }
  addComponent(typeOrClass, params) {
    const wasm = this._engine.wasm;
    const type = isString(typeOrClass) ? typeOrClass : typeOrClass.TypeName;
    const componentType = wasm._typeIndexFor(type);
    let component = null;
    let componentIndex = null;
    if (componentType < 0) {
      if (!(type in wasm._componentTypeIndices)) {
        throw new TypeError("Unknown component type '" + type + "'");
      }
      const componentId = wasm._wl_object_add_js_component(this.objectId, wasm._componentTypeIndices[type]);
      componentIndex = wasm._wl_get_js_component_index_for_id(componentId);
      component = wasm._components[componentIndex];
    } else {
      const componentId = wasm._wl_object_add_component(this.objectId, componentType);
      component = this._engine._wrapComponent(type, componentType, componentId);
    }
    if (params !== void 0)
      component.copy(params);
    if (componentType < 0) {
      wasm._wljs_component_init(componentIndex);
    }
    if (!params || !("active" in params && !params.active)) {
      component.active = true;
    }
    return component;
  }
  /**
   * Search for descendants matching the name.
   *
   * This method is a wrapper around {@link Object3D.findByNameDirect} and
   * {@link Object3D.findByNameRecursive}.
   *
   * @param name The name to search for.
   * @param recursive If `true`, the method will look at all the descendants of this object.
   *     If `false`, this method will only perform the search in direct children.
   * @returns An array of {@link Object3D} matching the name.
   *
   * @since 1.1.0
   */
  findByName(name, recursive = false) {
    return recursive ? this.findByNameRecursive(name) : this.findByNameDirect(name);
  }
  /**
   * Search for all **direct** children matching the name.
   *
   * @note Even though this method is heavily optimized, it does perform
   * a linear search to find the objects. Do not use in a hot path.
   *
   * @param name The name to search for.
   * @returns An array of {@link Object3D} matching the name.
   *
   * @since 1.1.0
   */
  findByNameDirect(name) {
    const wasm = this._engine.wasm;
    const id = this._objectId;
    const tempSizeU16 = wasm._tempMemSize >> 2;
    const maxCount = tempSizeU16 - 2;
    const buffer = wasm._tempMemUint16;
    buffer[maxCount] = 0;
    buffer[maxCount + 1] = 0;
    const bufferPtr = wasm._tempMem;
    const indexPtr = bufferPtr + maxCount * 2;
    const childCountPtr = bufferPtr + maxCount * 2 + 2;
    const namePtr = wasm.tempUTF8(name, (maxCount + 2) * 2);
    const result = [];
    let read = 0;
    while (read = wasm._wl_object_findByName(id, namePtr, indexPtr, childCountPtr, bufferPtr, maxCount)) {
      for (let i = 0; i < read; ++i)
        result.push(this.engine.wrapObject(buffer[i]));
    }
    return result;
  }
  /**
   * Search for **all descendants** matching the name.
   *
   * @note Even though this method is heavily optimized, it does perform
   * a linear search to find the objects. Do not use in a hot path.
   *
   * @param name The name to search for.
   * @returns An array of {@link Object3D} matching the name.
   *
   * @since 1.1.0
   */
  findByNameRecursive(name) {
    const wasm = this._engine.wasm;
    const id = this._objectId;
    const tempSizeU16 = wasm._tempMemSize >> 2;
    const maxCount = tempSizeU16 - 1;
    const buffer = wasm._tempMemUint16;
    buffer[maxCount] = 0;
    const bufferPtr = wasm._tempMem;
    const indexPtr = bufferPtr + maxCount * 2;
    const namePtr = wasm.tempUTF8(name, (maxCount + 1) * 2);
    let read = 0;
    const result = [];
    while (read = wasm._wl_object_findByNameRecursive(id, namePtr, indexPtr, bufferPtr, maxCount)) {
      for (let i = 0; i < read; ++i)
        result.push(this.engine.wrapObject(buffer[i]));
    }
    return result;
  }
  /**
   * Whether given object's transformation has changed.
   */
  get changed() {
    return !!this._engine.wasm._wl_object_is_changed(this.objectId);
  }
  /**
   * `true` if the object is destroyed, `false` otherwise.
   *
   * If {@link WonderlandEngine.erasePrototypeOnDestroy} is `true`,
   * reading a custom property will not work:
   *
   * ```js
   * engine.erasePrototypeOnDestroy = true;
   *
   * const obj = scene.addObject();
   * obj.customParam = 'Hello World!';
   *
   * console.log(obj.isDestroyed); // Prints `false`
   * obj.destroy();
   * console.log(obj.isDestroyed); // Prints `true`
   * console.log(obj.customParam); // Throws an error
   * ```
   *
   * @since 1.1.1
   */
  get isDestroyed() {
    return this._objectId < 0;
  }
  /**
   * Checks equality by comparing whether the wrapped native object ids are
   * equal.
   *
   * @param otherObject Object to check equality with.
   * @returns Whether this object equals the given object.
   */
  equals(otherObject) {
    if (!otherObject)
      return false;
    return this.objectId == otherObject.objectId;
  }
};
var Skin = class {
  /**
   * Index of the skin in the manager.
   * @hidden
   */
  _index;
  /** Wonderland Engine instance. @hidden */
  _engine;
  constructor(engine2, index) {
    this._engine = engine2;
    this._index = index;
  }
  /** Amount of joints in this skin. */
  get jointCount() {
    return this._engine.wasm._wl_skin_get_joint_count(this._index);
  }
  /** Joints object ids for this skin */
  get jointIds() {
    const wasm = this._engine.wasm;
    return new Uint16Array(wasm.HEAPU16.buffer, wasm._wl_skin_joint_ids(this._index), this.jointCount);
  }
  /**
   * Dual quaternions in a flat array of size 8 times {@link jointCount}.
   *
   * Inverse bind transforms of the skin.
   */
  get inverseBindTransforms() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_skin_inverse_bind_transforms(this._index), 8 * this.jointCount);
  }
  /**
   * Vectors in a flat array of size 3 times {@link jointCount}.
   *
   * Inverse bind scalings of the skin.
   */
  get inverseBindScalings() {
    const wasm = this._engine.wasm;
    return new Float32Array(wasm.HEAPF32.buffer, wasm._wl_skin_inverse_bind_scalings(this._index), 3 * this.jointCount);
  }
  /**
   * Checks equality by comparing whether the wrapped native skin ids are
   * equal.
   *
   * @param otherSkin Skin to check equality with.
   * @returns Whether this skin equals the given skin.
   *
   * @since 1.0.0
   */
  equals(otherSkin) {
    if (!otherSkin)
      return false;
    return this._index === otherSkin._index;
  }
};
var RayHit = class {
  /** Wonderland Engine instance. @hidden */
  _engine;
  /** Pointer to the memory heap. */
  _ptr;
  /**
   * @param ptr Pointer to the ray hits memory.
   */
  constructor(engine2, ptr) {
    if ((ptr & 3) !== 0) {
      throw new Error("Misaligned pointer: please report a bug");
    }
    this._engine = engine2;
    this._ptr = ptr;
  }
  /** Array of ray hit locations. */
  get locations() {
    let p = this._ptr;
    let l = [];
    for (let i = 0; i < this.hitCount; ++i) {
      l.push(new Float32Array(this._engine.wasm.HEAPF32.buffer, p + 12 * i, 3));
    }
    return l;
  }
  /** Array of ray hit normals (only when using {@link Physics#rayCast}. */
  get normals() {
    let p = this._ptr + 48;
    let l = [];
    for (let i = 0; i < this.hitCount; ++i) {
      l.push(new Float32Array(this._engine.wasm.HEAPF32.buffer, p + 12 * i, 3));
    }
    return l;
  }
  /**
   * Prefer these to recalculating the distance from locations.
   *
   * Distances of array hits to ray origin.
   */
  get distances() {
    const p = this._ptr + 48 * 2;
    return new Float32Array(this._engine.wasm.HEAPF32.buffer, p, this.hitCount);
  }
  /** Hit objects */
  get objects() {
    const HEAPU16 = this._engine.wasm.HEAPU16;
    const objects = [null, null, null, null];
    let p = this._ptr + (48 * 2 + 16) >> 1;
    for (let i = 0; i < this.hitCount; ++i) {
      objects[i] = this._engine.wrapObject(HEAPU16[p + i]);
    }
    return objects;
  }
  /** Number of hits (max 4) */
  get hitCount() {
    return Math.min(this._engine.wasm.HEAPU32[this._ptr / 4 + 30], 4);
  }
};
var math = class {
  /** (Experimental!) Cubic Hermite spline interpolation for vector3 and quaternions.
   *
   * With `f == 0`, `out` will be `b`, if `f == 1`, `out` will be c.
   *
   * Whether a quaternion or vector3 interpolation is intended is determined by
   * length of `a`.
   *
   * @param out Array to write result to.
   * @param a First tangent/handle.
   * @param b First point or quaternion.
   * @param c Second point or quaternion.
   * @param d Second handle.
   * @param f Interpolation factor in [0; 1].
   * @returns The `out` parameter.
   *
   * @since 0.8.6
   */
  static cubicHermite(out, a, b, c, d, f, engine2 = WL) {
    const wasm = engine2.wasm;
    wasm._tempMemFloat.subarray(0).set(a);
    wasm._tempMemFloat.subarray(4).set(b);
    wasm._tempMemFloat.subarray(8).set(c);
    wasm._tempMemFloat.subarray(12).set(d);
    const isQuat = a.length == 4;
    wasm._wl_math_cubicHermite(wasm._tempMem + 4 * 16, wasm._tempMem + 4 * 0, wasm._tempMem + 4 * 4, wasm._tempMem + 4 * 8, wasm._tempMem + 4 * 12, f, isQuat);
    out[0] = wasm._tempMemFloat[16];
    out[1] = wasm._tempMemFloat[17];
    out[2] = wasm._tempMemFloat[18];
    if (isQuat)
      out[3] = wasm._tempMemFloat[19];
    return out;
  }
};
var I18N = class {
  /**
   * {@link Emitter} for language change events.
   *
   * First parameter to a listener is the old language index,
   * second parameter is the new language index.
   *
   * Usage from a within a component:
   *
   * ```js
   * this.engine.i18n.onLanguageChanged.add((oldLanguageIndex, newLanguageIndex) => {
   *     const oldLanguage = this.engine.i18n.languageName(oldLanguageIndex);
   *     const newLanguage = this.engine.i18n.languageName(newLanguageIndex);
   *     console.log("Switched from", oldLanguage, "to", newLanguage);
   * });
   * ```
   */
  onLanguageChanged = new Emitter();
  /** Wonderland Engine instance. @hidden */
  _engine;
  /** Previously set language index. @hidden */
  _prevLanguageIndex = -1;
  /**
   * Constructor
   */
  constructor(engine2) {
    this._engine = engine2;
  }
  /**
   * Set current language and apply translations to linked text parameters.
   *
   * @note This is equivalent to {@link I18N.setLanguage}.
   *
   * @param code Language code to switch to
   */
  set language(code) {
    this.setLanguage(code);
  }
  /** Get current language code. */
  get language() {
    const wasm = this._engine.wasm;
    const code = wasm._wl_i18n_currentLanguage();
    if (code === 0)
      return null;
    return wasm.UTF8ToString(code);
  }
  /**
   * Get the current language index.
   *
   * This method is more efficient than its equivalent:
   *
   * ```js
   * const index = i18n.languageIndex(i18n.language);
   * ```
   */
  get currentIndex() {
    return this._engine.wasm._wl_i18n_currentLanguageIndex();
  }
  /** Previous language index. */
  get previousIndex() {
    return this._prevLanguageIndex;
  }
  /**
   * Set current language and apply translations to linked text parameters.
   *
   * @param code The language code.
   * @returns A promise that resolves with the current index code when the
   *     language is loaded.
   */
  setLanguage(code) {
    if (code == null)
      return Promise.resolve(this.currentIndex);
    const wasm = this._engine.wasm;
    this._prevLanguageIndex = this.currentIndex;
    wasm._wl_i18n_setLanguage(wasm.tempUTF8(code));
    return this._engine.scene._flushAppend(this._engine.scene.baseURL).then(() => this.currentIndex);
  }
  /**
   * Get translated string for a term for the currently loaded language.
   *
   * @param term Term to translate
   */
  translate(term) {
    const wasm = this._engine.wasm;
    const translation = wasm._wl_i18n_translate(wasm.tempUTF8(term));
    if (translation === 0)
      return null;
    return wasm.UTF8ToString(translation);
  }
  /**
   * Get the number of languages in the project.
   *
   */
  languageCount() {
    const wasm = this._engine.wasm;
    return wasm._wl_i18n_languageCount();
  }
  /**
   * Get a language code.
   *
   * @param index Index of the language to get the code from
   */
  languageIndex(code) {
    const wasm = this._engine.wasm;
    return wasm._wl_i18n_languageIndex(wasm.tempUTF8(code));
  }
  /**
   * Get a language code.
   *
   * @param index Index of the language to get the code from
   */
  languageCode(index) {
    const wasm = this._engine.wasm;
    const code = wasm._wl_i18n_languageCode(index);
    if (code === 0)
      return null;
    return wasm.UTF8ToString(code);
  }
  /**
   * Get a language name.
   *
   * @param index Index of the language to get the name from
   */
  languageName(index) {
    const wasm = this._engine.wasm;
    const name = wasm._wl_i18n_languageName(index);
    if (name === 0)
      return null;
    return wasm.UTF8ToString(name);
  }
};
var XR = class {
  /** Wonderland WASM bridge. @hidden */
  #wasm;
  #mode;
  constructor(wasm, mode) {
    this.#wasm = wasm;
    this.#mode = mode;
  }
  /** Current WebXR session mode */
  get sessionMode() {
    return this.#mode;
  }
  /** Current WebXR session */
  get session() {
    return this.#wasm.webxr_session;
  }
  /** Current WebXR frame */
  get frame() {
    return this.#wasm.webxr_frame;
  }
  referenceSpaceForType(type) {
    return this.#wasm.webxr_refSpaces[type] ?? null;
  }
  /** Set current reference space type used for retrieving eye, head, hand and joint poses */
  set currentReferenceSpace(refSpace) {
    this.#wasm.webxr_refSpace = refSpace;
    this.#wasm.webxr_refSpaceType = null;
    for (const type of Object.keys(this.#wasm.webxr_refSpaces)) {
      if (this.#wasm.webxr_refSpaces[type] === refSpace) {
        this.#wasm.webxr_refSpaceType = type;
      }
    }
  }
  /** Current reference space type used for retrieving eye, head, hand and joint poses */
  get currentReferenceSpace() {
    return this.#wasm.webxr_refSpace;
  }
  /** Current WebXR reference space type or `null` if not a default reference space */
  get currentReferenceSpaceType() {
    return this.#wasm.webxr_refSpaceType;
  }
  /** Current WebXR base layer  */
  get baseLayer() {
    return this.#wasm.webxr_baseLayer;
  }
  /** Current WebXR framebuffer */
  get framebuffers() {
    if (!Array.isArray(this.#wasm.webxr_fbo)) {
      return [this.#wasm.GL.framebuffers[this.#wasm.webxr_fbo]];
    }
    return this.#wasm.webxr_fbo.map((id) => this.#wasm.GL.framebuffers[id]);
  }
};

// node_modules/@wonderlandengine/api/dist/utils/fetch.js
function fetchWithProgress(path, onProgress) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", path);
    xhr.responseType = "arraybuffer";
    xhr.onprogress = (progress) => {
      if (progress.lengthComputable) {
        onProgress?.(progress.loaded, progress.total);
      }
    };
    xhr.onload = () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        const buffer = xhr.response;
        onProgress?.(buffer.byteLength, buffer.byteLength);
        resolve(buffer);
      } else {
        reject(xhr.statusText);
      }
    };
    xhr.onerror = () => reject(xhr.statusText);
    xhr.send();
  });
}
function getBaseUrl(url) {
  return url.substring(0, url.lastIndexOf("/"));
}

// node_modules/@wonderlandengine/api/dist/utils/misc.js
function timeout(time) {
  return new Promise((res) => setTimeout(res, time));
}
function clamp(val, min4, max4) {
  return Math.max(Math.min(max4, val), min4);
}

// node_modules/@wonderlandengine/api/dist/scene.js
var MAGIC_BIN = "WLEV";
var Scene = class {
  /** Called before rendering the scene */
  onPreRender = new Emitter();
  /** Called after the scene has been rendered */
  onPostRender = new Emitter();
  /** Wonderland Engine instance. @hidden */
  _engine;
  /** Ray hit pointer in WASM heap. @hidden */
  _rayHit;
  /** Ray hit. @hidden */
  _hit;
  /**
   * Relative directory of the scene that was loaded with {@link Scene.load}
   * Used for loading any files relative to the main scene.
   *
   * We need this for the tests that load bin files since we aren't loading
   * from the deploy folder directly. (test/resources/projects/*.bin)
   *
   * @hidden
   */
  _baseURL;
  constructor(engine2) {
    this._engine = engine2;
    this._rayHit = engine2.wasm._malloc(4 * (3 * 4 + 3 * 4 + 4 + 2) + 4);
    this._hit = new RayHit(this._engine, this._rayHit);
    this._baseURL = "";
  }
  /**
   * Currently active view components.
   */
  get activeViews() {
    const wasm = this._engine.wasm;
    const count = wasm._wl_scene_get_active_views(this._engine.wasm._tempMem, 16);
    const views = [];
    const viewTypeIndex = wasm._typeIndexFor("view");
    for (let i = 0; i < count; ++i) {
      views.push(new ViewComponent(this._engine, viewTypeIndex, this._engine.wasm._tempMemInt[i]));
    }
    return views;
  }
  /**
   * Relative directory of the scene that was loaded with {@link Scene.load}
   * Used for loading any files relative to the main scene.
   *
   * @hidden
   */
  get baseURL() {
    return this._baseURL;
  }
  /**
   * Cast a ray through the scene and find intersecting objects.
   *
   * The resulting ray hit will contain up to **4** closest ray hits,
   * sorted by increasing distance.
   *
   * @param o Ray origin.
   * @param d Ray direction.
   * @param group Collision group to filter by: only objects that are
   *        part of given group are considered for raycast.
   * @param maxDistance Maximum **inclusive** hit distance. Defaults to `100`.
   *
   * @returns The scene cached {@link RayHit} instance.
   * @note The returned object is owned by the Scene instance
   *   will be reused with the next {@link Scene#rayCast} call.
   */
  rayCast(o, d, group, maxDistance = 100) {
    this._engine.wasm._wl_scene_ray_cast(o[0], o[1], o[2], d[0], d[1], d[2], group, this._rayHit, maxDistance);
    return this._hit;
  }
  /**
   * Add an object to the scene.
   *
   * @param parent Parent object or `null`.
   * @returns A newly created object.
   */
  addObject(parent = null) {
    const parentId = parent ? parent.objectId : 0;
    const objectId = this._engine.wasm._wl_scene_add_object(parentId);
    return this._engine.wrapObject(objectId);
  }
  /**
   * Batch-add objects to the scene.
   *
   * Will provide better performance for adding multiple objects (e.g. > 16)
   * than calling {@link Scene#addObject} repeatedly in a loop.
   *
   * By providing upfront information of how many objects will be required,
   * the engine is able to batch-allocate the required memory rather than
   * convervatively grow the memory in small steps.
   *
   * **Experimental:** This API might change in upcoming versions.
   *
   * @param count Number of objects to add.
   * @param parent Parent object or `null`, default `null`.
   * @param componentCountHint Hint for how many components in total will
   *      be added to the created objects afterwards, default `0`.
   * @returns Newly created objects
   */
  addObjects(count, parent = null, componentCountHint = 0) {
    const parentId = parent ? parent.objectId : 0;
    this._engine.wasm.requireTempMem(count * 2);
    const actualCount = this._engine.wasm._wl_scene_add_objects(parentId, count, componentCountHint || 0, this._engine.wasm._tempMem, this._engine.wasm._tempMemSize >> 1);
    const ids = this._engine.wasm._tempMemUint16.subarray(0, actualCount);
    const wrapper = this._engine.wrapObject.bind(this._engine);
    const objects = Array.from(ids, wrapper);
    return objects;
  }
  /**
   * Pre-allocate memory for a given amount of objects and components.
   *
   * Will provide better performance for adding objects later with {@link Scene#addObject}
   * and {@link Scene#addObjects}.
   *
   * By providing upfront information of how many objects will be required,
   * the engine is able to batch-allocate the required memory rather than
   * conservatively grow the memory in small steps.
   *
   * **Experimental:** This API might change in upcoming versions.
   *
   * @param objectCount Number of objects to add.
   * @param componentCountPerType Amount of components to
   *      allocate for {@link Object3D.addComponent}, e.g. `{mesh: 100, collision: 200, "my-comp": 100}`.
   * @since 0.8.10
   */
  reserveObjects(objectCount, componentCountPerType) {
    const wasm = this._engine.wasm;
    componentCountPerType = componentCountPerType || {};
    const jsManagerIndex = wasm._jsManagerIndex;
    let countsPerTypeIndex = wasm._tempMemInt.subarray();
    countsPerTypeIndex.fill(0);
    for (const e of Object.entries(componentCountPerType)) {
      const typeIndex = wasm._typeIndexFor(e[0]);
      countsPerTypeIndex[typeIndex < 0 ? jsManagerIndex : typeIndex] += e[1];
    }
    wasm._wl_scene_reserve_objects(objectCount, wasm._tempMem);
  }
  /**
   * Top-level objects of this scene.
   *
   * See {@link Object3D.children} for more information.
   *
   * @since 1.2.0
   */
  get children() {
    const root = this._engine.wrapObject(0);
    return root.children;
  }
  /**
   * Search for objects matching the name.
   *
   * See {@link Object3D.findByName} for more information.
   *
   * @param name The name to search for.
   * @param recursive If `true`, the method will look at all the objects of
   *     this scene. If `false`, this method will only perform the search in
   *     root objects.
   * @returns An array of {@link Object3D} matching the name.
   *
   * @since 1.2.0
   */
  findByName(name, recursive = false) {
    const root = this._engine.wrapObject(0);
    return root.findByName(name, recursive);
  }
  /**
   * Search for all **top-level** objects matching the name.
   *
   * See {@link Object3D.findByNameDirect} for more information.
   *
   * @param name The name to search for.
   * @returns An array of {@link Object3D} matching the name.
   *
   * @since 1.2.0
   */
  findByNameDirect(name) {
    const root = this._engine.wrapObject(0);
    return root.findByNameDirect(name);
  }
  /**
   * Search for **all objects** matching the name.
   *
   * See {@link Object3D.findByNameRecursive} for more information.
   *
   * @param name The name to search for.
   * @returns An array of {@link Object3D} matching the name.
   *
   * @since 1.2.0
   */
  findByNameRecursive(name) {
    const root = this._engine.wrapObject(0);
    return root.findByNameRecursive(name);
  }
  /**
   * Set the background clear color.
   *
   * @param color new clear color (RGBA).
   * @since 0.8.5
   */
  set clearColor(color) {
    this._engine.wasm._wl_scene_set_clearColor(color[0], color[1], color[2], color[3]);
  }
  /**
   * Set whether to clear the color framebuffer before drawing.
   *
   * This function is useful if an external framework (e.g. an AR tracking
   * framework) is responsible for drawing a camera frame before Wonderland
   * Engine draws the scene on top of it.
   *
   * @param b Whether to enable color clear.
   * @since 0.9.4
   */
  set colorClearEnabled(b) {
    this._engine.wasm._wl_scene_enableColorClear(b);
  }
  /** Hosting engine instance. */
  get engine() {
    return this._engine;
  }
  /**
   * Load a scene file (.bin).
   *
   * Will replace the currently active scene with the one loaded
   * from given file. It is assumed that JavaScript components required by
   * the new scene were registered in advance.
   *
   * Once the scene is loaded successfully and initialized,
   * {@link WonderlandEngine.onSceneLoaded} is notified.
   *
   * #### ArrayBuffer
   *
   * The `load()` method accepts an in-memory buffer:
   *
   * ```js
   * scene.load({
   *     buffer: new ArrayBuffer(...),
   *     baseURL: 'https://my-website/assets'
   * })
   * ```
   *
   * @note The `baseURL` is mandatory. It's used to fetch images and languages.
   *
   * Use {@link Scene.setLoadingProgress} to update the loading progress bar
   * when using an ArrayBuffer.
   *
   * @param opts Path to the file to load, or an option object.
   *     For more information about the options, see the {@link SceneLoadOptions} documentation.
   * @returns Promise that resolves when the scene was loaded.
   */
  async load(options) {
    let buffer = null;
    let baseURL = null;
    let filename = null;
    if (isString(options)) {
      filename = options;
      buffer = await fetchWithProgress(filename, (bytes, size2) => {
        this.engine.log.info(LogTag.Scene, `Scene downloading: ${bytes} / ${size2}`);
        this.setLoadingProgress(bytes / size2);
      });
      baseURL = getBaseUrl(filename);
      this.engine.log.info(LogTag.Scene, `Scene download of ${buffer.byteLength} bytes successful.`);
    } else {
      ({ buffer, baseURL } = options);
      filename = baseURL ? `${baseURL}/scene.bin` : "scene.bin";
    }
    if (!buffer) {
      throw new Error("Failed to load scene, buffer not provided");
    }
    if (!isString(baseURL)) {
      throw new Error("Failed to load scene, baseURL not provided");
    }
    if (!this._engine.onLoadingScreenEnd.isDataRetained) {
      this._engine.onLoadingScreenEnd.notify();
    }
    this._baseURL = baseURL;
    const wasm = this._engine.wasm;
    const size = buffer.byteLength;
    const ptr = wasm._malloc(size);
    new Uint8Array(wasm.HEAPU8.buffer, ptr, size).set(new Uint8Array(buffer));
    try {
      wasm._wl_load_scene_bin(ptr, size, wasm.tempUTF8(filename));
    } finally {
      wasm._free(ptr);
    }
    const i18n = this._engine.i18n;
    const langPromise = i18n.setLanguage(i18n.languageCode(0));
    await Promise.all([langPromise, this._flushAppend(this._baseURL)]);
    this._engine.onSceneLoaded.notify();
  }
  /**
   * Append a scene file.
   *
   * Loads and parses the file and its images and appends the result
   * to the currently active scene.
   *
   * Supported formats are streamable Wonderland scene files (.bin) and glTF
   * 3D scenes (.gltf, .glb).
   *
   * ```js
   * WL.scene.append(filename).then(root => {
   *     // root contains the loaded scene
   * });
   * ```
   *
   * In case the `loadGltfExtensions` option is set to true, the response
   * will be an object containing both the root of the loaded scene and
   * any glTF extensions found on nodes, meshes and the root of the file.
   *
   * ```js
   * WL.scene.append(filename, { loadGltfExtensions: true }).then(({root, extensions}) => {
   *     // root contains the loaded scene
   *     // extensions.root contains any extensions at the root of glTF document
   *     const rootExtensions = extensions.root;
   *     // extensions.mesh and extensions.node contain extensions indexed by Object id
   *     const childObject = root.children[0];
   *     const meshExtensions = root.meshExtensions[childObject.objectId];
   *     const nodeExtensions = root.nodeExtensions[childObject.objectId];
   *     // extensions.idMapping contains a mapping from glTF node index to Object id
   * });
   * ```
   *
   * If the file to be loaded is located in a subfolder, it might be useful
   * to define the `baseURL` option. This will ensure any bin files
   * referenced by the loaded bin file are loaded at the correct path.
   *
   * ```js
   * WL.scene.append(filename, { baseURL: 'scenes' }).then(({root, extensions}) => {
   *     // do stuff
   * });
   * ```
   *
   * @param file The .bin, .gltf or .glb file to append. Should be a URL or
   *   an `ArrayBuffer` with the file content.
   * @param options Additional options for loading.
   * @returns Promise that resolves when the scene was appended.
   */
  async append(file, options = {}) {
    const { loadGltfExtensions = false, baseURL = isString(file) ? getBaseUrl(file) : this._baseURL } = options;
    const wasm = this._engine.wasm;
    const buffer = isString(file) ? await fetchWithProgress(file) : file;
    let error3 = null;
    let result = void 0;
    let callback = wasm.addFunction((objectId, extensionData, extensionDataSize) => {
      if (objectId < 0) {
        error3 = new Error(`Scene.append(): Internal runtime error, found root id = ${objectId}`);
        return;
      }
      const root = objectId ? this._engine.wrapObject(objectId) : null;
      result = root;
      if (!extensionData || !extensionDataSize)
        return;
      const marshalled = new Uint32Array(wasm.HEAPU32.buffer, extensionData, extensionDataSize / 4);
      const extensions = this._unmarshallGltfExtensions(marshalled);
      result = { root, extensions };
    }, "viii");
    const size = buffer.byteLength;
    const ptr = wasm._malloc(size);
    const data = new Uint8Array(wasm.HEAPU8.buffer, ptr, size);
    data.set(new Uint8Array(buffer));
    const isBinFile = data.byteLength > MAGIC_BIN.length && data.subarray(0, MAGIC_BIN.length).every((value, i) => value === MAGIC_BIN.charCodeAt(i));
    try {
      if (isBinFile) {
        wasm._wl_append_scene_bin(ptr, size, callback);
      } else {
        wasm._wl_append_scene_gltf(ptr, size, loadGltfExtensions, callback);
      }
    } catch (e) {
      wasm.removeFunction(callback);
      throw e;
    } finally {
      wasm._free(ptr);
    }
    while (result === void 0 && !error3)
      await timeout(4);
    wasm.removeFunction(callback);
    if (error3)
      throw error3;
    if (isBinFile)
      await this._flushAppend(baseURL);
    return result;
  }
  /**
   * Update the loading screen progress bar.
   *
   * @param value Current loading percentage, in the range [0; 1].
   */
  setLoadingProgress(percentage) {
    const wasm = this.engine.wasm;
    wasm._wl_set_loading_screen_progress(clamp(percentage, 0, 1));
  }
  /**
   * Set the current material to render the sky.
   *
   * @note The sky needs to be enabled in the editor when creating the scene.
   * For more information, please refer to the background [tutorial](https://wonderlandengine.com/tutorials/background-effect/).
   */
  set skyMaterial(material) {
    this._engine.wasm._wl_scene_set_sky_material(material?._index ?? 0);
  }
  /** Current sky material, or `null` if no sky is set. */
  get skyMaterial() {
    const id = this._engine.wasm._wl_scene_get_sky_material();
    return id > 0 ? new Material(this._engine, id) : null;
  }
  /**
   * Load all currently queued bin files.
   *
   * Used by {@link Scene.append} and {@link Scene.load}
   * to load all delay-load bins.
   *
   * Used by {@link I18N.language} to trigger loading the
   * associated language bin, after it was queued.
   *
   * @param baseURL Url that is added to each path.
   * @param options Additional options for loading.
   *
   * @hidden
   */
  _flushAppend(baseURL) {
    const wasm = this._engine.wasm;
    const count = wasm._wl_scene_queued_bin_count();
    if (!count)
      return Promise.resolve();
    const urls = new Array(count).fill(0).map((_, i) => {
      const ptr = wasm._wl_scene_queued_bin_path(i);
      return wasm.UTF8ToString(ptr);
    });
    wasm._wl_scene_clear_queued_bin_list();
    const promises = urls.map((path) => this.append(baseURL.length ? `${baseURL}/${path}` : path));
    return Promise.all(promises).then((data) => {
      const i18n = this._engine.i18n;
      this._engine.i18n.onLanguageChanged.notify(i18n.previousIndex, i18n.currentIndex);
      return data;
    });
  }
  /**
   * Unmarshalls the GltfExtensions from an Uint32Array.
   *
   * @param data Array containing the gltf extension data.
   * @returns The extensions stored in an object literal.
   *
   * @hidden
   */
  _unmarshallGltfExtensions(data) {
    const extensions = {
      root: {},
      mesh: {},
      node: {},
      idMapping: []
    };
    let index = 0;
    const readString = () => {
      const strPtr = data[index++];
      const strLen = data[index++];
      return this._engine.wasm.UTF8ViewToString(strPtr, strPtr + strLen);
    };
    const idMappingSize = data[index++];
    const idMapping = new Array(idMappingSize);
    for (let i = 0; i < idMappingSize; ++i) {
      idMapping[i] = data[index++];
    }
    extensions.idMapping = idMapping;
    const meshExtensionsSize = data[index++];
    for (let i = 0; i < meshExtensionsSize; ++i) {
      const objectId = data[index++];
      extensions.mesh[idMapping[objectId]] = JSON.parse(readString());
    }
    const nodeExtensionsSize = data[index++];
    for (let i = 0; i < nodeExtensionsSize; ++i) {
      const objectId = data[index++];
      extensions.node[idMapping[objectId]] = JSON.parse(readString());
    }
    const rootExtensionsStr = readString();
    if (rootExtensionsStr) {
      extensions.root = JSON.parse(rootExtensionsStr);
    }
    return extensions;
  }
  /**
   * Reset the scene.
   *
   * This method deletes all used and allocated objects, and components.
   */
  reset() {
    this._engine.wasm._wl_scene_reset();
    this._baseURL = "";
  }
};

// node_modules/@wonderlandengine/api/dist/texture-manager.js
var TextureManager = class {
  /** Wonderland Engine instance. @hidden */
  _engine;
  /** Texture cache. @hidden */
  #cache = [];
  /** @hidden */
  constructor(engine2) {
    this._engine = engine2;
  }
  /**
   * Retrieve the texture with the given id.
   *
   * @param id The texture identifier.
   * @return The {@link Texture} if found, `null` otherwise.
   */
  get(id) {
    return this.#cache[id] ?? null;
  }
  /**
   * Load an image from URL as {@link Texture}.
   *
   * @param filename URL to load from.
   * @param crossOrigin Cross origin flag for the image object.
   * @returns Loaded texture.
   */
  load(filename, crossOrigin) {
    let image = new Image();
    image.crossOrigin = crossOrigin ?? image.crossOrigin;
    image.src = filename;
    return new Promise((resolve, reject) => {
      image.onload = () => {
        let texture = new Texture(this._engine, image);
        if (!texture.valid) {
          reject("Failed to add image " + image.src + " to texture atlas. Probably incompatible format.");
        }
        resolve(texture);
      };
      image.onerror = function() {
        reject("Failed to load image. Not found or no read access");
      };
    });
  }
  /**
   * Wrap a texture ID using {@link Texture}.
   *
   * @note This method performs caching and will return the same
   * instance on subsequent calls.
   *
   * @param id ID of the texture to create.
   *
   * @returns The texture.
   */
  wrap(id) {
    const texture = this.#cache[id] ?? (this.#cache[id] = new Texture(this._engine, id));
    texture["_id"] = id;
    return texture;
  }
  /** Number of textures allocated in the manager. */
  get allocatedCount() {
    return this.#cache.length;
  }
  /**
   * Number of textures in the manager.
   *
   * @note For performance reasons, avoid calling this method when possible.
   */
  get count() {
    let count = 0;
    for (const tex of this.#cache) {
      if (tex && tex.id >= 0)
        ++count;
    }
    return count;
  }
  /**
   * Set a new texture in the manager cache.
   *
   * @note This api is meant to be used internally.
   *
   * @param texture The texture to add.
   *
   * @hidden
   */
  _set(texture) {
    this.#cache[texture.id] = texture;
  }
  /**
   * Destroys the texture.
   *
   * @note This api is meant to be used internally.
   *
   * @param texture The texture to destroy.
   *
   * @hidden
   */
  _destroy(texture) {
    this._engine.wasm._wl_texture_destroy(texture.id);
    const img = texture["_imageIndex"];
    if (img !== null) {
      this._engine.wasm._images[img] = null;
    }
  }
  /**
   * Reset the manager.
   *
   * @note This api is meant to be used internally.
   *
   * @hidden
   */
  _reset() {
    this.#cache.length = 0;
  }
};

// node_modules/@wonderlandengine/api/dist/engine.js
function checkXRSupport() {
  if (!navigator.xr) {
    const isLocalhost2 = location.hostname === "localhost" || location.hostname === "127.0.0.1";
    const missingHTTPS = location.protocol !== "https:" && !isLocalhost2;
    return Promise.reject(missingHTTPS ? "WebXR is only supported with HTTPS or on localhost!" : "WebXR unsupported in this browser.");
  }
  return Promise.resolve();
}
var WonderlandEngine = class {
  /**
   * {@link Emitter} for WebXR session end events.
   *
   * Usage from within a component:
   *
   * ```js
   * this.engine.onXRSessionEnd.add(() => console.log("XR session ended."));
   * ```
   */
  onXRSessionEnd = new Emitter();
  /**
   * {@link RetainEmitter} for WebXR session start events.
   *
   * Usage from within a component:
   *
   * ```js
   * this.engine.onXRSessionStart.add((session, mode) => console.log(session, mode));
   * ```
   *
   * By default, this emitter is retained and will automatically call any callback added
   * while a session is already started:
   *
   * ```js
   * // XR session is already active.
   * this.engine.onXRSessionStart.add((session, mode) => {
   *     console.log(session, mode); // Triggered immediately.
   * });
   * ```
   */
  onXRSessionStart = new RetainEmitter();
  /**
   * {@link Emitter} for canvas / main framebuffer resize events.
   *
   * Usage from within a component:
   *
   * ```js
   * this.engine.onResize.add(() => {
   *     const canvas = this.engine.canvas;
   *     console.log(`New Size: ${canvas.width}, ${canvas.height}`);
   * });
   * ```
   *
   * @note The size of the canvas is in physical pixels, and is set via {@link WonderlandEngine.resize}.
   */
  onResize = new Emitter();
  /** Whether AR is supported by the browser. */
  arSupported = false;
  /** Whether VR is supported by the browser. */
  vrSupported = false;
  /**
   * {@link RetainEmitter} signalling the end of the loading screen.
   *
   * Listeners get notified when the first call to {@link Scene#load()} is
   * invoked. At this point the new scene has not become active, and none of
   * its resources or components are initialized.
   *
   * Compared to {@link onSceneLoaded}, this does not wait for all components
   * to be fully initialized and activated. Any handler added inside
   * {@link Component#init()}, {@link Component#start()} or
   * {@link Component#onActivate()} will be called immediately.
   *
   * Usage:
   *
   * ```js
   * this.engine.onLoadingScreenEnd.add(() => console.log("Wait is over!"));
   * ```
   */
  onLoadingScreenEnd = new RetainEmitter();
  /**
   * {@link Emitter} for scene loaded events.
   *
   * Listeners get notified when a call to {@link Scene#load()} finishes. At
   * this point all resources are loaded and all components had their
   * {@link Component#init()} as well as (if active)
   * {@link Component#start()} and {@link Component#onActivate()} methods
   * called.
   *
   * Usage from within a component:
   *
   * ```js
   * this.engine.onSceneLoaded.add(() => console.log("Scene switched!"));
   * ```
   */
  onSceneLoaded = new Emitter();
  /**
   * Current main scene.
   */
  scene = null;
  /**
   * Access to internationalization.
   */
  i18n = new I18N(this);
  /**
   * WebXR related state, `null` if no XR session is active.
   */
  xr = null;
  /**
   * If `true`, {@link Texture}, {@link Object3D}, and {@link Component}
   * instances have their prototype erased upon destruction.
   *
   * #### Object
   *
   * ```js
   * engine.erasePrototypeOnDestroy = true;
   *
   * const obj = engine.scene.addObject();
   * obj.name = 'iamalive';
   * console.log(obj.name); // Prints 'iamalive'
   *
   * obj.destroy();
   * console.log(obj.name); // Throws an error
   * ```
   *
   * #### Component
   *
   * Components will also be affected:
   *
   * ```js
   * class MyComponent extends Component {
   *     static TypeName = 'my-component';
   *     static Properties = {
   *         alive: Property.bool(true)
   *     };
   *
   *     start() {
   *         this.destroy();
   *         console.log(this.alive) // Throws an error
   *     }
   * }
   * ```
   *
   * A component is also destroyed if its ancestor gets destroyed:
   *
   * ```js
   * class MyComponent extends Component {
   *     ...
   *     start() {
   *         this.object.parent.destroy();
   *         console.log(this.alive) // Throws an error
   *     }
   * }
   * ```
   *
   * @note Native components will not be erased if destroyed via object destruction:
   *
   * ```js
   * const mesh = obj.addComponent('mesh');
   * obj.destroy();
   * console.log(mesh.active) // Doesn't throw even if the mesh is destroyed
   * ```
   *
   * @since 1.1.1
   */
  erasePrototypeOnDestroy = false;
  /**
   * Component class instances per type to avoid GC.
   *
   * @note Maps the manager index to the list of components.
   *
   * @hidden
   */
  _componentCache = {};
  /** Object class instances to avoid GC. @hidden */
  _objectCache = [];
  /**
   * WebAssembly bridge.
   *
   * @hidden
   */
  #wasm;
  /**
   * Physics manager, only available when physx is enabled in the runtime.
   *
   * @hidden
   */
  #physics = null;
  /** Texture manager. @hidden */
  #textures = new TextureManager(this);
  /**
   * Resize observer to track for canvas size changes.
   *
   * @hidden
   */
  #resizeObserver = null;
  /**
   * Initial reference space type set by webxr_init. See {@link _init} for
   * more information.
   *
   * @hidden
   */
  #initialReferenceSpaceType = null;
  /**
   * Create a new engine instance.
   *
   * @param wasm Wasm bridge instance
   * @param loadingScreen Loading screen .bin file data
   *
   * @hidden
   */
  constructor(wasm, loadingScreen) {
    this.#wasm = wasm;
    this.#wasm["_setEngine"](this);
    this.#wasm._loadingScreen = loadingScreen;
    this._componentCache = {};
    this._objectCache.length = 0;
    this.canvas.addEventListener("webglcontextlost", (e) => this.log.error(LogTag.Engine, "Context lost:", e), false);
  }
  /**
   * Start the engine if it's not already running.
   *
   * When using the {@link loadRuntime} function, this method is called
   * automatically.
   */
  start() {
    this.wasm._wl_application_start();
  }
  /**
   * Register a custom JavaScript component type.
   *
   * You can register a component directly using a class inheriting from {@link Component}:
   *
   * ```js
   * import { Component, Type } from '@wonderlandengine/api';
   *
   * export class MyComponent extends Component {
   *     static TypeName = 'my-component';
   *     static Properties = {
   *         myParam: {type: Type.Float, default: 42.0},
   *     };
   *     init() {}
   *     start() {}
   *     update(dt) {}
   *     onActivate() {}
   *     onDeactivate() {}
   *     onDestroy() {}
   * });
   *
   * // Here, we assume we have an engine already instantiated.
   * // In general, the registration occurs in the `index.js` file in your
   * // final application.
   * engine.registerComponent(MyComponent);
   * ```
   *
   * {@label CLASSES}
   * @param classes Custom component(s) extending {@link Component}.
   *
   * @since 1.0.0
   */
  registerComponent(...classes) {
    for (const arg of classes) {
      this.wasm._registerComponent(arg);
    }
  }
  /**
   * Checks whether the given component is registered or not.
   *
   * @param typeOrClass A string representing the component typename (e.g., `'cursor-component'`),
   *     or a component class (e.g., `CursorComponent`).
   * @returns `true` if the component is registered, `false` otherwise.
   */
  isRegistered(typeOrClass) {
    return this.#wasm.isRegistered(isString(typeOrClass) ? typeOrClass : typeOrClass.TypeName);
  }
  /**
   * Resize the canvas and the rendering context.
   *
   * @note The `width` and `height` parameters will be scaled by the
   * `devicePixelRatio` value. By default, the pixel ratio used is
   * [window.devicePixelRatio](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio).
   *
   * @param width The width, in CSS pixels.
   * @param height The height, in CSS pixels.
   * @param devicePixelRatio The pixel ratio factor.
   */
  resize(width, height, devicePixelRatio = window.devicePixelRatio) {
    width = width * devicePixelRatio;
    height = height * devicePixelRatio;
    this.canvas.width = width;
    this.canvas.height = height;
    this.wasm._wl_application_resize(width, height);
    this.onResize.notify();
  }
  /**
   * Run the next frame.
   *
   * @param fixedDelta The elapsed time between this frame and the previous one.
   *
   * @note The engine automatically schedules next frames. You should only
   * use this method for testing.
   */
  nextFrame(fixedDelta = 0) {
    this.#wasm._wl_nextFrame(fixedDelta);
  }
  /**
   * Request an XR session.
   *
   * @note Please use this call instead of directly calling `navigator.xr.requestSession()`.
   * Wonderland Engine requires to be aware that a session is started, and this
   * is done through this call.
   *
   * @param mode The XR mode.
   * @param features An array of required features, e.g., `['local-floor', 'hit-test']`.
   * @param optionalFeatures An array of optional features, e.g., `['bounded-floor', 'depth-sensing']`.
   * @returns A promise resolving with the `XRSession`, a string error message otherwise.
   */
  requestXRSession(mode, features, optionalFeatures = []) {
    return checkXRSupport().then(() => this.#wasm.webxr_requestSession(mode, features, optionalFeatures));
  }
  /**
   * Offer an XR session.
   *
   * Adds an interactive UI element to the browser interface to start an XR
   * session. Browser support is optional, so it's advised to still allow
   * requesting a session with a UI element on the website itself.
   *
   * @note Please use this call instead of directly calling `navigator.xr.offerSession()`.
   * Wonderland Engine requires to be aware that a session is started, and this
   * is done through this call.
   *
   * @param mode The XR mode.
   * @param features An array of required features, e.g., `['local-floor', 'hit-test']`.
   * @param optionalFeatures An array of optional features, e.g., `['bounded-floor', 'depth-sensing']`.
   * @returns A promise resolving with the `XRSession`, a string error message otherwise.
   *
   * @since 1.1.5
   */
  offerXRSession(mode, features, optionalFeatures = []) {
    return checkXRSupport().then(() => this.#wasm.webxr_offerSession(mode, features, optionalFeatures));
  }
  /**
   * Wrap an object ID using {@link Object}.
   *
   * @note This method performs caching and will return the same
   * instance on subsequent calls.
   *
   * @param objectId ID of the object to create.
   *
   * @returns The object
   */
  wrapObject(objectId) {
    const cache = this._objectCache;
    const o = cache[objectId] || (cache[objectId] = new Object3D(this, objectId));
    o["_objectId"] = objectId;
    return o;
  }
  /* Public Getters & Setter */
  /**
   * WebAssembly bridge.
   *
   * @note Use with care. This object is used to communicate
   * with the WebAssembly code throughout the api.
   *
   * @hidden
   */
  get wasm() {
    return this.#wasm;
  }
  /** Canvas element that Wonderland Engine renders to. */
  get canvas() {
    return this.#wasm.canvas;
  }
  /**
   * Current WebXR session or `null` if no session active.
   *
   * @deprecated Use {@link XR.session} on the {@link xr}
   * object instead.
   */
  get xrSession() {
    return this.xr?.session ?? null;
  }
  /**
   * Current WebXR frame or `null` if no session active.
   *
   * @deprecated Use {@link XR.frame} on the {@link xr}
   * object instead.
   */
  get xrFrame() {
    return this.xr?.frame ?? null;
  }
  /**
   * Current WebXR base layer or `null` if no session active.
   *
   * @deprecated Use {@link XR.baseLayer} on the {@link xr}
   * object instead.
   */
  get xrBaseLayer() {
    return this.xr?.baseLayer ?? null;
  }
  /**
   * Current WebXR framebuffer or `null` if no session active.
   *
   * @deprecated Use {@link XR.framebuffers} on the
   * {@link xr} object instead.
   */
  get xrFramebuffer() {
    return this.xr?.framebuffers[0] ?? null;
  }
  /** Framebuffer scale factor. */
  get xrFramebufferScaleFactor() {
    return this.#wasm.webxr_framebufferScaleFactor;
  }
  set xrFramebufferScaleFactor(value) {
    this.#wasm.webxr_framebufferScaleFactor = value;
  }
  /** Physics manager, only available when physx is enabled in the runtime. */
  get physics() {
    return this.#physics;
  }
  /**
   * Texture managger.
   *
   * Use this to load or programmatically create new textures at runtime.
   */
  get textures() {
    return this.#textures;
  }
  /*
   * Enable or disable the mechanism to automatically resize the canvas.
   *
   * Internally, the engine uses a [ResizeObserver](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver).
   * Changing the canvas css will thus automatically be tracked by the engine.
   */
  set autoResizeCanvas(flag) {
    const state = !!this.#resizeObserver;
    if (state === flag)
      return;
    if (!flag) {
      this.#resizeObserver?.unobserve(this.canvas);
      this.#resizeObserver = null;
      return;
    }
    this.#resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        if (entry.target === this.canvas) {
          this.resize(entry.contentRect.width, entry.contentRect.height);
        }
      }
    });
    this.#resizeObserver.observe(this.canvas);
  }
  /** `true` if the canvas is automatically resized by the engine. */
  get autoResizeCanvas() {
    return this.#resizeObserver !== null;
  }
  /** Retrieves the runtime version. */
  get runtimeVersion() {
    const wasm = this.#wasm;
    const v = wasm._wl_application_version(wasm._tempMem);
    return {
      major: wasm._tempMemUint16[0],
      minor: wasm._tempMemUint16[1],
      patch: wasm._tempMemUint16[2],
      rc: wasm._tempMemUint16[3]
    };
  }
  /** Engine {@link Logger}. Use it to turn on / off logging. */
  get log() {
    return this.#wasm._log;
  }
  /* Internal-Only Methods */
  /**
   * Initialize the engine.
   *
   * @note Should be called after the WebAssembly is fully loaded.
   *
   * @hidden
   */
  _init() {
    this.scene = new Scene(this);
    const onXRStart = () => {
      this.#initialReferenceSpaceType = this.xr.currentReferenceSpaceType;
      const newSpace = this.xr.referenceSpaceForType("local") ?? this.xr.referenceSpaceForType("viewer");
      this.xr.currentReferenceSpace = newSpace;
    };
    this.onXRSessionStart.add(onXRStart);
    this.onLoadingScreenEnd.once(() => {
      this.onXRSessionStart.remove(onXRStart);
      if (!this.xr || !this.#initialReferenceSpaceType)
        return;
      this.xr.currentReferenceSpace = this.xr.referenceSpaceForType(this.#initialReferenceSpaceType) ?? this.xr.referenceSpaceForType("viewer");
      this.#initialReferenceSpaceType = null;
    });
    this.#wasm._wl_set_error_callback(this.#wasm.addFunction((messagePtr) => {
      throw new Error(this.#wasm.UTF8ToString(messagePtr));
    }, "vi"));
    this.#physics = null;
    if (this.#wasm.withPhysX) {
      const physics = new Physics(this);
      this.#wasm._wl_physx_set_collision_callback(this.#wasm.addFunction((a, index, type, b) => {
        const callback = physics._callbacks[a][index];
        const component = new PhysXComponent(this, this.wasm._typeIndexFor("physx"), b);
        callback(type, component);
      }, "viiii"));
      this.#physics = physics;
    }
    this.resize(this.canvas.clientWidth, this.canvas.clientHeight);
  }
  /**
   * Reset the runtime state, including:
   *     - Component cache
   *     - Images
   *     - Callbacks
   *
   * @note This api is meant to be used internally.
   *
   * @hidden
   */
  _reset() {
    this._componentCache = {};
    this._objectCache.length = 0;
    this.#textures._reset();
    this.scene.reset();
    this.wasm.reset();
  }
  /**
   * Retrieves a component instance if it exists, or create and cache
   * a new one.
   *
   * @note This api is meant to be used internally. Please have a look at
   * {@link Object3D.addComponent} instead.
   *
   * @param type component type name
   * @param componentType Component manager index
   * @param componentId Component id in the manager
   *
   * @returns JavaScript instance wrapping the native component
   *
   * @hidden
   */
  _wrapComponent(type, componentType, componentId) {
    if (componentId < 0)
      return null;
    const c = this._componentCache[componentType] || (this._componentCache[componentType] = []);
    if (c[componentId]) {
      return c[componentId];
    }
    let component;
    if (type == "collision") {
      component = new CollisionComponent(this, componentType, componentId);
    } else if (type == "text") {
      component = new TextComponent(this, componentType, componentId);
    } else if (type == "view") {
      component = new ViewComponent(this, componentType, componentId);
    } else if (type == "mesh") {
      component = new MeshComponent(this, componentType, componentId);
    } else if (type == "input") {
      component = new InputComponent(this, componentType, componentId);
    } else if (type == "light") {
      component = new LightComponent(this, componentType, componentId);
    } else if (type == "animation") {
      component = new AnimationComponent(this, componentType, componentId);
    } else if (type == "physx") {
      component = new PhysXComponent(this, componentType, componentId);
    } else {
      const typeIndex = this.wasm._componentTypeIndices[type];
      const constructor = this.wasm._componentTypes[typeIndex];
      component = new constructor(this);
    }
    component._engine = this;
    component._manager = componentType;
    component._id = componentId;
    c[componentId] = component;
    return component;
  }
  /**
   * Perform cleanup upon object destruction.
   *
   * @param instance The instance to destroy.
   *
   * @hidden
   */
  _destroyObject(instance) {
    const id = instance.objectId;
    instance._objectId = -1;
    if (this.erasePrototypeOnDestroy && instance) {
      Object.setPrototypeOf(instance, DestroyedObjectInstance);
    }
    this._objectCache[id] = null;
  }
  /**
   * Perform cleanup upon component destruction.
   *
   * @param instance The instance to destroy.
   *
   * @hidden
   */
  _destroyComponent(instance) {
    const id = instance._id;
    const manager = instance._manager;
    instance._id = -1;
    instance._manager = -1;
    if (this.erasePrototypeOnDestroy && instance) {
      Object.setPrototypeOf(instance, DestroyedComponentInstance);
    }
    const cache = this._componentCache[manager];
    if (cache)
      cache[id] = null;
  }
  /**
   * Perform cleanup upon texture destruction.
   *
   * @param texture The instance to destroy.
   *
   * @hidden
   */
  _destroyTexture(texture) {
    this.textures._destroy(texture);
    if (this.erasePrototypeOnDestroy) {
      Object.setPrototypeOf(texture, DestroyedTextureInstance);
    }
  }
};

// node_modules/@wonderlandengine/api/dist/utils/bitset.js
function assert(bit) {
  if (bit >= 32) {
    throw new Error(`BitSet.enable(): Value ${bit} is over 31`);
  }
}
var BitSet = class {
  /** Enabled bits. @hidden */
  _bits = 0;
  /**
   * Enable the bit at the given index.
   *
   * @param bits A spread of all the bits to enable.
   * @returns Reference to self (for method chaining).
   */
  enable(...bits) {
    for (const bit of bits) {
      assert(bit);
      this._bits |= 1 << bit >>> 0;
    }
    return this;
  }
  /**
   * Enable all bits.
   *
   * @returns Reference to self (for method chaining).
   */
  enableAll() {
    this._bits = ~0;
    return this;
  }
  /**
   * Disable the bit at the given index.
   *
   * @param bits A spread of all the bits to disable.
   * @returns Reference to self (for method chaining).
   */
  disable(...bits) {
    for (const bit of bits) {
      assert(bit);
      this._bits &= ~(1 << bit >>> 0);
    }
    return this;
  }
  /**
   * Disable all bits.
   *
   * @returns Reference to self (for method chaining).
   */
  disableAll() {
    this._bits = 0;
    return this;
  }
  /**
   * Checker whether the bit is set or not.
   *
   * @param bit The bit to check.
   * @returns `true` if it's enabled, `false` otherwise.
   */
  enabled(bit) {
    return !!(this._bits & 1 << bit >>> 0);
  }
};

// node_modules/@wonderlandengine/api/dist/utils/logger.js
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["Info"] = 0] = "Info";
  LogLevel2[LogLevel2["Warn"] = 1] = "Warn";
  LogLevel2[LogLevel2["Error"] = 2] = "Error";
})(LogLevel || (LogLevel = {}));
var Logger = class {
  /**
   * Bitset of enabled levels.
   *
   * @hidden
   */
  levels = new BitSet();
  /**
   * Bitset of enabled tags.
   *
   * @hidden
   */
  tags = new BitSet().enableAll();
  /**
   * Create a new logger instance.
   *
   * @param levels Default set of levels to enable.
   */
  constructor(...levels) {
    this.levels.enable(...levels);
  }
  /**
   * Log the message(s) using `console.log`.
   *
   * @param tag Tag represented by a positive integer.
   * @param msg A spread of message to log.
   * @returns Reference to self (for method chaining).
   */
  info(tag, ...msg) {
    if (this.levels.enabled(LogLevel.Info) && this.tags.enabled(tag)) {
      console.log(...msg);
    }
    return this;
  }
  /**
   * Log the message(s) using `console.warn`.
   *
   * @param tag Tag represented by a positive integer.
   * @param msg A spread of message to log.
   * @returns Reference to self (for method chaining).
   */
  warn(tag, ...msg) {
    if (this.levels.enabled(LogLevel.Warn) && this.tags.enabled(tag)) {
      console.warn(...msg);
    }
    return this;
  }
  /**
   * Log the message(s) using `console.error`.
   *
   * @param tag Tag represented by a positive integer.
   * @param msg A spread of message to log.
   * @returns Reference to self (for method chaining).
   */
  error(tag, ...msg) {
    if (this.levels.enabled(LogLevel.Error) && this.tags.enabled(tag)) {
      console.error(...msg);
    }
    return this;
  }
};

// node_modules/@wonderlandengine/api/dist/wasm.js
var _componentDefaults = /* @__PURE__ */ new Map([
  [Type.Bool, false],
  [Type.Int, 0],
  [Type.Float, 0],
  [Type.String, ""],
  [Type.Enum, void 0],
  [Type.Object, null],
  [Type.Mesh, null],
  [Type.Texture, null],
  [Type.Material, null],
  [Type.Animation, null],
  [Type.Skin, null],
  [Type.Color, [0, 0, 0, 1]]
]);
function _setupDefaults(ctor) {
  for (const name in ctor.Properties) {
    const p = ctor.Properties[name];
    if (p.type === Type.Enum) {
      if (p.values?.length) {
        if (typeof p.default !== "number") {
          p.default = p.values.indexOf(p.default);
        }
        if (p.default < 0 || p.default >= p.values.length) {
          p.default = 0;
        }
      } else {
        p.default = void 0;
      }
    } else {
      p.default = p.default ?? _componentDefaults.get(p.type);
    }
    ctor.prototype[name] = p.default;
  }
}
var WASM = class {
  /**
   * Emscripten worker field.
   *
   * @note This api is meant to be used internally.
   */
  worker = "";
  /**
   * Emscripten wasm field.
   *
   * @note This api is meant to be used internally.
   */
  wasm = null;
  /**
   * Emscripten canvas.
   *
   * @note This api is meant to be used internally.
   */
  canvas = null;
  /** Current WebXR  */
  /**
   * Emscripten WebXR session.
   *
   * @note This api is meant to be used internally.
   */
  webxr_session = null;
  /**
   * Emscripten WebXR request session callback.
   *
   * @note This api is meant to be used internally.
   */
  webxr_requestSession = null;
  /**
   * Emscripten WebXR offer session callback.
   *
   * @note This api is meant to be used internally.
   */
  webxr_offerSession = null;
  /**
   * Emscripten WebXR frame.
   *
   * @note This api is meant to be used internally.
   */
  webxr_frame = null;
  /**
   * Emscripten current WebXR reference space.
   *
   * @note This api is meant to be used internally.
   */
  webxr_refSpace = null;
  /**
   * Emscripten WebXR reference spaces.
   *
   * @note This api is meant to be used internally.
   */
  webxr_refSpaces = null;
  /**
   * Emscripten WebXR current reference space type.
   *
   * @note This api is meant to be used internally.
   */
  webxr_refSpaceType = null;
  /**
   * Emscripten WebXR GL projection layer.
   *
   * @note This api is meant to be used internally.
   */
  webxr_baseLayer = null;
  /**
   * Emscripten WebXR framebuffer scale factor.
   *
   * @note This api is meant to be used internally.
   */
  webxr_framebufferScaleFactor = 1;
  /**
   * Emscripten WebXR framebuffer(s).
   *
   * @note This api is meant to be used internally.
   */
  /* webxr_fbo will not get overwritten if we are rendering to the
   * default framebuffer, e.g., when using WebXR emulator. */
  webxr_fbo = 0;
  /**
   * Convert a WASM memory view to a JavaScript string.
   *
   * @param ptr Pointer start
   * @param ptrEnd Pointer end
   * @returns JavaScript string
   */
  UTF8ViewToString;
  /** Logger instance. */
  _log = new Logger();
  /** If `true`, logs will not spam the console on error. */
  _deactivate_component_on_error = false;
  /** Temporary memory pointer. */
  _tempMem = null;
  /** Temporary memory size. */
  _tempMemSize = 0;
  /** Temporary float memory view. */
  _tempMemFloat = null;
  /** Temporary int memory view. */
  _tempMemInt = null;
  /** Temporary uint8 memory view. */
  _tempMemUint8 = null;
  /** Temporary uint32 memory view. */
  _tempMemUint32 = null;
  /** Temporary uint16 memory view. */
  _tempMemUint16 = null;
  /** Loading screen .bin file data */
  _loadingScreen = null;
  /** List of callbacks triggered when the scene is loaded. */
  _sceneLoadedCallback = [];
  /**
   * Material definition cache. Each pipeline has its own
   * associated material definition.
   */
  _materialDefinitions = [];
  /** Image cache. */
  _images = [];
  /** Component instances. */
  _components = [];
  /** Component Type info. */
  _componentTypes = [];
  /** Index per component type name. */
  _componentTypeIndices = {};
  /** Wonderland engine instance. */
  _engine = null;
  /**
   * `true` if this runtime is using physx.
   *
   * @note This api is meant to be used internally.
   */
  _withPhysX = false;
  /** Decoder for UTF8 `ArrayBuffer` to JavaScript string. */
  _utf8Decoder = new TextDecoder("utf8");
  /** JavaScript manager index. */
  _jsManagerIndexCached = null;
  /**
   * Registration index of {@link BrokenComponent}.
   *
   * This is used to return dummy instances when a component
   * isn't registered.
   *
   * @hidden
   */
  _brokenComponentIndex = 0;
  /**
   * Create a new instance of the WebAssembly <> API bridge.
   *
   * @param threads `true` if the runtime used has threads support
   */
  constructor(threads2) {
    if (threads2) {
      this.UTF8ViewToString = (s, e) => {
        if (!s)
          return "";
        return this._utf8Decoder.decode(this.HEAPU8.slice(s, e));
      };
      return;
    }
    this.UTF8ViewToString = (s, e) => {
      if (!s)
        return "";
      return this._utf8Decoder.decode(this.HEAPU8.subarray(s, e));
    };
    this._brokenComponentIndex = this._registerComponent(BrokenComponent);
  }
  /**
   * Reset the cache of the library.
   *
   * @note Should only be called when tearing down the runtime.
   */
  reset() {
    for (const img of this._images) {
      if (!img || !img.src)
        continue;
      img.src = "";
      img.onload = null;
      img.onerror = null;
    }
    this._images = [];
    this.allocateTempMemory(1024);
    this._materialDefinitions = [];
    this._components = [];
    this._componentTypes = [];
    this._componentTypeIndices = {};
    this._jsManagerIndexCached = null;
    this._brokenComponentIndex = this._registerComponent(BrokenComponent);
  }
  /**
   * Checks whether the given component is registered or not.
   *
   * @param ctor  A string representing the component typename (e.g., `'cursor-component'`).
   * @returns `true` if the component is registered, `false` otherwise.
   */
  isRegistered(type) {
    return type in this._componentTypeIndices;
  }
  /**
   * Register a legacy component in this Emscripten instance.
   *
   * @note This api is meant to be used internally.
   *
   * @param typeName The name of the component.
   * @param params An object containing the parameters (properties).
   * @param object The object's prototype.
   * @returns The registration index
   */
  _registerComponentLegacy(typeName, params, object) {
    const ctor = class CustomComponent extends Component {
    };
    ctor.TypeName = typeName;
    ctor.Properties = params;
    Object.assign(ctor.prototype, object);
    return this._registerComponent(ctor);
  }
  /**
   * Register a class component in this Emscripten instance.
   *
   * @note This api is meant to be used internally.
   *
   * @param ctor The class to register.
   * @returns The registration index.
   */
  _registerComponent(ctor) {
    if (!ctor.TypeName)
      throw new Error("no name provided for component.");
    if (!ctor.prototype._triggerInit) {
      throw new Error(`registerComponent(): Component ${ctor.TypeName} must extend Component`);
    }
    inheritProperties(ctor);
    _setupDefaults(ctor);
    const typeIndex = ctor.TypeName in this._componentTypeIndices ? this._componentTypeIndices[ctor.TypeName] : this._componentTypes.length;
    this._componentTypes[typeIndex] = ctor;
    this._componentTypeIndices[ctor.TypeName] = typeIndex;
    if (ctor === BrokenComponent)
      return typeIndex;
    this._log.info(LogTag.Engine, "Registered component", ctor.TypeName, `(class ${ctor.name})`, "with index", typeIndex);
    if (ctor.onRegister)
      ctor.onRegister(this._engine);
    return typeIndex;
  }
  /**
   * Allocate the requested amount of temporary memory
   * in this WASM instance.
   *
   * @param size The number of bytes to allocate
   */
  allocateTempMemory(size) {
    this._log.info(LogTag.Engine, "Allocating temp mem:", size);
    this._tempMemSize = size;
    if (this._tempMem)
      this._free(this._tempMem);
    this._tempMem = this._malloc(this._tempMemSize);
    this.updateTempMemory();
  }
  /**
   * @todo: Delete this and only keep `allocateTempMemory`
   *
   * @param size Number of bytes to allocate
   */
  requireTempMem(size) {
    if (this._tempMemSize >= size)
      return;
    this.allocateTempMemory(Math.ceil(size / 1024) * 1024);
  }
  /**
   * Update the temporary memory views. This must be called whenever the
   * temporary memory address changes.
   *
   * @note This api is meant to be used internally.
   */
  updateTempMemory() {
    this._tempMemFloat = new Float32Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize >> 2);
    this._tempMemInt = new Int32Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize >> 2);
    this._tempMemUint32 = new Uint32Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize >> 2);
    this._tempMemUint16 = new Uint16Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize >> 1);
    this._tempMemUint8 = new Uint8Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize);
  }
  /**
   * Returns a uint8 buffer view on temporary WASM memory.
   *
   * **Note**: this method might allocate if the requested memory is bigger
   * than the current temporary memory allocated.
   *
   * @param count The number of **elements** required
   * @returns A {@link TypedArray} over the WASM memory
   */
  getTempBufferU8(count) {
    this.requireTempMem(count);
    return this._tempMemUint8;
  }
  /**
   * Returns a uint16 buffer view on temporary WASM memory.
   *
   * **Note**: this method might allocate if the requested memory is bigger
   * than the current temporary memory allocated.
   *
   * @param count The number of **elements** required
   * @returns A {@link TypedArray} over the WASM memory
   */
  getTempBufferU16(count) {
    this.requireTempMem(count * 2);
    return this._tempMemUint16;
  }
  /**
   * Returns a uint32 buffer view on temporary WASM memory.
   *
   * **Note**: this method might allocate if the requested memory is bigger
   * than the current temporary memory allocated.
   *
   * @param count The number of **elements** required.
   * @returns A {@link TypedArray} over the WASM memory.
   */
  getTempBufferU32(count) {
    this.requireTempMem(count * 4);
    return this._tempMemUint32;
  }
  /**
   * Returns a int32 buffer view on temporary WASM memory.
   *
   * **Note**: this method might allocate if the requested memory is bigger
   * than the current temporary memory allocated.
   *
   * @param count The number of **elements** required.
   * @returns A {@link TypedArray} over the WASM memory.
   */
  getTempBufferI32(count) {
    this.requireTempMem(count * 4);
    return this._tempMemInt;
  }
  /**
   * Returns a float32 buffer view on temporary WASM memory.
   *
   * **Note**: this method might allocate if the requested memory is bigger
   * than the current temporary memory allocated.
   *
   * @param count The number of **elements** required.
   * @returns A {@link TypedArray} over the WASM memory.
   */
  getTempBufferF32(count) {
    this.requireTempMem(count * 4);
    return this._tempMemFloat;
  }
  /**
   * Copy the string into temporary WASM memory and retrieve the pointer.
   *
   * @note This method will compute the strlen and append a `\0`.
   *
   * @note The result should be used **directly** otherwise it might get
   * overridden by any next call modifying the temporary memory.
   *
   * @param str The string to write to temporary memory
   * @param byteOffset The starting byte offset in the temporary memory at which
   *     the string should be written. This is useful when using multiple temporaries.
   * @return The temporary pointer onto the WASM memory
   */
  tempUTF8(str8, byteOffset = 0) {
    const strLen = this.lengthBytesUTF8(str8) + 1;
    this.requireTempMem(strLen + byteOffset);
    const ptr = this._tempMem + byteOffset;
    this.stringToUTF8(str8, ptr, strLen);
    return ptr;
  }
  /**
   * Return the index of the component type.
   *
   * @note This method uses malloc and copies the string
   * to avoid overwriting caller's temporary data.
   *
   * @param type The type
   * @return The component type index
   */
  _typeIndexFor(type) {
    const lengthBytes = this.lengthBytesUTF8(type) + 1;
    const mem = this._malloc(lengthBytes);
    this.stringToUTF8(type, mem, lengthBytes);
    const componentType = this._wl_get_component_manager_index(mem);
    this._free(mem);
    return componentType;
  }
  /**
   * Return the name of component type stored at the given index.
   *
   * @param typeIndex The type index
   * @return The name as a string
   */
  _typeNameFor(typeIndex) {
    return this.UTF8ToString(this._wl_component_manager_name(typeIndex));
  }
  /**
   * Returns `true` if the runtime supports physx or not.
   */
  get withPhysX() {
    return this._withPhysX;
  }
  /** JavaScript manager index. */
  get _jsManagerIndex() {
    if (this._jsManagerIndexCached === null) {
      this._jsManagerIndexCached = this._typeIndexFor("js");
    }
    return this._jsManagerIndexCached;
  }
  /**
   * Set the engine instance holding this bridge.
   *
   * @note This api is meant to be used internally.
   *
   * @param engine The engine instance.
   */
  _setEngine(engine2) {
    this._engine = engine2;
  }
  /* WebAssembly to JS call bridge. */
  _wljs_xr_session_start(mode) {
    if (this._engine.xr === null) {
      this._engine.xr = new XR(this, mode);
      this._engine.onXRSessionStart.notify(this.webxr_session, mode);
    }
  }
  _wljs_xr_session_end() {
    const startEmitter = this._engine.onXRSessionStart;
    if (startEmitter instanceof RetainEmitter)
      startEmitter.reset();
    this._engine.onXRSessionEnd.notify();
    this._engine.xr = null;
  }
  _wljs_xr_disable() {
    this._engine.arSupported = false;
    this._engine.vrSupported = false;
  }
  _wljs_allocate(numComponents) {
    this._components = new Array(numComponents);
  }
  _wljs_init(withPhysX) {
    this._withPhysX = withPhysX;
    this.allocateTempMemory(1024);
  }
  _wljs_reallocate(numComponents) {
    if (numComponents > this._components.length) {
      this._components.length = numComponents;
    }
  }
  _wljs_scene_add_material_definition(definitionId) {
    const definition = /* @__PURE__ */ new Map();
    const nbParams = this._wl_material_definition_get_count(definitionId);
    for (let i = 0; i < nbParams; ++i) {
      const name = this.UTF8ToString(this._wl_material_definition_get_param_name(definitionId, i));
      const t = this._wl_material_definition_get_param_type(definitionId, i);
      definition.set(name, {
        index: i,
        type: {
          type: t & 255,
          componentCount: t >> 8 & 255,
          metaType: t >> 16 & 255
        }
      });
    }
    this._materialDefinitions[definitionId] = definition;
  }
  _wljs_set_component_param_bool(c, p, pe, v) {
    const param = this.UTF8ViewToString(p, pe);
    this._components[c][param] = v !== 0;
  }
  _wljs_set_component_param_int(c, p, pe, v) {
    const param = this.UTF8ViewToString(p, pe);
    this._components[c][param] = v;
  }
  _wljs_set_component_param_float(c, p, pe, v) {
    const param = this.UTF8ViewToString(p, pe);
    this._components[c][param] = v;
  }
  _wljs_set_component_param_string(c, p, pe, v, ve) {
    const param = this.UTF8ViewToString(p, pe);
    const value = this.UTF8ViewToString(v, ve);
    this._components[c][param] = value;
  }
  _wljs_set_component_param_color(c, p, pe, v) {
    const param = this.UTF8ViewToString(p, pe);
    this._components[c][param] = new Float32Array([0, 8, 16, 24].map((s) => (v >>> s & 255) / 255));
  }
  _wljs_set_component_param_object(c, p, pe, v) {
    const param = this.UTF8ViewToString(p, pe);
    this._components[c][param] = v > 0 ? this._engine.wrapObject(v) : null;
  }
  _wljs_set_component_param_mesh(c, p, pe, v) {
    const param = this.UTF8ViewToString(p, pe);
    this._components[c][param] = v > 0 ? new Mesh(this._engine, v) : null;
  }
  _wljs_set_component_param_texture(c, p, pe, v) {
    const param = this.UTF8ViewToString(p, pe);
    this._components[c][param] = v > 0 ? this._engine.textures.wrap(v) : null;
  }
  _wljs_set_component_param_material(c, p, pe, v) {
    const param = this.UTF8ViewToString(p, pe);
    this._components[c][param] = v > 0 ? new Material(this._engine, v) : null;
  }
  _wljs_set_component_param_animation(c, p, pe, v) {
    const param = this.UTF8ViewToString(p, pe);
    this._components[c][param] = v > 0 ? new Animation(this._engine, v) : null;
  }
  _wljs_set_component_param_skin(c, p, pe, v) {
    const param = this.UTF8ViewToString(p, pe);
    this._components[c][param] = v > 0 ? new Skin(this._engine, v) : null;
  }
  _wljs_get_component_type_index(namePtr, nameEndPtr) {
    const typename = this.UTF8ViewToString(namePtr, nameEndPtr);
    const index = this._componentTypeIndices[typename];
    if (index === void 0) {
      return this._brokenComponentIndex;
    }
    return index;
  }
  _wljs_component_create(jsManagerIndex, index, id, type, object) {
    const ctor = this._componentTypes[type];
    if (!ctor) {
      throw new Error(`Type index ${type} isn't registered`);
    }
    let component = null;
    try {
      component = new ctor();
    } catch (e) {
      this._log.error(LogTag.Component, `Exception during instantiation of component ${ctor.TypeName}`);
      this._log.error(LogTag.Component, e);
      component = new BrokenComponent(this._engine);
    }
    component._engine = this._engine;
    component._manager = jsManagerIndex;
    component._id = id;
    component._object = this._engine.wrapObject(object);
    try {
      component.resetProperties();
    } catch (e) {
      this._log.error(LogTag.Component, `Exception during ${component.type} resetProperties() on object ${component.object.name}`);
      this._log.error(LogTag.Component, e);
    }
    this._components[index] = component;
    return component;
  }
  _wljs_component_init(component) {
    const c = this._components[component];
    c._triggerInit();
  }
  _wljs_component_update(component, dt) {
    const c = this._components[component];
    c._triggerUpdate(dt);
  }
  _wljs_component_onActivate(component) {
    const c = this._components[component];
    if (c)
      c._triggerOnActivate();
  }
  _wljs_component_onDeactivate(component) {
    const c = this._components[component];
    c._triggerOnDeactivate();
  }
  _wljs_component_onDestroy(component) {
    const c = this._components[component];
    c._triggerOnDestroy();
  }
  _wljs_swap(a, b) {
    const componentA = this._components[a];
    this._components[a] = this._components[b];
    this._components[b] = componentA;
  }
  _wljs_copy(src, dst) {
    const destComp = this._components[dst];
    try {
      destComp.copy(this._components[src]);
    } catch (e) {
      this._log.error(LogTag.Component, `Exception during ${destComp.type} copy() on object ${destComp.object.name}`);
      this._log.error(LogTag.Component, e);
    }
  }
};
function throwInvalidRuntime(version) {
  return function() {
    throw new Error(`Feature added in version ${version}.
	\u2192 Please use a Wonderland Engine editor version >= ${version}`);
  };
}
var requireRuntime1_1_1 = throwInvalidRuntime("1.1.1");
var requireRuntime1_1_5 = throwInvalidRuntime("1.1.5");
WASM.prototype._wl_physx_component_get_offsetTranslation = requireRuntime1_1_1;
WASM.prototype._wl_physx_component_set_offsetTranslation = requireRuntime1_1_1;
WASM.prototype._wl_physx_component_get_offsetTransform = requireRuntime1_1_1;
WASM.prototype._wl_physx_component_set_offsetRotation = requireRuntime1_1_1;
WASM.prototype._wl_object_clone = requireRuntime1_1_1;
WASM.prototype._wl_physx_component_set_sleepOnActivate = requireRuntime1_1_5;
WASM.prototype._wl_physx_component_get_sleepOnActivate = requireRuntime1_1_5;
WASM.prototype.webxr_offerSession = requireRuntime1_1_5;

// node_modules/@wonderlandengine/api/dist/version.js
var APIVersion = {
  major: 1,
  minor: 1,
  patch: 5,
  rc: 0
};

// node_modules/@wonderlandengine/api/dist/index.js
var LOADING_SCREEN_PATH = "WonderlandRuntime-LoadingScreen.bin";
function loadScript(scriptURL) {
  return new Promise((res, rej) => {
    const s = document.createElement("script");
    const node = document.body.appendChild(s);
    s.onload = () => {
      document.body.removeChild(node);
      res();
    };
    s.onerror = (e) => {
      document.body.removeChild(node);
      rej(e);
    };
    s.src = scriptURL;
  });
}
async function detectFeatures() {
  let [simdSupported, threadsSupported] = await Promise.all([simd(), threads()]);
  if (simdSupported) {
    console.log("WASM SIMD is supported");
  } else {
    console.warn("WASM SIMD is not supported");
  }
  if (threadsSupported) {
    if (self.crossOriginIsolated) {
      console.log("WASM Threads is supported");
    } else {
      console.warn("WASM Threads is supported, but the page is not crossOriginIsolated, therefore thread support is disabled.");
    }
  } else {
    console.warn("WASM Threads is not supported");
  }
  threadsSupported = threadsSupported && self.crossOriginIsolated;
  return {
    simdSupported,
    threadsSupported
  };
}
var xrSupported = {
  ar: null,
  vr: null
};
function checkXRSupport2() {
  if (typeof navigator === "undefined" || !navigator.xr) {
    xrSupported.vr = false;
    xrSupported.ar = false;
    return Promise.resolve(xrSupported);
  }
  const vrPromise = xrSupported.vr !== null ? Promise.resolve() : navigator.xr.isSessionSupported("immersive-vr").then((supported) => xrSupported.vr = supported);
  const arPromise = xrSupported.ar !== null ? Promise.resolve() : navigator.xr.isSessionSupported("immersive-ar").then((supported) => xrSupported.ar = supported);
  return Promise.all([vrPromise, arPromise]).then(() => xrSupported);
}
function checkRuntimeCompatibility(version) {
  const { major, minor } = version;
  let majorDiff = major - APIVersion.major;
  let minorDiff = minor - APIVersion.minor;
  if (!majorDiff && !minorDiff)
    return;
  const error3 = "checkRuntimeCompatibility(): Version compatibility mismatch:\n	\u2192 API and runtime compatibility is enforced on a patch level (versions x.y.*)\n";
  const isRuntimeOlder = majorDiff < 0 || !majorDiff && minorDiff < 0;
  if (isRuntimeOlder) {
    throw new Error(`${error3}	\u2192 Please use a Wonderland Engine editor version >= ${APIVersion.major}.${APIVersion.minor}.*`);
  }
  throw new Error(`${error3}	\u2192 Please use a new API version >= ${version.major}.${version.minor}.*`);
}
async function loadRuntime(runtime, options = {}) {
  const xrPromise = checkXRSupport2();
  const baseURL = getBaseUrl(runtime);
  const { simdSupported, threadsSupported } = await detectFeatures();
  const { simd: simd2 = simdSupported, threads: threads2 = threadsSupported, physx = false, loader = false, xrFramebufferScaleFactor = 1, xrOfferSession = null, loadingScreen = baseURL ? `${baseURL}/${LOADING_SCREEN_PATH}` : LOADING_SCREEN_PATH, canvas: canvas2 = "canvas", logs = [LogLevel.Info, LogLevel.Warn, LogLevel.Error] } = options;
  const variant = [];
  if (loader)
    variant.push("loader");
  if (physx)
    variant.push("physx");
  if (simd2)
    variant.push("simd");
  if (threads2)
    variant.push("threads");
  const variantStr = variant.join("-");
  let filename = runtime;
  if (variantStr)
    filename = `${filename}-${variantStr}`;
  const download = function(filename2, errorMessage) {
    return fetch(filename2).then((r) => {
      if (!r.ok)
        return Promise.reject(errorMessage);
      return r.arrayBuffer();
    }).catch((_) => Promise.reject(errorMessage));
  };
  const [wasmData, loadingScreenData] = await Promise.all([
    download(`${filename}.wasm`, "Failed to fetch runtime .wasm file"),
    download(loadingScreen, "Failed to fetch loading screen file")
  ]);
  const glCanvas = document.getElementById(canvas2);
  if (!glCanvas) {
    throw new Error(`loadRuntime(): Failed to find canvas with id '${canvas2}'`);
  }
  if (!(glCanvas instanceof HTMLCanvasElement)) {
    throw new Error(`loadRuntime(): HTML element '${canvas2}' must be a canvas`);
  }
  const wasm = new WASM(threads2);
  wasm.worker = `${filename}.worker.js`;
  wasm.wasm = wasmData;
  wasm.canvas = glCanvas;
  wasm._log.levels.enable(...logs);
  const engine2 = new WonderlandEngine(wasm, loadingScreenData);
  if (!window._WL) {
    window._WL = { runtimes: {} };
  }
  const runtimes = window._WL.runtimes;
  const runtimeGlobalId = variantStr ? variantStr : "default";
  if (!runtimes[runtimeGlobalId]) {
    await loadScript(`${filename}.js`);
    runtimes[runtimeGlobalId] = window.instantiateWonderlandRuntime;
    window.instantiateWonderlandRuntime = void 0;
  }
  await runtimes[runtimeGlobalId](wasm);
  engine2._init();
  checkRuntimeCompatibility(engine2.runtimeVersion);
  const xr = await xrPromise;
  engine2.arSupported = xr.ar;
  engine2.vrSupported = xr.vr;
  engine2.xrFramebufferScaleFactor = xrFramebufferScaleFactor;
  engine2.autoResizeCanvas = true;
  engine2.start();
  if (xrOfferSession !== null) {
    let mode = xrOfferSession.mode;
    if (mode == "auto") {
      if (engine2.vrSupported) {
        mode = "immersive-vr";
      } else if (engine2.arSupported) {
        mode = "immersive-ar";
      } else {
        mode = "inline";
      }
    }
    const offerSession = function() {
      engine2.offerXRSession(mode, xrOfferSession.features, xrOfferSession.optionalFeatures).then(
        /* When the session ends, offer to start a new one again */
        (s) => s.addEventListener("end", offerSession)
      ).catch(console.warn);
    };
    offerSession();
  }
  return engine2;
}

// node_modules/@wonderlandengine/components/dist/8thwall-camera.js
var ARCamera8thwall = class extends Component {
  /* 8thwall camera pipeline module name */
  name = "wonderland-engine-8thwall-camera";
  started = false;
  view = null;
  // cache camera
  position = [0, 0, 0];
  // cache 8thwall cam position
  rotation = [0, 0, 0, -1];
  // cache 8thwall cam rotation
  glTextureRenderer = null;
  // cache XR8.GlTextureRenderer.pipelineModule
  promptForDeviceMotion() {
    return new Promise(async (resolve, reject) => {
      window.dispatchEvent(new Event("8thwall-request-user-interaction"));
      window.addEventListener("8thwall-safe-to-request-permissions", async () => {
        try {
          const motionEvent = await DeviceMotionEvent.requestPermission();
          resolve(motionEvent);
        } catch (exception) {
          reject(exception);
        }
      });
    });
  }
  async getPermissions() {
    if (DeviceMotionEvent && DeviceMotionEvent.requestPermission) {
      try {
        const result = await DeviceMotionEvent.requestPermission();
        if (result !== "granted") {
          throw new Error("MotionEvent");
        }
      } catch (exception) {
        if (exception.name === "NotAllowedError") {
          const motionEvent = await this.promptForDeviceMotion();
          if (motionEvent !== "granted") {
            throw new Error("MotionEvent");
          }
        } else {
          throw new Error("MotionEvent");
        }
      }
    }
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true
      });
      stream.getTracks().forEach((track) => {
        track.stop();
      });
    } catch (exception) {
      throw new Error("Camera");
    }
  }
  init() {
    this.view = this.object.getComponent("view");
    this.onUpdate = this.onUpdate.bind(this);
    this.onAttach = this.onAttach.bind(this);
    this.onException = this.onException.bind(this);
    this.onCameraStatusChange = this.onCameraStatusChange.bind(this);
  }
  async start() {
    this.view = this.object.getComponent("view");
    if (!this.useCustomUIOverlays) {
      OverlaysHandler.init();
    }
    try {
      await this.getPermissions();
    } catch (error3) {
      window.dispatchEvent(new CustomEvent("8thwall-permission-fail", { detail: error3 }));
      return;
    }
    await this.waitForXR8();
    XR8.XrController.configure({
      disableWorldTracking: false
    });
    this.glTextureRenderer = XR8.GlTextureRenderer.pipelineModule();
    XR8.addCameraPipelineModules([
      this.glTextureRenderer,
      XR8.XrController.pipelineModule(),
      this
    ]);
    const config = {
      cameraConfig: {
        direction: XR8.XrConfig.camera().BACK
      },
      canvas: Module.canvas,
      allowedDevices: XR8.XrConfig.device().ANY,
      ownRunLoop: false
    };
    XR8.run(config);
  }
  /**
   * @private
   * 8thwall pipeline function
   */
  onAttach(params) {
    this.started = true;
    this.engine.scene.colorClearEnabled = false;
    const gl = Module.ctx;
    const rot = this.object.rotationWorld;
    const pos = this.object.getTranslationWorld([]);
    this.position = Array.from(pos);
    this.rotation = Array.from(rot);
    XR8.XrController.updateCameraProjectionMatrix({
      origin: { x: pos[0], y: pos[1], z: pos[2] },
      facing: { x: rot[0], y: rot[1], z: rot[2], w: rot[3] },
      cam: {
        pixelRectWidth: Module.canvas.width,
        pixelRectHeight: Module.canvas.height,
        nearClipPlane: this.view.near,
        farClipPlane: this.view.far
      }
    });
    this.engine.scene.onPreRender.push(() => {
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      XR8.runPreRender(Date.now());
      XR8.runRender();
    });
    this.engine.scene.onPostRender.push(() => {
      XR8.runPostRender(Date.now());
    });
  }
  /**
   * @private
   * 8thwall pipeline function
   */
  onCameraStatusChange(e) {
    if (e && e.status === "failed") {
      this.onException(new Error(`Camera failed with status: ${e.status}`));
    }
  }
  /**
   * @private
   * 8thwall pipeline function
   */
  onUpdate(e) {
    if (!e.processCpuResult.reality)
      return;
    const { rotation, position, intrinsics } = e.processCpuResult.reality;
    this.rotation[0] = rotation.x;
    this.rotation[1] = rotation.y;
    this.rotation[2] = rotation.z;
    this.rotation[3] = rotation.w;
    this.position[0] = position.x;
    this.position[1] = position.y;
    this.position[2] = position.z;
    if (intrinsics) {
      const projectionMatrix = this.view.projectionMatrix;
      for (let i = 0; i < 16; i++) {
        if (Number.isFinite(intrinsics[i])) {
          projectionMatrix[i] = intrinsics[i];
        }
      }
    }
    if (position && rotation) {
      this.object.rotationWorld = this.rotation;
      this.object.setTranslationWorld(this.position);
    }
  }
  /**
   * @private
   * 8thwall pipeline function
   */
  onException(error3) {
    console.error("8thwall exception:", error3);
    window.dispatchEvent(new CustomEvent("8thwall-error", { detail: error3 }));
  }
  waitForXR8() {
    return new Promise((resolve, _rej) => {
      if (window.XR8) {
        resolve();
      } else {
        window.addEventListener("xrloaded", () => resolve());
      }
    });
  }
};
__publicField(ARCamera8thwall, "TypeName", "8thwall-camera");
__publicField(ARCamera8thwall, "Properties", {
  /** Override the WL html overlays for handling camera/motion permissions and error handling */
  useCustomUIOverlays: { type: Type.Bool, default: false }
});
var OverlaysHandler = {
  init: function() {
    this.handleRequestUserInteraction = this.handleRequestUserInteraction.bind(this);
    this.handlePermissionFail = this.handlePermissionFail.bind(this);
    this.handleError = this.handleError.bind(this);
    window.addEventListener("8thwall-request-user-interaction", this.handleRequestUserInteraction);
    window.addEventListener("8thwall-permission-fail", this.handlePermissionFail);
    window.addEventListener("8thwall-error", this.handleError);
  },
  handleRequestUserInteraction: function() {
    const overlay = this.showOverlay(requestPermissionOverlay);
    window.addEventListener("8thwall-safe-to-request-permissions", () => {
      overlay.remove();
    });
  },
  handlePermissionFail: function(_reason) {
    this.showOverlay(failedPermissionOverlay);
  },
  handleError: function(_error) {
    this.showOverlay(runtimeErrorOverlay);
  },
  showOverlay: function(htmlContent) {
    const overlay = document.createElement("div");
    overlay.innerHTML = htmlContent;
    document.body.appendChild(overlay);
    return overlay;
  }
};
var requestPermissionOverlay = `
<style>
  #request-permission-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 999;
    color: #fff;
    background-color: rgba(0, 0, 0, 0.5);
    text-align: center;
    font-family: sans-serif;
  }

  .request-permission-overlay_title {
    margin: 30px;
    font-size: 32px;
  }

  .request-permission-overlay_button {
    background-color: #e80086;
    font-size: 22px;
    padding: 10px 30px;
    color: #fff;
    border-radius: 15px;
    border: none;
  }
</style>

<div id="request-permission-overlay">
  <div class="request-permission-overlay_title">This app requires to use your camera and motion sensors</div>

  <button class="request-permission-overlay_button" onclick="window.dispatchEvent(new Event('8thwall-safe-to-request-permissions'))">OK</button>
</div>`;
var failedPermissionOverlay = `
<style>
  #failed-permission-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 999;
    color: #fff;
    background-color: rgba(0, 0, 0, 0.5);
    text-align: center;
    font-family: sans-serif;
  }

  .failed-permission-overlay_title {
    margin: 30px;
    font-size: 32px;
  }

  .failed-permission-overlay_button {
    background-color: #e80086;
    font-size: 22px;
    padding: 10px 30px;
    color: #fff;
    border-radius: 15px;
    border: none;
  }
</style>

<div id="failed-permission-overlay">
  <div class="failed-permission-overlay_title">Failed to grant permissions. Reset the the permissions and refresh the page.</div>

  <button class="failed-permission-overlay_button" onclick="window.location.reload()">Refresh the page</button>
</div>`;
var runtimeErrorOverlay = `
<style>
  #wall-error-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 999;
    color: #fff;
    background-color: rgba(0, 0, 0, 0.5);
    text-align: center;
    font-family: sans-serif;
  }

  .wall-error-overlay_title {
    margin: 30px;
    font-size: 32px;
  }

  .wall-error-overlay_button {
    background-color: #e80086;
    font-size: 22px;
    padding: 10px 30px;
    color: #fff;
    border-radius: 15px;
    border: none;
  }
</style>

<div id="wall-error-overlay">
  <div class="wall-error-overlay_title">Error has occurred. Please reload the page</div>

  <button class="wall-error-overlay_button" onclick="window.location.reload()">Reload</button>
</div>`;

// node_modules/@wonderlandengine/components/dist/utils/webxr.js
var tempVec = new Float32Array(3);
var tempQuat = new Float32Array(4);
function setXRRigidTransformLocal(o, transform) {
  const r = transform.orientation;
  tempQuat[0] = r.x;
  tempQuat[1] = r.y;
  tempQuat[2] = r.z;
  tempQuat[3] = r.w;
  const t = transform.position;
  tempVec[0] = t.x;
  tempVec[1] = t.y;
  tempVec[2] = t.z;
  o.resetPositionRotation();
  o.setRotationLocal(tempQuat);
  o.translateLocal(tempVec);
}

// node_modules/@wonderlandengine/components/dist/anchor.js
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var tempVec3 = new Float32Array(3);
var tempQuat2 = new Float32Array(4);
var _anchors, _addAnchor, addAnchor_fn, _removeAnchor, removeAnchor_fn, _getFrame, getFrame_fn, _createAnchor, createAnchor_fn, _onAddAnchor, onAddAnchor_fn, _onRestoreAnchor, onRestoreAnchor_fn, _onCreate, onCreate_fn;
var _Anchor = class extends Component {
  constructor() {
    super(...arguments);
    __privateAdd(this, _getFrame);
    __privateAdd(this, _createAnchor);
    __privateAdd(this, _onAddAnchor);
    __privateAdd(this, _onRestoreAnchor);
    __privateAdd(this, _onCreate);
    __publicField(this, "persist", false);
    /** Unique identifier to load a persistent anchor from, or empty/null if unknown */
    __publicField(this, "uuid", null);
    /** The xrAnchor, if created */
    __publicField(this, "xrAnchor", null);
    /** Emits events when the anchor is created either by being restored or newly created */
    __publicField(this, "onCreate", new Emitter());
    /** Whether the anchor is currently being tracked */
    __publicField(this, "visible", false);
    /** Emits an event when this anchor starts tracking */
    __publicField(this, "onTrackingFound", new Emitter());
    /** Emits an event when this anchor stops tracking */
    __publicField(this, "onTrackingLost", new Emitter());
    /** XRFrame to use for creating the anchor */
    __publicField(this, "xrFrame", null);
    /** XRHitTestResult to use for creating the anchor */
    __publicField(this, "xrHitResult", null);
  }
  /** Retrieve all anchors of the current scene */
  static getAllAnchors() {
    return __privateGet(_Anchor, _anchors);
  }
  /**
   * Create a new anchor
   *
   * @param o Object to attach the component to
   * @param params Parameters for the anchor component
   * @param frame XRFrame to use for anchor cration, if null, will use the current frame if available
   * @param hitResult Optional hit-test result to create the anchor with
   * @returns Promise for the newly created anchor component
   */
  static create(o, params, frame, hitResult) {
    const a = o.addComponent(_Anchor, { ...params, active: false });
    if (a === null)
      return null;
    a.xrHitResult = hitResult ?? null;
    a.xrFrame = frame ?? null;
    a.onCreate.once(() => (a.xrFrame = null, a.xrHitResult = null));
    a.active = true;
    return a.onCreate.promise();
  }
  start() {
    if (this.uuid && this.engine.xr) {
      this.persist = true;
      if (this.engine.xr.session.restorePersistentAnchor === void 0) {
        console.warn("anchor: Persistent anchors are not supported by your client. Ignoring persist property.");
      }
      this.engine.xr.session.restorePersistentAnchor(this.uuid).then(__privateMethod(this, _onRestoreAnchor, onRestoreAnchor_fn).bind(this));
    } else if (__privateMethod(this, _getFrame, getFrame_fn).call(this)) {
      __privateMethod(this, _createAnchor, createAnchor_fn).call(this).then(__privateMethod(this, _onAddAnchor, onAddAnchor_fn).bind(this));
    } else {
      throw new Error("Anchors can only be created during the XR frame in an active XR session");
    }
  }
  update() {
    if (!this.xrAnchor || !this.engine.xr)
      return;
    const pose = this.engine.xr.frame.getPose(this.xrAnchor.anchorSpace, this.engine.xr.currentReferenceSpace);
    const visible = !!pose;
    if (visible != this.visible) {
      this.visible = visible;
      (visible ? this.onTrackingFound : this.onTrackingLost).notify(this);
    }
    if (pose) {
      setXRRigidTransformLocal(this.object, pose.transform);
    }
  }
  onDestroy() {
    var _a;
    __privateMethod(_a = _Anchor, _removeAnchor, removeAnchor_fn).call(_a, this);
  }
};
var Anchor = _Anchor;
_anchors = new WeakMap();
_addAnchor = new WeakSet();
addAnchor_fn = function(anchor) {
  __privateGet(_Anchor, _anchors).push(anchor);
};
_removeAnchor = new WeakSet();
removeAnchor_fn = function(anchor) {
  const index = __privateGet(_Anchor, _anchors).indexOf(anchor);
  if (index < 0)
    return;
  __privateGet(_Anchor, _anchors).splice(index, 1);
};
_getFrame = new WeakSet();
getFrame_fn = function() {
  return this.xrFrame || this.engine.xr.frame;
};
_createAnchor = new WeakSet();
createAnchor_fn = async function() {
  if (!__privateMethod(this, _getFrame, getFrame_fn).call(this).createAnchor) {
    throw new Error("Cannot create anchor - anchors not supported, did you enable the 'anchors' WebXR feature?");
  }
  if (this.xrHitResult) {
    if (this.xrHitResult.createAnchor === void 0) {
      throw new Error("Requested anchor on XRHitTestResult, but WebXR hit-test feature is not available.");
    }
    return this.xrHitResult.createAnchor();
  } else {
    this.object.getTranslationWorld(tempVec3);
    tempQuat2.set(this.object.rotationWorld);
    const rotation = tempQuat2;
    const anchorPose = new XRRigidTransform({ x: tempVec3[0], y: tempVec3[1], z: tempVec3[2] }, { x: rotation[0], y: rotation[1], z: rotation[2], w: rotation[3] });
    return __privateMethod(this, _getFrame, getFrame_fn).call(this)?.createAnchor(anchorPose, this.engine.xr.currentReferenceSpace);
  }
};
_onAddAnchor = new WeakSet();
onAddAnchor_fn = function(anchor) {
  if (!anchor)
    return;
  if (this.persist) {
    if (anchor.requestPersistentHandle !== void 0) {
      anchor.requestPersistentHandle().then((uuid) => {
        var _a;
        this.uuid = uuid;
        __privateMethod(this, _onCreate, onCreate_fn).call(this, anchor);
        __privateMethod(_a = _Anchor, _addAnchor, addAnchor_fn).call(_a, this);
      });
      return;
    } else {
      console.warn("anchor: Persistent anchors are not supported by your client. Ignoring persist property.");
    }
  }
  __privateMethod(this, _onCreate, onCreate_fn).call(this, anchor);
};
_onRestoreAnchor = new WeakSet();
onRestoreAnchor_fn = function(anchor) {
  __privateMethod(this, _onCreate, onCreate_fn).call(this, anchor);
};
_onCreate = new WeakSet();
onCreate_fn = function(anchor) {
  this.xrAnchor = anchor;
  this.onCreate.notify(this);
};
__privateAdd(Anchor, _addAnchor);
__privateAdd(Anchor, _removeAnchor);
__publicField(Anchor, "TypeName", "anchor");
/* Static management of all anchors */
__privateAdd(Anchor, _anchors, []);
__decorate2([
  property.bool(false)
], Anchor.prototype, "persist", void 0);
__decorate2([
  property.string()
], Anchor.prototype, "uuid", void 0);

// node_modules/@wonderlandengine/components/dist/cursor-target.js
var CursorTarget = class extends Component {
  /** Emitter for events when the target is hovered */
  onHover = new Emitter();
  /** Emitter for events when the target is unhovered */
  onUnhover = new Emitter();
  /** Emitter for events when the target is clicked */
  onClick = new Emitter();
  /** Emitter for events when the cursor moves on the target */
  onMove = new Emitter();
  /** Emitter for events when the user pressed the select button on the target */
  onDown = new Emitter();
  /** Emitter for events when the user unpressed the select button on the target */
  onUp = new Emitter();
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    this.onHover.add(f);
   */
  addHoverFunction(f) {
    this.onHover.add(f);
  }
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    this.onHover.remove(f);
   */
  removeHoverFunction(f) {
    this.onHover.remove(f);
  }
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    this.onUnhover.add(f);
   */
  addUnHoverFunction(f) {
    this.onUnhover.add(f);
  }
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    this.onUnhover.remove(f);
   */
  removeUnHoverFunction(f) {
    this.onUnhover.remove(f);
  }
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    this.onClick.add(f);
   */
  addClickFunction(f) {
    this.onClick.add(f);
  }
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    component.onClick.remove(f);
   */
  removeClickFunction(f) {
    this.onClick.remove(f);
  }
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    component.onMove.add(f);
   */
  addMoveFunction(f) {
    this.onMove.add(f);
  }
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    component.onMove.remove(f);
   */
  removeMoveFunction(f) {
    this.onMove.remove(f);
  }
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    component.onDown.add(f);
   */
  addDownFunction(f) {
    this.onDown.add(f);
  }
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    component.onDown.remove(f);
   */
  removeDownFunction(f) {
    this.onDown.remove(f);
  }
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    component.onUp.add(f);
   */
  addUpFunction(f) {
    this.onUp.add(f);
  }
  /**
   * @deprecated Use the emitter instead.
   *
   * @example
   *    component.onUp.remove(f);
   */
  removeUpFunction(f) {
    this.onUp.remove(f);
  }
};
__publicField(CursorTarget, "TypeName", "cursor-target");
__publicField(CursorTarget, "Properties", {});

// node_modules/gl-matrix/esm/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
var degree = Math.PI / 180;
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };

// node_modules/gl-matrix/esm/mat3.js
var mat3_exports = {};
__export(mat3_exports, {
  add: () => add,
  adjoint: () => adjoint,
  clone: () => clone,
  copy: () => copy,
  create: () => create,
  determinant: () => determinant,
  equals: () => equals,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromMat2d: () => fromMat2d,
  fromMat4: () => fromMat4,
  fromQuat: () => fromQuat,
  fromRotation: () => fromRotation,
  fromScaling: () => fromScaling,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues,
  identity: () => identity,
  invert: () => invert,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  normalFromMat4: () => normalFromMat4,
  projection: () => projection,
  rotate: () => rotate,
  scale: () => scale,
  set: () => set,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  translate: () => translate,
  transpose: () => transpose
});
function create() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
function clone(a) {
  var out = new ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function transpose(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }
  return out;
}
function invert(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function adjoint(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
function determinant(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b00 = b[0], b01 = b[1], b02 = b[2];
  var b10 = b[3], b11 = b[4], b12 = b[5];
  var b20 = b[6], b21 = b[7], b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate(out, a, v) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
function rotate(out, a, rad) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale(out, a, v) {
  var x = v[0], y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
function fromRotation(out, rad) {
  var s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
function fromQuat(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
function normalFromMat4(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
function multiplyScalarAndAdd(out, a, b, scale11) {
  out[0] = a[0] + b[0] * scale11;
  out[1] = a[1] + b[1] * scale11;
  out[2] = a[2] + b[2] * scale11;
  out[3] = a[3] + b[3] * scale11;
  out[4] = a[4] + b[4] * scale11;
  out[5] = a[5] + b[5] * scale11;
  out[6] = a[6] + b[6] * scale11;
  out[7] = a[7] + b[7] * scale11;
  out[8] = a[8] + b[8] * scale11;
  return out;
}
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
function equals(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
}
var mul = multiply;
var sub = subtract;

// node_modules/gl-matrix/esm/mat4.js
var mat4_exports = {};
__export(mat4_exports, {
  add: () => add2,
  adjoint: () => adjoint2,
  clone: () => clone2,
  copy: () => copy2,
  create: () => create2,
  determinant: () => determinant2,
  equals: () => equals2,
  exactEquals: () => exactEquals2,
  frob: () => frob2,
  fromQuat: () => fromQuat3,
  fromQuat2: () => fromQuat2,
  fromRotation: () => fromRotation2,
  fromRotationTranslation: () => fromRotationTranslation,
  fromRotationTranslationScale: () => fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
  fromScaling: () => fromScaling2,
  fromTranslation: () => fromTranslation2,
  fromValues: () => fromValues2,
  fromXRotation: () => fromXRotation,
  fromYRotation: () => fromYRotation,
  fromZRotation: () => fromZRotation,
  frustum: () => frustum,
  getRotation: () => getRotation,
  getScaling: () => getScaling,
  getTranslation: () => getTranslation,
  identity: () => identity2,
  invert: () => invert2,
  lookAt: () => lookAt,
  mul: () => mul2,
  multiply: () => multiply2,
  multiplyScalar: () => multiplyScalar2,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
  ortho: () => ortho,
  orthoNO: () => orthoNO,
  orthoZO: () => orthoZO,
  perspective: () => perspective,
  perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
  perspectiveNO: () => perspectiveNO,
  perspectiveZO: () => perspectiveZO,
  rotate: () => rotate2,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  scale: () => scale2,
  set: () => set2,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  targetTo: () => targetTo,
  translate: () => translate2,
  transpose: () => transpose2
});
function create2() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone2(a) {
  var out = new ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function copy2(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function fromValues2(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set2(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose2(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a03 = a[3];
    var a12 = a[6], a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}
function invert2(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint2(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
function determinant2(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply2(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate2(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
}
function scale2(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function rotate2(out, a, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len6 = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len6 < EPSILON) {
    return null;
  }
  len6 = 1 / len6;
  x *= len6;
  y *= len6;
  z *= len6;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}
function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
function fromTranslation2(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromScaling2(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation2(out, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len6 = Math.hypot(x, y, z);
  var s, c, t;
  if (len6 < EPSILON) {
    return null;
  }
  len6 = 1 / len6;
  x *= len6;
  y *= len6;
  z *= len6;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q, v) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a, translation);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
function fromRotationTranslationScale(out, q, v, s) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat3(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  var xScale = 2 / (leftTan + rightTan);
  var yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len6;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity2(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len6 = 1 / Math.hypot(z0, z1, z2);
  z0 *= len6;
  z1 *= len6;
  z2 *= len6;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len6 = Math.hypot(x0, x1, x2);
  if (!len6) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len6 = 1 / len6;
    x0 *= len6;
    x1 *= len6;
    x2 *= len6;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len6 = Math.hypot(y0, y1, y2);
  if (!len6) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len6 = 1 / len6;
    y0 *= len6;
    y1 *= len6;
    y2 *= len6;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target, up) {
  var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
  var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
  var len6 = z0 * z0 + z1 * z1 + z2 * z2;
  if (len6 > 0) {
    len6 = 1 / Math.sqrt(len6);
    z0 *= len6;
    z1 *= len6;
    z2 *= len6;
  }
  var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
  len6 = x0 * x0 + x1 * x1 + x2 * x2;
  if (len6 > 0) {
    len6 = 1 / Math.sqrt(len6);
    x0 *= len6;
    x1 *= len6;
    x2 *= len6;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str2(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
function frob2(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
function add2(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
function subtract2(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
function multiplyScalar2(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
function multiplyScalarAndAdd2(out, a, b, scale11) {
  out[0] = a[0] + b[0] * scale11;
  out[1] = a[1] + b[1] * scale11;
  out[2] = a[2] + b[2] * scale11;
  out[3] = a[3] + b[3] * scale11;
  out[4] = a[4] + b[4] * scale11;
  out[5] = a[5] + b[5] * scale11;
  out[6] = a[6] + b[6] * scale11;
  out[7] = a[7] + b[7] * scale11;
  out[8] = a[8] + b[8] * scale11;
  out[9] = a[9] + b[9] * scale11;
  out[10] = a[10] + b[10] * scale11;
  out[11] = a[11] + b[11] * scale11;
  out[12] = a[12] + b[12] * scale11;
  out[13] = a[13] + b[13] * scale11;
  out[14] = a[14] + b[14] * scale11;
  out[15] = a[15] + b[15] * scale11;
  return out;
}
function exactEquals2(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
function equals2(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
  var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
  var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
  var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul2 = multiply2;
var sub2 = subtract2;

// node_modules/gl-matrix/esm/quat.js
var quat_exports = {};
__export(quat_exports, {
  add: () => add5,
  calculateW: () => calculateW,
  clone: () => clone5,
  conjugate: () => conjugate,
  copy: () => copy5,
  create: () => create5,
  dot: () => dot3,
  equals: () => equals5,
  exactEquals: () => exactEquals5,
  exp: () => exp,
  fromEuler: () => fromEuler,
  fromMat3: () => fromMat3,
  fromValues: () => fromValues5,
  getAngle: () => getAngle,
  getAxisAngle: () => getAxisAngle,
  identity: () => identity3,
  invert: () => invert3,
  len: () => len3,
  length: () => length3,
  lerp: () => lerp3,
  ln: () => ln,
  mul: () => mul5,
  multiply: () => multiply5,
  normalize: () => normalize3,
  pow: () => pow,
  random: () => random3,
  rotateX: () => rotateX3,
  rotateY: () => rotateY3,
  rotateZ: () => rotateZ3,
  rotationTo: () => rotationTo,
  scale: () => scale5,
  set: () => set5,
  setAxes: () => setAxes,
  setAxisAngle: () => setAxisAngle,
  slerp: () => slerp,
  sqlerp: () => sqlerp,
  sqrLen: () => sqrLen3,
  squaredLength: () => squaredLength3,
  str: () => str5
});

// node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add3,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone3,
  copy: () => copy3,
  create: () => create3,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals3,
  exactEquals: () => exactEquals3,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues3,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max,
  min: () => min,
  mul: () => mul3,
  multiply: () => multiply3,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  round: () => round,
  scale: () => scale3,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set3,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str3,
  sub: () => sub3,
  subtract: () => subtract3,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone3(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
function fromValues3(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy3(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function set3(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add3(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract3(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply3(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
function scale3(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function scaleAndAdd(out, a, b, scale11) {
  out[0] = a[0] + b[0] * scale11;
  out[1] = a[1] + b[1] * scale11;
  out[2] = a[2] + b[2] * scale11;
  return out;
}
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function inverse(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  return out;
}
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len6 = x * x + y * y + z * z;
  if (len6 > 0) {
    len6 = 1 / Math.sqrt(len6);
  }
  out[0] = a[0] * len6;
  out[1] = a[1] * len6;
  out[2] = a[2] * len6;
  return out;
}
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function random(out, scale11) {
  scale11 = scale11 || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale11;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale11;
  return out;
}
function transformMat4(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat3(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a[0], y = a[1], z = a[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a, b) {
  var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str3(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
function exactEquals3(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals3(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var sub3 = subtract3;
var mul3 = multiply3;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create3();
  return function(a, stride, offset2, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset2) {
      offset2 = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset2, a.length);
    } else {
      l = a.length;
    }
    for (i = offset2; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();

// node_modules/gl-matrix/esm/vec4.js
var vec4_exports = {};
__export(vec4_exports, {
  add: () => add4,
  ceil: () => ceil2,
  clone: () => clone4,
  copy: () => copy4,
  create: () => create4,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot2,
  equals: () => equals4,
  exactEquals: () => exactEquals4,
  floor: () => floor2,
  forEach: () => forEach2,
  fromValues: () => fromValues4,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length2,
  lerp: () => lerp2,
  max: () => max2,
  min: () => min2,
  mul: () => mul4,
  multiply: () => multiply4,
  negate: () => negate2,
  normalize: () => normalize2,
  random: () => random2,
  round: () => round2,
  scale: () => scale4,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set4,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength2,
  str: () => str4,
  sub: () => sub4,
  subtract: () => subtract4,
  transformMat4: () => transformMat42,
  transformQuat: () => transformQuat2,
  zero: () => zero2
});
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone4(a) {
  var out = new ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function fromValues4(x, y, z, w) {
  var out = new ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function copy4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function set4(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function add4(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
function subtract4(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
function multiply4(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
function divide2(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
function ceil2(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
function floor2(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
function min2(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
function max2(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
function round2(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
function scale4(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
function scaleAndAdd2(out, a, b, scale11) {
  out[0] = a[0] + b[0] * scale11;
  out[1] = a[1] + b[1] * scale11;
  out[2] = a[2] + b[2] * scale11;
  out[3] = a[3] + b[3] * scale11;
  return out;
}
function distance2(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
function squaredDistance2(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
function length2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
function squaredLength2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
function negate2(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
function inverse2(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  out[3] = 1 / a[3];
  return out;
}
function normalize2(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len6 = x * x + y * y + z * z + w * w;
  if (len6 > 0) {
    len6 = 1 / Math.sqrt(len6);
  }
  out[0] = x * len6;
  out[1] = y * len6;
  out[2] = z * len6;
  out[3] = w * len6;
  return out;
}
function dot2(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
function cross2(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0], B = v[0] * w[2] - v[2] * w[0], C = v[0] * w[3] - v[3] * w[0], D = v[1] * w[2] - v[2] * w[1], E = v[1] * w[3] - v[3] * w[1], F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
function lerp2(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
function random2(out, scale11) {
  scale11 = scale11 || 1;
  var v1, v2, v3, v4;
  var s1, s2;
  do {
    v1 = RANDOM() * 2 - 1;
    v2 = RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = RANDOM() * 2 - 1;
    v4 = RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);
  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale11 * v1;
  out[1] = scale11 * v2;
  out[2] = scale11 * v3 * d;
  out[3] = scale11 * v4 * d;
  return out;
}
function transformMat42(out, a, m) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
function transformQuat2(out, a, q) {
  var x = a[0], y = a[1], z = a[2];
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z;
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}
function str4(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
function exactEquals4(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function equals4(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
var sub4 = subtract4;
var mul4 = multiply4;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var len2 = length2;
var sqrLen2 = squaredLength2;
var forEach2 = function() {
  var vec = create4();
  return function(a, stride, offset2, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset2) {
      offset2 = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset2, a.length);
    } else {
      l = a.length;
    }
    for (i = offset2; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
}();

// node_modules/gl-matrix/esm/quat.js
function create5() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity3(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2;
  var s = Math.sin(rad / 2);
  if (s > EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
function getAngle(a, b) {
  var dotproduct = dot3(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
function multiply5(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX3(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY3(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var by = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ3(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bz = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
  return out;
}
function exp(out, a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
function ln(out, a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
function pow(out, a, b) {
  ln(out, a);
  scale5(out, out, b);
  exp(out, out);
  return out;
}
function slerp(out, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function random3(out) {
  var u1 = RANDOM();
  var u2 = RANDOM();
  var u3 = RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
  return out;
}
function invert3(out, a) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var dot7 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot7 ? 1 / dot7 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
function str5(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
var clone5 = clone4;
var fromValues5 = fromValues4;
var copy5 = copy4;
var set5 = set4;
var add5 = add4;
var mul5 = multiply5;
var scale5 = scale4;
var dot3 = dot2;
var lerp3 = lerp2;
var length3 = length2;
var len3 = length3;
var squaredLength3 = squaredLength2;
var sqrLen3 = squaredLength3;
var normalize3 = normalize2;
var exactEquals5 = exactEquals4;
var equals5 = equals4;
var rotationTo = function() {
  var tmpvec3 = create3();
  var xUnitVec3 = fromValues3(1, 0, 0);
  var yUnitVec3 = fromValues3(0, 1, 0);
  return function(out, a, b) {
    var dot7 = dot(a, b);
    if (dot7 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 1e-6)
        cross(tmpvec3, yUnitVec3, a);
      normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot7 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot7;
      return normalize3(out, out);
    }
  };
}();
var sqlerp = function() {
  var temp1 = create5();
  var temp2 = create5();
  return function(out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
var setAxes = function() {
  var matr = create();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize3(out, fromMat3(out, matr));
  };
}();

// node_modules/gl-matrix/esm/quat2.js
var quat2_exports = {};
__export(quat2_exports, {
  add: () => add6,
  clone: () => clone6,
  conjugate: () => conjugate2,
  copy: () => copy6,
  create: () => create6,
  dot: () => dot4,
  equals: () => equals6,
  exactEquals: () => exactEquals6,
  fromMat4: () => fromMat42,
  fromRotation: () => fromRotation3,
  fromRotationTranslation: () => fromRotationTranslation2,
  fromRotationTranslationValues: () => fromRotationTranslationValues,
  fromTranslation: () => fromTranslation3,
  fromValues: () => fromValues6,
  getDual: () => getDual,
  getReal: () => getReal,
  getTranslation: () => getTranslation2,
  identity: () => identity4,
  invert: () => invert4,
  len: () => len4,
  length: () => length4,
  lerp: () => lerp4,
  mul: () => mul6,
  multiply: () => multiply6,
  normalize: () => normalize4,
  rotateAroundAxis: () => rotateAroundAxis,
  rotateByQuatAppend: () => rotateByQuatAppend,
  rotateByQuatPrepend: () => rotateByQuatPrepend,
  rotateX: () => rotateX4,
  rotateY: () => rotateY4,
  rotateZ: () => rotateZ4,
  scale: () => scale6,
  set: () => set6,
  setDual: () => setDual,
  setReal: () => setReal,
  sqrLen: () => sqrLen4,
  squaredLength: () => squaredLength4,
  str: () => str6,
  translate: () => translate3
});
function create6() {
  var dq = new ARRAY_TYPE(8);
  if (ARRAY_TYPE != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }
  dq[3] = 1;
  return dq;
}
function clone6(a) {
  var dq = new ARRAY_TYPE(8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}
function fromValues6(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}
function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5, ay = y2 * 0.5, az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}
function fromRotationTranslation2(out, q, t) {
  var ax = t[0] * 0.5, ay = t[1] * 0.5, az = t[2] * 0.5, bx = q[0], by = q[1], bz = q[2], bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
function fromTranslation3(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}
function fromRotation3(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
function fromMat42(out, a) {
  var outer = create5();
  getRotation(outer, a);
  var t = new ARRAY_TYPE(3);
  getTranslation(t, a);
  fromRotationTranslation2(out, outer, t);
  return out;
}
function copy6(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}
function identity4(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
function set6(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}
var getReal = copy5;
function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}
var setReal = copy5;
function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}
function getTranslation2(out, a) {
  var ax = a[4], ay = a[5], az = a[6], aw = a[7], bx = -a[0], by = -a[1], bz = -a[2], bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}
function translate3(out, a, v) {
  var ax1 = a[0], ay1 = a[1], az1 = a[2], aw1 = a[3], bx1 = v[0] * 0.5, by1 = v[1] * 0.5, bz1 = v[2] * 0.5, ax2 = a[4], ay2 = a[5], az2 = a[6], aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}
function rotateX4(out, a, rad) {
  var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
  rotateX3(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
function rotateY4(out, a, rad) {
  var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
  rotateY3(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
function rotateZ4(out, a, rad) {
  var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
  rotateZ3(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
function rotateByQuatAppend(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3], ax = a[0], ay = a[1], az = a[2], aw = a[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}
function rotateByQuatPrepend(out, q, a) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3], bx = a[0], by = a[1], bz = a[2], bw = a[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}
function rotateAroundAxis(out, a, axis, rad) {
  if (Math.abs(rad) < EPSILON) {
    return copy6(out, a);
  }
  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a[0], ay1 = a[1], az1 = a[2], aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a[4], ay = a[5], az = a[6], aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function add6(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}
function multiply6(out, a, b) {
  var ax0 = a[0], ay0 = a[1], az0 = a[2], aw0 = a[3], bx1 = b[4], by1 = b[5], bz1 = b[6], bw1 = b[7], ax1 = a[4], ay1 = a[5], az1 = a[6], aw1 = a[7], bx0 = b[0], by0 = b[1], bz0 = b[2], bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
var mul6 = multiply6;
function scale6(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}
var dot4 = dot3;
function lerp4(out, a, b, t) {
  var mt = 1 - t;
  if (dot4(a, b) < 0)
    t = -t;
  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;
  return out;
}
function invert4(out, a) {
  var sqlen = squaredLength4(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}
function conjugate2(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}
var length4 = length3;
var len4 = length4;
var squaredLength4 = squaredLength3;
var sqrLen4 = squaredLength4;
function normalize4(out, a) {
  var magnitude = squaredLength4(a);
  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;
    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];
    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }
  return out;
}
function str6(a) {
  return "quat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ")";
}
function exactEquals6(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
function equals6(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7));
}

// node_modules/gl-matrix/esm/vec2.js
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add7,
  angle: () => angle2,
  ceil: () => ceil3,
  clone: () => clone7,
  copy: () => copy7,
  create: () => create7,
  cross: () => cross3,
  dist: () => dist3,
  distance: () => distance3,
  div: () => div3,
  divide: () => divide3,
  dot: () => dot5,
  equals: () => equals7,
  exactEquals: () => exactEquals7,
  floor: () => floor3,
  forEach: () => forEach3,
  fromValues: () => fromValues7,
  inverse: () => inverse3,
  len: () => len5,
  length: () => length5,
  lerp: () => lerp5,
  max: () => max3,
  min: () => min3,
  mul: () => mul7,
  multiply: () => multiply7,
  negate: () => negate3,
  normalize: () => normalize5,
  random: () => random4,
  rotate: () => rotate3,
  round: () => round3,
  scale: () => scale7,
  scaleAndAdd: () => scaleAndAdd3,
  set: () => set7,
  sqrDist: () => sqrDist3,
  sqrLen: () => sqrLen5,
  squaredDistance: () => squaredDistance3,
  squaredLength: () => squaredLength5,
  str: () => str7,
  sub: () => sub5,
  subtract: () => subtract5,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat43,
  zero: () => zero3
});
function create7() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone7(a) {
  var out = new ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function fromValues7(x, y) {
  var out = new ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
function copy7(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function set7(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
function add7(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
function subtract5(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
function multiply7(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
function divide3(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
function ceil3(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
function floor3(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
function min3(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
function max3(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
function round3(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
function scale7(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
function scaleAndAdd3(out, a, b, scale11) {
  out[0] = a[0] + b[0] * scale11;
  out[1] = a[1] + b[1] * scale11;
  return out;
}
function distance3(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return Math.hypot(x, y);
}
function squaredDistance3(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return x * x + y * y;
}
function length5(a) {
  var x = a[0], y = a[1];
  return Math.hypot(x, y);
}
function squaredLength5(a) {
  var x = a[0], y = a[1];
  return x * x + y * y;
}
function negate3(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
function inverse3(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  return out;
}
function normalize5(out, a) {
  var x = a[0], y = a[1];
  var len6 = x * x + y * y;
  if (len6 > 0) {
    len6 = 1 / Math.sqrt(len6);
  }
  out[0] = a[0] * len6;
  out[1] = a[1] * len6;
  return out;
}
function dot5(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
function cross3(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
function lerp5(out, a, b, t) {
  var ax = a[0], ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
function random4(out, scale11) {
  scale11 = scale11 || 1;
  var r = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r) * scale11;
  out[1] = Math.sin(r) * scale11;
  return out;
}
function transformMat2(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
function transformMat2d(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
function transformMat32(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function transformMat43(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
function rotate3(out, a, b, rad) {
  var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(rad), cosC = Math.cos(rad);
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
function angle2(a, b) {
  var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero3(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str7(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
function exactEquals7(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
function equals7(a, b) {
  var a0 = a[0], a1 = a[1];
  var b0 = b[0], b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len5 = length5;
var sub5 = subtract5;
var mul7 = multiply7;
var div3 = divide3;
var dist3 = distance3;
var sqrDist3 = squaredDistance3;
var sqrLen5 = squaredLength5;
var forEach3 = function() {
  var vec = create7();
  return function(a, stride, offset2, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset2) {
      offset2 = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset2, a.length);
    } else {
      l = a.length;
    }
    for (i = offset2; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();

// node_modules/@wonderlandengine/components/dist/hit-test-location.js
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HitTestLocation = class extends Component {
  tempScaling = new Float32Array(3);
  visible = false;
  xrHitTestSource = null;
  /** Reference space for creating the hit test when the session starts */
  xrReferenceSpace = null;
  /**
   * For maintaining backwards compatibility: Whether to scale the object to 0 and back.
   * @deprecated Use onHitLost and onHitFound instead.
   */
  scaleObject = true;
  /** Emits an event when the hit test switches from visible to invisible */
  onHitLost = new Emitter();
  /** Emits an event when the hit test switches from invisible to visible */
  onHitFound = new Emitter();
  onSessionStartCallback = null;
  onSessionEndCallback = null;
  start() {
    this.onSessionStartCallback = this.onXRSessionStart.bind(this);
    this.onSessionEndCallback = this.onXRSessionEnd.bind(this);
    if (this.scaleObject) {
      this.tempScaling.set(this.object.scalingLocal);
      this.object.scale([0, 0, 0]);
      this.onHitLost.add(() => {
        this.tempScaling.set(this.object.scalingLocal);
        this.object.scale([0, 0, 0]);
      });
      this.onHitFound.add(() => {
        this.object.scalingLocal.set(this.tempScaling);
        this.object.setDirty();
      });
    }
  }
  onActivate() {
    this.engine.onXRSessionStart.add(this.onSessionStartCallback);
    this.engine.onXRSessionEnd.add(this.onSessionEndCallback);
  }
  onDeactivate() {
    this.engine.onXRSessionStart.remove(this.onSessionStartCallback);
    this.engine.onXRSessionEnd.remove(this.onSessionEndCallback);
  }
  update() {
    const wasVisible = this.visible;
    if (this.xrHitTestSource) {
      const frame = this.engine.xrFrame;
      if (!frame)
        return;
      let hitTestResults = frame.getHitTestResults(this.xrHitTestSource);
      if (hitTestResults.length > 0) {
        let pose = hitTestResults[0].getPose(this.engine.xr.currentReferenceSpace);
        this.visible = !!pose;
        if (pose) {
          setXRRigidTransformLocal(this.object, pose.transform);
        }
      } else {
        this.visible = false;
      }
    }
    if (this.visible != wasVisible) {
      (this.visible ? this.onHitFound : this.onHitLost).notify(this);
    }
  }
  getHitTestResults(frame = this.engine.xr?.frame ?? null) {
    if (!frame)
      return [];
    if (!this.xrHitTestSource)
      return [];
    return frame.getHitTestResults(this.xrHitTestSource);
  }
  onXRSessionStart(session) {
    if (session.requestHitTestSource === void 0) {
      console.error("hit-test-location: hit test feature not available. Deactivating component.");
      this.active = false;
      return;
    }
    session.requestHitTestSource({
      space: this.xrReferenceSpace ?? this.engine.xr.referenceSpaceForType("viewer")
    }).then((hitTestSource) => {
      this.xrHitTestSource = hitTestSource;
    }).catch(console.error);
  }
  onXRSessionEnd() {
    if (!this.xrHitTestSource)
      return;
    this.xrHitTestSource.cancel();
    this.xrHitTestSource = null;
  }
};
__publicField(HitTestLocation, "TypeName", "hit-test-location");
__decorate3([
  property.bool(true)
], HitTestLocation.prototype, "scaleObject", void 0);

// node_modules/@wonderlandengine/components/dist/cursor.js
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var tempVec2 = new Float32Array(3);
var ZERO = [0, 0, 0];
var CursorTargetEmitters = class {
  /** Emitter for events when the target is hovered */
  onHover = new Emitter();
  /** Emitter for events when the target is unhovered */
  onUnhover = new Emitter();
  /** Emitter for events when the target is clicked */
  onClick = new Emitter();
  /** Emitter for events when the cursor moves on the target */
  onMove = new Emitter();
  /** Emitter for events when the user pressed the select button on the target */
  onDown = new Emitter();
  /** Emitter for events when the user unpressed the select button on the target */
  onUp = new Emitter();
};
var Cursor = class extends Component {
  static onRegister(engine2) {
    engine2.registerComponent(HitTestLocation);
  }
  _collisionMask = 0;
  _onDeactivateCallbacks = [];
  _input = null;
  _origin = new Float32Array(3);
  _cursorObjScale = new Float32Array(3);
  _direction = new Float32Array(3);
  _projectionMatrix = new Float32Array(16);
  _viewComponent = null;
  _isDown = false;
  _lastIsDown = false;
  _arTouchDown = false;
  _lastPointerPos = new Float32Array(2);
  _lastCursorPosOnTarget = new Float32Array(3);
  _hitTestLocation = null;
  _hitTestObject = null;
  _onSessionStartCallback = null;
  /**
   * Whether the cursor (and cursorObject) is visible, i.e. pointing at an object
   * that matches the collision group
   */
  visible = true;
  /** Currently hovered object */
  hoveringObject = null;
  /** CursorTarget component of the currently hovered object */
  hoveringObjectTarget = null;
  /** Whether the cursor is hovering reality via hit-test */
  hoveringReality = false;
  /**
   * Global target lets you receive global cursor events on any object.
   */
  globalTarget = new CursorTargetEmitters();
  /**
   * Hit test target lets you receive cursor events for "reality", if
   * `useWebXRHitTest` is set to `true`.
   *
   * @example
   * ```js
   * cursor.hitTestTarget.onClick.add((hit, cursor) => {
   *     // User clicked on reality
   * });
   * ```
   */
  hitTestTarget = new CursorTargetEmitters();
  /** World position of the cursor */
  cursorPos = new Float32Array(3);
  /** Collision group for the ray cast. Only objects in this group will be affected by this cursor. */
  collisionGroup = 1;
  /** (optional) Object that visualizes the cursor's ray. */
  cursorRayObject = null;
  /** Axis along which to scale the `cursorRayObject`. */
  cursorRayScalingAxis = 2;
  /** (optional) Object that visualizes the cursor's hit location. */
  cursorObject = null;
  /** Handedness for VR cursors to accept trigger events only from respective controller. */
  handedness = 0;
  /** Mode for raycasting, whether to use PhysX or simple collision components */
  rayCastMode = 0;
  /** Maximum distance for the cursor's ray cast. */
  maxDistance = 100;
  /** Whether to set the CSS style of the mouse cursor on desktop */
  styleCursor = true;
  /**
   * Use WebXR hit-test if available.
   *
   * Attaches a hit-test-location component to the cursorObject, which will be used
   * by the cursor to send events to the hitTestTarget with HitTestResult.
   */
  useWebXRHitTest = false;
  _onViewportResize = () => {
    if (!this._viewComponent)
      return;
    mat4_exports.invert(this._projectionMatrix, this._viewComponent.projectionMatrix);
  };
  start() {
    this._collisionMask = 1 << this.collisionGroup;
    if (this.handedness == 0) {
      const inputComp = this.object.getComponent("input");
      if (!inputComp) {
        console.warn("cursor component on object", this.object.name, 'was configured with handedness "input component", but object has no input component.');
      } else {
        this.handedness = inputComp.handedness || "none";
        this._input = inputComp;
      }
    } else {
      this.handedness = ["left", "right", "none"][this.handedness - 1];
    }
    this._viewComponent = this.object.getComponent(ViewComponent);
    if (this.useWebXRHitTest) {
      this._hitTestObject = this.engine.scene.addObject(this.object);
      this._hitTestLocation = this._hitTestObject.addComponent(HitTestLocation, {
        scaleObject: false
      }) ?? null;
    }
    this._onSessionStartCallback = this.setupVREvents.bind(this);
  }
  onActivate() {
    this.engine.onXRSessionStart.add(this._onSessionStartCallback);
    this.engine.onResize.add(this._onViewportResize);
    this._setCursorVisibility(true);
    if (this._viewComponent != null) {
      const canvas2 = this.engine.canvas;
      const onClick = this.onClick.bind(this);
      const onPointerMove = this.onPointerMove.bind(this);
      const onPointerDown = this.onPointerDown.bind(this);
      const onPointerUp = this.onPointerUp.bind(this);
      canvas2.addEventListener("click", onClick);
      canvas2.addEventListener("pointermove", onPointerMove);
      canvas2.addEventListener("pointerdown", onPointerDown);
      canvas2.addEventListener("pointerup", onPointerUp);
      this._onDeactivateCallbacks.push(() => {
        canvas2.removeEventListener("click", onClick);
        canvas2.removeEventListener("pointermove", onPointerMove);
        canvas2.removeEventListener("pointerdown", onPointerDown);
        canvas2.removeEventListener("pointerup", onPointerUp);
      });
    }
    this._onViewportResize();
  }
  _setCursorRayTransform(hitPosition) {
    if (!this.cursorRayObject)
      return;
    const dist4 = vec3_exports.dist(this._origin, hitPosition);
    this.cursorRayObject.setPositionLocal([0, 0, -dist4 / 2]);
    if (this.cursorRayScalingAxis != 4) {
      tempVec2.fill(1);
      tempVec2[this.cursorRayScalingAxis] = dist4 / 2;
      this.cursorRayObject.setScalingLocal(tempVec2);
    }
  }
  _setCursorVisibility(visible) {
    if (this.visible == visible)
      return;
    this.visible = visible;
    if (!this.cursorObject)
      return;
    if (visible) {
      this.cursorObject.setScalingWorld(this._cursorObjScale);
    } else {
      this.cursorObject.getScalingWorld(this._cursorObjScale);
      this.cursorObject.scaleLocal([0, 0, 0]);
    }
  }
  update() {
    if (this.engine.xr && this._arTouchDown && this._input && this.engine.xr.session.inputSources[0].handedness === "none" && this.engine.xr.session.inputSources[0].gamepad) {
      const p = this.engine.xr.session.inputSources[0].gamepad.axes;
      this._direction[0] = p[0];
      this._direction[1] = -p[1];
      this._direction[2] = -1;
      this.applyTransformAndProjectDirection();
    } else if (this.engine.xr && this._input && this._input.xrInputSource) {
      this._direction[0] = 0;
      this._direction[1] = 0;
      this._direction[2] = -1;
      this.applyTransformToDirection();
    } else if (this._viewComponent) {
      this.updateDirection();
    }
    this.rayCast(null, this.engine.xr?.frame);
    if (this.cursorObject) {
      if (this.hoveringObject && (this.cursorPos[0] != 0 || this.cursorPos[1] != 0 || this.cursorPos[2] != 0)) {
        this._setCursorVisibility(true);
        this.cursorObject.setPositionWorld(this.cursorPos);
        this._setCursorRayTransform(this.cursorPos);
      } else {
        this._setCursorVisibility(false);
      }
    }
  }
  /* Returns the hovered cursor target, if available */
  notify(event, originalEvent) {
    const target = this.hoveringObject;
    if (target) {
      const cursorTarget = this.hoveringObjectTarget;
      if (cursorTarget)
        cursorTarget[event].notify(target, this, originalEvent ?? void 0);
      this.globalTarget[event].notify(target, this, originalEvent ?? void 0);
    }
  }
  hoverBehaviour(rayHit, hitTestResult, doClick, originalEvent) {
    const hit = !this.hoveringReality && rayHit.hitCount > 0 ? rayHit.objects[0] : null;
    if (hit) {
      if (!this.hoveringObject || !this.hoveringObject.equals(hit)) {
        if (this.hoveringObject) {
          this.notify("onUnhover", originalEvent);
        }
        this.hoveringObject = hit;
        this.hoveringObjectTarget = this.hoveringObject.getComponent(CursorTarget);
        if (this.styleCursor)
          this.engine.canvas.style.cursor = "pointer";
        this.notify("onHover", originalEvent);
      }
    } else if (this.hoveringObject) {
      this.notify("onUnhover", originalEvent);
      this.hoveringObject = null;
      this.hoveringObjectTarget = null;
      if (this.styleCursor)
        this.engine.canvas.style.cursor = "default";
    }
    if (this.hoveringObject) {
      if (this._isDown !== this._lastIsDown) {
        this.notify(this._isDown ? "onDown" : "onUp", originalEvent);
      }
      if (doClick)
        this.notify("onClick", originalEvent);
    } else if (this.hoveringReality) {
      if (this._isDown !== this._lastIsDown) {
        (this._isDown ? this.hitTestTarget.onDown : this.hitTestTarget.onUp).notify(hitTestResult, this, originalEvent ?? void 0);
      }
      if (doClick)
        this.hitTestTarget.onClick.notify(hitTestResult, this, originalEvent ?? void 0);
    }
    if (hit) {
      if (this.hoveringObject) {
        this.hoveringObject.transformPointInverseWorld(tempVec2, this.cursorPos);
      } else {
        tempVec2.set(this.cursorPos);
      }
      if (!vec3_exports.equals(this._lastCursorPosOnTarget, tempVec2)) {
        this.notify("onMove", originalEvent);
        this._lastCursorPosOnTarget.set(tempVec2);
      }
    } else if (this.hoveringReality) {
      if (!vec3_exports.equals(this._lastCursorPosOnTarget, this.cursorPos)) {
        this.hitTestTarget.onMove.notify(hitTestResult, this, originalEvent ?? void 0);
        this._lastCursorPosOnTarget.set(this.cursorPos);
      }
    } else {
      this._lastCursorPosOnTarget.set(this.cursorPos);
    }
    this._lastIsDown = this._isDown;
  }
  /**
   * Setup event listeners on session object
   * @param s WebXR session
   *
   * Sets up 'select' and 'end' events.
   */
  setupVREvents(s) {
    if (!s)
      console.error("setupVREvents called without a valid session");
    if (!this.active)
      return;
    const onSelect = this.onSelect.bind(this);
    s.addEventListener("select", onSelect);
    const onSelectStart = this.onSelectStart.bind(this);
    s.addEventListener("selectstart", onSelectStart);
    const onSelectEnd = this.onSelectEnd.bind(this);
    s.addEventListener("selectend", onSelectEnd);
    this._onDeactivateCallbacks.push(() => {
      if (!this.engine.xr)
        return;
      s.removeEventListener("select", onSelect);
      s.removeEventListener("selectstart", onSelectStart);
      s.removeEventListener("selectend", onSelectEnd);
    });
    this._onViewportResize();
  }
  onDeactivate() {
    this.engine.onXRSessionStart.remove(this._onSessionStartCallback);
    this.engine.onResize.remove(this._onViewportResize);
    this._setCursorVisibility(false);
    if (this.hoveringObject)
      this.notify("onUnhover", null);
    if (this.cursorRayObject)
      this.cursorRayObject.setScalingLocal(ZERO);
    for (const f of this._onDeactivateCallbacks)
      f();
    this._onDeactivateCallbacks.length = 0;
  }
  onDestroy() {
    this._hitTestObject?.destroy();
  }
  /** 'select' event listener */
  onSelect(e) {
    if (e.inputSource.handedness != this.handedness)
      return;
    this.rayCast(e, e.frame, true);
  }
  /** 'selectstart' event listener */
  onSelectStart(e) {
    this._arTouchDown = true;
    if (e.inputSource.handedness == this.handedness) {
      this._isDown = true;
      this.rayCast(e, e.frame);
    }
  }
  /** 'selectend' event listener */
  onSelectEnd(e) {
    this._arTouchDown = false;
    if (e.inputSource.handedness == this.handedness) {
      this._isDown = false;
      this.rayCast(e, e.frame);
    }
  }
  /** 'pointermove' event listener */
  onPointerMove(e) {
    if (!e.isPrimary)
      return;
    this.updateMousePos(e);
    this.rayCast(e, null);
  }
  /** 'click' event listener */
  onClick(e) {
    this.updateMousePos(e);
    this.rayCast(e, null, true);
  }
  /** 'pointerdown' event listener */
  onPointerDown(e) {
    if (!e.isPrimary || e.button !== 0)
      return;
    this.updateMousePos(e);
    this._isDown = true;
    this.rayCast(e);
  }
  /** 'pointerup' event listener */
  onPointerUp(e) {
    if (!e.isPrimary || e.button !== 0)
      return;
    this.updateMousePos(e);
    this._isDown = false;
    this.rayCast(e);
  }
  /**
   * Update mouse position in non-VR mode and raycast for new position
   * @returns @ref WL.RayHit for new position.
   */
  updateMousePos(e) {
    this._lastPointerPos[0] = e.clientX;
    this._lastPointerPos[1] = e.clientY;
    this.updateDirection();
  }
  updateDirection() {
    const bounds = this.engine.canvas.getBoundingClientRect();
    const left = this._lastPointerPos[0] / bounds.width;
    const top = this._lastPointerPos[1] / bounds.height;
    this._direction[0] = left * 2 - 1;
    this._direction[1] = -top * 2 + 1;
    this._direction[2] = -1;
    this.applyTransformAndProjectDirection();
  }
  applyTransformAndProjectDirection() {
    vec3_exports.transformMat4(this._direction, this._direction, this._projectionMatrix);
    vec3_exports.normalize(this._direction, this._direction);
    this.applyTransformToDirection();
  }
  applyTransformToDirection() {
    this.object.transformVectorWorld(this._direction, this._direction);
    this.object.getPositionWorld(this._origin);
  }
  rayCast(originalEvent, frame = null, doClick = false) {
    const rayHit = this.rayCastMode == 0 ? this.engine.scene.rayCast(this._origin, this._direction, this._collisionMask) : this.engine.physics.rayCast(this._origin, this._direction, this._collisionMask, this.maxDistance);
    let hitResultDistance = Infinity;
    let hitTestResult = null;
    if (this._hitTestLocation?.visible) {
      this._hitTestObject.getPositionWorld(this.cursorPos);
      hitResultDistance = vec3_exports.distance(this.object.getPositionWorld(tempVec2), this.cursorPos);
      hitTestResult = this._hitTestLocation?.getHitTestResults(frame)[0];
    }
    let hoveringReality = false;
    if (rayHit.hitCount > 0) {
      const d = rayHit.distances[0];
      if (hitResultDistance >= d) {
        this.cursorPos.set(rayHit.locations[0]);
      } else {
        hoveringReality = true;
      }
    } else if (hitResultDistance < Infinity) {
    } else {
      this.cursorPos.fill(0);
    }
    if (hoveringReality && !this.hoveringReality) {
      this.hitTestTarget.onHover.notify(hitTestResult, this);
    } else if (!hoveringReality && this.hoveringReality) {
      this.hitTestTarget.onUnhover.notify(hitTestResult, this);
    }
    this.hoveringReality = hoveringReality;
    this.hoverBehaviour(rayHit, hitTestResult, doClick, originalEvent);
    return rayHit;
  }
};
__publicField(Cursor, "TypeName", "cursor");
/* Dependencies is deprecated, but we keep it here for compatibility
 * with 1.0.0-rc2 until 1.0.0 is released */
__publicField(Cursor, "Dependencies", [HitTestLocation]);
__decorate4([
  property.int(1)
], Cursor.prototype, "collisionGroup", void 0);
__decorate4([
  property.object()
], Cursor.prototype, "cursorRayObject", void 0);
__decorate4([
  property.enum(["x", "y", "z", "none"], "z")
], Cursor.prototype, "cursorRayScalingAxis", void 0);
__decorate4([
  property.object()
], Cursor.prototype, "cursorObject", void 0);
__decorate4([
  property.enum(["input component", "left", "right", "none"], "input component")
], Cursor.prototype, "handedness", void 0);
__decorate4([
  property.enum(["collision", "physx"], "collision")
], Cursor.prototype, "rayCastMode", void 0);
__decorate4([
  property.float(100)
], Cursor.prototype, "maxDistance", void 0);
__decorate4([
  property.bool(true)
], Cursor.prototype, "styleCursor", void 0);
__decorate4([
  property.bool(false)
], Cursor.prototype, "useWebXRHitTest", void 0);

// node_modules/@wonderlandengine/components/dist/debug-object.js
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DebugObject = class extends Component {
  /** A second object to print the name of */
  obj = null;
  start() {
    let origin = new Float32Array(3);
    quat2_exports.getTranslation(origin, this.object.transformWorld);
    console.log("Debug object:", this.object.name);
    console.log("Other object:", this.obj?.name);
    console.log("	translation", origin);
    console.log("	transformWorld", this.object.transformWorld);
    console.log("	transformLocal", this.object.transformLocal);
  }
};
__publicField(DebugObject, "TypeName", "debug-object");
__decorate5([
  property.object()
], DebugObject.prototype, "obj", void 0);

// node_modules/@wonderlandengine/components/dist/device-orientation-look.js
function quatFromEulerYXZ(out, x, y, z) {
  const c1 = Math.cos(x / 2);
  const c2 = Math.cos(y / 2);
  const c3 = Math.cos(z / 2);
  const s1 = Math.sin(x / 2);
  const s2 = Math.sin(y / 2);
  const s3 = Math.sin(z / 2);
  out[0] = s1 * c2 * c3 + c1 * s2 * s3;
  out[1] = c1 * s2 * c3 - s1 * c2 * s3;
  out[2] = c1 * c2 * s3 - s1 * s2 * c3;
  out[3] = c1 * c2 * c3 + s1 * s2 * s3;
}
var DeviceOrientationLook = class extends Component {
  start() {
    this.rotationX = 0;
    this.rotationY = 0;
    this.lastClientX = -1;
    this.lastClientY = -1;
  }
  init() {
    this.deviceOrientation = [0, 0, 0, 1];
    this.screenOrientation = window.innerHeight > window.innerWidth ? 0 : 90;
    this._origin = [0, 0, 0];
    window.addEventListener("deviceorientation", function(e) {
      let alpha = e.alpha || 0;
      let beta = e.beta || 0;
      let gamma = e.gamma || 0;
      const toRad = Math.PI / 180;
      quatFromEulerYXZ(this.deviceOrientation, beta * toRad, alpha * toRad, -gamma * toRad);
    }.bind(this));
    window.addEventListener("orientationchange", function(e) {
      this.screenOrientation = window.orientation || 0;
    }.bind(this), false);
  }
  update() {
    if (this.engine.xr)
      return;
    this.object.getTranslationLocal(this._origin);
    this.object.resetTransform();
    if (this.screenOrientation != 0) {
      this.object.rotateAxisAngleDeg([0, 0, -1], this.screenOrientation);
    }
    this.object.rotate([-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)]);
    this.object.rotate(this.deviceOrientation);
    this.object.translate(this._origin);
  }
};
__publicField(DeviceOrientationLook, "TypeName", "device-orientation-look");
__publicField(DeviceOrientationLook, "Properties", {});

// node_modules/@wonderlandengine/components/dist/finger-cursor.js
var FingerCursor = class extends Component {
  init() {
    this.lastTarget = null;
  }
  start() {
    this.tip = this.object.getComponent("collision");
  }
  update() {
    const overlaps = this.tip.queryOverlaps();
    let overlapFound = null;
    for (let i = 0; i < overlaps.length; ++i) {
      const o = overlaps[i].object;
      const target = o.getComponent("cursor-target");
      if (target) {
        if (!target.equals(this.lastTarget)) {
          target.onHover(o, this);
          target.onClick(o, this);
        }
        overlapFound = target;
        break;
      }
    }
    if (!overlapFound) {
      if (this.lastTarget)
        this.lastTarget.onUnhover(this.lastTarget.object, this);
      this.lastTarget = null;
      return;
    } else {
      this.lastTarget = overlapFound;
    }
  }
};
__publicField(FingerCursor, "TypeName", "finger-cursor");
__publicField(FingerCursor, "Properties", {});

// node_modules/@wonderlandengine/components/dist/fixed-foveation.js
var FixedFoveation = class extends Component {
  start() {
    this.onSessionStartCallback = this.setFixedFoveation.bind(this);
  }
  onActivate() {
    this.engine.onXRSessionStart.add(this.onSessionStartCallback);
  }
  onDeactivate() {
    this.engine.onXRSessionStart.remove(this.onSessionStartCallback);
  }
  setFixedFoveation() {
    this.engine.xr.baseLayer.fixedFoveation = this.fixedFoveation;
  }
};
__publicField(FixedFoveation, "TypeName", "fixed-foveation");
__publicField(FixedFoveation, "Properties", {
  /** Amount to apply from 0 (none) to 1 (full) */
  fixedFoveation: { type: Type.Float, default: 0.5 }
});

// node_modules/@wonderlandengine/components/dist/hand-tracking.js
var __decorate6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ORDERED_JOINTS = [
  "wrist",
  "thumb-metacarpal",
  "thumb-phalanx-proximal",
  "thumb-phalanx-distal",
  "thumb-tip",
  "index-finger-metacarpal",
  "index-finger-phalanx-proximal",
  "index-finger-phalanx-intermediate",
  "index-finger-phalanx-distal",
  "index-finger-tip",
  "middle-finger-metacarpal",
  "middle-finger-phalanx-proximal",
  "middle-finger-phalanx-intermediate",
  "middle-finger-phalanx-distal",
  "middle-finger-tip",
  "ring-finger-metacarpal",
  "ring-finger-phalanx-proximal",
  "ring-finger-phalanx-intermediate",
  "ring-finger-phalanx-distal",
  "ring-finger-tip",
  "pinky-finger-metacarpal",
  "pinky-finger-phalanx-proximal",
  "pinky-finger-phalanx-intermediate",
  "pinky-finger-phalanx-distal",
  "pinky-finger-tip"
];
var invTranslation = vec3_exports.create();
var invRotation = quat_exports.create();
var tempVec0 = vec3_exports.create();
var tempVec1 = vec3_exports.create();
var HandTracking = class extends Component {
  /** Handedness determining whether to receive tracking input from right or left hand */
  handedness = 0;
  /** (optional) Mesh to use to visualize joints */
  jointMesh = null;
  /** Material to use for display. Applied to either the spawned skinned mesh or the joint spheres. */
  jointMaterial = null;
  /** (optional) Skin to apply tracked joint poses to. If not present,
   * joint spheres will be used for display instead. */
  handSkin = null;
  /** Deactivate children if no pose was tracked */
  deactivateChildrenWithoutPose = true;
  /** Controller objects to activate including children if no pose is available */
  controllerToDeactivate = null;
  init() {
    this.handedness = ["left", "right"][this.handedness];
  }
  joints = {};
  session = null;
  /* Whether last update had a hand pose */
  hasPose = false;
  _childrenActive = true;
  start() {
    if (!("XRHand" in window)) {
      console.warn("WebXR Hand Tracking not supported by this browser.");
      this.active = false;
      return;
    }
    if (this.handSkin) {
      const skin = this.handSkin;
      const jointIds = skin.jointIds;
      this.joints[ORDERED_JOINTS[0]] = this.engine.wrapObject(jointIds[0]);
      for (let j = 0; j < jointIds.length; ++j) {
        const joint = this.engine.wrapObject(jointIds[j]);
        this.joints[joint.name] = joint;
      }
      return;
    }
    const jointObjects = this.engine.scene.addObjects(ORDERED_JOINTS.length, this.object, ORDERED_JOINTS.length);
    for (let j = 0; j < ORDERED_JOINTS.length; ++j) {
      const joint = jointObjects[j];
      joint.addComponent(MeshComponent, {
        mesh: this.jointMesh,
        material: this.jointMaterial
      });
      this.joints[ORDERED_JOINTS[j]] = joint;
      joint.name = ORDERED_JOINTS[j];
    }
  }
  update(dt) {
    if (!this.engine.xr)
      return;
    this.hasPose = false;
    if (this.engine.xr.session.inputSources) {
      for (let i = 0; i < this.engine.xr.session.inputSources.length; ++i) {
        const inputSource = this.engine.xr.session.inputSources[i];
        if (!inputSource?.hand || inputSource?.handedness != this.handedness)
          continue;
        const wristSpace = inputSource.hand.get("wrist");
        if (wristSpace) {
          const p = this.engine.xr.frame.getJointPose(wristSpace, this.engine.xr.currentReferenceSpace);
          if (p) {
            setXRRigidTransformLocal(this.object, p.transform);
          }
        }
        this.object.getRotationLocal(invRotation);
        quat_exports.conjugate(invRotation, invRotation);
        this.object.getPositionLocal(invTranslation);
        this.joints["wrist"].resetTransform();
        for (let j = 0; j < ORDERED_JOINTS.length; ++j) {
          const jointName = ORDERED_JOINTS[j];
          const joint = this.joints[jointName];
          if (!joint)
            continue;
          let jointPose = null;
          const jointSpace = inputSource.hand.get(jointName);
          if (jointSpace) {
            jointPose = this.engine.xr.frame.getJointPose(jointSpace, this.engine.xr.currentReferenceSpace);
          }
          if (jointPose) {
            this.hasPose = true;
            joint.resetPositionRotation();
            joint.translateLocal([
              jointPose.transform.position.x - invTranslation[0],
              jointPose.transform.position.y - invTranslation[1],
              jointPose.transform.position.z - invTranslation[2]
            ]);
            joint.rotateLocal(invRotation);
            joint.rotateObject([
              jointPose.transform.orientation.x,
              jointPose.transform.orientation.y,
              jointPose.transform.orientation.z,
              jointPose.transform.orientation.w
            ]);
            if (!this.handSkin) {
              const r = jointPose.radius || 7e-3;
              joint.setScalingLocal([r, r, r]);
            }
          }
        }
      }
    }
    if (!this.hasPose && this._childrenActive) {
      this._childrenActive = false;
      if (this.deactivateChildrenWithoutPose) {
        this.setChildrenActive(false);
      }
      if (this.controllerToDeactivate) {
        this.controllerToDeactivate.active = true;
        this.setChildrenActive(true, this.controllerToDeactivate);
      }
    } else if (this.hasPose && !this._childrenActive) {
      this._childrenActive = true;
      if (this.deactivateChildrenWithoutPose) {
        this.setChildrenActive(true);
      }
      if (this.controllerToDeactivate) {
        this.controllerToDeactivate.active = false;
        this.setChildrenActive(false, this.controllerToDeactivate);
      }
    }
  }
  setChildrenActive(active, object) {
    object = object || this.object;
    const children = object.children;
    for (const o of children) {
      o.active = active;
      this.setChildrenActive(active, o);
    }
  }
  isGrabbing() {
    this.joints["index-finger-tip"].getPositionLocal(tempVec0);
    this.joints["thumb-tip"].getPositionLocal(tempVec1);
    return vec3_exports.sqrDist(tempVec0, tempVec1) < 1e-3;
  }
};
__publicField(HandTracking, "TypeName", "hand-tracking");
__decorate6([
  property.enum(["left", "right"])
], HandTracking.prototype, "handedness", void 0);
__decorate6([
  property.mesh()
], HandTracking.prototype, "jointMesh", void 0);
__decorate6([
  property.material()
], HandTracking.prototype, "jointMaterial", void 0);
__decorate6([
  property.skin()
], HandTracking.prototype, "handSkin", void 0);
__decorate6([
  property.bool(true)
], HandTracking.prototype, "deactivateChildrenWithoutPose", void 0);
__decorate6([
  property.object()
], HandTracking.prototype, "controllerToDeactivate", void 0);

// node_modules/@wonderlandengine/components/dist/howler-audio-listener.js
var import_howler = __toESM(require_howler(), 1);
var HowlerAudioListener = class extends Component {
  init() {
    this.origin = new Float32Array(3);
    this.fwd = new Float32Array(3);
    this.up = new Float32Array(3);
  }
  update() {
    if (!this.spatial)
      return;
    this.object.getTranslationWorld(this.origin);
    this.object.getForward(this.fwd);
    this.object.getUp(this.up);
    Howler.pos(this.origin[0], this.origin[1], this.origin[2]);
    Howler.orientation(this.fwd[0], this.fwd[1], this.fwd[2], this.up[0], this.up[1], this.up[2]);
  }
};
__publicField(HowlerAudioListener, "TypeName", "howler-audio-listener");
__publicField(HowlerAudioListener, "Properties", {
  /** Whether audio should be spatialized/positional. */
  spatial: { type: Type.Bool, default: true }
});

// node_modules/@wonderlandengine/components/dist/howler-audio-source.js
var import_howler2 = __toESM(require_howler(), 1);
var HowlerAudioSource = class extends Component {
  start() {
    this.audio = new Howl({
      src: [this.src],
      loop: this.loop,
      volume: this.volume,
      autoplay: this.autoplay
    });
    this.lastPlayedAudioId = null;
    this.origin = new Float32Array(3);
    this.lastOrigin = new Float32Array(3);
    if (this.spatial && this.autoplay) {
      this.updatePosition();
      this.play();
    }
  }
  update() {
    if (!this.spatial || !this.lastPlayedAudioId)
      return;
    this.object.getTranslationWorld(this.origin);
    if (Math.abs(this.lastOrigin[0] - this.origin[0]) > 5e-3 || Math.abs(this.lastOrigin[1] - this.origin[1]) > 5e-3 || Math.abs(this.lastOrigin[2] - this.origin[2]) > 5e-3) {
      this.updatePosition();
    }
  }
  updatePosition() {
    this.audio.pos(this.origin[0], this.origin[1], this.origin[2], this.lastPlayedAudioId);
    this.lastOrigin.set(this.origin);
  }
  play() {
    if (this.lastPlayedAudioId)
      this.audio.stop(this.lastPlayedAudioId);
    this.lastPlayedAudioId = this.audio.play();
    if (this.spatial)
      this.updatePosition();
  }
  stop() {
    if (!this.lastPlayedAudioId)
      return;
    this.audio.stop(this.lastPlayedAudioId);
    this.lastPlayedAudioId = null;
  }
  onDeactivate() {
    this.stop();
  }
};
__publicField(HowlerAudioSource, "TypeName", "howler-audio-source");
__publicField(HowlerAudioSource, "Properties", {
  /** Volume */
  volume: { type: Type.Float, default: 1 },
  /** Whether audio should be spatialized/positional */
  spatial: { type: Type.Bool, default: true },
  /** Whether to loop the sound */
  loop: { type: Type.Bool, default: false },
  /** Whether to start playing automatically */
  autoplay: { type: Type.Bool, default: false },
  /** URL to a sound file to play */
  src: { type: Type.String, default: "" }
});

// node_modules/@wonderlandengine/components/dist/utils/utils.js
function setFirstMaterialTexture(mat, texture, customTextureProperty) {
  if (customTextureProperty !== "auto") {
    mat[customTextureProperty] = texture;
    return true;
  }
  const shader = mat.shader;
  if (shader === "Flat Opaque Textured") {
    mat.flatTexture = texture;
    return true;
  } else if (shader === "Phong Opaque Textured" || shader === "Foliage" || shader === "Phong Normalmapped" || shader === "Phong Lightmapped") {
    mat.diffuseTexture = texture;
    return true;
  } else if (shader === "Particle") {
    mat.mainTexture = texture;
    return true;
  } else if (shader === "DistanceFieldVector") {
    mat.vectorTexture = texture;
    return true;
  } else if (shader === "Background" || shader === "Sky") {
    mat.texture = texture;
    return true;
  } else if (shader === "Physical Opaque Textured") {
    mat.albedoTexture = texture;
    return true;
  }
  return false;
}

// node_modules/@wonderlandengine/components/dist/image-texture.js
var ImageTexture = class extends Component {
  start() {
    if (!this.material) {
      throw Error("image-texture: material property not set");
    }
    this.engine.textures.load(this.url, "anonymous").then((texture) => {
      const mat = this.material;
      if (!setFirstMaterialTexture(mat, texture, this.textureProperty)) {
        console.error("Shader", mat.shader, "not supported by image-texture");
      }
    }).catch(console.err);
  }
};
__publicField(ImageTexture, "TypeName", "image-texture");
__publicField(ImageTexture, "Properties", {
  /** URL to download the image from */
  url: Property.string(),
  /** Material to apply the video texture to */
  material: Property.material(),
  /** Name of the texture property to set */
  textureProperty: Property.string("auto")
});

// node_modules/@wonderlandengine/components/dist/mouse-look.js
var __decorate7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var preventDefault = (e) => {
  e.preventDefault();
};
var MouseLookComponent = class extends Component {
  /** Mouse look sensitivity */
  sensitity = 0.25;
  /** Require a mouse button to be pressed to control view.
   * Otherwise view will allways follow mouse movement */
  requireMouseDown = true;
  /** If "moveOnClick" is enabled, mouse button which should
   * be held down to control view */
  mouseButtonIndex = 0;
  /** Enables pointer lock on "mousedown" event on canvas */
  pointerLockOnClick = false;
  currentRotationY = 0;
  currentRotationX = 0;
  origin = new Float32Array(3);
  parentOrigin = new Float32Array(3);
  rotationX = 0;
  rotationY = 0;
  mouseDown = false;
  onActivate() {
    document.addEventListener("mousemove", this.onMouseMove);
    const canvas2 = this.engine.canvas;
    if (this.pointerLockOnClick) {
      canvas2.addEventListener("mousedown", this.requestPointerLock);
    }
    if (this.requireMouseDown) {
      if (this.mouseButtonIndex === 2) {
        canvas2.addEventListener("contextmenu", preventDefault, false);
      }
      canvas2.addEventListener("mousedown", this.onMouseDown);
      canvas2.addEventListener("mouseup", this.onMouseUp);
    }
  }
  onDeactivate() {
    document.removeEventListener("mousemove", this.onMouseMove);
    const canvas2 = this.engine.canvas;
    if (this.pointerLockOnClick) {
      canvas2.removeEventListener("mousedown", this.requestPointerLock);
    }
    if (this.requireMouseDown) {
      if (this.mouseButtonIndex === 2) {
        canvas2.removeEventListener("contextmenu", preventDefault, false);
      }
      canvas2.removeEventListener("mousedown", this.onMouseDown);
      canvas2.removeEventListener("mouseup", this.onMouseUp);
    }
  }
  requestPointerLock = () => {
    const canvas2 = this.engine.canvas;
    canvas2.requestPointerLock = canvas2.requestPointerLock || canvas2.mozRequestPointerLock || canvas2.webkitRequestPointerLock;
    canvas2.requestPointerLock();
  };
  onMouseDown = (e) => {
    if (e.button === this.mouseButtonIndex) {
      this.mouseDown = true;
      document.body.style.cursor = "grabbing";
      if (e.button === 1) {
        e.preventDefault();
        return false;
      }
    }
  };
  onMouseUp = (e) => {
    if (e.button === this.mouseButtonIndex) {
      this.mouseDown = false;
      document.body.style.cursor = "initial";
    }
  };
  onMouseMove = (e) => {
    if (this.active && (this.mouseDown || !this.requireMouseDown)) {
      this.rotationY = -this.sensitity * e.movementX / 100;
      this.rotationX = -this.sensitity * e.movementY / 100;
      this.currentRotationX += this.rotationX;
      this.currentRotationY += this.rotationY;
      this.currentRotationX = Math.min(1.507, this.currentRotationX);
      this.currentRotationX = Math.max(-1.507, this.currentRotationX);
      this.object.getPositionWorld(this.origin);
      const parent = this.object.parent;
      if (parent) {
        parent.getPositionWorld(this.parentOrigin);
        vec3_exports.sub(this.origin, this.origin, this.parentOrigin);
      }
      this.object.resetPositionRotation();
      this.object.rotateAxisAngleRadLocal([1, 0, 0], this.currentRotationX);
      this.object.rotateAxisAngleRadLocal([0, 1, 0], this.currentRotationY);
      this.object.translateLocal(this.origin);
    }
  };
};
__publicField(MouseLookComponent, "TypeName", "mouse-look");
__decorate7([
  property.float(0.25)
], MouseLookComponent.prototype, "sensitity", void 0);
__decorate7([
  property.bool(true)
], MouseLookComponent.prototype, "requireMouseDown", void 0);
__decorate7([
  property.int()
], MouseLookComponent.prototype, "mouseButtonIndex", void 0);
__decorate7([
  property.bool(false)
], MouseLookComponent.prototype, "pointerLockOnClick", void 0);

// node_modules/@wonderlandengine/components/dist/player-height.js
var __decorate8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PlayerHeight = class extends Component {
  height = 1.75;
  onSessionStartCallback;
  onSessionEndCallback;
  start() {
    this.object.resetPositionRotation();
    this.object.translateLocal([0, this.height, 0]);
    this.onSessionStartCallback = this.onXRSessionStart.bind(this);
    this.onSessionEndCallback = this.onXRSessionEnd.bind(this);
  }
  onActivate() {
    this.engine.onXRSessionStart.add(this.onSessionStartCallback);
    this.engine.onXRSessionEnd.add(this.onSessionEndCallback);
  }
  onDeactivate() {
    this.engine.onXRSessionStart.remove(this.onSessionStartCallback);
    this.engine.onXRSessionEnd.remove(this.onSessionEndCallback);
  }
  onXRSessionStart() {
    const type = this.engine.xr?.currentReferenceSpaceType;
    if (type !== "local" && type !== "viewer") {
      this.object.resetPositionRotation();
    }
  }
  onXRSessionEnd() {
    const type = this.engine.xr?.currentReferenceSpaceType;
    if (type !== "local" && type !== "viewer") {
      this.object.resetPositionRotation();
      this.object.translateLocal([0, this.height, 0]);
    }
  }
};
__publicField(PlayerHeight, "TypeName", "player-height");
__decorate8([
  property.float(1.75)
], PlayerHeight.prototype, "height", void 0);

// node_modules/@wonderlandengine/components/dist/target-framerate.js
var TargetFramerate = class extends Component {
  start() {
    this.onSessionStartCallback = this.setTargetFramerate.bind(this);
  }
  onActivate() {
    this.engine.onXRSessionStart.add(this.onSessionStartCallback);
  }
  onDeactivate() {
    this.engine.onXRSessionStart.remove(this.onSessionStartCallback);
  }
  setTargetFramerate(s) {
    if (s.supportedFrameRates && s.updateTargetFrameRate) {
      const a = this.engine.xr.session.supportedFrameRates;
      a.sort((a2, b) => Math.abs(a2 - this.framerate) - Math.abs(b - this.framerate));
      this.engine.xr.session.updateTargetFrameRate(a[0]);
    }
  }
};
__publicField(TargetFramerate, "TypeName", "target-framerate");
__publicField(TargetFramerate, "Properties", {
  framerate: { type: Type.Float, default: 90 }
});

// node_modules/@wonderlandengine/components/dist/teleport.js
var TeleportComponent = class extends Component {
  init() {
    this._prevThumbstickAxis = new Float32Array(2);
    this._tempVec = new Float32Array(3);
    this._tempVec0 = new Float32Array(3);
    this._currentIndicatorRotation = 0;
    this.input = this.object.getComponent("input");
    if (!this.input) {
      console.error(this.object.name, "generic-teleport-component.js: input component is required on the object");
      return;
    }
    if (!this.teleportIndicatorMeshObject) {
      console.error(this.object.name, "generic-teleport-component.js: Teleport indicator mesh is missing");
      return;
    }
    if (!this.camRoot) {
      console.error(this.object.name, "generic-teleport-component.js: camRoot not set");
      return;
    }
    this.isIndicating = false;
    this.indicatorHidden = true;
    this.hitSpot = new Float32Array(3);
    this._hasHit = false;
    this._extraRotation = 0;
    this._currentStickAxes = new Float32Array(2);
  }
  start() {
    if (this.cam) {
      this.isMouseIndicating = false;
      canvas.addEventListener("mousedown", this.onMouseDown.bind(this));
      canvas.addEventListener("mouseup", this.onMouseUp.bind(this));
    }
    if (this.handedness == 0) {
      const inputComp = this.object.getComponent("input");
      if (!inputComp) {
        console.warn("teleport component on object", this.object.name, 'was configured with handedness "input component", but object has no input component.');
      } else {
        this.handedness = inputComp.handedness;
        this.input = inputComp;
      }
    } else {
      this.handedness = ["left", "right"][this.handedness - 1];
    }
    this.onSessionStartCallback = this.setupVREvents.bind(this);
    this.teleportIndicatorMeshObject.active = false;
  }
  onActivate() {
    this.engine.onXRSessionStart.add(this.onSessionStartCallback);
  }
  onDeactivate() {
    this.engine.onXRSessionStart.remove(this.onSessionStartCallback);
  }
  /* Get current camera Y rotation */
  _getCamRotation() {
    this.eyeLeft.getForward(this._tempVec);
    this._tempVec[1] = 0;
    vec3_exports.normalize(this._tempVec, this._tempVec);
    return Math.atan2(this._tempVec[0], this._tempVec[2]);
  }
  update() {
    let inputLength = 0;
    if (this.gamepad && this.gamepad.axes) {
      this._currentStickAxes[0] = this.gamepad.axes[2];
      this._currentStickAxes[1] = this.gamepad.axes[3];
      inputLength = Math.abs(this._currentStickAxes[0]) + Math.abs(this._currentStickAxes[1]);
    }
    if (!this.isIndicating && this._prevThumbstickAxis[1] >= this.thumbstickActivationThreshhold && this._currentStickAxes[1] < this.thumbstickActivationThreshhold) {
      this.isIndicating = true;
    } else if (this.isIndicating && inputLength < this.thumbstickDeactivationThreshhold) {
      this.isIndicating = false;
      this.teleportIndicatorMeshObject.active = false;
      if (this._hasHit) {
        this._teleportPlayer(this.hitSpot, this._extraRotation);
      }
    }
    if (this.isIndicating && this.teleportIndicatorMeshObject && this.input) {
      const origin = this._tempVec0;
      this.object.getPositionWorld(origin);
      const direction2 = this.object.getForwardWorld(this._tempVec);
      let rayHit = this.rayHit = this.rayCastMode == 0 ? this.engine.scene.rayCast(origin, direction2, 1 << this.floorGroup) : this.engine.physics.rayCast(origin, direction2, 1 << this.floorGroup, this.maxDistance);
      if (rayHit.hitCount > 0) {
        this.indicatorHidden = false;
        this._extraRotation = Math.PI + Math.atan2(this._currentStickAxes[0], this._currentStickAxes[1]);
        this._currentIndicatorRotation = this._getCamRotation() + (this._extraRotation - Math.PI);
        this.teleportIndicatorMeshObject.resetPositionRotation();
        this.teleportIndicatorMeshObject.rotateAxisAngleRad([0, 1, 0], this._currentIndicatorRotation);
        this.teleportIndicatorMeshObject.translate(rayHit.locations[0]);
        this.teleportIndicatorMeshObject.translate([
          0,
          this.indicatorYOffset,
          0
        ]);
        this.teleportIndicatorMeshObject.active = true;
        this.hitSpot.set(rayHit.locations[0]);
        this._hasHit = true;
      } else {
        if (!this.indicatorHidden) {
          this.teleportIndicatorMeshObject.active = false;
          this.indicatorHidden = true;
        }
        this._hasHit = false;
      }
    } else if (this.teleportIndicatorMeshObject && this.isMouseIndicating) {
      this.onMousePressed();
    }
    this._prevThumbstickAxis.set(this._currentStickAxes);
  }
  setupVREvents(s) {
    this.session = s;
    s.addEventListener("end", function() {
      this.gamepad = null;
      this.session = null;
    }.bind(this));
    if (s.inputSources && s.inputSources.length) {
      for (let i = 0; i < s.inputSources.length; i++) {
        let inputSource = s.inputSources[i];
        if (inputSource.handedness == this.handedness) {
          this.gamepad = inputSource.gamepad;
        }
      }
    }
    s.addEventListener("inputsourceschange", function(e) {
      if (e.added && e.added.length) {
        for (let i = 0; i < e.added.length; i++) {
          let inputSource = e.added[i];
          if (inputSource.handedness == this.handedness) {
            this.gamepad = inputSource.gamepad;
          }
        }
      }
    }.bind(this));
  }
  onMouseDown() {
    this.isMouseIndicating = true;
  }
  onMouseUp() {
    this.isMouseIndicating = false;
    this.teleportIndicatorMeshObject.active = false;
    if (this._hasHit) {
      this._teleportPlayer(this.hitSpot, 0);
    }
  }
  onMousePressed() {
    let origin = [0, 0, 0];
    this.cam.getPositionWorld(origin);
    const direction2 = this.cam.getForward(this._tempVec);
    let rayHit = this.rayHit = this.rayCastMode == 0 ? this.engine.scene.rayCast(origin, direction2, 1 << this.floorGroup) : this.engine.physics.rayCast(origin, direction2, 1 << this.floorGroup, this.maxDistance);
    if (rayHit.hitCount > 0) {
      this.indicatorHidden = false;
      direction2[1] = 0;
      vec3_exports.normalize(direction2, direction2);
      this._currentIndicatorRotation = -Math.sign(direction2[2]) * Math.acos(direction2[0]) - Math.PI * 0.5;
      this.teleportIndicatorMeshObject.resetPositionRotation();
      this.teleportIndicatorMeshObject.rotateAxisAngleRad([0, 1, 0], this._currentIndicatorRotation);
      this.teleportIndicatorMeshObject.translate(rayHit.locations[0]);
      this.teleportIndicatorMeshObject.active = true;
      this.hitSpot = rayHit.locations[0];
      this._hasHit = true;
    } else {
      if (!this.indicatorHidden) {
        this.teleportIndicatorMeshObject.active = false;
        this.indicatorHidden = true;
      }
      this._hasHit = false;
    }
  }
  _teleportPlayer(newPosition, rotationToAdd) {
    this.camRoot.rotateAxisAngleRad([0, 1, 0], rotationToAdd);
    const p = this._tempVec;
    const p1 = this._tempVec0;
    if (this.session) {
      this.eyeLeft.getPositionWorld(p);
      this.eyeRight.getPositionWorld(p1);
      vec3_exports.add(p, p, p1);
      vec3_exports.scale(p, p, 0.5);
    } else {
      this.cam.getPositionWorld(p);
    }
    this.camRoot.getPositionWorld(p1);
    vec3_exports.sub(p, p1, p);
    p[0] += newPosition[0];
    p[1] = newPosition[1];
    p[2] += newPosition[2];
    this.camRoot.setPositionWorld(p);
  }
};
__publicField(TeleportComponent, "TypeName", "teleport");
__publicField(TeleportComponent, "Properties", {
  /** Object that will be placed as indiciation forwhere the player will teleport to. */
  teleportIndicatorMeshObject: { type: Type.Object },
  /** Root of the player, the object that will be positioned on teleportation. */
  camRoot: { type: Type.Object },
  /** Non-vr camera for use outside of VR */
  cam: { type: Type.Object },
  /** Left eye for use in VR*/
  eyeLeft: { type: Type.Object },
  /** Right eye for use in VR*/
  eyeRight: { type: Type.Object },
  /** Handedness for VR cursors to accept trigger events only from respective controller. */
  handedness: {
    type: Type.Enum,
    values: ["input component", "left", "right", "none"],
    default: "input component"
  },
  /** Collision group of valid "floor" objects that can be teleported on */
  floorGroup: { type: Type.Int, default: 1 },
  /** How far the thumbstick needs to be pushed to have the teleport target indicator show up */
  thumbstickActivationThreshhold: { type: Type.Float, default: -0.7 },
  /** How far the thumbstick needs to be released to execute the teleport */
  thumbstickDeactivationThreshhold: { type: Type.Float, default: 0.3 },
  /** Offset to apply to the indicator object, e.g. to avoid it from Z-fighting with the floor */
  indicatorYOffset: { type: Type.Float, default: 0.01 },
  /** Mode for raycasting, whether to use PhysX or simple collision components */
  rayCastMode: {
    type: Type.Enum,
    values: ["collision", "physx"],
    default: "collision"
  },
  /** Max distance for PhysX raycast */
  maxDistance: { type: Type.Float, default: 100 }
});

// node_modules/@wonderlandengine/components/dist/trail.js
var direction = vec3_exports.create();
var offset = vec3_exports.create();
var normal = vec3_exports.create();
var Trail = class extends Component {
  init() {
    this.points = new Array(this.segments + 1);
    for (let i = 0; i < this.points.length; ++i) {
      this.points[i] = vec3_exports.create();
    }
    this.currentPointOffset = 0;
    this.up = [0, 1, 0];
    this.timeTillNext = this.interval;
  }
  start() {
    this.trailContainer = this.engine.scene.addObject();
    this.meshComp = this.trailContainer.addComponent("mesh");
    this.meshComp.material = this.material;
    const vertexCount = 2 * this.points.length;
    this.indexData = new Uint32Array(6 * this.segments);
    for (let i = 0, v = 0; i < vertexCount - 2; i += 2, v += 6) {
      this.indexData.subarray(v, v + 6).set([i + 1, i + 0, i + 2, i + 2, i + 3, i + 1]);
    }
    this.mesh = new Mesh(this.engine, {
      vertexCount,
      indexData: this.indexData,
      indexType: MeshIndexType.UnsignedInt
    });
    this.meshComp.mesh = this.mesh;
  }
  updateVertices() {
    const positions = this.mesh.attribute(MeshAttribute.Position);
    const texCoords = this.mesh.attribute(MeshAttribute.TextureCoordinate);
    const normals = this.mesh.attribute(MeshAttribute.Normal);
    vec3_exports.set(direction, 0, 0, 0);
    for (let i = 0; i < this.points.length; ++i) {
      const curr = this.points[(this.currentPointIndex + i + 1) % this.points.length];
      const next = this.points[(this.currentPointIndex + i + 2) % this.points.length];
      if (i !== this.points.length - 1) {
        vec3_exports.sub(direction, next, curr);
      }
      vec3_exports.cross(offset, this.up, direction);
      vec3_exports.normalize(offset, offset);
      const timeFraction = 1 - this.timeTillNext / this.interval;
      const fraction = (i - timeFraction) / this.segments;
      vec3_exports.scale(offset, offset, (this.taper ? fraction : 1) * this.width / 2);
      positions.set(i * 2, [
        curr[0] - offset[0],
        curr[1] - offset[1],
        curr[2] - offset[2]
      ]);
      positions.set(i * 2 + 1, [
        curr[0] + offset[0],
        curr[1] + offset[1],
        curr[2] + offset[2]
      ]);
      if (normals) {
        vec3_exports.cross(normal, direction, offset);
        vec3_exports.normalize(normal, normal);
        normals.set(i * 2, normal);
        normals.set(i * 2 + 1, normal);
      }
      if (texCoords) {
        texCoords.set(i * 2, [0, fraction]);
        texCoords.set(i * 2 + 1, [1, fraction]);
      }
    }
    this.mesh.update();
  }
  resetTrail() {
    this.object.getTranslationWorld(this.points[0]);
    for (let i = 1; i < this.points.length; ++i) {
      vec3_exports.copy(this.points[i], this.points[0]);
    }
    this.currentPointIndex = 0;
    this.timeTillNext = this.interval;
  }
  update(dt) {
    this.timeTillNext -= dt;
    if (dt > this.resetThreshold) {
      this.resetTrail();
    }
    if (this.timeTillNext < 0) {
      this.currentPointIndex = (this.currentPointIndex + 1) % this.points.length;
      this.timeTillNext = this.timeTillNext % this.interval + this.interval;
    }
    this.object.getTranslationWorld(this.points[this.currentPointIndex]);
    this.updateVertices();
  }
  onActivate() {
    this.resetTrail();
  }
  onDestroy() {
    this.trailContainer.destroy();
    this.mesh.destroy();
  }
};
__publicField(Trail, "TypeName", "trail");
__publicField(Trail, "Properties", {
  /** The material to apply to the trail mesh */
  material: { type: Type.Material },
  /** The number of segments in the trail mesh */
  segments: { type: Type.Int, default: 50 },
  /** The time interval before recording a new point */
  interval: { type: Type.Float, default: 0.1 },
  /** The width of the trail (in world space) */
  width: { type: Type.Float, default: 1 },
  /** Whether or not the trail should taper off */
  taper: { type: Type.Bool, default: true },
  /**
   * The maximum delta time in seconds, above which the trail resets.
   * This prevents the trail from jumping around when updates happen
   * infrequently (e.g. when the tab doesn't have focus).
   */
  resetThreshold: { type: Type.Float, default: 0.5 }
});

// node_modules/@wonderlandengine/components/dist/two-joint-ik-solver.js
function clamp2(v, a, b) {
  return Math.max(a, Math.min(v, b));
}
var rootScaling = new Float32Array(3);
var tempQuat3 = new Float32Array(4);
var middlePos = new Float32Array(3);
var endPos = new Float32Array(3);
var targetPos = new Float32Array(3);
var helperPos = new Float32Array(3);
var rootTransform = new Float32Array(8);
var middleTransform = new Float32Array(8);
var endTransform = new Float32Array(8);
var twoJointIK = function() {
  const ta = new Float32Array(3);
  const ca = new Float32Array(3);
  const ba = new Float32Array(3);
  const ab = new Float32Array(3);
  const cb = new Float32Array(3);
  const axis0 = new Float32Array(3);
  const axis1 = new Float32Array(3);
  const temp = new Float32Array(3);
  return function(root, middle, b, c, targetPos2, eps, helper) {
    ba.set(b);
    const lab = vec3_exports.length(ba);
    vec3_exports.sub(ta, b, c);
    const lcb = vec3_exports.length(ta);
    ta.set(targetPos2);
    const lat = clamp2(vec3_exports.length(ta), eps, lab + lcb - eps);
    ca.set(c);
    vec3_exports.scale(ab, b, -1);
    vec3_exports.sub(cb, c, b);
    vec3_exports.normalize(ca, ca);
    vec3_exports.normalize(ba, ba);
    vec3_exports.normalize(ab, ab);
    vec3_exports.normalize(cb, cb);
    vec3_exports.normalize(ta, ta);
    const ac_ab_0 = Math.acos(clamp2(vec3_exports.dot(ca, ba), -1, 1));
    const ba_bc_0 = Math.acos(clamp2(vec3_exports.dot(ab, cb), -1, 1));
    const ac_at_0 = Math.acos(clamp2(vec3_exports.dot(ca, ta), -1, 1));
    const ac_ab_1 = Math.acos(clamp2((lcb * lcb - lab * lab - lat * lat) / (-2 * lab * lat), -1, 1));
    const ba_bc_1 = Math.acos(clamp2((lat * lat - lab * lab - lcb * lcb) / (-2 * lab * lcb), -1, 1));
    if (helper) {
      vec3_exports.sub(ba, helper, b);
      vec3_exports.normalize(ba, ba);
    }
    vec3_exports.cross(axis0, ca, ba);
    vec3_exports.normalize(axis0, axis0);
    vec3_exports.cross(axis1, c, targetPos2);
    vec3_exports.normalize(axis1, axis1);
    middle.transformVectorInverseLocal(temp, axis0);
    root.rotateAxisAngleRadObject(axis1, ac_at_0);
    root.rotateAxisAngleRadObject(axis0, ac_ab_1 - ac_ab_0);
    middle.rotateAxisAngleRadObject(axis0, ba_bc_1 - ba_bc_0);
  };
}();
var TwoJointIkSolver = class extends Component {
  time = 0;
  start() {
    this.root.getTransformLocal(rootTransform);
    this.middle.getTransformLocal(middleTransform);
    this.end.getTransformLocal(endTransform);
  }
  update(dt) {
    this.time += dt;
    this.root.setTransformLocal(rootTransform);
    this.middle.setTransformLocal(middleTransform);
    this.end.setTransformLocal(endTransform);
    this.root.getScalingWorld(rootScaling);
    this.middle.getPositionLocal(middlePos);
    this.end.getPositionLocal(endPos);
    this.middle.transformPointLocal(endPos, endPos);
    if (this.helper) {
      this.helper.getPositionWorld(helperPos);
      this.root.transformPointInverseWorld(helperPos, helperPos);
      vec3_exports.div(helperPos, helperPos, rootScaling);
    }
    this.target.getPositionWorld(targetPos);
    this.root.transformPointInverseWorld(targetPos, targetPos);
    vec3_exports.div(targetPos, targetPos, rootScaling);
    twoJointIK(this.root, this.middle, middlePos, endPos, targetPos, 0.01, this.helper ? helperPos : null, this.time);
    if (this.copyTargetRotation) {
      this.end.setRotationWorld(this.target.getRotationWorld(tempQuat3));
    }
  }
};
__publicField(TwoJointIkSolver, "TypeName", "two-joint-ik-solver");
__publicField(TwoJointIkSolver, "Properties", {
  /** Root bone, never moves */
  root: Property.object(),
  /** Bone attached to the root */
  middle: Property.object(),
  /** Bone attached to the middle */
  end: Property.object(),
  /** Target the joins should reach for */
  target: Property.object(),
  /** Flag for copying rotation from target to end */
  copyTargetRotation: Property.bool(true),
  /** Helper object to use to determine joint rotation axis */
  helper: Property.object()
});

// node_modules/@wonderlandengine/components/dist/video-texture.js
var VideoTexture = class extends Component {
  init() {
    if (!this.material) {
      throw Error("video-texture: material property not set");
    }
    this.loaded = false;
    this.frameUpdateRequested = true;
  }
  start() {
    this.video = document.createElement("video");
    this.video.src = this.url;
    this.video.crossOrigin = "anonymous";
    this.video.playsInline = true;
    this.video.loop = this.loop;
    this.video.muted = this.muted;
    this.video.addEventListener("playing", () => {
      this.loaded = true;
    });
    if (this.autoplay) {
      const playAfterUserGesture = () => {
        this.video.play();
        window.removeEventListener("click", playAfterUserGesture);
        window.removeEventListener("touchstart", playAfterUserGesture);
      };
      window.addEventListener("click", playAfterUserGesture);
      window.addEventListener("touchstart", playAfterUserGesture);
    }
  }
  applyTexture() {
    const mat = this.material;
    const shader = mat.shader;
    const texture = this.texture = new Texture(this.engine, this.video);
    if (!setFirstMaterialTexture(mat, texture, this.textureProperty)) {
      console.error("Shader", shader, "not supported by video-texture");
    }
    if ("requestVideoFrameCallback" in this.video) {
      this.video.requestVideoFrameCallback(this.updateVideo.bind(this));
    } else {
      this.video.addEventListener("timeupdate", () => {
        this.frameUpdateRequested = true;
      });
    }
  }
  update(dt) {
    if (this.loaded && this.frameUpdateRequested) {
      if (this.texture) {
        this.texture.update();
      } else {
        this.applyTexture();
      }
      this.frameUpdateRequested = false;
    }
  }
  updateVideo() {
    this.frameUpdateRequested = true;
    this.video.requestVideoFrameCallback(this.updateVideo.bind(this));
  }
};
__publicField(VideoTexture, "TypeName", "video-texture");
__publicField(VideoTexture, "Properties", {
  /** URL to download video from */
  url: Property.string(),
  /** Material to apply the video texture to */
  material: Property.material(),
  /** Whether to loop the video */
  loop: Property.bool(true),
  /** Whether to automatically start playing the video */
  autoplay: Property.bool(true),
  /** Whether to mute sound */
  muted: Property.bool(true),
  /** Name of the texture property to set */
  textureProperty: Property.string("auto")
});

// node_modules/@wonderlandengine/components/dist/vr-mode-active-switch.js
var VrModeActiveSwitch = class extends Component {
  start() {
    this.components = [];
    this.getComponents(this.object);
    this.onXRSessionEnd();
    this.onSessionStartCallback = this.onXRSessionStart.bind(this);
    this.onSessionEndCallback = this.onXRSessionEnd.bind(this);
  }
  onActivate() {
    this.engine.onXRSessionStart.add(this.onSessionStartCallback);
    this.engine.onXRSessionEnd.add(this.onSessionEndCallback);
  }
  onDeactivate() {
    this.engine.onXRSessionStart.remove(this.onSessionStartCallback);
    this.engine.onXRSessionEnd.remove(this.onSessionEndCallback);
  }
  getComponents(obj) {
    const comps = obj.getComponents().filter((c) => c.type !== "vr-mode-active-switch");
    this.components = this.components.concat(comps);
    if (this.affectChildren) {
      let children = obj.children;
      for (let i = 0; i < children.length; ++i) {
        this.getComponents(children[i]);
      }
    }
  }
  setComponentsActive(active) {
    const comps = this.components;
    for (let i = 0; i < comps.length; ++i) {
      comps[i].active = active;
    }
  }
  onXRSessionStart() {
    this.setComponentsActive(this.activateComponents == 0);
  }
  onXRSessionEnd() {
    this.setComponentsActive(this.activateComponents != 0);
  }
};
__publicField(VrModeActiveSwitch, "TypeName", "vr-mode-active-switch");
__publicField(VrModeActiveSwitch, "Properties", {
  /** When components should be active: In VR or when not in VR */
  activateComponents: {
    type: Type.Enum,
    values: ["in VR", "in non-VR"],
    default: "in VR"
  },
  /** Whether child object's components should be affected */
  affectChildren: { type: Type.Bool, default: true }
});

// node_modules/@wonderlandengine/components/dist/plane-detection.js
var import_earcut = __toESM(require_earcut(), 1);
var __decorate9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var tempVec32 = new Float32Array(3);
function extentsFromContour(out, points) {
  if (points.length == 0)
    return out;
  let absMaxX = Math.abs(points[0].x);
  let absMaxZ = Math.abs(points[0].z);
  for (let i = 1; i < points.length; ++i) {
    absMaxX = Math.max(absMaxX, Math.abs(points[i].x));
    absMaxZ = Math.max(absMaxZ, Math.abs(points[i].z));
  }
  out[0] = absMaxX;
  out[1] = 0;
  out[2] = absMaxZ;
}
function within(x, a, b) {
  if (a > b)
    return x < a && x > b;
  return x > a && x < b;
}
function isPointLocalOnXRPlanePolygon(p, plane) {
  const points = plane.polygon;
  if (points.length < 3)
    return false;
  const pX = p[0];
  const pZ = p[2];
  let intersections = 0;
  for (let n = 0, l = points.length - 1; n < points.length; ++n) {
    const aX = points[l].x;
    const aZ = points[l].z;
    const s = (points[n].z - aZ) / (points[n].x - aX);
    const x = Math.abs((pZ - aZ) / s);
    if (x >= 0 && x <= 1 && within(x + pX, aX, points[n].x))
      ++intersections;
    l = n;
  }
  return (intersections & 1) == 0;
}
function isPointWorldOnXRPlanePolygon(object, p, plane) {
  if (plane.polygon.length < 3)
    return false;
  isPointLocalOnXRPlanePolygon(object.transformPointInverseWorld(tempVec32, p), plane);
}
function planeMeshFromContour(engine2, points, meshToUpdate = null) {
  const vertexCount = points.length;
  const vertices = new Float32Array(vertexCount * 2);
  for (let i = 0, d = 0; i < vertexCount; ++i, d += 2) {
    vertices[d] = points[i].x;
    vertices[d + 1] = points[i].z;
  }
  const triangles = (0, import_earcut.default)(vertices);
  const mesh = meshToUpdate || new Mesh(engine2, {
    vertexCount,
    /* Assumption here that we will never have more than 256 points
     * in the detected plane meshes! */
    indexType: MeshIndexType.UnsignedByte,
    indexData: triangles
  });
  if (mesh.vertexCount !== vertexCount) {
    console.warn("vertexCount of meshToUpdate did not match required vertexCount");
    return mesh;
  }
  const positions = mesh.attribute(MeshAttribute.Position);
  const textureCoords = mesh.attribute(MeshAttribute.TextureCoordinate);
  const normals = mesh.attribute(MeshAttribute.Normal);
  tempVec32[1] = 0;
  for (let i = 0, s = 0; i < vertexCount; ++i, s += 2) {
    tempVec32[0] = vertices[s];
    tempVec32[2] = vertices[s + 1];
    positions.set(i, tempVec32);
  }
  textureCoords?.set(0, vertices);
  if (normals) {
    tempVec32[0] = 0;
    tempVec32[1] = 1;
    tempVec32[2] = 0;
    for (let i = 0; i < vertexCount; ++i) {
      normals.set(i, tempVec32);
    }
  }
  if (meshToUpdate)
    mesh.update();
  return mesh;
}
var _planeLost, planeLost_fn, _planeFound, planeFound_fn, _planeUpdate, planeUpdate_fn, _planeUpdatePose, planeUpdatePose_fn;
var PlaneDetection = class extends Component {
  constructor() {
    super(...arguments);
    __privateAdd(this, _planeLost);
    __privateAdd(this, _planeFound);
    __privateAdd(this, _planeUpdate);
    __privateAdd(this, _planeUpdatePose);
    /**
     * Material to assign to created plane meshes or `null` if meshes should not be created.
     */
    __publicField(this, "planeMaterial", null);
    /**
     * Collision mask to assign to newly created collision components or a negative value if
     * collision components should not be created.
     */
    __publicField(this, "collisionMask", -1);
    /** Map of all planes and their last updated timestamps */
    __publicField(this, "planes", /* @__PURE__ */ new Map());
    /** Objects generated for each XRPlane */
    __publicField(this, "planeObjects", /* @__PURE__ */ new Map());
    /** Called when a plane starts tracking */
    __publicField(this, "onPlaneFound", new Emitter());
    /** Called when a plane stops tracking */
    __publicField(this, "onPlaneLost", new Emitter());
  }
  update() {
    if (!this.engine.xr?.frame)
      return;
    if (this.engine.xr.frame.detectedPlanes === void 0) {
      console.error("plane-detection: WebXR feature not available.");
      this.active = false;
      return;
    }
    const detectedPlanes = this.engine.xr.frame.detectedPlanes;
    for (const [plane, _] of this.planes) {
      if (!detectedPlanes.has(plane)) {
        __privateMethod(this, _planeLost, planeLost_fn).call(this, plane);
      }
    }
    detectedPlanes.forEach((plane) => {
      if (this.planes.has(plane)) {
        if (plane.lastChangedTime > this.planes.get(plane)) {
          __privateMethod(this, _planeUpdate, planeUpdate_fn).call(this, plane);
        }
      } else {
        __privateMethod(this, _planeFound, planeFound_fn).call(this, plane);
      }
      __privateMethod(this, _planeUpdatePose, planeUpdatePose_fn).call(this, plane);
    });
  }
};
_planeLost = new WeakSet();
planeLost_fn = function(plane) {
  this.planes.delete(plane);
  const o = this.planeObjects.get(plane);
  this.onPlaneLost.notify(plane, o);
  if (o.objectId > 0)
    o.destroy();
};
_planeFound = new WeakSet();
planeFound_fn = function(plane) {
  this.planes.set(plane, plane.lastChangedTime);
  const o = this.engine.scene.addObject(this.object);
  this.planeObjects.set(plane, o);
  if (this.planeMaterial) {
    o.addComponent(MeshComponent, {
      mesh: planeMeshFromContour(this.engine, plane.polygon),
      material: this.planeMaterial
    });
  }
  if (this.collisionMask >= 0) {
    extentsFromContour(tempVec32, plane.polygon);
    tempVec32[1] = 0.025;
    o.addComponent(CollisionComponent, {
      group: this.collisionMask,
      collider: Collider.Box,
      extents: tempVec32
    });
  }
  this.onPlaneFound.notify(plane, o);
};
_planeUpdate = new WeakSet();
planeUpdate_fn = function(plane) {
  this.planes.set(plane, plane.lastChangedTime);
  const planeMesh = this.planeObjects.get(plane).getComponent(MeshComponent);
  if (!planeMesh)
    return;
  planeMeshFromContour(this.engine, plane.polygon, planeMesh.mesh);
};
_planeUpdatePose = new WeakSet();
planeUpdatePose_fn = function(plane) {
  const o = this.planeObjects.get(plane);
  const pose = this.engine.xr.frame.getPose(plane.planeSpace, this.engine.xr.currentReferenceSpace);
  if (!pose) {
    o.active = false;
    return;
  }
  setXRRigidTransformLocal(o, pose.transform);
};
__publicField(PlaneDetection, "TypeName", "plane-detection");
__decorate9([
  property.material()
], PlaneDetection.prototype, "planeMaterial", void 0);
__decorate9([
  property.int()
], PlaneDetection.prototype, "collisionMask", void 0);

// node_modules/@wonderlandengine/components/dist/vrm.js
var VRM_ROLL_AXES = {
  X: [1, 0, 0],
  Y: [0, 1, 0],
  Z: [0, 0, 1]
};
var VRM_AIM_AXES = {
  PositiveX: [1, 0, 0],
  NegativeX: [-1, 0, 0],
  PositiveY: [0, 1, 0],
  NegativeY: [0, -1, 0],
  PositiveZ: [0, 0, 1],
  NegativeZ: [0, 0, -1]
};
var Vrm = class extends Component {
  /** Meta information about the VRM model */
  meta = null;
  /** The humanoid bones of the VRM model */
  bones = {
    /* Torso */
    hips: null,
    spine: null,
    chest: null,
    upperChest: null,
    neck: null,
    /* Head */
    head: null,
    leftEye: null,
    rightEye: null,
    jaw: null,
    /* Legs */
    leftUpperLeg: null,
    leftLowerLeg: null,
    leftFoot: null,
    leftToes: null,
    rightUpperLeg: null,
    rightLowerLeg: null,
    rightFoot: null,
    rightToes: null,
    /* Arms */
    leftShoulder: null,
    leftUpperArm: null,
    leftLowerArm: null,
    leftHand: null,
    rightShoulder: null,
    rightUpperArm: null,
    rightLowerArm: null,
    rightHand: null,
    /* Fingers */
    leftThumbMetacarpal: null,
    leftThumbProximal: null,
    leftThumbDistal: null,
    leftIndexProximal: null,
    leftIndexIntermediate: null,
    leftIndexDistal: null,
    leftMiddleProximal: null,
    leftMiddleIntermediate: null,
    leftMiddleDistal: null,
    leftRingProximal: null,
    leftRingIntermediate: null,
    leftRingDistal: null,
    leftLittleProximal: null,
    leftLittleIntermediate: null,
    leftLittleDistal: null,
    rightThumbMetacarpal: null,
    rightThumbProximal: null,
    rightThumbDistal: null,
    rightIndexProximal: null,
    rightIndexIntermediate: null,
    rightIndexDistal: null,
    rightMiddleProximal: null,
    rightMiddleIntermediate: null,
    rightMiddleDistal: null,
    rightRingProximal: null,
    rightRingIntermediate: null,
    rightRingDistal: null,
    rightLittleProximal: null,
    rightLittleIntermediate: null,
    rightLittleDistal: null
  };
  /** Rotations of the bones in the rest pose (T-pose) */
  restPose = {};
  /* All node constraints, ordered to deal with dependencies */
  _nodeConstraints = [];
  /* VRMC_springBone chains */
  _springChains = [];
  /* Spherical colliders for spring bones */
  _sphereColliders = [];
  /* Capsule shaped colliders for spring bones */
  _capsuleColliders = [];
  /* Indicates which meshes are rendered in first/third person views */
  _firstPersonAnnotations = [];
  /* Contains details for (bone type) lookAt behaviour */
  _lookAt = null;
  /* Whether or not the VRM component has been initialized with `initializeVrm` */
  _initialized = false;
  init() {
    this._tempV3 = vec3_exports.create();
    this._tempV3A = vec3_exports.create();
    this._tempV3B = vec3_exports.create();
    this._tempQuat = quat_exports.create();
    this._tempQuatA = quat_exports.create();
    this._tempQuatB = quat_exports.create();
    this._tempMat4A = mat4_exports.create();
    this._tempQuat2 = quat2_exports.create();
    this._tailToShape = vec3_exports.create();
    this._headToTail = vec3_exports.create();
    this._inertia = vec3_exports.create();
    this._stiffness = vec3_exports.create();
    this._external = vec3_exports.create();
    this._rightVector = vec3_exports.set(vec3_exports.create(), 1, 0, 0);
    this._upVector = vec3_exports.set(vec3_exports.create(), 0, 1, 0);
    this._forwardVector = vec3_exports.set(vec3_exports.create(), 0, 0, 1);
    this._identityQuat = quat_exports.identity(quat_exports.create());
    this._rad2deg = 180 / Math.PI;
  }
  start() {
    if (!this.src) {
      console.error("vrm: src property not set");
      return;
    }
    this.engine.scene.append(this.src, { loadGltfExtensions: true }).then(({ root, extensions }) => {
      root.children.forEach((child) => child.parent = this.object);
      this._initializeVrm(extensions);
      root.destroy();
    });
  }
  /**
   * Parses the VRM glTF extensions and initializes the vrm component.
   * @param {GLTFExtensions} extensions The glTF extensions for the VRM model
   */
  _initializeVrm(extensions) {
    if (this._initialized) {
      throw Error("VRM component has already been initialized");
    }
    const VRMC_vrm = extensions.root["VRMC_vrm"];
    if (!VRMC_vrm) {
      throw Error("Missing VRM extensions");
    }
    if (VRMC_vrm.specVersion !== "1.0") {
      throw Error(`Unsupported VRM version, only 1.0 is supported, but encountered '${VRMC_vrm.specVersion}'`);
    }
    this.meta = VRMC_vrm.meta;
    this._parseHumanoid(VRMC_vrm.humanoid, extensions);
    if (VRMC_vrm.firstPerson) {
      this._parseFirstPerson(VRMC_vrm.firstPerson, extensions);
    }
    if (VRMC_vrm.lookAt) {
      this._parseLookAt(VRMC_vrm.lookAt);
    }
    this._findAndParseNodeConstraints(extensions);
    const springBone = extensions.root["VRMC_springBone"];
    if (springBone) {
      this._parseAndInitializeSpringBones(springBone, extensions);
    }
    this._initialized = true;
  }
  _parseHumanoid(humanoid, extensions) {
    for (const boneName in humanoid.humanBones) {
      if (!(boneName in this.bones)) {
        console.warn(`Unrecognized bone '${boneName}'`);
        continue;
      }
      const node = humanoid.humanBones[boneName].node;
      const objectId = extensions.idMapping[node];
      this.bones[boneName] = this.engine.wrapObject(objectId);
      this.restPose[boneName] = quat_exports.copy(quat_exports.create(), this.bones[boneName].rotationLocal);
    }
  }
  _parseFirstPerson(firstPerson, extensions) {
    for (const meshAnnotation of firstPerson.meshAnnotations) {
      const annotation = {
        node: this.engine.wrapObject(extensions.idMapping[meshAnnotation.node]),
        firstPerson: true,
        thirdPerson: true
      };
      switch (meshAnnotation.type) {
        case "firstPersonOnly":
          annotation.thirdPerson = false;
          break;
        case "thirdPersonOnly":
          annotation.firstPerson = false;
          break;
        case "both":
          break;
        case "auto":
          console.warn("First person mesh annotation type 'auto' is not supported, treating as 'both'!");
          break;
        default:
          console.error(`Invalid mesh annotation type '${meshAnnotation.type}'`);
          break;
      }
      this._firstPersonAnnotations.push(annotation);
    }
  }
  _parseLookAt(lookAt3) {
    if (lookAt3.type !== "bone") {
      console.warn(`Unsupported lookAt type '${lookAt3.type}', only 'bone' is supported`);
      return;
    }
    const parseRangeMap = (rangeMap) => {
      return {
        inputMaxValue: rangeMap.inputMaxValue,
        outputScale: rangeMap.outputScale
      };
    };
    this._lookAt = {
      offsetFromHeadBone: lookAt3.offsetFromHeadBone || [0, 0, 0],
      horizontalInner: parseRangeMap(lookAt3.rangeMapHorizontalInner),
      horizontalOuter: parseRangeMap(lookAt3.rangeMapHorizontalOuter),
      verticalDown: parseRangeMap(lookAt3.rangeMapVerticalDown),
      verticalUp: parseRangeMap(lookAt3.rangeMapVerticalUp)
    };
  }
  _findAndParseNodeConstraints(extensions) {
    const traverse = (object) => {
      const nodeExtensions = extensions.node[object.objectId];
      if (nodeExtensions && "VRMC_node_constraint" in nodeExtensions) {
        const nodeConstraintExtension = nodeExtensions["VRMC_node_constraint"];
        const constraint = nodeConstraintExtension.constraint;
        let type, axis;
        if ("roll" in constraint) {
          type = "roll";
          axis = VRM_ROLL_AXES[constraint.roll.rollAxis];
        } else if ("aim" in constraint) {
          type = "aim";
          axis = VRM_AIM_AXES[constraint.aim.aimAxis];
        } else if ("rotation" in constraint) {
          type = "rotation";
        }
        if (type) {
          const source = this.engine.wrapObject(extensions.idMapping[constraint[type].source]);
          this._nodeConstraints.push({
            type,
            source,
            destination: object,
            axis,
            weight: constraint[type].weight,
            /* Rest pose */
            destinationRestLocalRotation: quat_exports.copy(quat_exports.create(), object.rotationLocal),
            sourceRestLocalRotation: quat_exports.copy(quat_exports.create(), source.rotationLocal),
            sourceRestLocalRotationInv: quat_exports.invert(quat_exports.create(), source.rotationLocal)
          });
        } else {
          console.warn("Unrecognized or invalid VRMC_node_constraint, ignoring it");
        }
      }
      for (const child of object.children) {
        traverse(child);
      }
    };
    traverse(this.object);
  }
  _parseAndInitializeSpringBones(springBone, extensions) {
    const colliders = (springBone.colliders || []).map((collider, i) => {
      const shapeType = "capsule" in collider.shape ? "capsule" : "sphere";
      return {
        id: i,
        object: this.engine.wrapObject(extensions.idMapping[collider.node]),
        shape: {
          isCapsule: shapeType === "capsule",
          radius: collider.shape[shapeType].radius,
          offset: collider.shape[shapeType].offset,
          tail: collider.shape[shapeType].tail
        },
        cache: {
          head: vec3_exports.create(),
          tail: vec3_exports.create()
        }
      };
    });
    this._sphereColliders = colliders.filter((c) => !c.shape.isCapsule);
    this._capsuleColliders = colliders.filter((c) => c.shape.isCapsule);
    const colliderGroups = (springBone.colliderGroups || []).map((group) => ({
      name: group.name,
      colliders: group.colliders.map((c) => colliders[c])
    }));
    for (const spring of springBone.springs) {
      const joints = [];
      for (const joint of spring.joints) {
        const springJoint = {
          hitRadius: 0,
          stiffness: 1,
          gravityPower: 0,
          gravityDir: [0, -1, 0],
          dragForce: 0.5,
          node: null,
          state: null
        };
        Object.assign(springJoint, joint);
        springJoint.node = this.engine.wrapObject(extensions.idMapping[springJoint.node]);
        joints.push(springJoint);
      }
      const springChainColliders = (spring.colliderGroups || []).flatMap((cg) => colliderGroups[cg].colliders);
      this._springChains.push({
        name: spring.name,
        center: spring.center ? this.engine.wrapObject(extensions.idMapping[spring.center]) : null,
        joints,
        sphereColliders: springChainColliders.filter((c) => !c.shape.isCapsule),
        capsuleColliders: springChainColliders.filter((c) => c.shape.isCapsule)
      });
    }
    for (const springChain of this._springChains) {
      for (let i = 0; i < springChain.joints.length - 1; ++i) {
        const springBoneJoint = springChain.joints[i];
        const childSpringBoneJoint = springChain.joints[i + 1];
        const springBonePosition = springBoneJoint.node.getTranslationWorld(vec3_exports.create());
        const childSpringBonePosition = childSpringBoneJoint.node.getTranslationWorld(vec3_exports.create());
        const boneDirection = vec3_exports.subtract(this._tempV3A, springBonePosition, childSpringBonePosition);
        const state = {
          prevTail: childSpringBonePosition,
          currentTail: vec3_exports.copy(vec3_exports.create(), childSpringBonePosition),
          initialLocalRotation: quat_exports.copy(quat_exports.create(), springBoneJoint.node.rotationLocal),
          initialLocalTransformInvert: quat2_exports.invert(quat2_exports.create(), springBoneJoint.node.transformLocal),
          boneAxis: vec3_exports.normalize(vec3_exports.create(), childSpringBoneJoint.node.getTranslationLocal(this._tempV3)),
          /* Ensure bone length is at least 1cm to avoid jittery behaviour from zero-length bones */
          boneLength: Math.max(0.01, vec3_exports.length(boneDirection)),
          /* Tail positions in center space, if needed */
          prevTailCenter: null,
          currentTailCenter: null
        };
        if (springChain.center) {
          state.prevTailCenter = springChain.center.transformPointInverseWorld(vec3_exports.create(), childSpringBonePosition);
          state.currentTailCenter = vec3_exports.copy(vec3_exports.create(), childSpringBonePosition);
        }
        springBoneJoint.state = state;
      }
    }
  }
  update(dt) {
    if (!this._initialized) {
      return;
    }
    this._resolveLookAt();
    this._resolveConstraints();
    this._updateSpringBones(dt);
  }
  _rangeMap(rangeMap, input) {
    const maxValue = rangeMap.inputMaxValue;
    const outputScale = rangeMap.outputScale;
    return Math.min(input, maxValue) / maxValue * outputScale;
  }
  _resolveLookAt() {
    if (!this._lookAt || !this.lookAtTarget) {
      return;
    }
    const lookAtSource = this.bones.head.transformPointWorld(this._tempV3A, this._lookAt.offsetFromHeadBone);
    const lookAtTarget = this.lookAtTarget.getTranslationWorld(this._tempV3B);
    const lookAtDirection = vec3_exports.sub(this._tempV3A, lookAtTarget, lookAtSource);
    vec3_exports.normalize(lookAtDirection, lookAtDirection);
    this.bones.head.parent.transformVectorInverseWorld(lookAtDirection);
    const z = vec3_exports.dot(lookAtDirection, this._forwardVector);
    const x = vec3_exports.dot(lookAtDirection, this._rightVector);
    const yaw = Math.atan2(x, z) * this._rad2deg;
    const xz = Math.sqrt(x * x + z * z);
    const y = vec3_exports.dot(lookAtDirection, this._upVector);
    let pitch = Math.atan2(-y, xz) * this._rad2deg;
    if (pitch > 0) {
      pitch = this._rangeMap(this._lookAt.verticalDown, pitch);
    } else {
      pitch = -this._rangeMap(this._lookAt.verticalUp, -pitch);
    }
    if (this.bones.leftEye) {
      let yawLeft = yaw;
      if (yawLeft > 0) {
        yawLeft = this._rangeMap(this._lookAt.horizontalInner, yawLeft);
      } else {
        yawLeft = -this._rangeMap(this._lookAt.horizontalOuter, -yawLeft);
      }
      const eyeRotation = quat_exports.fromEuler(this._tempQuatA, pitch, yawLeft, 0);
      this.bones.leftEye.rotationLocal = quat_exports.multiply(eyeRotation, this.restPose.leftEye, eyeRotation);
    }
    if (this.bones.rightEye) {
      let yawRight = yaw;
      if (yawRight > 0) {
        yawRight = this._rangeMap(this._lookAt.horizontalOuter, yawRight);
      } else {
        yawRight = -this._rangeMap(this._lookAt.horizontalInner, -yawRight);
      }
      const eyeRotation = quat_exports.fromEuler(this._tempQuatA, pitch, yawRight, 0);
      this.bones.rightEye.rotationLocal = quat_exports.multiply(eyeRotation, this.restPose.rightEye, eyeRotation);
    }
  }
  _resolveConstraints() {
    for (const nodeConstraint of this._nodeConstraints) {
      this._resolveConstraint(nodeConstraint);
    }
  }
  _resolveConstraint(nodeConstraint) {
    const dstRestQuat = nodeConstraint.destinationRestLocalRotation;
    const srcRestQuatInv = nodeConstraint.sourceRestLocalRotationInv;
    const targetQuat = quat_exports.identity(this._tempQuatA);
    switch (nodeConstraint.type) {
      case "roll":
        {
          const deltaSrcQuat = quat_exports.multiply(this._tempQuatA, srcRestQuatInv, nodeConstraint.source.rotationLocal);
          const deltaSrcQuatInParent = quat_exports.multiply(this._tempQuatA, nodeConstraint.sourceRestLocalRotation, deltaSrcQuat);
          quat_exports.mul(deltaSrcQuatInParent, deltaSrcQuatInParent, srcRestQuatInv);
          const dstRestQuatInv = quat_exports.invert(this._tempQuatB, dstRestQuat);
          const deltaSrcQuatInDst = quat_exports.multiply(this._tempQuatB, dstRestQuatInv, deltaSrcQuatInParent);
          quat_exports.multiply(deltaSrcQuatInDst, deltaSrcQuatInDst, dstRestQuat);
          const toVec = vec3_exports.transformQuat(this._tempV3A, nodeConstraint.axis, deltaSrcQuatInDst);
          const fromToQuat = quat_exports.rotationTo(this._tempQuatA, nodeConstraint.axis, toVec);
          quat_exports.mul(targetQuat, dstRestQuat, quat_exports.invert(this._tempQuat, fromToQuat));
          quat_exports.mul(targetQuat, targetQuat, deltaSrcQuatInDst);
        }
        break;
      case "aim":
        {
          const dstParentWorldQuat = nodeConstraint.destination.parent.rotationWorld;
          const fromVec = vec3_exports.transformQuat(this._tempV3A, nodeConstraint.axis, dstRestQuat);
          vec3_exports.transformQuat(fromVec, fromVec, dstParentWorldQuat);
          const toVec = nodeConstraint.source.getTranslationWorld(this._tempV3B);
          vec3_exports.sub(toVec, toVec, nodeConstraint.destination.getTranslationWorld(this._tempV3));
          vec3_exports.normalize(toVec, toVec);
          const fromToQuat = quat_exports.rotationTo(this._tempQuatA, fromVec, toVec);
          quat_exports.mul(targetQuat, quat_exports.invert(this._tempQuat, dstParentWorldQuat), fromToQuat);
          quat_exports.mul(targetQuat, targetQuat, dstParentWorldQuat);
          quat_exports.mul(targetQuat, targetQuat, dstRestQuat);
        }
        break;
      case "rotation":
        {
          const srcDeltaQuat = quat_exports.mul(targetQuat, srcRestQuatInv, nodeConstraint.source.rotationLocal);
          quat_exports.mul(targetQuat, dstRestQuat, srcDeltaQuat);
        }
        break;
    }
    quat_exports.slerp(targetQuat, dstRestQuat, targetQuat, nodeConstraint.weight);
    nodeConstraint.destination.rotationLocal = targetQuat;
  }
  _updateSpringBones(dt) {
    this._sphereColliders.forEach(({ object, shape, cache }) => {
      const offset2 = vec3_exports.copy(cache.head, shape.offset);
      object.transformVectorWorld(offset2);
      vec3_exports.add(cache.head, object.getTranslationWorld(this._tempV3), offset2);
    });
    this._capsuleColliders.forEach(({ object, shape, cache }) => {
      const shapeCenter = object.getTranslationWorld(this._tempV3A);
      const headOffset = vec3_exports.copy(cache.head, shape.offset);
      object.transformVectorWorld(headOffset);
      vec3_exports.add(cache.head, shapeCenter, headOffset);
      const tailOffset = vec3_exports.copy(cache.tail, shape.tail);
      object.transformVectorWorld(tailOffset);
      vec3_exports.add(cache.tail, shapeCenter, tailOffset);
    });
    this._springChains.forEach((springChain) => {
      for (let i = 0; i < springChain.joints.length - 1; ++i) {
        const joint = springChain.joints[i];
        const parentWorldRotation = joint.node.parent ? joint.node.parent.rotationWorld : this._identityQuat;
        const inertia = this._inertia;
        if (springChain.center) {
          vec3_exports.sub(inertia, joint.state.currentTailCenter, joint.state.prevTailCenter);
          springChain.center.transformVectorWorld(inertia);
        } else {
          vec3_exports.sub(inertia, joint.state.currentTail, joint.state.prevTail);
        }
        vec3_exports.scale(inertia, inertia, 1 - joint.dragForce);
        const stiffness = vec3_exports.copy(this._stiffness, joint.state.boneAxis);
        vec3_exports.transformQuat(stiffness, stiffness, joint.state.initialLocalRotation);
        vec3_exports.transformQuat(stiffness, stiffness, parentWorldRotation);
        vec3_exports.scale(stiffness, stiffness, dt * joint.stiffness);
        const external = vec3_exports.scale(this._external, joint.gravityDir, dt * joint.gravityPower);
        const nextTail = vec3_exports.copy(this._tempV3A, joint.state.currentTail);
        vec3_exports.add(nextTail, nextTail, inertia);
        vec3_exports.add(nextTail, nextTail, stiffness);
        vec3_exports.add(nextTail, nextTail, external);
        const worldPosition = joint.node.getTranslationWorld(this._tempV3B);
        vec3_exports.sub(nextTail, nextTail, worldPosition);
        vec3_exports.normalize(nextTail, nextTail);
        vec3_exports.scaleAndAdd(nextTail, worldPosition, nextTail, joint.state.boneLength);
        for (const { shape, cache } of springChain.sphereColliders) {
          let tailToShape = this._tailToShape;
          const sphereCenter = cache.head;
          tailToShape = vec3_exports.sub(tailToShape, nextTail, sphereCenter);
          const radius = shape.radius + joint.hitRadius;
          const dist4 = vec3_exports.length(tailToShape) - radius;
          if (dist4 < 0) {
            vec3_exports.normalize(tailToShape, tailToShape);
            vec3_exports.scaleAndAdd(nextTail, nextTail, tailToShape, -dist4);
            vec3_exports.sub(nextTail, nextTail, worldPosition);
            vec3_exports.normalize(nextTail, nextTail);
            vec3_exports.scaleAndAdd(nextTail, worldPosition, nextTail, joint.state.boneLength);
          }
        }
        for (const { shape, cache } of springChain.capsuleColliders) {
          let tailToShape = this._tailToShape;
          const head = cache.head;
          const tail = cache.tail;
          tailToShape = vec3_exports.sub(tailToShape, nextTail, head);
          const headToTail = vec3_exports.sub(this._headToTail, tail, head);
          const dot7 = vec3_exports.dot(headToTail, tailToShape);
          if (vec3_exports.squaredLength(headToTail) <= dot7) {
            vec3_exports.sub(tailToShape, nextTail, tail);
          } else if (dot7 > 0) {
            vec3_exports.scale(headToTail, headToTail, dot7 / vec3_exports.squaredLength(headToTail));
            vec3_exports.sub(tailToShape, tailToShape, headToTail);
          }
          const radius = shape.radius + joint.hitRadius;
          const dist4 = vec3_exports.length(tailToShape) - radius;
          if (dist4 < 0) {
            vec3_exports.normalize(tailToShape, tailToShape);
            vec3_exports.scaleAndAdd(nextTail, nextTail, tailToShape, -dist4);
            vec3_exports.sub(nextTail, nextTail, worldPosition);
            vec3_exports.normalize(nextTail, nextTail);
            vec3_exports.scaleAndAdd(nextTail, worldPosition, nextTail, joint.state.boneLength);
          }
        }
        vec3_exports.copy(joint.state.prevTail, joint.state.currentTail);
        vec3_exports.copy(joint.state.currentTail, nextTail);
        if (springChain.center) {
          vec3_exports.copy(joint.state.prevTailCenter, joint.state.currentTailCenter);
          vec3_exports.copy(joint.state.currentTailCenter, nextTail);
          springChain.center.transformPointInverseWorld(joint.state.currentTailCenter);
        }
        joint.node.parent.transformPointInverseWorld(nextTail);
        const nextTailDualQuat = quat2_exports.fromTranslation(this._tempQuat2, nextTail);
        quat2_exports.multiply(nextTailDualQuat, joint.state.initialLocalTransformInvert, nextTailDualQuat);
        quat2_exports.getTranslation(nextTail, nextTailDualQuat);
        vec3_exports.normalize(nextTail, nextTail);
        const jointRotation = quat_exports.rotationTo(this._tempQuatA, joint.state.boneAxis, nextTail);
        joint.node.rotationLocal = quat_exports.mul(this._tempQuatA, joint.state.initialLocalRotation, jointRotation);
      }
    });
  }
  /**
   * @param {boolean} firstPerson Whether the model should render for first person or third person views
   */
  set firstPerson(firstPerson) {
    this._firstPersonAnnotations.forEach((annotation) => {
      const visible = firstPerson == annotation.firstPerson || firstPerson != annotation.thirdPerson;
      annotation.node.getComponents("mesh").forEach((mesh) => {
        mesh.active = visible;
      });
    });
  }
};
__publicField(Vrm, "TypeName", "vrm");
__publicField(Vrm, "Properties", {
  /** URL to a VRM file to load */
  src: { type: Type.String },
  /** Object the VRM is looking at */
  lookAtTarget: { type: Type.Object }
});

// node_modules/@wonderlandengine/components/dist/wasd-controls.js
var _direction = new Float32Array(3);
var WasdControlsComponent = class extends Component {
  init() {
    this.up = false;
    this.right = false;
    this.down = false;
    this.left = false;
    window.addEventListener("keydown", this.press.bind(this));
    window.addEventListener("keyup", this.release.bind(this));
  }
  start() {
    this.headObject = this.headObject || this.object;
  }
  update() {
    vec3_exports.zero(_direction);
    if (this.up)
      _direction[2] -= 1;
    if (this.down)
      _direction[2] += 1;
    if (this.left)
      _direction[0] -= 1;
    if (this.right)
      _direction[0] += 1;
    vec3_exports.normalize(_direction, _direction);
    _direction[0] *= this.speed;
    _direction[2] *= this.speed;
    vec3_exports.transformQuat(_direction, _direction, this.headObject.transformWorld);
    if (this.lockY) {
      _direction[1] = 0;
      vec3_exports.normalize(_direction, _direction);
      vec3_exports.scale(_direction, _direction, this.speed);
    }
    this.object.translateLocal(_direction);
  }
  press(e) {
    if (e.keyCode === 38 || e.keyCode === 87 || e.keyCode === 90) {
      this.up = true;
    } else if (e.keyCode === 39 || e.keyCode === 68) {
      this.right = true;
    } else if (e.keyCode === 40 || e.keyCode === 83) {
      this.down = true;
    } else if (e.keyCode === 37 || e.keyCode === 65 || e.keyCode === 81) {
      this.left = true;
    }
  }
  release(e) {
    if (e.keyCode === 38 || e.keyCode === 87 || e.keyCode === 90) {
      this.up = false;
    } else if (e.keyCode === 39 || e.keyCode === 68) {
      this.right = false;
    } else if (e.keyCode === 40 || e.keyCode === 83) {
      this.down = false;
    } else if (e.keyCode === 37 || e.keyCode === 65 || e.keyCode === 81) {
      this.left = false;
    }
  }
};
__publicField(WasdControlsComponent, "TypeName", "wasd-controls");
__publicField(WasdControlsComponent, "Properties", {
  /** Movement speed in m/s. */
  speed: { type: Type.Float, default: 0.1 },
  /** Flag for only moving the object on the global x & z planes */
  lockY: { type: Type.Bool, default: false },
  /** Object of which the orientation is used to determine forward direction */
  headObject: { type: Type.Object }
});

// js/button.js
function hapticFeedback(object, strength, duration) {
  const input = object.getComponent(InputComponent);
  if (input && input.xrInputSource) {
    const gamepad = input.xrInputSource.gamepad;
    if (gamepad && gamepad.hapticActuators)
      gamepad.hapticActuators[0].pulse(strength, duration);
  }
}
var ButtonComponent = class extends Component {
  static onRegister(engine2) {
    engine2.registerComponent(HowlerAudioSource);
    engine2.registerComponent(CursorTarget);
  }
  /* Position to return to when "unpressing" the button */
  returnPos = new Float32Array(3);
  start() {
    this.mesh = this.buttonMeshObject.getComponent(MeshComponent);
    this.defaultMaterial = this.mesh.material;
    this.buttonMeshObject.getTranslationLocal(this.returnPos);
    this.target = this.object.getComponent(CursorTarget) || this.object.addComponent(CursorTarget);
    this.soundClick = this.object.addComponent(HowlerAudioSource, {
      src: "sfx/click.wav",
      spatial: true
    });
    this.soundUnClick = this.object.addComponent(HowlerAudioSource, {
      src: "sfx/unclick.wav",
      spatial: true
    });
  }
  onActivate() {
    this.target.onHover.add(this.onHover);
    this.target.onUnhover.add(this.onUnhover);
    this.target.onDown.add(this.onDown);
    this.target.onUp.add(this.onUp);
  }
  onDeactivate() {
    this.target.onHover.remove(this.onHover);
    this.target.onUnhover.remove(this.onUnhover);
    this.target.onDown.remove(this.onDown);
    this.target.onUp.remove(this.onUp);
  }
  /* Called by 'cursor-target' */
  onHover = (_, cursor) => {
    this.mesh.material = this.hoverMaterial;
    if (cursor.type === "finger-cursor") {
      this.onDown(_, cursor);
    }
    hapticFeedback(cursor.object, 0.5, 50);
  };
  /* Called by 'cursor-target' */
  onDown = (_, cursor) => {
    this.soundClick.play();
    this.buttonMeshObject.translate([0, -0.1, 0]);
    hapticFeedback(cursor.object, 1, 20);
  };
  /* Called by 'cursor-target' */
  onUp = (_, cursor) => {
    this.soundUnClick.play();
    this.buttonMeshObject.setTranslationLocal(this.returnPos);
    hapticFeedback(cursor.object, 0.7, 20);
  };
  /* Called by 'cursor-target' */
  onUnhover = (_, cursor) => {
    this.mesh.material = this.defaultMaterial;
    if (cursor.type === "finger-cursor") {
      this.onUp(_, cursor);
    }
    hapticFeedback(cursor.object, 0.3, 50);
  };
};
__publicField(ButtonComponent, "TypeName", "button");
__publicField(ButtonComponent, "Properties", {
  /** Object that has the button's mesh attached */
  buttonMeshObject: Property.object(),
  /** Material to apply when the user hovers the button */
  hoverMaterial: Property.material()
});

// js/pp/index.js
var pp_exports = {};
__export(pp_exports, {
  AddPPToWindowComponent: () => AddPPToWindowComponent,
  AddWLToWindowComponent: () => AddWLToWindowComponent,
  AdjustHierarchyPhysXScaleComponent: () => AdjustHierarchyPhysXScaleComponent,
  AnalyticsUtils: () => AnalyticsUtils,
  ArrayUtils: () => ArrayUtils,
  AudioEvent: () => AudioEvent,
  AudioManager: () => AudioManager,
  AudioManagerComponent: () => AudioManagerComponent,
  AudioPlayer: () => AudioPlayer,
  AudioSetup: () => AudioSetup,
  AudioUtils: () => AudioUtils,
  BaseGamepad: () => BaseGamepad,
  BasePose: () => BasePose,
  BasePoseParams: () => BasePoseParams,
  BenchmarkMaxPhysXComponent: () => BenchmarkMaxPhysXComponent,
  BenchmarkMaxVisibleTrianglesComponent: () => BenchmarkMaxVisibleTrianglesComponent,
  BrowserUtils: () => BrowserUtils,
  CADisplayLeaderboardComponent: () => CADisplayLeaderboardComponent,
  CADummyServer: () => CADummyServer,
  CAError: () => CAError,
  CAUtils: () => CAUtils,
  CharacterColliderAdditionalParams: () => CharacterColliderAdditionalParams,
  CharacterColliderDebugParams: () => CharacterColliderDebugParams,
  CharacterColliderHorizontalCheckParams: () => CharacterColliderHorizontalCheckParams,
  CharacterColliderHorizontalPositionVerticalCheckDirection: () => CharacterColliderHorizontalPositionVerticalCheckDirection,
  CharacterColliderSetup: () => CharacterColliderSetup,
  CharacterColliderSetupSimplifiedCreationAccuracyLevel: () => CharacterColliderSetupSimplifiedCreationAccuracyLevel,
  CharacterColliderSetupSimplifiedCreationParams: () => CharacterColliderSetupSimplifiedCreationParams,
  CharacterColliderSetupUtils: () => CharacterColliderSetupUtils,
  CharacterColliderSlideFlickerPreventionMode: () => CharacterColliderSlideFlickerPreventionMode,
  CharacterColliderSplitMovementParams: () => CharacterColliderSplitMovementParams,
  CharacterColliderSurfaceParams: () => CharacterColliderSurfaceParams,
  CharacterColliderVerticalCheckParams: () => CharacterColliderVerticalCheckParams,
  CharacterColliderWallSlideParams: () => CharacterColliderWallSlideParams,
  CharacterCollisionCheckTransformResults: () => CharacterCollisionCheckTransformResults,
  CharacterCollisionCheckType: () => CharacterCollisionCheckType,
  CharacterCollisionDebugResults: () => CharacterCollisionDebugResults,
  CharacterCollisionInternalResults: () => CharacterCollisionInternalResults,
  CharacterCollisionMovementResults: () => CharacterCollisionMovementResults,
  CharacterCollisionResults: () => CharacterCollisionResults,
  CharacterCollisionSplitMovementResults: () => CharacterCollisionSplitMovementResults,
  CharacterCollisionSurfaceInfo: () => CharacterCollisionSurfaceInfo,
  CharacterCollisionSurfaceResults: () => CharacterCollisionSurfaceResults,
  CharacterCollisionSystem: () => CharacterCollisionSystem,
  CharacterCollisionSystemComponent: () => CharacterCollisionSystemComponent,
  CharacterCollisionTeleportResults: () => CharacterCollisionTeleportResults,
  CharacterCollisionTransformResults: () => CharacterCollisionTransformResults,
  CharacterCollisionWallSlideResults: () => CharacterCollisionWallSlideResults,
  ClassicGamepadCore: () => ClassicGamepadCore,
  ClearConsoleOnXRSessionStartComponent: () => ClearConsoleOnXRSessionStartComponent,
  CloneParams: () => CloneParams,
  CollisionCheck: () => CollisionCheck,
  CollisionCheckBridge: () => CollisionCheckBridge,
  CollisionCheckParams: () => CollisionCheckParams,
  CollisionCheckUtils: () => CollisionCheckUtils,
  CollisionRuntimeParams: () => CollisionRuntimeParams,
  ColorUtils: () => ColorUtils,
  ComponentUtils: () => ComponentUtils,
  ConsoleOriginalFunctions: () => ConsoleOriginalFunctions,
  ConsoleVR: () => ConsoleVR,
  ConsoleVRToolComponent: () => ConsoleVRToolComponent,
  ConsoleVRWidget: () => ConsoleVRWidget,
  ConsoleVRWidgetConfig: () => ConsoleVRWidgetConfig,
  ConsoleVRWidgetConsoleFunction: () => ConsoleVRWidgetConsoleFunction,
  ConsoleVRWidgetMessage: () => ConsoleVRWidgetMessage,
  ConsoleVRWidgetMessageType: () => ConsoleVRWidgetMessageType,
  ConsoleVRWidgetParams: () => ConsoleVRWidgetParams,
  ConsoleVRWidgetPulseOnNewMessage: () => ConsoleVRWidgetPulseOnNewMessage,
  ConsoleVRWidgetSender: () => ConsoleVRWidgetSender,
  ConsoleVRWidgetUI: () => ConsoleVRWidgetUI,
  CopyHandTransformComponent: () => CopyHandTransformComponent,
  CopyHeadTransformComponent: () => CopyHeadTransformComponent,
  CopyPlayerTransformComponent: () => CopyPlayerTransformComponent,
  CopyReferenceSpaceTransformComponent: () => CopyReferenceSpaceTransformComponent,
  CustomCloneParams: () => CustomCloneParams,
  DebugArrayFunctionsPerformanceAnalyzerComponent: () => DebugArrayFunctionsPerformanceAnalyzerComponent,
  DebugFunctionPerformanceAnalysisResults: () => DebugFunctionPerformanceAnalysisResults,
  DebugFunctionsOverwriter: () => DebugFunctionsOverwriter,
  DebugFunctionsOverwriterParams: () => DebugFunctionsOverwriterParams,
  DebugFunctionsPerformanceAnalysisResultsLogger: () => DebugFunctionsPerformanceAnalysisResultsLogger,
  DebugFunctionsPerformanceAnalysisResultsLoggerParams: () => DebugFunctionsPerformanceAnalysisResultsLoggerParams,
  DebugFunctionsPerformanceAnalyzer: () => DebugFunctionsPerformanceAnalyzer,
  DebugFunctionsPerformanceAnalyzerComponent: () => DebugFunctionsPerformanceAnalyzerComponent,
  DebugFunctionsPerformanceAnalyzerParams: () => DebugFunctionsPerformanceAnalyzerParams,
  DebugFunctionsPerformanceAnalyzerSortOrder: () => DebugFunctionsPerformanceAnalyzerSortOrder,
  DebugManager: () => DebugManager,
  DebugManagerComponent: () => DebugManagerComponent,
  DebugPPArrayCreationPerformanceAnalyzerComponent: () => DebugPPArrayCreationPerformanceAnalyzerComponent,
  DebugPPFunctionsPerformanceAnalyzerComponent: () => DebugPPFunctionsPerformanceAnalyzerComponent,
  DebugTransformComponent: () => DebugTransformComponent,
  DebugVisualManager: () => DebugVisualManager,
  DebugWLComponentsFunctionsPerformanceAnalyzerComponent: () => DebugWLComponentsFunctionsPerformanceAnalyzerComponent,
  DebugWLFunctionsPerformanceAnalyzerComponent: () => DebugWLFunctionsPerformanceAnalyzerComponent,
  DeepCloneParams: () => DeepCloneParams,
  DefaultResources: () => DefaultResources,
  DefaultResourcesMaterials: () => DefaultResourcesMaterials,
  DefaultResourcesMeshes: () => DefaultResourcesMeshes,
  DefaultWLComponentCloneCallbacks: () => DefaultWLComponentCloneCallbacks,
  Direction2DTo3DConverter: () => Direction2DTo3DConverter,
  Direction2DTo3DConverterParams: () => Direction2DTo3DConverterParams,
  EPSILON: () => EPSILON2,
  EPSILON_DEGREES: () => EPSILON_DEGREES,
  EPSILON_SQUARED: () => EPSILON_SQUARED,
  EasingFunction: () => EasingFunction,
  EasyLightAttenuation: () => EasyLightAttenuation,
  EasyLightAttenuationComponent: () => EasyLightAttenuationComponent,
  EasyLightColor: () => EasyLightColor,
  EasyLightColorComponent: () => EasyLightColorComponent,
  EasyMeshAmbientFactor: () => EasyMeshAmbientFactor,
  EasyMeshAmbientFactorComponent: () => EasyMeshAmbientFactorComponent,
  EasyMeshColor: () => EasyMeshColor,
  EasyMeshColorComponent: () => EasyMeshColorComponent,
  EasyObjectTuner: () => EasyObjectTuner,
  EasyScale: () => EasyScale,
  EasyScaleComponent: () => EasyScaleComponent,
  EasySetTuneTargeetGrabComponent: () => EasySetTuneTargeetGrabComponent,
  EasySetTuneTargetChildNumberComponent: () => EasySetTuneTargetChildNumberComponent,
  EasyTextColor: () => EasyTextColor,
  EasyTextColorComponent: () => EasyTextColorComponent,
  EasyTransform: () => EasyTransform,
  EasyTransformComponent: () => EasyTransformComponent,
  EasyTuneBaseArrayWidgetSelector: () => EasyTuneBaseArrayWidgetSelector,
  EasyTuneBaseWidget: () => EasyTuneBaseWidget,
  EasyTuneBaseWidgetConfig: () => EasyTuneBaseWidgetConfig,
  EasyTuneBaseWidgetParams: () => EasyTuneBaseWidgetParams,
  EasyTuneBaseWidgetUI: () => EasyTuneBaseWidgetUI,
  EasyTuneBool: () => EasyTuneBool,
  EasyTuneBoolArray: () => EasyTuneBoolArray,
  EasyTuneBoolArrayWidget: () => EasyTuneBoolArrayWidget,
  EasyTuneBoolArrayWidgetConfig: () => EasyTuneBoolArrayWidgetConfig,
  EasyTuneBoolArrayWidgetSelector: () => EasyTuneBoolArrayWidgetSelector,
  EasyTuneBoolArrayWidgetUI: () => EasyTuneBoolArrayWidgetUI,
  EasyTuneImportVariablesComponent: () => EasyTuneImportVariablesComponent,
  EasyTuneInt: () => EasyTuneInt,
  EasyTuneIntArray: () => EasyTuneIntArray,
  EasyTuneNoneWidget: () => EasyTuneNoneWidget,
  EasyTuneNoneWidgetConfig: () => EasyTuneNoneWidgetConfig,
  EasyTuneNoneWidgetUI: () => EasyTuneNoneWidgetUI,
  EasyTuneNumber: () => EasyTuneNumber,
  EasyTuneNumberArray: () => EasyTuneNumberArray,
  EasyTuneNumberArrayWidget: () => EasyTuneNumberArrayWidget,
  EasyTuneNumberArrayWidgetConfig: () => EasyTuneNumberArrayWidgetConfig,
  EasyTuneNumberArrayWidgetSelector: () => EasyTuneNumberArrayWidgetSelector,
  EasyTuneNumberArrayWidgetUI: () => EasyTuneNumberArrayWidgetUI,
  EasyTuneToolComponent: () => EasyTuneToolComponent,
  EasyTuneTransform: () => EasyTuneTransform,
  EasyTuneTransformWidget: () => EasyTuneTransformWidget,
  EasyTuneTransformWidgetConfig: () => EasyTuneTransformWidgetConfig,
  EasyTuneTransformWidgetUI: () => EasyTuneTransformWidgetUI,
  EasyTuneUtils: () => EasyTuneUtils,
  EasyTuneVariable: () => EasyTuneVariable,
  EasyTuneVariableArray: () => EasyTuneVariableArray,
  EasyTuneVariableType: () => EasyTuneVariableType,
  EasyTuneVariables: () => EasyTuneVariables,
  EasyTuneWidget: () => EasyTuneWidget,
  EasyTuneWidgetConfig: () => EasyTuneWidgetConfig,
  EasyTuneWidgetParams: () => EasyTuneWidgetParams,
  EnableDebugComponent: () => EnableDebugComponent,
  EnableToolComponent: () => EnableToolComponent,
  FSM: () => FSM,
  FingerCursorComponent: () => FingerCursorComponent,
  GamepadAxesEvent: () => GamepadAxesEvent,
  GamepadAxesID: () => GamepadAxesID,
  GamepadAxesInfo: () => GamepadAxesInfo,
  GamepadButtonEvent: () => GamepadButtonEvent,
  GamepadButtonID: () => GamepadButtonID,
  GamepadButtonInfo: () => GamepadButtonInfo,
  GamepadControlSchemeComponent: () => GamepadControlSchemeComponent,
  GamepadCore: () => GamepadCore,
  GamepadMeshAnimatorComponent: () => GamepadMeshAnimatorComponent,
  GamepadPulseInfo: () => GamepadPulseInfo,
  GamepadUtils: () => GamepadUtils,
  GamepadsManager: () => GamepadsManager,
  GetDefaultResourcesComponent: () => GetDefaultResourcesComponent,
  GetSceneObjectsComponent: () => GetSceneObjectsComponent,
  Globals: () => Globals,
  GrabbableComponent: () => GrabbableComponent,
  GrabberHandComponent: () => GrabberHandComponent,
  HandPose: () => HandPose,
  HandPoseParams: () => HandPoseParams,
  Handedness: () => Handedness,
  HandednessIndex: () => HandednessIndex,
  HeadPose: () => HeadPose,
  HowlerAudioPlayer: () => HowlerAudioPlayer,
  InitConsoleVRComponent: () => InitConsoleVRComponent,
  InitEasyTuneVariablesComponent: () => InitEasyTuneVariablesComponent,
  InputManager: () => InputManager,
  InputManagerComponent: () => InputManagerComponent,
  InputSourceType: () => InputSourceType,
  InputUtils: () => InputUtils,
  IntOverFactor: () => IntOverFactor,
  IntRangeOverFactor: () => IntRangeOverFactor,
  JSUtils: () => JSUtils,
  KeyID: () => KeyID,
  Keyboard: () => Keyboard,
  KeyboardGamepadCore: () => KeyboardGamepadCore,
  Mat3Utils: () => Mat3Utils,
  Mat4Utils: () => Mat4Utils,
  MaterialUtils: () => MaterialUtils,
  MathUtils: () => MathUtils,
  MeshCreationParams: () => MeshCreationParams,
  MeshCreationTriangleParams: () => MeshCreationTriangleParams,
  MeshCreationVertexParams: () => MeshCreationVertexParams,
  MeshUtils: () => MeshUtils,
  Mouse: () => Mouse,
  MouseButtonID: () => MouseButtonID,
  MuteEverythingComponent: () => MuteEverythingComponent,
  NumberOverFactor: () => NumberOverFactor,
  NumberRangeOverFactor: () => NumberRangeOverFactor,
  ObjectPool: () => ObjectPool,
  ObjectPoolManager: () => ObjectPoolManager,
  ObjectPoolManagerComponent: () => ObjectPoolManagerComponent,
  ObjectPoolParams: () => ObjectPoolParams,
  ObjectUtils: () => ObjectUtils,
  PPGatewayComponent: () => PPGatewayComponent,
  PerformDelayedMode: () => PerformDelayedMode,
  PerformMode: () => PerformMode,
  PhysicsCollisionCollector: () => PhysicsCollisionCollector,
  PhysicsLayerFlags: () => PhysicsLayerFlags,
  PhysicsUtils: () => PhysicsUtils,
  PlayerHeadManager: () => PlayerHeadManager,
  PlayerHeadManagerParams: () => PlayerHeadManagerParams,
  PlayerLocomotion: () => PlayerLocomotion,
  PlayerLocomotionComponent: () => PlayerLocomotionComponent,
  PlayerLocomotionDirectionReferenceType: () => PlayerLocomotionDirectionReferenceType,
  PlayerLocomotionMovement: () => PlayerLocomotionMovement,
  PlayerLocomotionMovementRuntimeParams: () => PlayerLocomotionMovementRuntimeParams,
  PlayerLocomotionParams: () => PlayerLocomotionParams,
  PlayerLocomotionRotate: () => PlayerLocomotionRotate,
  PlayerLocomotionRotateParams: () => PlayerLocomotionRotateParams,
  PlayerLocomotionSmooth: () => PlayerLocomotionSmooth,
  PlayerLocomotionSmoothParams: () => PlayerLocomotionSmoothParams,
  PlayerLocomotionTeleport: () => PlayerLocomotionTeleport,
  PlayerLocomotionTeleportDetectionParams: () => PlayerLocomotionTeleportDetectionParams,
  PlayerLocomotionTeleportDetectionRuntimeParams: () => PlayerLocomotionTeleportDetectionRuntimeParams,
  PlayerLocomotionTeleportDetectionState: () => PlayerLocomotionTeleportDetectionState,
  PlayerLocomotionTeleportDetectionVisualizer: () => PlayerLocomotionTeleportDetectionVisualizer,
  PlayerLocomotionTeleportDetectionVisualizerParams: () => PlayerLocomotionTeleportDetectionVisualizerParams,
  PlayerLocomotionTeleportParable: () => PlayerLocomotionTeleportParable,
  PlayerLocomotionTeleportParams: () => PlayerLocomotionTeleportParams,
  PlayerLocomotionTeleportRuntimeParams: () => PlayerLocomotionTeleportRuntimeParams,
  PlayerLocomotionTeleportState: () => PlayerLocomotionTeleportState,
  PlayerLocomotionTeleportTeleportBlinkState: () => PlayerLocomotionTeleportTeleportBlinkState,
  PlayerLocomotionTeleportTeleportParams: () => PlayerLocomotionTeleportTeleportParams,
  PlayerLocomotionTeleportTeleportShiftState: () => PlayerLocomotionTeleportTeleportShiftState,
  PlayerLocomotionTeleportTeleportState: () => PlayerLocomotionTeleportTeleportState,
  PlayerLocomotionTeleportTeleportType: () => PlayerLocomotionTeleportTeleportType,
  PlayerLocomotionType: () => PlayerLocomotionType,
  PlayerObjects: () => PlayerObjects,
  PlayerObscureManager: () => PlayerObscureManager,
  PlayerObscureManagerParams: () => PlayerObscureManagerParams,
  PlayerTransformManager: () => PlayerTransformManager,
  PlayerTransformManagerParams: () => PlayerTransformManagerParams,
  PlayerTransformManagerSyncFlag: () => PlayerTransformManagerSyncFlag,
  PluginUtils: () => PluginUtils,
  Quat2Utils: () => Quat2Utils,
  QuatUtils: () => QuatUtils,
  RaycastHit: () => RaycastHit,
  RaycastParams: () => RaycastParams,
  RaycastResults: () => RaycastResults,
  SaveManager: () => SaveManager,
  SaveUtils: () => SaveUtils,
  SceneObjects: () => SceneObjects,
  SceneUtils: () => SceneUtils,
  SetActiveComponent: () => SetActiveComponent,
  SetHandLocalTransformComponent: () => SetHandLocalTransformComponent,
  SetHeadLocalTransformComponent: () => SetHeadLocalTransformComponent,
  SetPlayerHeightComponent: () => SetPlayerHeightComponent,
  SetTrackedHandJointLocalTransformComponent: () => SetTrackedHandJointLocalTransformComponent,
  ShowFPSComponent: () => ShowFPSComponent,
  SkipStateFunction: () => SkipStateFunction,
  SpatialAudioListenerComponent: () => SpatialAudioListenerComponent,
  State: () => State,
  StateData: () => StateData,
  SwitchHandObjectComponent: () => SwitchHandObjectComponent,
  TextUtils: () => TextUtils,
  Timer: () => Timer,
  TimerState: () => TimerState,
  ToolCursorComponent: () => ToolCursorComponent,
  ToolHandedness: () => ToolHandedness,
  ToolInputSourceType: () => ToolInputSourceType,
  TrackedHandDrawAllJointsComponent: () => TrackedHandDrawAllJointsComponent,
  TrackedHandDrawJointComponent: () => TrackedHandDrawJointComponent,
  TrackedHandDrawSkinComponent: () => TrackedHandDrawSkinComponent,
  TrackedHandJointID: () => TrackedHandJointID,
  TrackedHandJointIDIndex: () => TrackedHandJointIDIndex,
  TrackedHandJointPose: () => TrackedHandJointPose,
  TrackedHandPose: () => TrackedHandPose,
  TrackedHandPoseParams: () => TrackedHandPoseParams,
  Transition: () => Transition,
  TransitionData: () => TransitionData,
  UniversalGamepad: () => UniversalGamepad,
  Vec2Utils: () => Vec2Utils,
  Vec3Utils: () => Vec3Utils,
  Vec4Utils: () => Vec4Utils,
  VecUtils: () => VecUtils,
  VirtualGamepad: () => VirtualGamepad,
  VirtualGamepadButtonParams: () => VirtualGamepadButtonParams,
  VirtualGamepadComponent: () => VirtualGamepadComponent,
  VirtualGamepadGamepadCore: () => VirtualGamepadGamepadCore,
  VirtualGamepadIcon: () => VirtualGamepadIcon,
  VirtualGamepadIconParams: () => VirtualGamepadIconParams,
  VirtualGamepadIconType: () => VirtualGamepadIconType,
  VirtualGamepadParams: () => VirtualGamepadParams,
  VirtualGamepadThumbstickParams: () => VirtualGamepadThumbstickParams,
  VirtualGamepadVirtualButton: () => VirtualGamepadVirtualButton,
  VirtualGamepadVirtualThumbstick: () => VirtualGamepadVirtualThumbstick,
  VisualArrow: () => VisualArrow,
  VisualArrowParams: () => VisualArrowParams,
  VisualElementType: () => VisualElementType,
  VisualLine: () => VisualLine,
  VisualLineParams: () => VisualLineParams,
  VisualManager: () => VisualManager,
  VisualManagerComponent: () => VisualManagerComponent,
  VisualMesh: () => VisualMesh,
  VisualMeshParams: () => VisualMeshParams,
  VisualPoint: () => VisualPoint,
  VisualPointParams: () => VisualPointParams,
  VisualRaycast: () => VisualRaycast,
  VisualRaycastParams: () => VisualRaycastParams,
  VisualResources: () => VisualResources,
  VisualResourcesMaterials: () => VisualResourcesMaterials,
  VisualText: () => VisualText,
  VisualTextParams: () => VisualTextParams,
  VisualTorus: () => VisualTorus,
  VisualTorusParams: () => VisualTorusParams,
  VisualTransform: () => VisualTransform,
  VisualTransformParams: () => VisualTransformParams,
  WidgetFrame: () => WidgetFrame,
  WidgetFrameConfig: () => WidgetFrameConfig,
  WidgetFrameUI: () => WidgetFrameUI,
  WidgetParams: () => WidgetParams,
  XRGamepadCore: () => XRGamepadCore,
  XRUtils: () => XRUtils,
  add: () => add8,
  addComponent: () => addComponent,
  addEngine: () => addEngine,
  addRefreshWidgetCallback: () => addRefreshWidgetCallback,
  addSetWidgetCurrentVariableCallback: () => addSetWidgetCurrentVariableCallback,
  angle: () => angle3,
  angleClamp: () => angleClamp,
  angleClampDegrees: () => angleClampDegrees,
  angleClampRadians: () => angleClampRadians,
  angleDegrees: () => angleDegrees,
  angleDistance: () => angleDistance,
  angleDistanceDegrees: () => angleDistanceDegrees,
  angleDistanceRadians: () => angleDistanceRadians,
  angleDistanceSigned: () => angleDistanceSigned,
  angleDistanceSignedDegrees: () => angleDistanceSignedDegrees,
  angleDistanceSignedRadians: () => angleDistanceSignedRadians,
  anglePivoted: () => anglePivoted,
  anglePivotedDegrees: () => anglePivotedDegrees,
  anglePivotedRadians: () => anglePivotedRadians,
  anglePivotedSigned: () => anglePivotedSigned,
  anglePivotedSignedDegrees: () => anglePivotedSignedDegrees,
  anglePivotedSignedRadians: () => anglePivotedSignedRadians,
  angleRadians: () => angleRadians,
  angleSigned: () => angleSigned,
  angleSignedDegrees: () => angleSignedDegrees,
  angleSignedRadians: () => angleSignedRadians,
  areButtonsPressEnd: () => areButtonsPressEnd,
  areButtonsPressStart: () => areButtonsPressStart,
  areButtonsTouchEnd: () => areButtonsTouchEnd,
  areButtonsTouchStart: () => areButtonsTouchStart,
  assert: () => assert2,
  ceil: () => ceil4,
  checkMovement: () => checkMovement,
  checkTeleportToTransform: () => checkTeleportToTransform,
  checkTransform: () => checkTransform,
  cleanObjectProperties: () => cleanObjectProperties,
  cloneCollision: () => cloneCollision,
  cloneDefault: () => cloneDefault,
  cloneMesh: () => cloneMesh,
  clonePhysX: () => clonePhysX,
  clonePostProcess: () => clonePostProcess,
  cloneText: () => cloneText,
  color1To255: () => color1To255,
  color255To1: () => color255To1,
  componentAlongAxis: () => componentAlongAxis,
  convertCharacterColliderSetupToCollisionCheckParams: () => convertCharacterColliderSetupToCollisionCheckParams,
  convertCharacterCollisionResultsToCollisionRuntimeParams: () => convertCharacterCollisionResultsToCollisionRuntimeParams,
  convertCollisionRuntimeParamsToCharacterCollisionResults: () => convertCollisionRuntimeParamsToCharacterCollisionResults,
  convertDirectionLocalToObject: () => convertDirectionLocalToObject,
  convertDirectionLocalToWorld: () => convertDirectionLocalToWorld,
  convertDirectionObjectToLocal: () => convertDirectionObjectToLocal,
  convertDirectionObjectToWorld: () => convertDirectionObjectToWorld,
  convertDirectionToLocal: () => convertDirectionToLocal,
  convertDirectionToLocalMatrix: () => convertDirectionToLocalMatrix,
  convertDirectionToLocalQuat: () => convertDirectionToLocalQuat,
  convertDirectionToWorld: () => convertDirectionToWorld,
  convertDirectionToWorldMatrix: () => convertDirectionToWorldMatrix,
  convertDirectionToWorldQuat: () => convertDirectionToWorldQuat,
  convertDirectionWorldToLocal: () => convertDirectionWorldToLocal,
  convertDirectionWorldToObject: () => convertDirectionWorldToObject,
  convertPositionLocalToObject: () => convertPositionLocalToObject,
  convertPositionLocalToWorld: () => convertPositionLocalToWorld,
  convertPositionObjectToLocal: () => convertPositionObjectToLocal,
  convertPositionObjectToWorld: () => convertPositionObjectToWorld,
  convertPositionToLocal: () => convertPositionToLocal,
  convertPositionToLocalMatrix: () => convertPositionToLocalMatrix,
  convertPositionToLocalQuat: () => convertPositionToLocalQuat,
  convertPositionToWorld: () => convertPositionToWorld,
  convertPositionToWorldMatrix: () => convertPositionToWorldMatrix,
  convertPositionToWorldQuat: () => convertPositionToWorldQuat,
  convertPositionWorldToLocal: () => convertPositionWorldToLocal,
  convertPositionWorldToObject: () => convertPositionWorldToObject,
  convertTransformLocalToObject: () => convertTransformLocalToObject,
  convertTransformLocalToObjectMatrix: () => convertTransformLocalToObjectMatrix,
  convertTransformLocalToObjectQuat: () => convertTransformLocalToObjectQuat,
  convertTransformLocalToWorld: () => convertTransformLocalToWorld,
  convertTransformLocalToWorldMatrix: () => convertTransformLocalToWorldMatrix,
  convertTransformLocalToWorldQuat: () => convertTransformLocalToWorldQuat,
  convertTransformObjectToLocal: () => convertTransformObjectToLocal,
  convertTransformObjectToLocalMatrix: () => convertTransformObjectToLocalMatrix,
  convertTransformObjectToLocalQuat: () => convertTransformObjectToLocalQuat,
  convertTransformObjectToWorld: () => convertTransformObjectToWorld,
  convertTransformObjectToWorldMatrix: () => convertTransformObjectToWorldMatrix,
  convertTransformObjectToWorldQuat: () => convertTransformObjectToWorldQuat,
  convertTransformWorldToLocal: () => convertTransformWorldToLocal,
  convertTransformWorldToLocalMatrix: () => convertTransformWorldToLocalMatrix,
  convertTransformWorldToLocalQuat: () => convertTransformWorldToLocalQuat,
  convertTransformWorldToObject: () => convertTransformWorldToObject,
  convertTransformWorldToObjectMatrix: () => convertTransformWorldToObjectMatrix,
  convertTransformWorldToObjectQuat: () => convertTransformWorldToObjectQuat,
  copyComponentAlongAxis: () => copyComponentAlongAxis,
  copyObjectProperties: () => copyObjectProperties,
  createPlane: () => createPlane,
  createSimplified: () => createSimplified,
  createTeleportColliderSetupFromMovementColliderSetup: () => createTeleportColliderSetupFromMovementColliderSetup,
  cross: () => cross4,
  debug: () => debug,
  degreesAddRotation: () => degreesAddRotation,
  degreesAddRotationDegrees: () => degreesAddRotationDegrees,
  degreesAddRotationQuat: () => degreesAddRotationQuat,
  degreesAddRotationRadians: () => degreesAddRotationRadians,
  degreesToMatrix: () => degreesToMatrix,
  degreesToQuat: () => degreesToQuat,
  destroy: () => destroy,
  distance: () => distance4,
  distanceSquared: () => distanceSquared,
  div: () => div4,
  doesObjectPropertyUseAccessors: () => doesObjectPropertyUseAccessors,
  dot: () => dot6,
  exitSession: () => exitSession,
  exportVariables: () => exportVariables,
  find: () => find,
  findAll: () => findAll,
  findAllEqual: () => findAllEqual,
  findAllIndexes: () => findAllIndexes,
  findAllIndexesEqual: () => findAllIndexesEqual,
  findEqual: () => findEqual,
  findIndex: () => findIndex,
  findIndexEqual: () => findIndexEqual,
  first: () => first,
  floor: () => floor4,
  fromAxis: () => fromAxis,
  fromAxisDegrees: () => fromAxisDegrees,
  fromAxisRadians: () => fromAxisRadians,
  fromDegrees: () => fromDegrees,
  fromMatrix: () => fromMatrix,
  fromQuat: () => fromQuat4,
  fromRadians: () => fromRadians,
  fromTwistSwing: () => fromTwistSwing,
  generate360TeleportParamsFromMovementParams: () => generate360TeleportParamsFromMovementParams,
  getAngle: () => getAngle2,
  getAngleDegrees: () => getAngleDegrees,
  getAngleRadians: () => getAngleRadians,
  getAssert: () => getAssert,
  getAudioManager: () => getAudioManager,
  getAxesLocal: () => getAxesLocal,
  getAxesWorld: () => getAxesWorld,
  getAxis: () => getAxis,
  getAxisScaled: () => getAxisScaled,
  getAxisScaledDegrees: () => getAxisScaledDegrees,
  getAxisScaledRadians: () => getAxisScaledRadians,
  getBackwardLocal: () => getBackwardLocal,
  getBackwardWorld: () => getBackwardWorld,
  getBody: () => getBody,
  getCanvas: () => getCanvas,
  getCharacterCollisionSystem: () => getCharacterCollisionSystem,
  getChildren: () => getChildren,
  getClassFromType: () => getClassFromType,
  getClear: () => getClear,
  getCloneCallback: () => getCloneCallback,
  getClonePostProcessCallback: () => getClonePostProcessCallback,
  getCollisionCheck: () => getCollisionCheck,
  getComponentBreadth: () => getComponentBreadth,
  getComponentChildren: () => getComponentChildren,
  getComponentDepth: () => getComponentDepth,
  getComponentDescendants: () => getComponentDescendants,
  getComponentDescendantsBreadth: () => getComponentDescendantsBreadth,
  getComponentDescendantsDepth: () => getComponentDescendantsDepth,
  getComponentHierarchy: () => getComponentHierarchy,
  getComponentHierarchyBreadth: () => getComponentHierarchyBreadth,
  getComponentHierarchyDepth: () => getComponentHierarchyDepth,
  getComponentObjects: () => getComponentObjects,
  getComponentSelf: () => getComponentSelf,
  getComponentsAmountMapChildren: () => getComponentsAmountMapChildren,
  getComponentsAmountMapDescendants: () => getComponentsAmountMapDescendants,
  getComponentsAmountMapHierarchy: () => getComponentsAmountMapHierarchy,
  getComponentsAmountMapSelf: () => getComponentsAmountMapSelf,
  getComponentsBreadth: () => getComponentsBreadth,
  getComponentsChildren: () => getComponentsChildren,
  getComponentsDepth: () => getComponentsDepth,
  getComponentsDescendants: () => getComponentsDescendants,
  getComponentsDescendantsBreadth: () => getComponentsDescendantsBreadth,
  getComponentsDescendantsDepth: () => getComponentsDescendantsDepth,
  getComponentsHierarchy: () => getComponentsHierarchy,
  getComponentsHierarchyBreadth: () => getComponentsHierarchyBreadth,
  getComponentsHierarchyDepth: () => getComponentsHierarchyDepth,
  getComponentsObjects: () => getComponentsObjects,
  getComponentsSelf: () => getComponentsSelf,
  getConsoleVR: () => getConsoleVR,
  getDebug: () => getDebug,
  getDebugManager: () => getDebugManager,
  getDebugVisualManager: () => getDebugVisualManager,
  getDefaultMaterials: () => getDefaultMaterials,
  getDefaultMeshes: () => getDefaultMeshes,
  getDefaultResources: () => getDefaultResources,
  getDefaultWLComponentCloneCallback: () => getDefaultWLComponentCloneCallback,
  getDescendants: () => getDescendants,
  getDescendantsBreadth: () => getDescendantsBreadth,
  getDescendantsDepth: () => getDescendantsDepth,
  getDocument: () => getDocument,
  getDownLocal: () => getDownLocal,
  getDownWorld: () => getDownWorld,
  getDummyServer: () => getDummyServer,
  getEasyTuneTarget: () => getEasyTuneTarget,
  getEasyTuneVariables: () => getEasyTuneVariables,
  getEngine: () => getEngine,
  getEngines: () => getEngines,
  getError: () => getError,
  getForwardLocal: () => getForwardLocal,
  getForwardWorld: () => getForwardWorld,
  getFrame: () => getFrame,
  getGamepad: () => getGamepad,
  getGamepads: () => getGamepads,
  getGamepadsManager: () => getGamepadsManager,
  getHandPose: () => getHandPose,
  getHandPoses: () => getHandPoses,
  getHandednessByIndex: () => getHandednessByIndex,
  getHeadPose: () => getHeadPose,
  getHierarchy: () => getHierarchy,
  getHierarchyBreadth: () => getHierarchyBreadth,
  getHierarchyDepth: () => getHierarchyDepth,
  getID: () => getID,
  getInfo: () => getInfo,
  getInputManager: () => getInputManager,
  getInputSource: () => getInputSource,
  getInputSourceType: () => getInputSourceType,
  getInputSourceTypeByHandedness: () => getInputSourceTypeByHandedness,
  getJavascriptComponentClass: () => getJavascriptComponentClass,
  getJavascriptComponentClassesByIndex: () => getJavascriptComponentClassesByIndex,
  getJavascriptComponentInstances: () => getJavascriptComponentInstances,
  getJavascriptComponentTypeFromIndex: () => getJavascriptComponentTypeFromIndex,
  getJavascriptComponentTypeIndex: () => getJavascriptComponentTypeIndex,
  getJavascriptComponentTypeIndexes: () => getJavascriptComponentTypeIndexes,
  getJointIDByIndex: () => getJointIDByIndex,
  getKeyboard: () => getKeyboard,
  getLayerFlagsNames: () => getLayerFlagsNames,
  getLeaderboard: () => getLeaderboard,
  getLeaderboardDummy: () => getLeaderboardDummy,
  getLeftGamepad: () => getLeftGamepad,
  getLeftHandPose: () => getLeftHandPose,
  getLeftLocal: () => getLeftLocal,
  getLeftTrackedHandPose: () => getLeftTrackedHandPose,
  getLeftWorld: () => getLeftWorld,
  getLog: () => getLog,
  getMainEngine: () => getMainEngine,
  getMouse: () => getMouse,
  getName: () => getName,
  getNavigator: () => getNavigator,
  getObjectByIDBreadth: () => getObjectByIDBreadth,
  getObjectByIDChildren: () => getObjectByIDChildren,
  getObjectByIDDepth: () => getObjectByIDDepth,
  getObjectByIDDescendants: () => getObjectByIDDescendants,
  getObjectByIDDescendantsBreadth: () => getObjectByIDDescendantsBreadth,
  getObjectByIDDescendantsDepth: () => getObjectByIDDescendantsDepth,
  getObjectByIDHierarchy: () => getObjectByIDHierarchy,
  getObjectByIDHierarchyBreadth: () => getObjectByIDHierarchyBreadth,
  getObjectByIDHierarchyDepth: () => getObjectByIDHierarchyDepth,
  getObjectByIDObjects: () => getObjectByIDObjects,
  getObjectByNameBreadth: () => getObjectByNameBreadth,
  getObjectByNameChildren: () => getObjectByNameChildren,
  getObjectByNameDepth: () => getObjectByNameDepth,
  getObjectByNameDescendants: () => getObjectByNameDescendants,
  getObjectByNameDescendantsBreadth: () => getObjectByNameDescendantsBreadth,
  getObjectByNameDescendantsDepth: () => getObjectByNameDescendantsDepth,
  getObjectByNameHierarchy: () => getObjectByNameHierarchy,
  getObjectByNameHierarchyBreadth: () => getObjectByNameHierarchyBreadth,
  getObjectByNameHierarchyDepth: () => getObjectByNameHierarchyDepth,
  getObjectByNameObjects: () => getObjectByNameObjects,
  getObjectFromPath: () => getObjectFromPath,
  getObjectNameFromPath: () => getObjectNameFromPath,
  getObjectParentFromPath: () => getObjectParentFromPath,
  getObjectPoolManager: () => getObjectPoolManager,
  getObjectProperty: () => getObjectProperty,
  getObjectPropertyDescriptor: () => getObjectPropertyDescriptor,
  getObjectPropertyNames: () => getObjectPropertyNames,
  getObjectPropertyOwnParent: () => getObjectPropertyOwnParent,
  getObjectPropertyOwnParents: () => getObjectPropertyOwnParents,
  getObjectPrototypes: () => getObjectPrototypes,
  getObjects: () => getObjects,
  getObjectsBreadth: () => getObjectsBreadth,
  getObjectsByIDObjects: () => getObjectsByIDObjects,
  getObjectsByNameBreadth: () => getObjectsByNameBreadth,
  getObjectsByNameChildren: () => getObjectsByNameChildren,
  getObjectsByNameDepth: () => getObjectsByNameDepth,
  getObjectsByNameDescendants: () => getObjectsByNameDescendants,
  getObjectsByNameDescendantsBreadth: () => getObjectsByNameDescendantsBreadth,
  getObjectsByNameDescendantsDepth: () => getObjectsByNameDescendantsDepth,
  getObjectsByNameHierarchy: () => getObjectsByNameHierarchy,
  getObjectsByNameHierarchyBreadth: () => getObjectsByNameHierarchyBreadth,
  getObjectsByNameHierarchyDepth: () => getObjectsByNameHierarchyDepth,
  getObjectsByNameObjects: () => getObjectsByNameObjects,
  getObjectsDepth: () => getObjectsDepth,
  getOppositeHandedness: () => getOppositeHandedness,
  getParent: () => getParent,
  getPhysics: () => getPhysics,
  getPlayerObjects: () => getPlayerObjects,
  getPositionLocal: () => getPositionLocal,
  getPositionWorld: () => getPositionWorld,
  getReferenceSpace: () => getReferenceSpace,
  getReferenceSpaceType: () => getReferenceSpaceType,
  getRightGamepad: () => getRightGamepad,
  getRightHandPose: () => getRightHandPose,
  getRightLocal: () => getRightLocal,
  getRightTrackedHandPose: () => getRightTrackedHandPose,
  getRightWorld: () => getRightWorld,
  getRotationLocal: () => getRotationLocal,
  getRotationLocalDegrees: () => getRotationLocalDegrees,
  getRotationLocalMatrix: () => getRotationLocalMatrix,
  getRotationLocalQuat: () => getRotationLocalQuat,
  getRotationLocalRadians: () => getRotationLocalRadians,
  getRotationMatrix: () => getRotationMatrix,
  getRotationWorld: () => getRotationWorld,
  getRotationWorldDegrees: () => getRotationWorldDegrees,
  getRotationWorldMatrix: () => getRotationWorldMatrix,
  getRotationWorldQuat: () => getRotationWorldQuat,
  getRotationWorldRadians: () => getRotationWorldRadians,
  getSDK: () => getSDK,
  getScaleLocal: () => getScaleLocal,
  getScaleWorld: () => getScaleWorld,
  getScene: () => getScene,
  getSceneObjects: () => getSceneObjects,
  getSelf: () => getSelf,
  getSession: () => getSession,
  getSessionMode: () => getSessionMode,
  getSimultaneousPressMaxDelay: () => getSimultaneousPressMaxDelay,
  getSimultaneousTouchMaxDelay: () => getSimultaneousTouchMaxDelay,
  getSwing: () => getSwing,
  getSwingFromTwist: () => getSwingFromTwist,
  getTrackedHandPose: () => getTrackedHandPose,
  getTrackedHandPoses: () => getTrackedHandPoses,
  getTransform: () => getTransform,
  getTransformLocal: () => getTransformLocal,
  getTransformLocalMatrix: () => getTransformLocalMatrix,
  getTransformLocalQuat: () => getTransformLocalQuat,
  getTransformMatrix: () => getTransformMatrix,
  getTransformQuat: () => getTransformQuat,
  getTransformWorld: () => getTransformWorld,
  getTransformWorldMatrix: () => getTransformWorldMatrix,
  getTransformWorldQuat: () => getTransformWorldQuat,
  getTwist: () => getTwist,
  getTwistFromSwing: () => getTwistFromSwing,
  getTypeFromTypeOrClass: () => getTypeFromTypeOrClass,
  getUpLocal: () => getUpLocal,
  getUpWorld: () => getUpWorld,
  getUser: () => getUser,
  getUserDummy: () => getUserDummy,
  getVisualManager: () => getVisualManager,
  getVisualResources: () => getVisualResources,
  getWASM: () => getWASM,
  getWLJavascriptComponentTypes: () => getWLJavascriptComponentTypes,
  getWLNativeComponentTypes: () => getWLNativeComponentTypes,
  getWarn: () => getWarn,
  getWindow: () => getWindow,
  getXR: () => getXR,
  hasAudioManager: () => hasAudioManager,
  hasCharacterCollisionSystem: () => hasCharacterCollisionSystem,
  hasCloneCallback: () => hasCloneCallback,
  hasClonePostProcess: () => hasClonePostProcess,
  hasClonePostProcessCallback: () => hasClonePostProcessCallback,
  hasConsoleVR: () => hasConsoleVR,
  hasDebugEnabled: () => hasDebugEnabled,
  hasDebugManager: () => hasDebugManager,
  hasDefaultResources: () => hasDefaultResources,
  hasDefaultWLComponentCloneCallback: () => hasDefaultWLComponentCloneCallback,
  hasEasyTuneTarget: () => hasEasyTuneTarget,
  hasEasyTuneVariables: () => hasEasyTuneVariables,
  hasEngine: () => hasEngine,
  hasEqual: () => hasEqual,
  hasInputManager: () => hasInputManager,
  hasObjectPoolManager: () => hasObjectPoolManager,
  hasPoseForwardFixed: () => hasPoseForwardFixed,
  hasSceneObjects: () => hasSceneObjects,
  hasToolEnabled: () => hasToolEnabled,
  hasUniformScaleLocal: () => hasUniformScaleLocal,
  hasUniformScaleWorld: () => hasUniformScaleWorld,
  hasVisualManager: () => hasVisualManager,
  hasVisualResources: () => hasVisualResources,
  hsvCodeToHuman: () => hsvCodeToHuman,
  hsvHumanToCode: () => hsvHumanToCode,
  hsvToRGB: () => hsvToRGB,
  importVariables: () => importVariables,
  info: () => info,
  initArrayExtension: () => initArrayExtension,
  initArrayExtensionProtoype: () => initArrayExtensionProtoype,
  initBridge: () => initBridge,
  initComponentMods: () => initComponentMods,
  initCursorComponentMod: () => initCursorComponentMod,
  initCursorComponentModPrototype: () => initCursorComponentModPrototype,
  initCursorTargetComponentMod: () => initCursorTargetComponentMod,
  initCursorTargetComponentModPrototype: () => initCursorTargetComponentModPrototype,
  initEngine: () => initEngine,
  initJSExtensions: () => initJSExtensions,
  initJSPlugins: () => initJSPlugins,
  initMathExtension: () => initMathExtension,
  initMathExtensionStatic: () => initMathExtensionStatic,
  initMouseLookComponentMod: () => initMouseLookComponentMod,
  initMouseLookComponentModPrototype: () => initMouseLookComponentModPrototype,
  initNumberExtension: () => initNumberExtension,
  initNumberExtensionPrototype: () => initNumberExtensionPrototype,
  initObjectExtension: () => initObjectExtension,
  initObjectExtensionProtoype: () => initObjectExtensionProtoype,
  initPP: () => initPP,
  initPlugins: () => initPlugins,
  initSceneExtension: () => initSceneExtension,
  initSceneExtensionPrototype: () => initSceneExtensionPrototype,
  initWLExtensions: () => initWLExtensions,
  initWLMods: () => initWLMods,
  initWLPlugins: () => initWLPlugins,
  injectProperties: () => injectProperties,
  isARSupported: () => isARSupported,
  isAnalyticsEnabled: () => isAnalyticsEnabled,
  isAnyButtonPressEnd: () => isAnyButtonPressEnd,
  isAnyButtonPressStart: () => isAnyButtonPressStart,
  isAnyButtonTouchEnd: () => isAnyButtonTouchEnd,
  isAnyButtonTouchStart: () => isAnyButtonTouchStart,
  isClass: () => isClass,
  isClassByName: () => isClassByName,
  isConcordant: () => isConcordant,
  isDataLogEnabled: () => isDataLogEnabled,
  isDebugEnabled: () => isDebugEnabled,
  isDesktop: () => isDesktop,
  isDeviceEmulated: () => isDeviceEmulated,
  isErrorsLogEnabled: () => isErrorsLogEnabled,
  isEventsLogEnabled: () => isEventsLogEnabled,
  isFartherAlongAxis: () => isFartherAlongAxis,
  isFunction: () => isFunction,
  isFunctionByName: () => isFunctionByName,
  isInsideAngleRange: () => isInsideAngleRange,
  isInsideAngleRangeDegrees: () => isInsideAngleRangeDegrees,
  isInsideAngleRangeRadians: () => isInsideAngleRangeRadians,
  isLocalhost: () => isLocalhost,
  isMobile: () => isMobile,
  isObject: () => isObject,
  isObjectByName: () => isObjectByName,
  isOnAxis: () => isOnAxis,
  isOnPlane: () => isOnPlane,
  isPlaybackBlocked: () => isPlaybackBlocked,
  isPoseForwardFixed: () => isPoseForwardFixed,
  isReferenceSpaceFloorBased: () => isReferenceSpaceFloorBased,
  isRegistered: () => isRegistered,
  isSDKAvailable: () => isSDKAvailable,
  isSessionActive: () => isSessionActive,
  isToTheRight: () => isToTheRight,
  isToolEnabled: () => isToolEnabled,
  isTransformChanged: () => isTransformChanged,
  isUseDummyServerOnError: () => isUseDummyServerOnError,
  isUseDummyServerOnSDKMissing: () => isUseDummyServerOnSDKMissing,
  isVRSupported: () => isVRSupported,
  isWLComponent: () => isWLComponent,
  isWLJavascriptComponent: () => isWLJavascriptComponent,
  isWLNativeComponent: () => isWLNativeComponent,
  isWLNativeComponentRegistered: () => isWLNativeComponentRegistered,
  isXRSupported: () => isXRSupported,
  last: () => last,
  lengthSigned: () => lengthSigned,
  load: () => load,
  loadBool: () => loadBool,
  loadNumber: () => loadNumber,
  loadString: () => loadString,
  lookAt: () => lookAt2,
  lookAtLocal: () => lookAtLocal,
  lookAtWorld: () => lookAtWorld,
  lookTo: () => lookTo,
  lookToLocal: () => lookToLocal,
  lookToWorld: () => lookToWorld,
  makeDoubleSided: () => makeDoubleSided,
  mapToRange: () => mapToRange,
  markDirty: () => markDirty,
  mat3_create: () => mat3_create,
  mat4_create: () => mat4_create,
  negate: () => negate4,
  openLink: () => openLink,
  openLinkOnClick: () => openLinkOnClick,
  overwriteObjectProperty: () => overwriteObjectProperty,
  perpendicularRandom: () => perpendicularRandom,
  projectOnAxis: () => projectOnAxis,
  projectOnAxisAlongAxis: () => projectOnAxisAlongAxis,
  projectOnPlane: () => projectOnPlane,
  projectOnPlaneAlongAxis: () => projectOnPlaneAlongAxis,
  pushUnique: () => pushUnique,
  quat2_create: () => quat2_create,
  quat_create: () => quat_create,
  radiansAddRotation: () => radiansAddRotation,
  radiansAddRotationDegrees: () => radiansAddRotationDegrees,
  radiansAddRotationQuat: () => radiansAddRotationQuat,
  radiansAddRotationRadians: () => radiansAddRotationRadians,
  radiansToMatrix: () => radiansToMatrix,
  radiansToQuat: () => radiansToQuat,
  random: () => random5,
  randomBool: () => randomBool,
  randomInt: () => randomInt,
  randomPick: () => randomPick,
  randomSign: () => randomSign,
  randomUUID: () => randomUUID,
  raycast: () => raycast,
  refreshWidget: () => refreshWidget,
  registerPPComponents: () => registerPPComponents,
  registerSessionEndEventListener: () => registerSessionEndEventListener,
  registerSessionStartEndEventListeners: () => registerSessionStartEndEventListeners,
  registerSessionStartEventListener: () => registerSessionStartEventListener,
  registerWLComponents: () => registerWLComponents,
  removeAll: () => removeAll,
  removeAllEqual: () => removeAllEqual,
  removeAllIndexes: () => removeAllIndexes,
  removeAudioManager: () => removeAudioManager,
  removeCharacterCollisionSystem: () => removeCharacterCollisionSystem,
  removeCloneCallback: () => removeCloneCallback,
  removeClonePostProcessCallback: () => removeClonePostProcessCallback,
  removeComponentAlongAxis: () => removeComponentAlongAxis,
  removeConsoleVR: () => removeConsoleVR,
  removeDebugEnabled: () => removeDebugEnabled,
  removeDebugManager: () => removeDebugManager,
  removeDefaultResources: () => removeDefaultResources,
  removeDefaultWLComponentCloneCallbacks: () => removeDefaultWLComponentCloneCallbacks,
  removeEasyTuneTarget: () => removeEasyTuneTarget,
  removeEasyTuneVariables: () => removeEasyTuneVariables,
  removeEngine: () => removeEngine,
  removeEqual: () => removeEqual,
  removeIndex: () => removeIndex,
  removeInputManager: () => removeInputManager,
  removeMainEngine: () => removeMainEngine,
  removeObjectPoolManager: () => removeObjectPoolManager,
  removePoseForwardFixed: () => removePoseForwardFixed,
  removeRefreshWidgetCallback: () => removeRefreshWidgetCallback,
  removeSceneObjects: () => removeSceneObjects,
  removeSetWidgetCurrentVariableCallback: () => removeSetWidgetCurrentVariableCallback,
  removeToolEnabled: () => removeToolEnabled,
  removeVisualManager: () => removeVisualManager,
  removeVisualResources: () => removeVisualResources,
  reserveObjects: () => reserveObjects,
  reserveObjectsChildren: () => reserveObjectsChildren,
  reserveObjectsDescendants: () => reserveObjectsDescendants,
  reserveObjectsHierarchy: () => reserveObjectsHierarchy,
  reserveObjectsSelf: () => reserveObjectsSelf,
  resetPosition: () => resetPosition,
  resetPositionLocal: () => resetPositionLocal,
  resetPositionWorld: () => resetPositionWorld,
  resetRotation: () => resetRotation,
  resetRotationLocal: () => resetRotationLocal,
  resetRotationWorld: () => resetRotationWorld,
  resetScale: () => resetScale,
  resetScaleLocal: () => resetScaleLocal,
  resetScaleWorld: () => resetScaleWorld,
  resetTransform: () => resetTransform,
  resetTransformLocal: () => resetTransformLocal,
  resetTransformWorld: () => resetTransformWorld,
  rgbCodeToHuman: () => rgbCodeToHuman,
  rgbHumanToCode: () => rgbHumanToCode,
  rgbToHSV: () => rgbToHSV,
  rotateAroundAxisLocal: () => rotateAroundAxisLocal,
  rotateAroundAxisLocalDegrees: () => rotateAroundAxisLocalDegrees,
  rotateAroundAxisLocalRadians: () => rotateAroundAxisLocalRadians,
  rotateAroundAxisObject: () => rotateAroundAxisObject,
  rotateAroundAxisObjectDegrees: () => rotateAroundAxisObjectDegrees,
  rotateAroundAxisObjectRadians: () => rotateAroundAxisObjectRadians,
  rotateAroundAxisWorld: () => rotateAroundAxisWorld,
  rotateAroundAxisWorldDegrees: () => rotateAroundAxisWorldDegrees,
  rotateAroundAxisWorldRadians: () => rotateAroundAxisWorldRadians,
  rotateAroundLocal: () => rotateAroundLocal,
  rotateAroundLocalDegrees: () => rotateAroundLocalDegrees,
  rotateAroundLocalMatrix: () => rotateAroundLocalMatrix,
  rotateAroundLocalQuat: () => rotateAroundLocalQuat,
  rotateAroundLocalRadians: () => rotateAroundLocalRadians,
  rotateAroundMatrix: () => rotateAroundMatrix,
  rotateAroundObject: () => rotateAroundObject,
  rotateAroundObjectDegrees: () => rotateAroundObjectDegrees,
  rotateAroundObjectMatrix: () => rotateAroundObjectMatrix,
  rotateAroundObjectQuat: () => rotateAroundObjectQuat,
  rotateAroundObjectRadians: () => rotateAroundObjectRadians,
  rotateAroundWorld: () => rotateAroundWorld,
  rotateAroundWorldDegrees: () => rotateAroundWorldDegrees,
  rotateAroundWorldMatrix: () => rotateAroundWorldMatrix,
  rotateAroundWorldQuat: () => rotateAroundWorldQuat,
  rotateAroundWorldRadians: () => rotateAroundWorldRadians,
  rotateAxisLocal: () => rotateAxisLocal,
  rotateAxisLocalDegrees: () => rotateAxisLocalDegrees,
  rotateAxisLocalRadians: () => rotateAxisLocalRadians,
  rotateAxisObject: () => rotateAxisObject,
  rotateAxisObjectDegrees: () => rotateAxisObjectDegrees,
  rotateAxisObjectRadians: () => rotateAxisObjectRadians,
  rotateAxisWorld: () => rotateAxisWorld,
  rotateAxisWorldDegrees: () => rotateAxisWorldDegrees,
  rotateAxisWorldRadians: () => rotateAxisWorldRadians,
  rotateLocal: () => rotateLocal,
  rotateLocalDegrees: () => rotateLocalDegrees,
  rotateLocalMatrix: () => rotateLocalMatrix,
  rotateLocalQuat: () => rotateLocalQuat,
  rotateLocalRadians: () => rotateLocalRadians,
  rotateMatrix: () => rotateMatrix,
  rotateObject: () => rotateObject,
  rotateObjectDegrees: () => rotateObjectDegrees,
  rotateObjectMatrix: () => rotateObjectMatrix,
  rotateObjectQuat: () => rotateObjectQuat,
  rotateObjectRadians: () => rotateObjectRadians,
  rotateWorld: () => rotateWorld,
  rotateWorldDegrees: () => rotateWorldDegrees,
  rotateWorldMatrix: () => rotateWorldMatrix,
  rotateWorldQuat: () => rotateWorldQuat,
  rotateWorldRadians: () => rotateWorldRadians,
  rotationAroundAxis: () => rotationAroundAxis,
  rotationAroundAxisDegrees: () => rotationAroundAxisDegrees,
  rotationAroundAxisQuat: () => rotationAroundAxisQuat,
  rotationAroundAxisRadians: () => rotationAroundAxisRadians,
  rotationToPivoted: () => rotationToPivoted,
  rotationToPivotedDegrees: () => rotationToPivotedDegrees,
  rotationToPivotedQuat: () => rotationToPivotedQuat,
  rotationToPivotedRadians: () => rotationToPivotedRadians,
  round: () => round4,
  roundDecimal: () => roundDecimal,
  save: () => save,
  scaleObject: () => scaleObject,
  sendData: () => sendData,
  sendEvent: () => sendEvent,
  setActive: () => setActive,
  setActiveChildren: () => setActiveChildren,
  setActiveDescendants: () => setActiveDescendants,
  setActiveDescendantsBreadth: () => setActiveDescendantsBreadth,
  setActiveDescendantsDepth: () => setActiveDescendantsDepth,
  setActiveHierarchy: () => setActiveHierarchy,
  setActiveHierarchyBreadth: () => setActiveHierarchyBreadth,
  setActiveHierarchyDepth: () => setActiveHierarchyDepth,
  setActiveObjects: () => setActiveObjects,
  setActiveSelf: () => setActiveSelf,
  setAlpha: () => setAlpha,
  setAnalyticsEnabled: () => setAnalyticsEnabled,
  setAudioManager: () => setAudioManager,
  setAxesLocal: () => setAxesLocal,
  setAxesWorld: () => setAxesWorld,
  setBackwardLocal: () => setBackwardLocal,
  setBackwardWorld: () => setBackwardWorld,
  setCharacterCollisionSystem: () => setCharacterCollisionSystem,
  setCloneCallback: () => setCloneCallback,
  setClonePostProcessCallback: () => setClonePostProcessCallback,
  setClonedMaterials: () => setClonedMaterials,
  setCollisionCheck: () => setCollisionCheck,
  setConsoleVR: () => setConsoleVR,
  setDataLogEnabled: () => setDataLogEnabled,
  setDebugEnabled: () => setDebugEnabled,
  setDebugManager: () => setDebugManager,
  setDefaultResources: () => setDefaultResources,
  setDefaultWLComponentCloneCallbacks: () => setDefaultWLComponentCloneCallbacks,
  setDownLocal: () => setDownLocal,
  setDownWorld: () => setDownWorld,
  setDummyServer: () => setDummyServer,
  setEasyTuneTarget: () => setEasyTuneTarget,
  setEasyTuneVariables: () => setEasyTuneVariables,
  setErrorsLogEnabled: () => setErrorsLogEnabled,
  setEventsLogEnabled: () => setEventsLogEnabled,
  setForwardLocal: () => setForwardLocal,
  setForwardWorld: () => setForwardWorld,
  setInputManager: () => setInputManager,
  setLayerFlagsNames: () => setLayerFlagsNames,
  setLeftLocal: () => setLeftLocal,
  setLeftWorld: () => setLeftWorld,
  setMainEngine: () => setMainEngine,
  setName: () => setName,
  setObjectAlpha: () => setObjectAlpha,
  setObjectClonedMaterials: () => setObjectClonedMaterials,
  setObjectFogColor: () => setObjectFogColor,
  setObjectMaterial: () => setObjectMaterial,
  setObjectPoolManager: () => setObjectPoolManager,
  setObjectProperty: () => setObjectProperty,
  setObjectSpecularColor: () => setObjectSpecularColor,
  setParent: () => setParent,
  setPoseForwardFixed: () => setPoseForwardFixed,
  setPositionLocal: () => setPositionLocal,
  setPositionRotationDegreesScale: () => setPositionRotationDegreesScale,
  setPositionRotationQuatScale: () => setPositionRotationQuatScale,
  setPositionRotationRadiansScale: () => setPositionRotationRadiansScale,
  setPositionRotationScale: () => setPositionRotationScale,
  setPositionWorld: () => setPositionWorld,
  setRightLocal: () => setRightLocal,
  setRightWorld: () => setRightWorld,
  setRotationLocal: () => setRotationLocal,
  setRotationLocalDegrees: () => setRotationLocalDegrees,
  setRotationLocalMatrix: () => setRotationLocalMatrix,
  setRotationLocalQuat: () => setRotationLocalQuat,
  setRotationLocalRadians: () => setRotationLocalRadians,
  setRotationMatrix: () => setRotationMatrix,
  setRotationWorld: () => setRotationWorld,
  setRotationWorldDegrees: () => setRotationWorldDegrees,
  setRotationWorldMatrix: () => setRotationWorldMatrix,
  setRotationWorldQuat: () => setRotationWorldQuat,
  setRotationWorldRadians: () => setRotationWorldRadians,
  setScaleLocal: () => setScaleLocal,
  setScaleWorld: () => setScaleWorld,
  setSceneObjects: () => setSceneObjects,
  setSendAnalyticsCallback: () => setSendAnalyticsCallback,
  setSimultaneousPressMaxDelay: () => setSimultaneousPressMaxDelay,
  setSimultaneousTouchMaxDelay: () => setSimultaneousTouchMaxDelay,
  setToolEnabled: () => setToolEnabled,
  setTransform: () => setTransform,
  setTransformLocal: () => setTransformLocal,
  setTransformLocalMatrix: () => setTransformLocalMatrix,
  setTransformLocalQuat: () => setTransformLocalQuat,
  setTransformMatrix: () => setTransformMatrix,
  setTransformQuat: () => setTransformQuat,
  setTransformWorld: () => setTransformWorld,
  setTransformWorldMatrix: () => setTransformWorldMatrix,
  setTransformWorldQuat: () => setTransformWorldQuat,
  setUpLocal: () => setUpLocal,
  setUpWorld: () => setUpWorld,
  setUseDummyServerOnError: () => setUseDummyServerOnError,
  setUseDummyServerOnSDKMissing: () => setUseDummyServerOnSDKMissing,
  setVisualManager: () => setVisualManager,
  setVisualResources: () => setVisualResources,
  setWidgetCurrentVariable: () => setWidgetCurrentVariable,
  sign: () => sign,
  signTo: () => signTo,
  sub: () => sub6,
  subRotation: () => subRotation,
  subRotationDegrees: () => subRotationDegrees,
  subRotationQuat: () => subRotationQuat,
  subRotationRadians: () => subRotationRadians,
  submitScore: () => submitScore,
  submitScoreDummy: () => submitScoreDummy,
  transformMat3: () => transformMat33,
  transformMat4: () => transformMat44,
  transformQuat: () => transformQuat3,
  translate: () => translate4,
  translateAxis: () => translateAxis,
  translateAxisLocal: () => translateAxisLocal,
  translateAxisObject: () => translateAxisObject,
  translateAxisWorld: () => translateAxisWorld,
  translateLocal: () => translateLocal,
  translateObject: () => translateObject,
  translateWorld: () => translateWorld,
  unregisterSessionEndEventListener: () => unregisterSessionEndEventListener,
  unregisterSessionStartEndEventListeners: () => unregisterSessionStartEndEventListeners,
  unregisterSessionStartEventListener: () => unregisterSessionStartEventListener,
  unshiftUnique: () => unshiftUnique,
  updateCeilingInfo: () => updateCeilingInfo,
  updateGroundInfo: () => updateGroundInfo,
  valueAlongAxis: () => valueAlongAxis,
  vec2_create: () => vec2_create,
  vec3_create: () => vec3_create,
  vec4_create: () => vec4_create,
  wrapObject: () => wrapObject
});

// js/pp/cauldron/wl/register_wl_components.js
function registerWLComponents(engine2) {
  engine2.registerComponent(ARCamera8thwall, Cursor, CursorTarget, DebugObject, DeviceOrientationLook, FingerCursor, FixedFoveation, HandTracking, HitTestLocation, HowlerAudioListener, HowlerAudioSource, ImageTexture, MouseLookComponent, PlayerHeight, TargetFramerate, TeleportComponent, Trail, TwoJointIkSolver, VideoTexture, VrModeActiveSwitch, Vrm, WasdControlsComponent);
}

// js/pp/audio/audio_globals.js
var audio_globals_exports = {};
__export(audio_globals_exports, {
  getAudioManager: () => getAudioManager,
  hasAudioManager: () => hasAudioManager,
  removeAudioManager: () => removeAudioManager,
  setAudioManager: () => setAudioManager
});
var _myAudioManagers = /* @__PURE__ */ new WeakMap();
function getAudioManager(engine2 = Globals.getMainEngine()) {
  return _myAudioManagers.get(engine2);
}
function setAudioManager(audioManager, engine2 = Globals.getMainEngine()) {
  _myAudioManagers.set(engine2, audioManager);
}
function removeAudioManager(engine2 = Globals.getMainEngine()) {
  _myAudioManagers.delete(engine2);
}
function hasAudioManager(engine2 = Globals.getMainEngine()) {
  return _myAudioManagers.has(engine2);
}

// js/pp/cauldron/cauldron/window_globals.js
var window_globals_exports = {};
__export(window_globals_exports, {
  getBody: () => getBody,
  getDocument: () => getDocument,
  getNavigator: () => getNavigator,
  getWindow: () => getWindow
});
function getWindow(engine2 = Globals.getMainEngine()) {
  return window;
}
function getNavigator(engine2 = Globals.getMainEngine()) {
  return getWindow(engine2).navigator;
}
function getDocument(engine2 = Globals.getMainEngine()) {
  return getWindow(engine2).document;
}
function getBody(engine2 = Globals.getMainEngine()) {
  return getDocument(engine2).body;
}

// js/pp/cauldron/object_pool/object_pool_globals.js
var object_pool_globals_exports = {};
__export(object_pool_globals_exports, {
  getObjectPoolManager: () => getObjectPoolManager,
  hasObjectPoolManager: () => hasObjectPoolManager,
  removeObjectPoolManager: () => removeObjectPoolManager,
  setObjectPoolManager: () => setObjectPoolManager
});
var _myObjectPoolManagers = /* @__PURE__ */ new WeakMap();
function getObjectPoolManager(engine2 = Globals.getMainEngine()) {
  return _myObjectPoolManagers.get(engine2);
}
function setObjectPoolManager(audioManager, engine2 = Globals.getMainEngine()) {
  _myObjectPoolManagers.set(engine2, audioManager);
}
function removeObjectPoolManager(engine2 = Globals.getMainEngine()) {
  _myObjectPoolManagers.delete(engine2);
}
function hasObjectPoolManager(engine2 = Globals.getMainEngine()) {
  return _myObjectPoolManagers.has(engine2);
}

// js/pp/cauldron/visual/visual_globals.js
var visual_globals_exports = {};
__export(visual_globals_exports, {
  getVisualManager: () => getVisualManager,
  getVisualResources: () => getVisualResources,
  hasVisualManager: () => hasVisualManager,
  hasVisualResources: () => hasVisualResources,
  removeVisualManager: () => removeVisualManager,
  removeVisualResources: () => removeVisualResources,
  setVisualManager: () => setVisualManager,
  setVisualResources: () => setVisualResources
});
var _myVisualResourcesContainer = /* @__PURE__ */ new WeakMap();
var _myVisualManagers = /* @__PURE__ */ new WeakMap();
function getVisualResources(engine2 = Globals.getMainEngineinEngine()) {
  return _myVisualResourcesContainer.get(engine2);
}
function setVisualResources(visualResources, engine2 = Globals.getMainEngine()) {
  _myVisualResourcesContainer.set(engine2, visualResources);
}
function removeVisualResources(engine2 = Globals.getMainEngine()) {
  _myVisualResourcesContainer.delete(engine2);
}
function hasVisualResources(engine2 = Globals.getMainEngine()) {
  return _myVisualResourcesContainer.has(engine2);
}
function getVisualManager(engine2 = Globals.getMainEngine()) {
  return _myVisualManagers.get(engine2);
}
function setVisualManager(visualManager, engine2 = Globals.getMainEngine()) {
  _myVisualManagers.set(engine2, visualManager);
}
function removeVisualManager(engine2 = Globals.getMainEngine()) {
  _myVisualManagers.delete(engine2);
}
function hasVisualManager(engine2 = Globals.getMainEngine()) {
  return _myVisualManagers.has(engine2);
}

// js/pp/cauldron/wl/engine_globals.js
var engine_globals_exports = {};
__export(engine_globals_exports, {
  addEngine: () => addEngine,
  getCanvas: () => getCanvas,
  getEngines: () => getEngines,
  getMainEngine: () => getMainEngine,
  getPhysics: () => getPhysics,
  getRoot: () => getRoot2,
  getScene: () => getScene,
  getWASM: () => getWASM,
  getXR: () => getXR,
  hasEngine: () => hasEngine,
  initEngine: () => initEngine,
  removeEngine: () => removeEngine,
  removeMainEngine: () => removeMainEngine,
  setMainEngine: () => setMainEngine
});

// js/pp/cauldron/js/utils/math_utils.js
var EasingFunction = {
  linear: (t) => t,
  easeInVeryWeak: (t) => 1 - Math.cos(t * Math.PI / 2),
  easeInWeak: (t) => Math.pow(t, 2),
  easeIn: (t) => Math.pow(t, 3),
  easeInStrong: (t) => Math.pow(t, 4),
  easeInVeryStrong: (t) => Math.pow(t, 5),
  easeOutVeryWeak: (t) => Math.sin(t * Math.PI / 2),
  easeOutWeak: (t) => 1 - Math.pow(1 - t, 2),
  easeOut: (t) => 1 - Math.pow(1 - t, 3),
  easeOutStrong: (t) => 1 - Math.pow(1 - t, 4),
  easeOutVeryStrong: (t) => 1 - Math.pow(1 - t, 5),
  easeInOutVeryWeak: (t) => -(Math.cos(t * Math.PI) - 1) / 2,
  easeInOutWeak: (t) => t < 0.5 ? 2 * Math.pow(t, 2) : 1 - Math.pow(-2 * t + 2, 2) / 2,
  easeInOut: (t) => t < 0.5 ? 4 * Math.pow(t, 3) : 1 - Math.pow(-2 * t + 2, 3) / 2,
  easeInOutStrong: (t) => t < 0.5 ? 8 * Math.pow(t, 4) : 1 - Math.pow(-2 * t + 2, 4) / 2,
  easeInOutVeryStrong: (t) => t < 0.5 ? 16 * Math.pow(t, 5) : 1 - Math.pow(-2 * t + 2, 5) / 2
};
var EPSILON2 = 1e-6;
var EPSILON_SQUARED = EPSILON2 * EPSILON2;
var EPSILON_DEGREES = 1e-5;
function clamp3(value, start, end) {
  let fixedStart = start != null ? start : -Number.MAX_VALUE;
  let fixedEnd = end != null ? end : Number.MAX_VALUE;
  let min4 = Math.min(fixedStart, fixedEnd);
  let max4 = Math.max(fixedStart, fixedEnd);
  return Math.min(Math.max(value, min4), max4);
}
function sign(value, zeroSign = 1) {
  let sign2 = Math.sign(value);
  if (sign2 == 0) {
    sign2 = Math.sign(zeroSign);
  }
  return sign2;
}
function toDegrees(angle4) {
  return angle4 * (180 / Math.PI);
}
function toRadians(angle4) {
  return angle4 * (Math.PI / 180);
}
function roundDecimal(number, decimalPlaces) {
  let factor = Math.pow(10, decimalPlaces);
  number = Math.round(number * factor) / factor;
  return number;
}
function mapToRange(value, originRangeStart, originRangeEnd, newRangeStart, newRangeEnd) {
  if (originRangeStart == originRangeEnd) {
    return newRangeStart;
  }
  let clampedValue = MathUtils.clamp(value, originRangeStart, originRangeEnd);
  if (clampedValue == originRangeStart) {
    return newRangeStart;
  } else if (clampedValue == originRangeEnd) {
    return newRangeEnd;
  }
  let newValue = newRangeStart + (newRangeEnd - newRangeStart) / (originRangeEnd - originRangeStart) * (clampedValue - originRangeStart);
  let clampedNewValue = MathUtils.clamp(newValue, newRangeStart, newRangeEnd);
  return clampedNewValue;
}
function random5(start = 0, end = 1) {
  return Math.random() * (end - start) + start;
}
function randomInt(start, end) {
  let min4 = Math.min(start, end);
  let max4 = Math.max(start, end);
  return Math.floor(Math.random() * (max4 - min4 + 1) + min4);
}
function randomBool() {
  return MathUtils.randomInt(0, 1) == 0;
}
function randomSign() {
  return Math.random() < 0.5 ? 1 : -1;
}
function randomPick(...args) {
  let random6 = null;
  if (args.length > 0) {
    if (args.length == 1 && args[0].length != null) {
      if (args[0].length > 0) {
        let randomIndex = MathUtils.randomInt(0, args[0].length - 1);
        random6 = args[0][randomIndex];
      }
    } else {
      let randomIndex = MathUtils.randomInt(0, args.length - 1);
      random6 = args[randomIndex];
    }
  }
  return random6;
}
var randomUUID = function() {
  let uuidRandomValues = new Uint8Array(1);
  let uuidSkeleton = "10000000-1000-4000-8000-" + 1e11;
  let replaceUUIDSkeletonRegex = new RegExp("[018]", "g");
  let replaceUUIDSkeletonCallback = (c) => ((c ^ crypto.getRandomValues(uuidRandomValues)[0] & 15) >> c / 4).toString(16);
  return function randomUUID2() {
    let uuid = "";
    if (crypto.randomUUID != null) {
      uuid = crypto.randomUUID();
    } else {
      uuid = uuidSkeleton.replace(replaceUUIDSkeletonRegex, replaceUUIDSkeletonCallback);
    }
    return uuid;
  };
}();
function lerp6(from, to, interpolationFactor) {
  if (interpolationFactor <= 0) {
    return from;
  } else if (interpolationFactor >= 1) {
    return to;
  }
  return interpolationFactor * (to - from) + from;
}
function interpolate(from, to, interpolationFactor, easingFunction = EasingFunction.linear) {
  let lerpFactor = easingFunction(interpolationFactor);
  return MathUtils.lerp(from, to, lerpFactor);
}
function angleDistance(from, to) {
  return MathUtils.angleDistanceDegrees(from, to);
}
function angleDistanceDegrees(from, to) {
  return Math.abs(MathUtils.angleDistanceSignedDegrees(from, to));
}
function angleDistanceRadians(from, to) {
  return Math.abs(MathUtils.angleDistanceSignedRadians(from, to));
}
function angleDistanceSigned(from, to) {
  return MathUtils.angleDistanceSignedDegrees(from, to);
}
function angleDistanceSignedDegrees(from, to) {
  let clampedFrom = MathUtils.angleClampDegrees(from, true);
  let clampedTo = MathUtils.angleClampDegrees(to, true);
  let distance5 = clampedTo - clampedFrom;
  if (clampedTo - clampedFrom > 180) {
    distance5 = clampedTo - clampedFrom - 360;
  } else if (clampedTo - clampedFrom < -180) {
    distance5 = clampedTo - clampedFrom + 360;
  }
  return distance5;
}
function angleDistanceSignedRadians(from, to) {
  return MathUtils.toRadians(MathUtils.angleDistanceSignedDegrees(MathUtils.toDegrees(from), MathUtils.toDegrees(to)));
}
function angleClamp(angle4, usePositiveRange = false) {
  return MathUtils.angleClampDegrees(angle4, usePositiveRange);
}
function angleClampDegrees(angle4, usePositiveRange = false) {
  let clampedAngle = angle4 % 360;
  if (clampedAngle < 0) {
    clampedAngle += 360;
  }
  if (!usePositiveRange) {
    if (clampedAngle > 180) {
      clampedAngle -= 360;
    }
  }
  return clampedAngle;
}
function angleClampRadians(angle4, usePositiveRange = false) {
  return MathUtils.toRadians(MathUtils.angleClampDegrees(MathUtils.toDegrees(angle4), usePositiveRange));
}
function isInsideAngleRange(angle4, start, end, useShortestAngle = false) {
  return MathUtils.isInsideAngleRangeDegrees(angle4, start, end, useShortestAngle);
}
function isInsideAngleRangeDegrees(angle4, start, end, useShortestAngle = false) {
  let insideAngleRange = false;
  let anglePositive = MathUtils.angleClampDegrees(angle4, true);
  let startPositive = MathUtils.angleClampDegrees(start, true);
  let endPositive = MathUtils.angleClampDegrees(end, true);
  if (useShortestAngle) {
    if (MathUtils.angleDistanceSignedDegrees(startPositive, endPositive) < 0) {
      let temp = startPositive;
      startPositive = endPositive;
      endPositive = temp;
    }
  }
  if (startPositive < endPositive) {
    insideAngleRange = anglePositive >= startPositive && anglePositive <= endPositive;
  } else {
    insideAngleRange = anglePositive >= startPositive || anglePositive <= endPositive;
  }
  return insideAngleRange;
}
function isInsideAngleRangeRadians(angle4, start, end, useShortestAngle = false) {
  return MathUtils.isInsideAngleRangeDegrees(MathUtils.toDegrees(angle4), MathUtils.toDegrees(start), MathUtils.toDegrees(end), useShortestAngle);
}
var MathUtils = {
  EPSILON: EPSILON2,
  EPSILON_SQUARED,
  EPSILON_DEGREES,
  clamp: clamp3,
  sign,
  toDegrees,
  toRadians,
  roundDecimal,
  mapToRange,
  random: random5,
  randomInt,
  randomBool,
  randomSign,
  randomPick,
  randomUUID,
  lerp: lerp6,
  interpolate,
  angleDistance,
  angleDistanceDegrees,
  angleDistanceRadians,
  angleDistanceSigned,
  angleDistanceSignedDegrees,
  angleDistanceSignedRadians,
  angleClamp,
  angleClampDegrees,
  angleClampRadians,
  isInsideAngleRange,
  isInsideAngleRangeDegrees,
  isInsideAngleRangeRadians
};

// js/pp/cauldron/js/utils/array_utils.js
function first(array) {
  return array.length > 0 ? array[0] : void 0;
}
function last(array) {
  return array.length > 0 ? array[array.length - 1] : void 0;
}
function has(array, callback) {
  return ArrayUtils.find(array, callback) != void 0;
}
function hasEqual(array, elementToFind, elementsEqualCallback = null) {
  return ArrayUtils.findEqual(array, elementToFind, elementsEqualCallback) != void 0;
}
function find(array, callback) {
  let elementFound = void 0;
  let index = array.findIndex(callback);
  if (index >= 0) {
    elementFound = array[index];
  }
  return elementFound;
}
function findIndex(array, callback) {
  return array.findIndex(callback);
}
function findAll(array, callback) {
  let elementsFound = array.filter(callback);
  return elementsFound;
}
function findAllIndexes(array, callback) {
  let indexes = [];
  for (let i = 0; i < array.length; i++) {
    let element = array[i];
    if (callback(element)) {
      indexes.push(i);
    }
  }
  return indexes;
}
function findEqual(array, elementToFind, elementsEqualCallback = null) {
  if (elementsEqualCallback == null) {
    let index = ArrayUtils.findIndexEqual(array, elementToFind);
    return index < 0 ? void 0 : array[index];
  }
  let elementFound = void 0;
  for (let i = 0; i < array.length; i++) {
    let currentElement = array[i];
    if (elementsEqualCallback(currentElement, elementToFind)) {
      elementFound = currentElement;
      break;
    }
  }
  return elementFound;
}
function findAllEqual(array, elementToFind, elementsEqualCallback = null) {
  if (elementsEqualCallback == null) {
    return _findAllEqualOptimized(array, elementToFind, false);
  }
  let elementsFound = [];
  for (let i = 0; i < array.length; i++) {
    let currentElement = array[i];
    if (elementsEqualCallback(currentElement, elementToFind)) {
      elementsFound.push(currentElement);
    }
  }
  return elementsFound;
}
function findIndexEqual(array, elementToFind, elementsEqualCallback = null) {
  if (elementsEqualCallback == null) {
    return array.indexOf(elementToFind);
  }
  let indexFound = -1;
  for (let i = 0; i < array.length; i++) {
    let currentElement = array[i];
    if (elementsEqualCallback(currentElement, elementToFind)) {
      indexFound = i;
      break;
    }
  }
  return indexFound;
}
function findAllIndexesEqual(array, elementToFind, elementsEqualCallback = null) {
  if (elementsEqualCallback == null) {
    return _findAllEqualOptimized(array, elementToFind, true);
  }
  let indexesFound = [];
  for (let i = 0; i < array.length; i++) {
    let currentElement = array[i];
    if (elementsEqualCallback(currentElement, elementToFind)) {
      indexesFound.push(i);
    }
  }
  return indexesFound;
}
function removeIndex(array, index) {
  let elementRemoved = void 0;
  if (index >= 0 && index < array.length) {
    let arrayRemoved = array.splice(index, 1);
    if (arrayRemoved.length == 1) {
      elementRemoved = arrayRemoved[0];
    }
  }
  return elementRemoved;
}
function removeAllIndexes(array, indexes) {
  let elementsRemoved = [];
  for (let index of indexes) {
    let elementRemoved = ArrayUtils.removeIndex(array, index);
    if (elementRemoved !== void 0) {
      elementsRemoved.push(elementRemoved);
    }
  }
  return elementsRemoved;
}
function remove(array, callback) {
  let elementRemoved = void 0;
  let index = array.findIndex(callback);
  if (index >= 0) {
    elementRemoved = ArrayUtils.removeIndex(array, index);
  }
  return elementRemoved;
}
function removeAll(array, callback) {
  let elementsRemoved = [];
  let currentElement = void 0;
  do {
    currentElement = ArrayUtils.remove(array, callback);
    if (currentElement !== void 0) {
      elementsRemoved.push(currentElement);
    }
  } while (currentElement !== void 0);
  return elementsRemoved;
}
function removeEqual(array, elementToRemove, elementsEqualCallback = null) {
  return ArrayUtils.removeIndex(array, ArrayUtils.findIndexEqual(array, elementToRemove, elementsEqualCallback));
}
function removeAllEqual(array, elementToRemove, elementsEqualCallback = null) {
  return ArrayUtils.removeAllIndexes(array, ArrayUtils.findAllIndexesEqual(array, elementToRemove, elementsEqualCallback));
}
function pushUnique(array, element, elementsEqualCallback = null) {
  let length10 = array.length;
  let hasElement = ArrayUtils.hasEqual(array, element, elementsEqualCallback);
  if (!hasElement) {
    length10 = array.push(element);
  }
  return length10;
}
function unshiftUnique(array, element, elementsEqualCallback = null) {
  let length10 = array.length;
  let hasElement = ArrayUtils.hasEqual(array, element, elementsEqualCallback);
  if (!hasElement) {
    length10 = array.unshift(element);
  }
  return length10;
}
function copy8(from, to, copyCallback = null) {
  while (to.length > from.length) {
    to.pop();
  }
  for (let i = 0; i < from.length; i++) {
    if (copyCallback == null) {
      to[i] = from[i];
    } else {
      to[i] = copyCallback(to[i], from[i]);
    }
  }
  return to;
}
function clone8(array, cloneCallback = null) {
  if (cloneCallback == null) {
    return array.slice(0);
  }
  let clone17 = null;
  switch (array.constructor.name) {
    case "Array":
      clone17 = new Array(array.length);
      break;
    case "Uint8ClampedArray":
      clone17 = new Uint8ClampedArray(array.length);
      break;
    case "Uint8Array":
      clone17 = new Uint8Array(array.length);
      break;
    case "Uint16Array":
      clone17 = new Uint16Array(array.length);
      break;
    case "Uint32Array":
      clone17 = new Uint32Array(array.length);
      break;
    case "Int8Array":
      clone17 = new Int8Array(array.length);
      break;
    case "Int16Array":
      clone17 = new Int16Array(array.length);
      break;
    case "Int32Array":
      clone17 = new Int32Array(array.length);
      break;
    case "Float32Array":
      clone17 = new Float32Array(array.length);
      break;
    case "Float64Array":
      clone17 = new Float64Array(array.length);
      break;
    default:
      clone17 = new Array(array.length);
      console.error("Cloned array type not supported!");
      break;
  }
  for (let i = 0; i < array.length; i++) {
    clone17[i] = ArrayUtils.cloneCallback(array[i]);
  }
  return clone17;
}
function equals8(array, other, elementsEqualCallback = null) {
  let equals12 = true;
  if (other != null && array.length == other.length) {
    for (let i = 0; i < array.length; i++) {
      if (elementsEqualCallback != null && !elementsEqualCallback(array[i], other[i]) || elementsEqualCallback == null && array[i] != other[i]) {
        equals12 = false;
        break;
      }
    }
  } else {
    equals12 = false;
  }
  return equals12;
}
function clear(array) {
  array.length = 0;
  return array;
}
var ArrayUtils = {
  first,
  last,
  has,
  hasEqual,
  find,
  findIndex,
  findAll,
  findAllIndexes,
  findEqual,
  findAllEqual,
  findIndexEqual,
  findAllIndexesEqual,
  removeIndex,
  removeAllIndexes,
  remove,
  removeAll,
  removeEqual,
  removeAllEqual,
  pushUnique,
  unshiftUnique,
  copy: copy8,
  clone: clone8,
  equals: equals8,
  clear
};
function _findAllEqualOptimized(array, elementToFind, getIndexes) {
  let elementsFound = [];
  let index = -1;
  while ((index = array.indexOf(elementToFind, index + 1)) >= 0) {
    elementsFound.push(getIndexes ? index : array[index]);
  }
  return elementsFound;
}

// js/pp/cauldron/js/utils/quat2_utils.js
function create11(x1, y1, z1, w1, x2, y2, z2, w2) {
  let out = quat2_exports.create();
  if (x1 !== void 0) {
    set8(out, x1, y1, z1, w1, x2, y2, z2, w2);
  }
  return out;
}
function set8(quat, x1, y1, z1, w1, x2, y2, z2, w2) {
  if (y1 === void 0) {
    quat2_exports.set(quat, x1, x1, x1, x1, x1, x1, x1, x1);
  } else {
    quat2_exports.set(quat, x1, y1, z1, w1, x2, y2, z2, w2);
  }
  return quat;
}
function normalize6(quat, out = Quat2Utils.create()) {
  quat2_exports.normalize(out, quat);
  return out;
}
function invert5(quat, out = Quat2Utils.create()) {
  quat2_exports.invert(out, quat);
  return out;
}
function conjugate3(quat, out = Quat2Utils.create()) {
  quat2_exports.conjugate(out, quat);
  return out;
}
function copy9(from, to) {
  quat2_exports.copy(to, from);
  return to;
}
function identity5(quat) {
  quat2_exports.identity(quat);
  return quat;
}
function getPosition(quat, out = Vec3Utils.create()) {
  quat2_exports.getTranslation(out, quat);
  return out;
}
function getRotation2(quat, out) {
  return Quat2Utils.getRotationDegrees(quat, out);
}
var getRotationDegrees = function() {
  let rotationQuat = create9();
  return function getRotationDegrees4(quat, out = Vec3Utils.create()) {
    QuatUtils.toDegrees(Quat2Utils.getRotationQuat(quat, rotationQuat), out);
    return out;
  };
}();
var getRotationRadians = function() {
  let rotationQuat = create9();
  return function getRotationRadians4(quat, out = Vec3Utils.create()) {
    QuatUtils.toRadians(Quat2Utils.getRotationQuat(quat, rotationQuat), out);
    return out;
  };
}();
function getRotationQuat(quat, out = QuatUtils.create()) {
  QuatUtils.copy(quat, out);
  return out;
}
var setPosition = function() {
  let rotationQuat = create9();
  return function setPosition4(quat, position) {
    Quat2Utils.getRotationQuat(quat, rotationQuat);
    Quat2Utils.setPositionRotationQuat(quat, position, rotationQuat);
    return quat;
  };
}();
function setRotation(quat, rotation) {
  return Quat2Utils.setRotationDegrees(quat, rotation);
}
var setRotationDegrees = function() {
  let position = create10();
  return function setRotationDegrees4(quat, rotation) {
    Quat2Utils.getPosition(quat, position);
    Quat2Utils.setPositionRotationDegrees(quat, position, rotation);
    return quat;
  };
}();
var setRotationRadians = function() {
  let position = create10();
  return function setRotationRadians4(quat, rotation) {
    Quat2Utils.getPosition(quat, position);
    Quat2Utils.setPositionRotationRadians(quat, position, rotation);
    return quat;
  };
}();
var setRotationQuat = function() {
  let position = create10();
  return function setRotationQuat4(quat, rotation) {
    Quat2Utils.getPosition(quat, position);
    Quat2Utils.setPositionRotationQuat(quat, position, rotation);
    return quat;
  };
}();
function setPositionRotation(quat, position, rotation) {
  return Quat2Utils.setPositionRotationDegrees(quat, position, rotation);
}
var setPositionRotationDegrees = function() {
  let rotationQuat = create9();
  return function setPositionRotationDegrees3(quat, position, rotation) {
    Vec3Utils.degreesToQuat(rotation, rotationQuat);
    Quat2Utils.setPositionRotationQuat(quat, position, rotationQuat);
    return quat;
  };
}();
var setPositionRotationRadians = function() {
  let rotationQuat = create9();
  return function setPositionRotationRadians3(quat, position, rotation) {
    Vec3Utils.radiansToQuat(rotation, rotationQuat);
    Quat2Utils.setPositionRotationQuat(quat, position, rotationQuat);
    return quat;
  };
}();
function setPositionRotationQuat(quat, position, rotation) {
  quat2_exports.fromRotationTranslation(quat, rotation, position);
  return quat;
}
function isNormalized(quat, epsilon = MathUtils.EPSILON) {
  return Math.abs(Quat2Utils.lengthSquared(quat) - 1) < epsilon;
}
function length6(quat) {
  return quat2_exports.length(quat);
}
function lengthSquared(quat) {
  return quat2_exports.squaredLength(quat);
}
function mul8(first2, second, out = Quat2Utils.create()) {
  quat2_exports.mul(out, first2, second);
  return out;
}
function getAxes(quat, out = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
  Quat2Utils.getLeft(quat, out[0]);
  Quat2Utils.getUp(quat, out[1]);
  Quat2Utils.getForward(quat, out[2]);
  return out;
}
var getForward = function() {
  let rotationMatrix = create8();
  return function getForward5(quat, out = Vec3Utils.create()) {
    QuatUtils.toMatrix(quat, rotationMatrix);
    Vec3Utils.set(out, rotationMatrix[6], rotationMatrix[7], rotationMatrix[8]);
    return out;
  };
}();
function getBackward(quat, out) {
  out = Quat2Utils.getForward(quat, out);
  Vec3Utils.negate(out, out);
  return out;
}
var getLeft = function() {
  let rotationMatrix = create8();
  return function getLeft5(quat, out = Vec3Utils.create()) {
    QuatUtils.toMatrix(quat, rotationMatrix);
    Vec3Utils.set(out, rotationMatrix[0], rotationMatrix[1], rotationMatrix[2]);
    return out;
  };
}();
function getRight(quat, out) {
  out = Quat2Utils.getLeft(quat, out);
  Vec3Utils.negate(out, out);
  return out;
}
var getUp = function() {
  let rotationMatrix = create8();
  return function getUp5(quat, out = Vec3Utils.create()) {
    QuatUtils.toMatrix(quat, rotationMatrix);
    Vec3Utils.set(out, rotationMatrix[3], rotationMatrix[4], rotationMatrix[5]);
    return out;
  };
}();
function getDown(quat, out) {
  out = Quat2Utils.getUp(quat, out);
  Vec3Utils.negate(out, out);
  return out;
}
function toWorld(quat, parentTransformQuat, out = Quat2Utils.create()) {
  Quat2Utils.mul(parentTransformQuat, quat, out);
  return out;
}
var toLocal = function() {
  let invertQuat = create11();
  return function toLocal4(quat, parentTransformQuat, out = Quat2Utils.create()) {
    Quat2Utils.conjugate(parentTransformQuat, invertQuat);
    Quat2Utils.mul(invertQuat, quat, out);
    return out;
  };
}();
function rotateAxis(quat, angle4, axis, out) {
  return Quat2Utils.rotateAxisDegrees(quat, angle4, axis, out);
}
function rotateAxisDegrees(quat, angle4, axis, out) {
  return Quat2Utils.rotateAxisRadians(quat, MathUtils.toRadians(angle4), axis, out);
}
var rotateAxisRadians = function() {
  let rotationQuat = create9();
  return function rotateAxisRadians5(quat, angle4, axis, out = Quat2Utils.create()) {
    Quat2Utils.getRotationQuat(quat, rotationQuat);
    QuatUtils.rotateAxisRadians(rotationQuat, angle4, axis, rotationQuat);
    Quat2Utils.copy(quat, out);
    Quat2Utils.setRotationQuat(out, rotationQuat);
    return out;
  };
}();
function toMatrix(quat, out = Mat4Utils.create()) {
  _customGLMatrixFromQuat2(out, quat);
  return out;
}
function fromMatrix(matrix, out = Quat2Utils.create()) {
  Mat4Utils.toQuat(matrix, out);
  return out;
}
function lerp7(from, to, interpolationFactor, out = Quat2Utils.create()) {
  if (interpolationFactor <= 0) {
    Quat2Utils.copy(from, out);
    return out;
  } else if (interpolationFactor >= 1) {
    Quat2Utils.copy(to, out);
    return out;
  }
  quat2_exports.lerp(out, from, to, interpolationFactor);
  return out;
}
function interpolate2(from, to, interpolationFactor, easingFunction = EasingFunction.linear, out = Quat2Utils.create()) {
  let lerpFactor = easingFunction(interpolationFactor);
  return Quat2Utils.lerp(from, to, lerpFactor, out);
}
var slerp2 = function() {
  let fromPosition = create10();
  let toPosition = create10();
  let interpolatedPosition = create10();
  let fromRotationQuat = create9();
  let toRotationQuat = create9();
  let interpolatedRotationQuat = create9();
  return function slerp4(from, to, interpolationFactor, out = Quat2Utils.create()) {
    if (interpolationFactor <= 0) {
      Quat2Utils.copy(from, out);
      return out;
    } else if (interpolationFactor >= 1) {
      Quat2Utils.copy(to, out);
      return out;
    }
    Quat2Utils.getPosition(from, fromPosition);
    Quat2Utils.getPosition(to, toPosition);
    Quat2Utils.getRotationQuat(from, fromRotationQuat);
    Quat2Utils.getRotationQuat(to, toRotationQuat);
    Vec3Utils.lerp(fromPosition, toPosition, interpolationFactor, interpolatedPosition);
    QuatUtils.slerp(fromRotationQuat, toRotationQuat, interpolationFactor, interpolatedRotationQuat);
    Quat2Utils.setPositionRotationQuat(out, interpolatedPosition, interpolatedRotationQuat);
    return out;
  };
}();
function sinterpolate(from, to, interpolationFactor, easingFunction = EasingFunction.linear, out = Quat2Utils.create()) {
  let lerpFactor = easingFunction(interpolationFactor);
  return Quat2Utils.slerp(from, to, lerpFactor, out);
}
var Quat2Utils = {
  create: create11,
  set: set8,
  normalize: normalize6,
  invert: invert5,
  conjugate: conjugate3,
  copy: copy9,
  identity: identity5,
  getPosition,
  getRotation: getRotation2,
  getRotationDegrees,
  getRotationRadians,
  getRotationQuat,
  setPosition,
  setRotation,
  setRotationDegrees,
  setRotationRadians,
  setRotationQuat,
  setPositionRotation,
  setPositionRotationDegrees,
  setPositionRotationRadians,
  setPositionRotationQuat,
  isNormalized,
  length: length6,
  lengthSquared,
  mul: mul8,
  getAxes,
  getForward,
  getBackward,
  getLeft,
  getRight,
  getUp,
  getDown,
  toWorld,
  toLocal,
  rotateAxis,
  rotateAxisDegrees,
  rotateAxisRadians,
  toMatrix,
  fromMatrix,
  lerp: lerp7,
  interpolate: interpolate2,
  slerp: slerp2,
  sinterpolate
};
var _customGLMatrixFromQuat2 = function() {
  let translation = create10();
  return function _customGLMatrixFromQuat22(out, a) {
    let bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
    let magnitude = bx * bx + by * by + bz * bz + bw * bw;
    if (magnitude > 0) {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }
    mat4_exports.fromRotationTranslation(out, a, translation);
    return out;
  };
}();

// js/pp/cauldron/js/utils/mat4_utils.js
function create12(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  let out = mat4_exports.create();
  if (m00 !== void 0) {
    set10(
      out,
      m00,
      m01,
      m02,
      m03,
      m10,
      m11,
      m12,
      m13,
      m20,
      m21,
      m22,
      m23,
      m30,
      m31,
      m32,
      m33
    );
  }
  return out;
}
function set10(matrix, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  if (m01 === void 0) {
    mat4_exports.set(
      matrix,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00
    );
  } else {
    mat4_exports.set(
      matrix,
      m00,
      m01,
      m02,
      m03,
      m10,
      m11,
      m12,
      m13,
      m20,
      m21,
      m22,
      m23,
      m30,
      m31,
      m32,
      m33
    );
  }
  return matrix;
}
function copy10(from, to) {
  mat4_exports.copy(to, from);
  return to;
}
function identity6(matrix) {
  mat4_exports.identity(matrix);
  return matrix;
}
function invert6(matrix, out = Mat4Utils.create()) {
  mat4_exports.invert(out, matrix);
  return out;
}
function mul9(first2, second, out = Mat4Utils.create()) {
  mat4_exports.mul(out, first2, second);
  return out;
}
function scale8(matrix, vector, out = Mat4Utils.create()) {
  mat4_exports.scale(out, matrix, vector);
  return out;
}
function clone9(matrix, out = Mat4Utils.create()) {
  Mat4Utils.copy(matrix, out);
  return out;
}
function getPosition2(matrix, out = Vec3Utils.create()) {
  mat4_exports.getTranslation(out, matrix);
  return out;
}
function getRotation3(matrix, out = Vec3Utils.create()) {
  return Mat4Utils.getRotationDegrees(matrix, out);
}
var getRotationDegrees2 = function() {
  let quat = create9();
  return function getRotationDegrees4(matrix, out = Vec3Utils.create()) {
    Mat4Utils.getRotationQuat(matrix, quat);
    QuatUtils.toDegrees(quat, out);
    return out;
  };
}();
var getRotationRadians2 = function() {
  let quat = create9();
  return function getRotationRadians4(matrix, out = Vec3Utils.create()) {
    Mat4Utils.getRotationQuat(matrix, quat);
    QuatUtils.toRadians(quat, out);
    return out;
  };
}();
var getRotationQuat2 = function() {
  let tempScale = create10();
  let transformMatrixNoScale = create12();
  let inverseScale = create10();
  let one = create10();
  set9(one, 1, 1, 1);
  return function getRotationQuat4(matrix, out = QuatUtils.create()) {
    Mat4Utils.getScale(matrix, tempScale);
    Vec3Utils.div(one, tempScale, inverseScale);
    Mat4Utils.scale(matrix, inverseScale, transformMatrixNoScale);
    _customGLMatrixGetRotation(out, transformMatrixNoScale);
    return out;
  };
}();
function getScale(matrix, out = Vec3Utils.create()) {
  mat4_exports.getScaling(out, matrix);
  return out;
}
function setPosition2(matrix, position) {
  matrix[12] = position[0];
  matrix[13] = position[1];
  matrix[14] = position[2];
  return matrix;
}
function setRotation2(matrix, rotation) {
  Mat4Utils.setRotationDegrees(matrix, rotation);
  return matrix;
}
var setRotationDegrees2 = function() {
  let quat = create9();
  return function setRotationDegrees4(matrix, rotation) {
    Mat4Utils.setRotationQuat(matrix, Vec3Utils.degreesToQuat(rotation, quat));
    return matrix;
  };
}();
var setRotationRadians2 = function() {
  let vector = create10();
  return function setRotationRadians4(matrix, rotation) {
    Mat4Utils.setRotationDegrees(matrix, Vec3Utils.toDegrees(rotation, vector));
    return matrix;
  };
}();
var setRotationQuat2 = function() {
  let position = create10();
  let scale11 = create10();
  return function setRotationQuat4(matrix, rotation) {
    Mat4Utils.getPosition(matrix, position);
    Mat4Utils.getScale(matrix, scale11);
    Mat4Utils.setPositionRotationQuatScale(matrix, position, rotation, scale11);
    return matrix;
  };
}();
var setScale = function() {
  let tempScale = create10();
  return function setScale3(matrix, scaleToSet) {
    Mat4Utils.getScale(matrix, tempScale);
    Vec3Utils.div(scaleToSet, tempScale, tempScale);
    Mat4Utils.scale(matrix, tempScale, matrix);
    return matrix;
  };
}();
function setPositionRotationScale(matrix, position, rotation, scale11) {
  Mat4Utils.setPositionRotationDegreesScale(matrix, position, rotation, scale11);
  return matrix;
}
var setPositionRotationDegreesScale = function() {
  let quat = create9();
  return function setPositionRotationDegreesScale2(matrix, position, rotation, scale11) {
    Mat4Utils.setPositionRotationQuatScale(matrix, position, Vec3Utils.degreesToQuat(rotation, quat), scale11);
    return matrix;
  };
}();
var setPositionRotationRadiansScale = function() {
  let vector = create10();
  return function setPositionRotationRadiansScale2(matrix, position, rotation, scale11) {
    Mat4Utils.setPositionRotationDegreesScale(matrix, position, Vec3Utils.toDegrees(rotation, vector), scale11);
    return matrix;
  };
}();
function setPositionRotationQuatScale(matrix, position, rotation, scale11) {
  mat4_exports.fromRotationTranslationScale(matrix, rotation, position, scale11);
  return matrix;
}
function setPositionRotation2(matrix, position, rotation) {
  Mat4Utils.setPositionRotationDegrees(matrix, position, rotation);
  return matrix;
}
var setPositionRotationDegrees2 = function() {
  let quat = create9();
  return function setPositionRotationDegrees3(matrix, position, rotation) {
    Mat4Utils.setPositionRotationQuat(matrix, position, Vec3Utils.degreesToQuat(rotation, quat));
    return matrix;
  };
}();
var setPositionRotationRadians2 = function() {
  let vector = create10();
  return function setPositionRotationRadians3(matrix, position, rotation) {
    Mat4Utils.setPositionRotationDegrees(matrix, position, Vec3Utils.toDegrees(rotation, vector));
    return matrix;
  };
}();
function setPositionRotationQuat2(matrix, position, rotation) {
  mat4_exports.fromRotationTranslation(matrix, rotation, position);
  return matrix;
}
function getAxes2(matrix, out = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
  Mat4Utils.getLeft(matrix, out[0]);
  Mat4Utils.getUp(matrix, out[1]);
  Mat4Utils.getForward(matrix, out[2]);
  return out;
}
function getForward2(matrix, out = Vec3Utils.create()) {
  Vec3Utils.set(out, matrix[8], matrix[9], matrix[10]);
  Vec3Utils.normalize(out, out);
  return out;
}
function getBackward2(matrix, out) {
  out = Mat4Utils.getForward(matrix, out);
  Vec3Utils.negate(out, out);
  return out;
}
function getLeft2(matrix, out = Vec3Utils.create()) {
  Vec3Utils.set(out, matrix[0], matrix[1], matrix[2]);
  Vec3Utils.normalize(out, out);
  return out;
}
function getRight2(matrix, out) {
  out = Mat4Utils.getLeft(matrix, out);
  Vec3Utils.negate(out, out);
  return out;
}
function getUp2(matrix, out = Vec3Utils.create()) {
  Vec3Utils.set(out, matrix[4], matrix[5], matrix[6]);
  Vec3Utils.normalize(out, out);
  return out;
}
function getDown2(matrix, out) {
  out = Mat4Utils.getUp(matrix, out);
  Vec3Utils.negate(out, out);
  return out;
}
var toWorld2 = function() {
  let convertTransform = create12();
  let position = create10();
  let tempScale = create10();
  let inverseScale = create10();
  let one = create10();
  set9(one, 1, 1, 1);
  return function toWorld4(matrix, parentTransformMatrix, out = Mat4Utils.create()) {
    if (Mat4Utils.hasUniformScale(parentTransformMatrix)) {
      Mat4Utils.mul(parentTransformMatrix, matrix, out);
    } else {
      Vec3Utils.set(position, matrix[12], matrix[13], matrix[14]);
      Vec3Utils.convertPositionToWorldMatrix(position, parentTransformMatrix, position);
      Mat4Utils.getScale(parentTransformMatrix, tempScale);
      Vec3Utils.div(one, tempScale, inverseScale);
      Mat4Utils.scale(parentTransformMatrix, inverseScale, convertTransform);
      Mat4Utils.mul(convertTransform, matrix, out);
      Mat4Utils.scale(out, tempScale, out);
      out[12] = position[0];
      out[13] = position[1];
      out[14] = position[2];
      out[15] = 1;
    }
    return out;
  };
}();
var toLocal2 = function() {
  let convertTransform = create12();
  let position = create10();
  let tempScale = create10();
  let inverseScale = create10();
  let one = create10();
  set9(one, 1, 1, 1);
  return function toLocal4(matrix, parentTransformMatrix, out = Mat4Utils.create()) {
    if (Mat4Utils.hasUniformScale(parentTransformMatrix)) {
      Mat4Utils.invert(parentTransformMatrix, convertTransform);
      Mat4Utils.mul(convertTransform, matrix, out);
    } else {
      Vec3Utils.set(position, matrix[12], matrix[13], matrix[14]);
      Vec3Utils.convertPositionToLocalMatrix(position, parentTransformMatrix, position);
      Mat4Utils.getScale(parentTransformMatrix, tempScale);
      Vec3Utils.div(one, tempScale, inverseScale);
      Mat4Utils.scale(parentTransformMatrix, inverseScale, convertTransform);
      Mat4Utils.invert(convertTransform, convertTransform);
      Mat4Utils.mul(convertTransform, matrix, out);
      Mat4Utils.scale(out, inverseScale, out);
      out[12] = position[0];
      out[13] = position[1];
      out[14] = position[2];
      out[15] = 1;
    }
    return out;
  };
}();
var hasUniformScale = function() {
  let scale11 = create10();
  return function hasUniformScale3(matrix) {
    Mat4Utils.getScale(matrix, scale11);
    return Math.abs(scale11[0] - scale11[1]) < MathUtils.EPSILON && Math.abs(scale11[1] - scale11[2]) < MathUtils.EPSILON && Math.abs(scale11[0] - scale11[2]) < MathUtils.EPSILON;
  };
}();
var toQuat = function() {
  let position = create10();
  let rotation = create9();
  return function toQuat4(matrix, out = Quat2Utils.create()) {
    Mat4Utils.getPosition(matrix, position);
    Mat4Utils.getRotationQuat(matrix, rotation);
    Quat2Utils.setPositionRotationQuat(out, position, rotation);
    return out;
  };
}();
function fromQuat4(quat, out = Mat4Utils.create()) {
  Quat2Utils.toMatrix(quat, out);
  return out;
}
var Mat4Utils = {
  create: create12,
  set: set10,
  copy: copy10,
  identity: identity6,
  invert: invert6,
  mul: mul9,
  scale: scale8,
  clone: clone9,
  getPosition: getPosition2,
  getRotation: getRotation3,
  getRotationDegrees: getRotationDegrees2,
  getRotationRadians: getRotationRadians2,
  getRotationQuat: getRotationQuat2,
  getScale,
  setPosition: setPosition2,
  setRotation: setRotation2,
  setRotationDegrees: setRotationDegrees2,
  setRotationRadians: setRotationRadians2,
  setRotationQuat: setRotationQuat2,
  setScale,
  setPositionRotationScale,
  setPositionRotationDegreesScale,
  setPositionRotationRadiansScale,
  setPositionRotationQuatScale,
  setPositionRotation: setPositionRotation2,
  setPositionRotationDegrees: setPositionRotationDegrees2,
  setPositionRotationRadians: setPositionRotationRadians2,
  setPositionRotationQuat: setPositionRotationQuat2,
  getAxes: getAxes2,
  getForward: getForward2,
  getBackward: getBackward2,
  getLeft: getLeft2,
  getRight: getRight2,
  getUp: getUp2,
  getDown: getDown2,
  toWorld: toWorld2,
  toLocal: toLocal2,
  hasUniformScale,
  toQuat,
  fromQuat: fromQuat4
};
var _customGLMatrixGetRotation = function() {
  let scaling = create10();
  return function _customGLMatrixGetRotation2(out, mat) {
    mat4_exports.getScaling(scaling, mat);
    let is1 = 1 / scaling[0];
    let is2 = 1 / scaling[1];
    let is3 = 1 / scaling[2];
    let sm11 = mat[0] * is1;
    let sm12 = mat[1] * is2;
    let sm13 = mat[2] * is3;
    let sm21 = mat[4] * is1;
    let sm22 = mat[5] * is2;
    let sm23 = mat[6] * is3;
    let sm31 = mat[8] * is1;
    let sm32 = mat[9] * is2;
    let sm33 = mat[10] * is3;
    let trace = sm11 + sm22 + sm33;
    let S = 0;
    if (trace > 0) {
      S = Math.sqrt(trace + 1) * 2;
      out[3] = 0.25 * S;
      out[0] = (sm23 - sm32) / S;
      out[1] = (sm31 - sm13) / S;
      out[2] = (sm12 - sm21) / S;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
      out[3] = (sm23 - sm32) / S;
      out[0] = 0.25 * S;
      out[1] = (sm12 + sm21) / S;
      out[2] = (sm31 + sm13) / S;
    } else if (sm22 > sm33) {
      S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
      out[3] = (sm31 - sm13) / S;
      out[0] = (sm12 + sm21) / S;
      out[1] = 0.25 * S;
      out[2] = (sm23 + sm32) / S;
    } else {
      S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
      out[3] = (sm12 - sm21) / S;
      out[0] = (sm31 + sm13) / S;
      out[1] = (sm23 + sm32) / S;
      out[2] = 0.25 * S;
    }
    return out;
  };
}();

// js/pp/cauldron/js/utils/vec3_utils.js
function create10(x, y, z) {
  let out = vec3_exports.create();
  if (x !== void 0) {
    set9(out, x, y, z);
  }
  return out;
}
function set9(vector, x, y, z) {
  if (y === void 0) {
    vec3_exports.set(vector, x, x, x);
  } else {
    vec3_exports.set(vector, x, y, z);
  }
  return vector;
}
function normalize7(vector, out = Vec3Utils.create()) {
  vec3_exports.normalize(out, vector);
  return out;
}
function copy11(from, to) {
  vec3_exports.copy(to, from);
  return to;
}
function clone10(vector, out = Vec3Utils.create()) {
  Vec3Utils.copy(vector, out);
  return out;
}
function zero4(vector) {
  vec3_exports.zero(vector);
  return vector;
}
function angle3(first2, second) {
  return Vec3Utils.angleDegrees(first2, second);
}
function angleDegrees(first2, second) {
  return MathUtils.toDegrees(Vec3Utils.angleRadians(first2, second));
}
function angleRadians(first2, second) {
  let firstX = first2[0];
  let firstY = first2[1];
  let firstZ = first2[2];
  let secondX = second[0];
  let secondY = second[1];
  let secondZ = second[2];
  let firstLengthSquared = firstX * firstX + firstY * firstY + firstZ * firstZ;
  let secondLengthSquared = secondX * secondX + secondY * secondY + secondZ * secondZ;
  let lengthSquared4 = firstLengthSquared * secondLengthSquared;
  let angle4 = 0;
  if (lengthSquared4 > MathUtils.EPSILON_SQUARED) {
    let length10 = Math.sqrt(lengthSquared4);
    let cos = Vec3Utils.dot(first2, second) / length10;
    angle4 = Math.acos(MathUtils.clamp(cos, -1, 1));
  }
  return angle4;
}
function equals9(first2, second, epsilon = 0) {
  let equals12 = first2.length == second.length;
  if (equals12) {
    equals12 &&= Math.abs(first2[0] - second[0]) <= epsilon;
    equals12 &&= Math.abs(first2[1] - second[1]) <= epsilon;
    equals12 &&= Math.abs(first2[2] - second[2]) <= epsilon;
  }
  return equals12;
}
function length7(vector) {
  return vec3_exports.length(vector);
}
function lengthSquared2(vector) {
  return vec3_exports.squaredLength(vector);
}
function distance4(first2, second) {
  return vec3_exports.dist(first2, second);
}
function distanceSquared(first2, second) {
  return vec3_exports.squaredDistance(first2, second);
}
function add8(first2, second, out = Vec3Utils.create()) {
  vec3_exports.add(out, first2, second);
  return out;
}
function sub6(first2, second, out = Vec3Utils.create()) {
  vec3_exports.sub(out, first2, second);
  return out;
}
function mul10(first2, second, out = Vec3Utils.create()) {
  vec3_exports.mul(out, first2, second);
  return out;
}
function div4(first2, second, out = Vec3Utils.create()) {
  vec3_exports.div(out, first2, second);
  return out;
}
function scale9(vector, value, out = Vec3Utils.create()) {
  vec3_exports.scale(out, vector, value);
  return out;
}
function dot6(first2, second) {
  return vec3_exports.dot(first2, second);
}
function negate4(vector, out = Vec3Utils.create()) {
  vec3_exports.negate(out, vector);
  return out;
}
function cross4(first2, second, out = Vec3Utils.create()) {
  vec3_exports.cross(out, first2, second);
  return out;
}
function transformQuat3(vector, quat, out = Vec3Utils.create()) {
  vec3_exports.transformQuat(out, vector, quat);
  return out;
}
function transformMat33(vector, matrix, out = Vec3Utils.create()) {
  vec3_exports.transformMat3(out, vector, matrix);
  return out;
}
function transformMat44(vector, mat4, out = Vec3Utils.create()) {
  vec3_exports.transformMat4(out, vector, mat4);
  return out;
}
function lengthSigned(vector, positiveDirection) {
  let signedLength = Vec3Utils.length(vector);
  if (!Vec3Utils.isConcordant(vector, positiveDirection)) {
    signedLength *= -1;
  }
  return signedLength;
}
function angleSigned(first2, second, referenceAxis) {
  return Vec3Utils.angleSignedDegrees(first2, second, referenceAxis);
}
function angleSignedDegrees(first2, second, referenceAxis) {
  return MathUtils.toDegrees(Vec3Utils.angleSignedRadians(first2, second, referenceAxis));
}
var angleSignedRadians = function() {
  let crossAxis = create10();
  return function angleSignedRadians2(first2, second, referenceAxis) {
    Vec3Utils.cross(first2, second, crossAxis);
    let angle4 = Vec3Utils.angleRadians(first2, second);
    if (!Vec3Utils.isConcordant(crossAxis, referenceAxis)) {
      angle4 = -angle4;
    }
    return angle4;
  };
}();
function anglePivoted(first2, second, referenceAxis) {
  return Vec3Utils.anglePivotedDegrees(first2, second, referenceAxis);
}
function anglePivotedDegrees(first2, second, referenceAxis) {
  return MathUtils.toDegrees(Vec3Utils.anglePivotedRadians(first2, second, referenceAxis));
}
var anglePivotedRadians = function() {
  let flatFirst = create10();
  let flatSecond = create10();
  return function anglePivotedRadians2(first2, second, referenceAxis) {
    flatFirst = Vec3Utils.removeComponentAlongAxis(first2, referenceAxis, flatFirst);
    flatSecond = Vec3Utils.removeComponentAlongAxis(second, referenceAxis, flatSecond);
    return Vec3Utils.angleRadians(flatFirst, flatSecond);
  };
}();
function anglePivotedSigned(first2, second, referenceAxis) {
  return Vec3Utils.anglePivotedSignedDegrees(first2, second, referenceAxis);
}
function anglePivotedSignedDegrees(first2, second, referenceAxis) {
  return MathUtils.toDegrees(Vec3Utils.anglePivotedSignedRadians(first2, second, referenceAxis));
}
var anglePivotedSignedRadians = function() {
  let flatFirst = create10();
  let flatSecond = create10();
  return function anglePivotedSignedRadians2(first2, second, referenceAxis) {
    flatFirst = Vec3Utils.removeComponentAlongAxis(first2, referenceAxis, flatFirst);
    flatSecond = Vec3Utils.removeComponentAlongAxis(second, referenceAxis, flatSecond);
    return Vec3Utils.angleSignedRadians(flatFirst, flatSecond, referenceAxis);
  };
}();
function toRadians2(vector, out = Vec3Utils.create()) {
  Vec3Utils.set(out, MathUtils.toRadians(vector[0]), MathUtils.toRadians(vector[1]), MathUtils.toRadians(vector[2]));
  return out;
}
function toDegrees2(vector, out = Vec3Utils.create()) {
  Vec3Utils.set(out, MathUtils.toDegrees(vector[0]), MathUtils.toDegrees(vector[1]), MathUtils.toDegrees(vector[2]));
  return out;
}
function toQuat2(vector, out) {
  return Vec3Utils.degreesToQuat(vector, out);
}
function radiansToQuat(vector, out = QuatUtils.create()) {
  QuatUtils.fromRadians(vector, out);
  return out;
}
function degreesToQuat(vector, out = QuatUtils.create()) {
  QuatUtils.fromDegrees(vector, out);
  return out;
}
function isNormalized2(vector, epsilon = MathUtils.EPSILON) {
  return Math.abs(Vec3Utils.lengthSquared(vector) - 1) < epsilon;
}
function isZero(vector, epsilon = 0) {
  return Vec3Utils.lengthSquared(vector) <= epsilon * epsilon;
}
function componentAlongAxis(vector, axis, out = Vec3Utils.create()) {
  let componentAlongAxisLength = Vec3Utils.dot(vector, axis);
  Vec3Utils.copy(axis, out);
  Vec3Utils.scale(out, componentAlongAxisLength, out);
  return out;
}
function valueAlongAxis(vector, axis) {
  let valueAlongAxis2 = Vec3Utils.dot(vector, axis);
  return valueAlongAxis2;
}
var removeComponentAlongAxis = function() {
  let componentAlong = create10();
  return function removeComponentAlongAxis2(vector, axis, out = Vec3Utils.create()) {
    Vec3Utils.componentAlongAxis(vector, axis, componentAlong);
    Vec3Utils.sub(vector, componentAlong, out);
    return out;
  };
}();
var copyComponentAlongAxis = function() {
  let componentAlong = create10();
  return function copyComponentAlongAxis2(from, to, axis, out = Vec3Utils.create()) {
    Vec3Utils.removeComponentAlongAxis(to, axis, out);
    Vec3Utils.componentAlongAxis(from, axis, componentAlong);
    Vec3Utils.add(out, componentAlong, out);
    return out;
  };
}();
function isConcordant(first2, second) {
  return Vec3Utils.dot(first2, second) >= 0;
}
function isFartherAlongAxis(first2, second, axis) {
  return Vec3Utils.valueAlongAxis(first2, axis) > Vec3Utils.valueAlongAxis(second, axis);
}
function isToTheRight(first2, second, referenceAxis) {
  return Vec3Utils.signTo(first2, second, referenceAxis) >= 0;
}
var signTo = function() {
  let componentAlongThis = create10();
  let componentAlongVector = create10();
  return function signTo2(first2, second, referenceAxis, zeroSign = 1) {
    Vec3Utils.removeComponentAlongAxis(first2, referenceAxis, componentAlongThis);
    Vec3Utils.removeComponentAlongAxis(second, referenceAxis, componentAlongVector);
    let angleSignedResult = Vec3Utils.angleSigned(first2, second, referenceAxis);
    return angleSignedResult > 0 ? 1 : angleSignedResult == 0 ? zeroSign : -1;
  };
}();
function projectOnAxis(vector, axis, out = Vec3Utils.create()) {
  Vec3Utils.componentAlongAxis(vector, axis, out);
  return out;
}
var projectOnAxisAlongAxis = function() {
  let up = create10();
  let vectorProjectedToAxis = create10();
  let fixedProjectAlongAxis = create10();
  return function projectOnAxisAlongAxis2(vector, axis, projectAlongAxis, out = Vec3Utils.create()) {
    if (Vec3Utils.isOnAxis(vector, axis) || Vec3Utils.isOnAxis(projectAlongAxis, axis)) {
      Vec3Utils.copy(vector, out);
    } else {
      Vec3Utils.cross(projectAlongAxis, axis, up);
      Vec3Utils.normalize(up, up);
      Vec3Utils.removeComponentAlongAxis(vector, up, out);
      if (!Vec3Utils.isOnAxis(out, axis)) {
        Vec3Utils.projectOnAxis(out, axis, vectorProjectedToAxis);
        Vec3Utils.sub(vectorProjectedToAxis, out, vectorProjectedToAxis);
        if (Vec3Utils.isConcordant(vectorProjectedToAxis, projectAlongAxis)) {
          Vec3Utils.copy(projectAlongAxis, fixedProjectAlongAxis);
        } else {
          Vec3Utils.negate(projectAlongAxis, fixedProjectAlongAxis);
        }
        let angleWithAlongAxis = Vec3Utils.angleRadians(fixedProjectAlongAxis, vectorProjectedToAxis);
        let lengthToRemove = Vec3Utils.length(vectorProjectedToAxis) / Math.cos(angleWithAlongAxis);
        Vec3Utils.scale(fixedProjectAlongAxis, lengthToRemove, fixedProjectAlongAxis);
        Vec3Utils.add(out, fixedProjectAlongAxis, out);
        Vec3Utils.projectOnAxis(out, axis, out);
      }
    }
    return out;
  };
}();
function projectOnPlane(vector, planeNormal, out = Vec3Utils.create()) {
  Vec3Utils.removeComponentAlongAxis(vector, planeNormal, out);
  return out;
}
var projectOnPlaneAlongAxis = function() {
  let vectorProjectedToPlane = create10();
  let fixedProjectAlongAxis = create10();
  return function projectOnPlaneAlongAxis2(vector, planeNormal, projectAlongAxis, out = Vec3Utils.create()) {
    if (Vec3Utils.isOnPlane(vector, planeNormal) || Vec3Utils.isOnPlane(projectAlongAxis, planeNormal)) {
      Vec3Utils.copy(vector, out);
    } else {
      Vec3Utils.copy(vector, out);
      Vec3Utils.projectOnPlane(out, planeNormal, vectorProjectedToPlane);
      Vec3Utils.sub(vectorProjectedToPlane, out, vectorProjectedToPlane);
      if (Vec3Utils.isConcordant(vectorProjectedToPlane, projectAlongAxis)) {
        Vec3Utils.copy(projectAlongAxis, fixedProjectAlongAxis);
      } else {
        Vec3Utils.negate(projectAlongAxis, fixedProjectAlongAxis);
      }
      let angleWithAlongAxis = Vec3Utils.angleRadians(fixedProjectAlongAxis, vectorProjectedToPlane);
      let lengthToRemove = Vec3Utils.length(vectorProjectedToPlane) / Math.cos(angleWithAlongAxis);
      Vec3Utils.scale(fixedProjectAlongAxis, lengthToRemove, fixedProjectAlongAxis);
      Vec3Utils.add(out, fixedProjectAlongAxis, out);
      Vec3Utils.projectOnPlane(out, planeNormal, out);
    }
    return out;
  };
}();
function isOnAxis(vector, axis) {
  let angleResult = Vec3Utils.angle(vector, axis);
  return Math.abs(angleResult) < MathUtils.EPSILON_DEGREES || Math.abs(angleResult - 180) < MathUtils.EPSILON_DEGREES;
}
function isOnPlane(vector, planeNormal) {
  let angleResult = Vec3Utils.angle(vector, planeNormal);
  return Math.abs(angleResult - 90) < MathUtils.EPSILON_DEGREES;
}
function rotate4(vector, rotation, out) {
  return Vec3Utils.rotateDegrees(vector, rotation, out);
}
var rotateDegrees = function() {
  let zero7 = create10();
  return function rotateDegrees4(vector, rotation, out) {
    return Vec3Utils.rotateAroundDegrees(vector, rotation, zero7, out);
  };
}();
var rotateRadians = function() {
  let zero7 = create10();
  return function rotateRadians4(vector, rotation, out) {
    return Vec3Utils.rotateAroundRadians(vector, rotation, zero7, out);
  };
}();
var rotateQuat = function() {
  let zero7 = create10();
  return function rotateQuat4(vector, rotation, out) {
    return Vec3Utils.rotateAroundQuat(vector, rotation, zero7, out);
  };
}();
function rotateAxis2(vector, angle4, axis, out) {
  return Vec3Utils.rotateAxisDegrees(vector, angle4, axis, out);
}
var rotateAxisDegrees2 = function() {
  let zero7 = create10();
  return function rotateAxisDegrees5(vector, angle4, axis, out) {
    return Vec3Utils.rotateAroundAxisDegrees(vector, angle4, axis, zero7, out);
  };
}();
var rotateAxisRadians2 = function() {
  let zero7 = create10();
  return function rotateAxisRadians5(vector, angle4, axis, out) {
    return Vec3Utils.rotateAroundAxisRadians(vector, angle4, axis, zero7, out);
  };
}();
function rotateAround(vector, rotation, origin, out) {
  return Vec3Utils.rotateAroundDegrees(vector, rotation, origin, out);
}
var rotateAroundDegrees = function() {
  let quat = create9();
  return function rotateAroundDegrees3(vector, rotation, origin, out = Vec3Utils.create()) {
    Vec3Utils.degreesToQuat(rotation, quat);
    return Vec3Utils.rotateAroundQuat(vector, quat, origin, out);
  };
}();
var rotateAroundRadians = function() {
  let quat = create9();
  return function rotateAroundRadians3(vector, rotation, origin, out = Vec3Utils.create()) {
    Vec3Utils.radiansToQuat(rotation, quat);
    return Vec3Utils.rotateAroundQuat(vector, quat, origin, out);
  };
}();
function rotateAroundQuat(vector, rotation, origin, out = Vec3Utils.create()) {
  Vec3Utils.sub(vector, origin, out);
  Vec3Utils.transformQuat(out, rotation, out);
  Vec3Utils.add(out, origin, out);
  return out;
}
function rotateAroundAxis2(vector, angle4, axis, origin, out) {
  return Vec3Utils.rotateAroundAxisDegrees(vector, angle4, axis, origin, out);
}
function rotateAroundAxisDegrees(vector, angle4, axis, origin, out) {
  return Vec3Utils.rotateAroundAxisRadians(vector, MathUtils.toRadians(angle4), axis, origin, out);
}
var rotateAroundAxisRadians = function() {
  let quat = create9();
  return function rotateAroundAxisRadians3(vector, angle4, axis, origin, out = Vec3Utils.create()) {
    QuatUtils.fromAxisRadians(angle4, axis, quat);
    return Vec3Utils.rotateAroundQuat(vector, quat, origin, out);
  };
}();
function convertPositionToWorld(vector, parentTransform, out) {
  return Vec3Utils.convertPositionToWorldMatrix(vector, parentTransform, out);
}
function convertPositionToLocal(vector, parentTransform, out) {
  return Vec3Utils.convertPositionToLocalMatrix(vector, parentTransform, out);
}
function convertPositionToWorldMatrix(vector, parentTransform, out = Vec3Utils.create()) {
  Vec3Utils.transformMat4(vector, parentTransform, out);
  return out;
}
var convertPositionToLocalMatrix = function() {
  let inverse4 = create12();
  return function convertPositionToLocalMatrix2(vector, parentTransform, out = Vec3Utils.create()) {
    Mat4Utils.invert(parentTransform, inverse4);
    Vec3Utils.transformMat4(vector, inverse4, out);
    return out;
  };
}();
var convertPositionToWorldQuat = function() {
  let parentTransformMatrix = create12();
  let position = create10();
  let rotation = create9();
  let one = create10();
  set9(one, 1, 1, 1);
  return function convertPositionToWorldQuat2(vector, parentTransform, out = Vec3Utils.create()) {
    Quat2Utils.getPosition(parentTransform, position);
    Quat2Utils.getRotationQuat(parentTransform, rotation);
    Mat4Utils.setPositionRotationQuatScale(parentTransformMatrix, position, rotation, one);
    return Vec3Utils.convertPositionToWorldMatrix(vector, parentTransformMatrix, out);
  };
}();
var convertPositionToLocalQuat = function() {
  let parentTransformMatrix = create12();
  let position = create10();
  let rotation = create9();
  let one = create10();
  set9(one, 1, 1, 1);
  return function convertPositionToLocalQuat2(vector, parentTransform, out = Vec3Utils.create()) {
    Quat2Utils.getPosition(parentTransform, position);
    Quat2Utils.getRotationQuat(parentTransform, rotation);
    Mat4Utils.setPositionRotationQuatScale(parentTransformMatrix, position, rotation, one);
    return Vec3Utils.convertPositionToLocalMatrix(vector, parentTransformMatrix, out);
  };
}();
function convertDirectionToWorld(vector, parentTransform, out) {
  return Vec3Utils.convertDirectionToWorldMatrix(vector, parentTransform, out);
}
function convertDirectionToLocal(vector, parentTransform, out) {
  return Vec3Utils.convertDirectionToLocalMatrix(vector, parentTransform, out);
}
var convertDirectionToWorldMatrix = function() {
  let rotation = create9();
  return function convertDirectionToWorldMatrix2(vector, parentTransform, out = Vec3Utils.create()) {
    Mat4Utils.getRotationQuat(parentTransform, rotation);
    Vec3Utils.transformQuat(vector, rotation, out);
    return out;
  };
}();
var convertDirectionToLocalMatrix = function() {
  let rotation = create9();
  return function convertDirectionToLocalMatrix2(vector, parentTransform, out = Vec3Utils.create()) {
    Mat4Utils.getRotationQuat(parentTransform, rotation);
    QuatUtils.conjugate(rotation, rotation);
    Vec3Utils.transformQuat(vector, rotation, out);
    return out;
  };
}();
var convertDirectionToWorldQuat = function() {
  let rotation = create9();
  return function convertDirectionToWorldQuat2(vector, parentTransform, out = Vec3Utils.create()) {
    Quat2Utils.getRotationQuat(parentTransform, rotation);
    Vec3Utils.transformQuat(vector, rotation, out);
    return out;
  };
}();
var convertDirectionToLocalQuat = function() {
  let rotation = create9();
  return function convertDirectionToLocalQuat2(vector, parentTransform, out = Vec3Utils.create()) {
    Quat2Utils.getRotationQuat(parentTransform, rotation);
    QuatUtils.conjugate(rotation, rotation);
    Vec3Utils.transformQuat(vector, rotation, out);
    return out;
  };
}();
function addRotation(vector, rotation, out) {
  return Vec3Utils.degreesAddRotation(vector, rotation, out);
}
function addRotationDegrees(vector, rotation, out) {
  return Vec3Utils.degreesAddRotationDegrees(vector, rotation, out);
}
function addRotationRadians(vector, rotation, out) {
  return Vec3Utils.degreesAddRotationRadians(vector, rotation, out);
}
function addRotationQuat(vector, rotation, out) {
  return Vec3Utils.degreesAddRotationQuat(vector, rotation, out);
}
function degreesAddRotation(vector, rotation, out) {
  return Vec3Utils.degreesAddRotationDegrees(vector, rotation, out);
}
var degreesAddRotationDegrees = function() {
  let quat = create9();
  return function degreesAddRotationDegrees2(vector, rotation, out = Vec3Utils.create()) {
    Vec3Utils.degreesToQuat(vector, quat);
    return QuatUtils.toDegrees(QuatUtils.addRotationDegrees(quat, rotation, quat), out);
  };
}();
var degreesAddRotationRadians = function() {
  let quat = create9();
  return function degreesAddRotationRadians2(vector, rotation, out = Vec3Utils.create()) {
    Vec3Utils.degreesToQuat(vector, quat);
    return QuatUtils.toDegrees(QuatUtils.addRotationRadians(quat, rotation, quat), out);
  };
}();
var degreesAddRotationQuat = function() {
  let quat = create9();
  return function degreesAddRotationQuat2(vector, rotation, out = Vec3Utils.create()) {
    Vec3Utils.degreesToQuat(vector, quat);
    return QuatUtils.toDegrees(QuatUtils.addRotationQuat(quat, rotation, quat), out);
  };
}();
function radiansAddRotation(vector, rotation, out) {
  return Vec3Utils.radiansAddRotationDegrees(vector, rotation, out);
}
var radiansAddRotationDegrees = function() {
  let quat = create9();
  return function radiansAddRotationDegrees2(vector, rotation, out = Vec3Utils.create()) {
    Vec3Utils.radiansToQuat(vector, quat);
    return QuatUtils.toRadians(QuatUtils.addRotationDegrees(quat, rotation, quat), out);
  };
}();
var radiansAddRotationRadians = function() {
  let quat = create9();
  return function radiansAddRotationRadians2(vector, rotation, out = Vec3Utils.create()) {
    Vec3Utils.radiansToQuat(vector, quat);
    return QuatUtils.toRadians(QuatUtils.addRotationRadians(quat, rotation, quat), out);
  };
}();
var radiansAddRotationQuat = function() {
  let quat = create9();
  return function radiansAddRotationQuat2(vector, rotation, out = Vec3Utils.create()) {
    Vec3Utils.radiansToQuat(vector, quat);
    return QuatUtils.toRadians(QuatUtils.addRotationQuat(quat, rotation, quat), out);
  };
}();
function toMatrix2(vector, out = Mat3Utils.create()) {
  return Vec3Utils.degreesToMatrix(vector, out);
}
var degreesToMatrix = function() {
  let quat = create9();
  return function degreesToMatrix2(vector, out = Mat3Utils.create()) {
    Vec3Utils.degreesToQuat(vector, quat);
    return QuatUtils.toMatrix(quat, out);
  };
}();
var radiansToMatrix = function() {
  let quat = create9();
  return function radiansToMatrix2(vector, out = Mat3Utils.create()) {
    Vec3Utils.radiansToQuat(vector, quat);
    return QuatUtils.toMatrix(quat, out);
  };
}();
function rotationTo2(from, to, out) {
  return Vec3Utils.rotationToDegrees(from, to, out);
}
var rotationToDegrees = function() {
  let rotationQuat = create9();
  return function rotationToDegrees3(from, to, out = Vec3Utils.create()) {
    Vec3Utils.rotationToQuat(from, to, rotationQuat);
    QuatUtils.toDegrees(rotationQuat, out);
    return out;
  };
}();
var rotationToRadians = function() {
  let rotationQuat = create9();
  return function rotationToRadians3(from, to, out = Vec3Utils.create()) {
    Vec3Utils.rotationToQuat(from, to, rotationQuat);
    QuatUtils.toRadians(rotationQuat, out);
    return out;
  };
}();
var rotationToQuat = function() {
  let rotationAxis = create10();
  return function rotationToQuat3(from, to, out = QuatUtils.create()) {
    Vec3Utils.cross(from, to, rotationAxis);
    Vec3Utils.normalize(rotationAxis, rotationAxis);
    let signedAngle = Vec3Utils.angleSigned(from, to, rotationAxis);
    QuatUtils.fromAxisRadians(signedAngle, rotationAxis, out);
    return out;
  };
}();
function rotationToPivoted(from, to, pivotAxis, out) {
  return Vec3Utils.rotationToPivotedDegrees(from, to, pivotAxis, out);
}
var rotationToPivotedDegrees = function() {
  let rotationQuat = create9();
  return function rotationToPivotedDegrees2(from, to, pivotAxis, out = Vec3Utils.create()) {
    Vec3Utils.rotationToPivotedQuat(from, to, pivotAxis, rotationQuat);
    QuatUtils.toDegrees(rotationQuat, out);
    return out;
  };
}();
var rotationToPivotedRadians = function() {
  let rotationQuat = create9();
  return function rotationToPivotedRadians2(from, to, pivotAxis, out = Vec3Utils.create()) {
    Vec3Utils.rotationToPivotedQuat(from, to, pivotAxis, rotationQuat);
    QuatUtils.toRadians(rotationQuat, out);
    return out;
  };
}();
var rotationToPivotedQuat = function() {
  let fromFlat = create10();
  let toFlat = create10();
  let rotationAxis = create10();
  return function rotationToPivotedQuat2(from, to, pivotAxis, out = QuatUtils.create()) {
    Vec3Utils.removeComponentAlongAxis(from, pivotAxis, fromFlat);
    Vec3Utils.removeComponentAlongAxis(to, pivotAxis, toFlat);
    Vec3Utils.cross(fromFlat, toFlat, rotationAxis);
    Vec3Utils.normalize(rotationAxis, rotationAxis);
    let signedAngle = Vec3Utils.angleSignedRadians(fromFlat, toFlat, rotationAxis);
    QuatUtils.fromAxisRadians(signedAngle, rotationAxis, out);
    return out;
  };
}();
function lerp8(from, to, interpolationFactor, out = Vec3Utils.create()) {
  if (interpolationFactor <= 0) {
    Vec3Utils.copy(from, out);
    return out;
  } else if (interpolationFactor >= 1) {
    Vec3Utils.copy(to, out);
    return out;
  }
  vec3_exports.lerp(out, from, to, interpolationFactor);
  return out;
}
function interpolate3(from, to, interpolationFactor, easingFunction = EasingFunction.linear, out = Vec3Utils.create()) {
  let lerpFactor = easingFunction(interpolationFactor);
  return Vec3Utils.lerp(from, to, lerpFactor, out);
}
var perpendicularRandom = function() {
  let notVector = create10();
  return function perpendicularRandom2(vector, out = Vec3Utils.create()) {
    if (Vec3Utils.isZero(vector)) {
      return Vec3Utils.zero(out);
    }
    Vec3Utils.copy(vector, notVector);
    let zeroAmount = false;
    for (let i = 0; i < 3; i++) {
      if (vector[i] == 0) {
        zeroAmount++;
      }
    }
    if (zeroAmount == 2) {
      if (notVector[0] == 0) {
        notVector[0] = 1;
      } else if (notVector[1] == 0) {
        notVector[1] = 1;
      } else if (notVector[2] == 0) {
        notVector[2] = 1;
      }
    } else {
      if (notVector[0] != 0) {
        notVector[0] = -notVector[0];
      } else if (notVector[1] != 0) {
        notVector[1] = -notVector[1];
      } else if (notVector[2] != 0) {
        notVector[2] = -notVector[2];
      }
    }
    Vec3Utils.cross(notVector, vector, out);
    return out;
  };
}();
var Vec3Utils = {
  create: create10,
  set: set9,
  normalize: normalize7,
  copy: copy11,
  clone: clone10,
  zero: zero4,
  angle: angle3,
  angleDegrees,
  angleRadians,
  equals: equals9,
  length: length7,
  lengthSquared: lengthSquared2,
  distance: distance4,
  distanceSquared,
  add: add8,
  sub: sub6,
  mul: mul10,
  div: div4,
  scale: scale9,
  dot: dot6,
  negate: negate4,
  cross: cross4,
  transformQuat: transformQuat3,
  transformMat3: transformMat33,
  transformMat4: transformMat44,
  lengthSigned,
  angleSigned,
  angleSignedDegrees,
  angleSignedRadians,
  anglePivoted,
  anglePivotedDegrees,
  anglePivotedRadians,
  anglePivotedSigned,
  anglePivotedSignedDegrees,
  anglePivotedSignedRadians,
  toRadians: toRadians2,
  toDegrees: toDegrees2,
  toQuat: toQuat2,
  radiansToQuat,
  degreesToQuat,
  isNormalized: isNormalized2,
  isZero,
  componentAlongAxis,
  valueAlongAxis,
  removeComponentAlongAxis,
  copyComponentAlongAxis,
  isConcordant,
  isFartherAlongAxis,
  isToTheRight,
  signTo,
  projectOnAxis,
  projectOnAxisAlongAxis,
  projectOnPlane,
  projectOnPlaneAlongAxis,
  isOnAxis,
  isOnPlane,
  rotate: rotate4,
  rotateDegrees,
  rotateRadians,
  rotateQuat,
  rotateAxis: rotateAxis2,
  rotateAxisDegrees: rotateAxisDegrees2,
  rotateAxisRadians: rotateAxisRadians2,
  rotateAround,
  rotateAroundDegrees,
  rotateAroundRadians,
  rotateAroundQuat,
  rotateAroundAxis: rotateAroundAxis2,
  rotateAroundAxisDegrees,
  rotateAroundAxisRadians,
  convertPositionToWorld,
  convertPositionToLocal,
  convertPositionToWorldMatrix,
  convertPositionToLocalMatrix,
  convertPositionToWorldQuat,
  convertPositionToLocalQuat,
  convertDirectionToWorld,
  convertDirectionToLocal,
  convertDirectionToWorldMatrix,
  convertDirectionToLocalMatrix,
  convertDirectionToWorldQuat,
  convertDirectionToLocalQuat,
  addRotation,
  addRotationDegrees,
  addRotationRadians,
  addRotationQuat,
  degreesAddRotation,
  degreesAddRotationDegrees,
  degreesAddRotationRadians,
  degreesAddRotationQuat,
  radiansAddRotation,
  radiansAddRotationDegrees,
  radiansAddRotationRadians,
  radiansAddRotationQuat,
  toMatrix: toMatrix2,
  degreesToMatrix,
  radiansToMatrix,
  rotationTo: rotationTo2,
  rotationToDegrees,
  rotationToRadians,
  rotationToQuat,
  rotationToPivoted,
  rotationToPivotedDegrees,
  rotationToPivotedRadians,
  rotationToPivotedQuat,
  lerp: lerp8,
  interpolate: interpolate3,
  perpendicularRandom
};

// js/pp/cauldron/js/utils/quat_utils.js
function create9(x, y, z, w) {
  let out = quat_exports.create();
  if (x !== void 0) {
    QuatUtils.set(out, x, y, z, w);
  }
  return out;
}
function set11(quat, x, y, z, w) {
  if (y === void 0) {
    quat_exports.set(quat, x, x, x, x);
  } else {
    quat_exports.set(quat, x, y, z, w);
  }
  return quat;
}
function normalize8(quat, out = QuatUtils.create()) {
  quat_exports.normalize(out, quat);
  return out;
}
function copy12(from, to) {
  quat_exports.copy(to, from);
  return to;
}
function clone11(quat, out = QuatUtils.create()) {
  QuatUtils.copy(quat, out);
  return out;
}
function identity7(quat) {
  quat_exports.identity(quat);
  return quat;
}
function length8(quat) {
  return quat_exports.length(quat);
}
function lengthSquared3(quat) {
  return quat_exports.squaredLength(quat);
}
function invert7(quat, out = QuatUtils.create()) {
  quat_exports.invert(out, quat);
  return out;
}
function conjugate4(quat, out = QuatUtils.create()) {
  quat_exports.conjugate(out, quat);
  return out;
}
function mul11(first2, second, out = QuatUtils.create()) {
  quat_exports.mul(out, first2, second);
  return out;
}
var getAxis = function() {
  let zero7 = create10(0, 0, 0);
  return function getAxis2(quat, out = Vec3Utils.create()) {
    let angle4 = quat_exports.getAxisAngle(out, quat);
    if (angle4 <= MathUtils.EPSILON) {
      Vec3Utils.copy(zero7, out);
    }
    return out;
  };
}();
function getAngle2(quat) {
  return QuatUtils.getAngleDegrees(quat);
}
function getAngleDegrees(quat) {
  let angle4 = QuatUtils.getAngleRadians(quat);
  return MathUtils.toDegrees(angle4);
}
var getAngleRadians = function() {
  let vector = create10();
  return function getAngleRadians2(quat) {
    let angle4 = quat_exports.getAxisAngle(vector, quat);
    return angle4;
  };
}();
function getAxisScaled(quat, out = Vec3Utils.create()) {
  return QuatUtils.getAxisScaledDegrees(quat, out);
}
function getAxisScaledDegrees(quat, out = Vec3Utils.create()) {
  QuatUtils.getAxis(quat, out);
  let angle4 = QuatUtils.getAngleDegrees(quat);
  Vec3Utils.scale(out, angle4, out);
  return out;
}
var getAxisScaledRadians = function() {
  let zero7 = create10(0, 0, 0);
  return function getAxisScaledRadians2(quat, out = Vec3Utils.create()) {
    QuatUtils.getAxis(quat, out);
    let angle4 = QuatUtils.getAngleRadians(quat);
    if (angle4 <= MathUtils.EPSILON) {
      Vec3Utils.copy(zero7, out);
    } else {
      Vec3Utils.scale(out, angle4, out);
    }
    return out;
  };
}();
function getAxes3(quat, out = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
  QuatUtils.getLeft(quat, out[0]);
  QuatUtils.getUp(quat, out[1]);
  QuatUtils.getForward(quat, out[2]);
  return out;
}
var getForward3 = function() {
  let rotationMatrix = create8();
  return function getForward5(quat, out = Vec3Utils.create()) {
    QuatUtils.toMatrix(quat, rotationMatrix);
    Vec3Utils.set(out, rotationMatrix[6], rotationMatrix[7], rotationMatrix[8]);
    return out;
  };
}();
function getBackward3(quat, out) {
  out = QuatUtils.getForward(quat, out);
  Vec3Utils.negate(out, out);
  return out;
}
var getLeft3 = function() {
  let rotationMatrix = create8();
  return function getLeft5(quat, out = Vec3Utils.create()) {
    QuatUtils.toMatrix(quat, rotationMatrix);
    Vec3Utils.set(out, rotationMatrix[0], rotationMatrix[1], rotationMatrix[2]);
    return out;
  };
}();
function getRight3(quat, out) {
  out = QuatUtils.getLeft(quat, out);
  Vec3Utils.negate(out, out);
  return out;
}
var getUp3 = function() {
  let rotationMatrix = create8();
  return function getUp5(quat, out = Vec3Utils.create()) {
    QuatUtils.toMatrix(quat, rotationMatrix);
    Vec3Utils.set(out, rotationMatrix[3], rotationMatrix[4], rotationMatrix[5]);
    return out;
  };
}();
function getDown3(quat, out) {
  out = QuatUtils.getUp(quat, out);
  Vec3Utils.negate(out, out);
  return out;
}
function setAxes2(quat, left, up, forward) {
  if (forward != null) {
    return QuatUtils.setForward(quat, forward, up, left);
  } else if (up != null) {
    return QuatUtils.setUp(quat, up, forward, left);
  } else {
    return QuatUtils.setLeft(quat, left, up, forward);
  }
}
var setForward = function() {
  let axes = [null, null, null];
  let priority = [2, 1, 0];
  return function setForward3(quat, forward, up = null, left = null) {
    axes[0] = left;
    axes[1] = up;
    axes[2] = forward;
    let result = _setAxes(quat, axes, priority);
    axes[0] = null;
    axes[1] = null;
    axes[2] = null;
    return result;
  };
}();
var setBackward = function() {
  let forward = create10();
  let axes = [null, null, null];
  let priority = [2, 1, 0];
  return function setBackward3(quat, backward, up = null, left = null) {
    Vec3Utils.negate(backward, forward);
    axes[0] = left;
    axes[1] = up;
    axes[2] = forward;
    let result = _setAxes(quat, axes, priority);
    axes[0] = null;
    axes[1] = null;
    axes[2] = null;
    return result;
  };
}();
var setUp = function() {
  let axes = [null, null, null];
  let priority = [1, 2, 0];
  return function setUp3(quat, up, forward = null, left = null) {
    axes[0] = left;
    axes[1] = up;
    axes[2] = forward;
    let result = _setAxes(quat, axes, priority);
    axes[0] = null;
    axes[1] = null;
    axes[2] = null;
    return result;
  };
}();
var setDown = function() {
  let up = create10();
  let axes = [null, null, null];
  let priority = [1, 2, 0];
  return function setDown3(quat, down, forward = null, left = null) {
    Vec3Utils.negate(down, up);
    axes[0] = left;
    axes[1] = up;
    axes[2] = forward;
    let result = _setAxes(quat, axes, priority);
    axes[0] = null;
    axes[1] = null;
    axes[2] = null;
    return result;
  };
}();
var setLeft = function() {
  let axes = [null, null, null];
  let priority = [0, 1, 2];
  return function setLeft3(quat, left, up = null, forward = null) {
    axes[0] = left;
    axes[1] = up;
    axes[2] = forward;
    let result = _setAxes(quat, axes, priority);
    axes[0] = null;
    axes[1] = null;
    axes[2] = null;
    return result;
  };
}();
var setRight = function() {
  let left = create10();
  let axes = [null, null, null];
  let priority = [0, 1, 2];
  return function setRight3(quat, right, up = null, forward = null) {
    Vec3Utils.negate(right, left);
    axes[0] = left;
    axes[1] = up;
    axes[2] = forward;
    let result = _setAxes(quat, axes, priority);
    axes[0] = null;
    axes[1] = null;
    axes[2] = null;
    return result;
  };
}();
function toWorld3(quat, parentQuat, out = QuatUtils.create()) {
  QuatUtils.mul(parentQuat, quat, out);
  return out;
}
var toLocal3 = function() {
  let invertQuat = create9();
  return function toLocal4(quat, parentQuat, out = QuatUtils.create()) {
    QuatUtils.conjugate(parentQuat, invertQuat);
    QuatUtils.mul(invertQuat, quat, out);
    return out;
  };
}();
function fromAxis(angle4, axis, out = QuatUtils.create()) {
  return QuatUtils.fromAxisDegrees(angle4, axis, out);
}
function fromAxisDegrees(angle4, axis, out = QuatUtils.create()) {
  QuatUtils.fromAxisRadians(MathUtils.toRadians(angle4), axis, out);
  return out;
}
function fromAxisRadians(angle4, axis, out = QuatUtils.create()) {
  quat_exports.setAxisAngle(out, axis, angle4);
  return out;
}
var fromAxes = function() {
  let matrix = create8();
  return function fromAxes3(leftAxis, upAxis, forwardAxis, out = QuatUtils.create()) {
    Mat3Utils.fromAxes(leftAxis, upAxis, forwardAxis, matrix);
    return Mat3Utils.toQuat(matrix, out);
  };
}();
var fromRadians = function() {
  let vector = create10();
  return function fromRadians2(radiansRotation, out = QuatUtils.create()) {
    Vec3Utils.toDegrees(radiansRotation, vector);
    return QuatUtils.fromDegrees(vector, out);
  };
}();
function fromDegrees(degreesRotation, out = QuatUtils.create()) {
  quat_exports.fromEuler(out, degreesRotation[0], degreesRotation[1], degreesRotation[2]);
  return out;
}
var toRadians3 = function() {
  let matrix = create8();
  return function toRadians5(quat, out = Vec3Utils.create()) {
    QuatUtils.toMatrix(quat, matrix);
    out[1] = Math.asin(-MathUtils.clamp(matrix[2], -1, 1));
    if (Math.abs(matrix[2]) < 1 - MathUtils.EPSILON) {
      out[0] = Math.atan2(matrix[5], matrix[8]);
      out[2] = Math.atan2(matrix[1], matrix[0]);
    } else {
      out[0] = 0;
      out[2] = Math.atan2(-matrix[3], matrix[4]);
    }
    return out;
  };
}();
function toDegrees3(quat, out = Vec3Utils.create()) {
  QuatUtils.toRadians(quat, out);
  Vec3Utils.toDegrees(out, out);
  return out;
}
function isNormalized3(quat, epsilon = MathUtils.EPSILON) {
  return Math.abs(QuatUtils.lengthSquared(quat) - 1) < epsilon;
}
function addRotation2(first2, second, out) {
  return QuatUtils.addRotationDegrees(first2, second, out);
}
var addRotationDegrees2 = function() {
  let secondQuat = create9();
  return function addRotationDegrees3(first2, second, out) {
    Vec3Utils.degreesToQuat(second, secondQuat);
    return QuatUtils.addRotationQuat(first2, secondQuat, out);
  };
}();
var addRotationRadians2 = function() {
  let secondQuat = create9();
  return function addRotationRadians3(first2, second, out) {
    Vec3Utils.radiansToQuat(second, secondQuat);
    return QuatUtils.addRotationQuat(first2, secondQuat, out);
  };
}();
function addRotationQuat2(first2, second, out = QuatUtils.create()) {
  QuatUtils.mul(second, first2, out);
  return out;
}
function subRotation(first2, second, out) {
  return QuatUtils.subRotationDegrees(first2, second, out);
}
var subRotationDegrees = function() {
  let secondQuat = create9();
  return function subRotationDegrees2(first2, second, out) {
    Vec3Utils.degreesToQuat(second, secondQuat);
    return QuatUtils.subRotationQuat(first2, secondQuat, out);
  };
}();
var subRotationRadians = function() {
  let secondQuat = create9();
  return function subRotationRadians2(first2, second, out) {
    Vec3Utils.radiansToQuat(second, secondQuat);
    return QuatUtils.subRotationQuat(first2, secondQuat, out);
  };
}();
var subRotationQuat = function() {
  let inverse4 = create9();
  return function subRotationQuat2(first2, second, out = QuatUtils.create()) {
    QuatUtils.invert(second, inverse4);
    QuatUtils.mul(first2, inverse4, out);
    return out;
  };
}();
function rotationTo3(from, to, out) {
  return QuatUtils.rotationToDegrees(from, to, out);
}
var rotationToDegrees2 = function() {
  let toQuat4 = create9();
  return function rotationToDegrees3(from, to, out) {
    Vec3Utils.degreesToQuat(to, toQuat4);
    return QuatUtils.rotationToQuat(from, toQuat4, out);
  };
}();
var rotationToRadians2 = function() {
  let toQuat4 = create9();
  return function rotationToRadians3(from, to, out) {
    Vec3Utils.radiansToQuat(to, toQuat4);
    return QuatUtils.rotationToQuat(from, toQuat4, out);
  };
}();
function rotationToQuat2(from, to, out) {
  return QuatUtils.normalize(QuatUtils.subRotationQuat(to, from, out), out);
}
function rotationAroundAxis(quat, axis, out) {
  return QuatUtils.rotationAroundAxisDegrees(quat, axis, out);
}
var rotationAroundAxisDegrees = function() {
  let rotationAroundQuat = create9();
  return function rotationAroundAxisDegrees2(quat, axis, out = Vec3Utils.create()) {
    QuatUtils.rotationAroundAxisQuat(quat, axis, rotationAroundQuat);
    return QuatUtils.toDegrees(rotationAroundQuat, out);
  };
}();
var rotationAroundAxisRadians = function() {
  let rotationAroundQuat = create9();
  return function rotationAroundAxisRadians2(quat, axis, out = Vec3Utils.create()) {
    QuatUtils.rotationAroundAxisQuat(quat, axis, rotationAroundQuat);
    return QuatUtils.toRadians(rotationAroundQuat, out);
  };
}();
function rotationAroundAxisQuat(quat, axis, out = QuatUtils.create()) {
  return QuatUtils.getTwist(quat, axis, out);
}
var getTwist = function() {
  let rotationAxis = create10();
  let projection2 = create10();
  let rotationAlongAxis = create9();
  return function getTwist2(quat, axis, out = QuatUtils.create()) {
    rotationAxis[0] = quat[0];
    rotationAxis[1] = quat[1];
    rotationAxis[2] = quat[2];
    let dotProd = Vec3Utils.dot(axis, rotationAxis);
    Vec3Utils.scale(axis, dotProd, projection2);
    rotationAlongAxis[0] = projection2[0];
    rotationAlongAxis[1] = projection2[1];
    rotationAlongAxis[2] = projection2[2];
    rotationAlongAxis[3] = quat[3];
    QuatUtils.normalize(rotationAlongAxis, rotationAlongAxis);
    if (dotProd < 0) {
      rotationAlongAxis[0] = -rotationAlongAxis[0];
      rotationAlongAxis[1] = -rotationAlongAxis[1];
      rotationAlongAxis[2] = -rotationAlongAxis[2];
      rotationAlongAxis[3] = -rotationAlongAxis[3];
    }
    return QuatUtils.copy(rotationAlongAxis, out);
  };
}();
var getSwing = function() {
  let twist = create9();
  return function getSwing2(quat, axis, out = QuatUtils.create()) {
    QuatUtils.getTwist(quat, axis, twist);
    QuatUtils.getSwingFromTwist(quat, twist, out);
    return out;
  };
}();
function getSwingFromTwist(quat, twist, out = QuatUtils.create()) {
  return QuatUtils.subRotationQuat(quat, twist, out);
}
var getTwistFromSwing = function() {
  let inverse4 = create9();
  return function getTwistFromSwing2(quat, swing, out = QuatUtils.create()) {
    QuatUtils.conjugate(swing, inverse4);
    QuatUtils.addRotationQuat(quat, inverse4, out);
    return out;
  };
}();
function fromTwistSwing(twist, swing, out = QuatUtils.create()) {
  return QuatUtils.addRotationQuat(twist, swing, out);
}
function toMatrix3(quat, out = Mat3Utils.create()) {
  mat3_exports.fromQuat(out, quat);
  return out;
}
function rotate5(first2, second, out) {
  return QuatUtils.rotateDegrees(first2, second, out);
}
function rotateDegrees2(first2, second, out) {
  return QuatUtils.addRotationDegrees(first2, second, out);
}
function rotateRadians2(first2, second, out) {
  return QuatUtils.addRotationRadians(first2, second, out);
}
function rotateQuat2(first2, second, out) {
  return QuatUtils.addRotationQuat(first2, second, out);
}
function rotateAxis3(quat, angle4, axis, out) {
  return QuatUtils.rotateAxisDegrees(quat, angle4, axis, out);
}
var rotateAxisDegrees3 = function() {
  let secondQuat = create9();
  return function rotateAxisDegrees5(quat, angle4, axis, out) {
    QuatUtils.fromAxisDegrees(angle4, axis, secondQuat);
    return QuatUtils.rotateQuat(quat, secondQuat, out);
  };
}();
var rotateAxisRadians3 = function() {
  let secondQuat = create9();
  return function rotateAxisRadians5(quat, angle4, axis, out) {
    QuatUtils.fromAxisRadians(angle4, axis, secondQuat);
    return QuatUtils.rotateQuat(quat, secondQuat, out);
  };
}();
function lerp9(from, to, interpolationFactor, out = QuatUtils.create()) {
  if (interpolationFactor <= 0) {
    QuatUtils.copy(from, out);
    return out;
  } else if (interpolationFactor >= 1) {
    QuatUtils.copy(to, out);
    return out;
  }
  quat_exports.lerp(out, from, to, interpolationFactor);
  return out;
}
function interpolate4(from, to, interpolationFactor, easingFunction = EasingFunction.linear, out = QuatUtils.create()) {
  let lerpFactor = easingFunction(interpolationFactor);
  return QuatUtils.lerp(from, to, lerpFactor, out);
}
function slerp3(from, to, interpolationFactor, out = QuatUtils.create()) {
  if (interpolationFactor <= 0) {
    QuatUtils.copy(from, out);
    return out;
  } else if (interpolationFactor >= 1) {
    QuatUtils.copy(to, out);
    return out;
  }
  quat_exports.slerp(out, from, to, interpolationFactor);
  return out;
}
function sinterpolate2(from, to, interpolationFactor, easingFunction = EasingFunction.linear, out = QuatUtils.create()) {
  let lerpFactor = easingFunction(interpolationFactor);
  return QuatUtils.slerp(from, to, lerpFactor, out);
}
var QuatUtils = {
  create: create9,
  set: set11,
  normalize: normalize8,
  copy: copy12,
  clone: clone11,
  identity: identity7,
  length: length8,
  lengthSquared: lengthSquared3,
  invert: invert7,
  conjugate: conjugate4,
  mul: mul11,
  getAxis,
  getAngle: getAngle2,
  getAngleDegrees,
  getAngleRadians,
  getAxisScaled,
  getAxisScaledDegrees,
  getAxisScaledRadians,
  getAxes: getAxes3,
  getForward: getForward3,
  getBackward: getBackward3,
  getLeft: getLeft3,
  getRight: getRight3,
  getUp: getUp3,
  getDown: getDown3,
  setAxes: setAxes2,
  setForward,
  setBackward,
  setUp,
  setDown,
  setLeft,
  setRight,
  toWorld: toWorld3,
  toLocal: toLocal3,
  fromAxis,
  fromAxisDegrees,
  fromAxisRadians,
  fromAxes,
  fromRadians,
  fromDegrees,
  toRadians: toRadians3,
  toDegrees: toDegrees3,
  isNormalized: isNormalized3,
  addRotation: addRotation2,
  addRotationDegrees: addRotationDegrees2,
  addRotationRadians: addRotationRadians2,
  addRotationQuat: addRotationQuat2,
  subRotation,
  subRotationDegrees,
  subRotationRadians,
  subRotationQuat,
  rotationTo: rotationTo3,
  rotationToDegrees: rotationToDegrees2,
  rotationToRadians: rotationToRadians2,
  rotationToQuat: rotationToQuat2,
  rotationAroundAxis,
  rotationAroundAxisDegrees,
  rotationAroundAxisRadians,
  rotationAroundAxisQuat,
  getTwist,
  getSwing,
  getSwingFromTwist,
  getTwistFromSwing,
  fromTwistSwing,
  toMatrix: toMatrix3,
  rotate: rotate5,
  rotateDegrees: rotateDegrees2,
  rotateRadians: rotateRadians2,
  rotateQuat: rotateQuat2,
  rotateAxis: rotateAxis3,
  rotateAxisDegrees: rotateAxisDegrees3,
  rotateAxisRadians: rotateAxisRadians3,
  lerp: lerp9,
  interpolate: interpolate4,
  slerp: slerp3,
  sinterpolate: sinterpolate2
};
var _setAxes = function() {
  let fixedAxes = [create10(), create10(), create10()];
  let fixedAxesFixSignMap = [
    [1, -1, 1],
    [1, 1, -1],
    [-1, 1, -1]
  ];
  let fixedLeft = create10();
  let fixedUp = create10();
  let fixedForward = create10();
  let currentAxis = create10();
  let rotationAxis = create10();
  let rotationMat = create8();
  let rotationQuat = create9();
  return function _setAxes2(quat, axes, priority) {
    let firstAxis = axes[priority[0]];
    let secondAxis = axes[priority[1]];
    let thirdAxis = axes[priority[2]];
    if (firstAxis == null || Vec3Utils.isZero(firstAxis, MathUtils.EPSILON)) {
      return;
    }
    let secondAxisValid = false;
    if (secondAxis != null) {
      let angleBetween = Vec3Utils.angleRadians(firstAxis, secondAxis);
      if (angleBetween > MathUtils.EPSILON) {
        secondAxisValid = true;
      }
    }
    let thirdAxisValid = false;
    if (thirdAxis != null) {
      let angleBetween = Vec3Utils.angleRadians(firstAxis, thirdAxis);
      if (angleBetween > MathUtils.EPSILON) {
        thirdAxisValid = true;
      }
    }
    if (secondAxisValid || thirdAxisValid) {
      let crossAxis = null;
      let secondAxisIndex = null;
      let thirdAxisIndex = null;
      if (secondAxisValid) {
        crossAxis = secondAxis;
        secondAxisIndex = 1;
        thirdAxisIndex = 2;
      } else {
        crossAxis = thirdAxis;
        secondAxisIndex = 2;
        thirdAxisIndex = 1;
      }
      let fixSignMap = fixedAxesFixSignMap[priority[0]];
      Vec3Utils.cross(firstAxis, crossAxis, fixedAxes[thirdAxisIndex]);
      Vec3Utils.scale(fixedAxes[thirdAxisIndex], fixSignMap[priority[thirdAxisIndex]], fixedAxes[thirdAxisIndex]);
      Vec3Utils.cross(firstAxis, fixedAxes[thirdAxisIndex], fixedAxes[secondAxisIndex]);
      Vec3Utils.scale(fixedAxes[secondAxisIndex], fixSignMap[priority[secondAxisIndex]], fixedAxes[secondAxisIndex]);
      Vec3Utils.cross(fixedAxes[1], fixedAxes[2], fixedAxes[0]);
      Vec3Utils.scale(fixedAxes[0], fixSignMap[priority[0]], fixedAxes[0]);
      Vec3Utils.normalize(fixedAxes[ArrayUtils.findIndexEqual(priority, 0)], fixedLeft);
      Vec3Utils.normalize(fixedAxes[ArrayUtils.findIndexEqual(priority, 1)], fixedUp);
      Vec3Utils.normalize(fixedAxes[ArrayUtils.findIndexEqual(priority, 2)], fixedForward);
      Mat3Utils.set(
        rotationMat,
        fixedLeft[0],
        fixedLeft[1],
        fixedLeft[2],
        fixedUp[0],
        fixedUp[1],
        fixedUp[2],
        fixedForward[0],
        fixedForward[1],
        fixedForward[2]
      );
      Mat3Utils.toQuat(rotationMat, rotationQuat);
      QuatUtils.copy(rotationQuat, quat);
    } else {
      if (priority[0] == 0) {
        QuatUtils.getLeft(quat, currentAxis);
      } else if (priority[0] == 1) {
        QuatUtils.getUp(quat, currentAxis);
      } else {
        QuatUtils.getForward(quat, currentAxis);
      }
      let angleBetween = Vec3Utils.angleRadians(firstAxis, currentAxis);
      if (angleBetween > MathUtils.EPSILON) {
        Vec3Utils.cross(currentAxis, firstAxis, rotationAxis);
        Vec3Utils.normalize(rotationAxis, rotationAxis);
        if (Vec3Utils.isZero(rotationAxis)) {
          Vec3Utils.perpendicularRandom(currentAxis, rotationAxis);
        }
        QuatUtils.fromAxisRadians(angleBetween, rotationAxis, rotationQuat);
        QuatUtils.rotateQuat(quat, rotationQuat, quat);
      }
    }
    return quat;
  };
}();

// js/pp/cauldron/js/utils/mat3_utils.js
function create8(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  let out = mat3_exports.create();
  if (m00 !== void 0) {
    set12(
      out,
      m00,
      m01,
      m02,
      m10,
      m11,
      m12,
      m20,
      m21,
      m22
    );
  }
  return out;
}
function set12(matrix, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  if (m01 === void 0) {
    mat3_exports.set(
      matrix,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00,
      m00
    );
  } else {
    mat3_exports.set(
      matrix,
      m00,
      m01,
      m02,
      m10,
      m11,
      m12,
      m20,
      m21,
      m22
    );
  }
  return matrix;
}
var toDegrees4 = function() {
  let quat = create9();
  return function toDegrees5(matrix, out = Vec3Utils.create()) {
    Mat3Utils.toQuat(matrix, quat);
    QuatUtils.toDegrees(quat, out);
    return out;
  };
}();
var toRadians4 = function() {
  let quat = create9();
  return function toRadians5(matrix, out = Vec3Utils.create()) {
    Mat3Utils.toQuat(matrix, quat);
    QuatUtils.toRadians(quat, out);
    return out;
  };
}();
function toQuat3(matrix, out = QuatUtils.create()) {
  quat_exports.fromMat3(out, matrix);
  return out;
}
function fromAxes2(leftAxis, upAxis, forwardAxis, out = Mat3Utils.create()) {
  Mat3Utils.set(
    out,
    leftAxis[0],
    leftAxis[1],
    leftAxis[2],
    upAxis[0],
    upAxis[1],
    upAxis[2],
    forwardAxis[0],
    forwardAxis[1],
    forwardAxis[2]
  );
  return out;
}
var Mat3Utils = {
  create: create8,
  set: set12,
  toDegrees: toDegrees4,
  toRadians: toRadians4,
  toQuat: toQuat3,
  fromAxes: fromAxes2
};

// js/pp/cauldron/wl/utils/object_utils.js
var CloneParams = class {
  constructor() {
    this.myCloneParent = void 0;
    this.myIgnoreNonCloneable = false;
    this.myIgnoreComponents = false;
    this.myIgnoreDescendants = false;
    this.myComponentsToIgnore = [];
    this.myComponentsToInclude = [];
    this.myIgnoreComponentCallback = null;
    this.myDescendantsToIgnore = [];
    this.myDescendantsToInclude = [];
    this.myIgnoreDescendantCallback = null;
    this.myUseDefaultComponentClone = false;
    this.myUseDefaultComponentCloneAsFallback = false;
    this.myDefaultComponentCloneAutoStartIfNotActive = true;
    this.myUseDefaultObjectClone = false;
    this.myUseDefaultObjectCloneAsFallback = false;
    this.myComponentDeepCloneParams = new DeepCloneParams();
    this.myComponentCustomCloneParams = new CustomCloneParams();
  }
};
function getPosition3(object, position) {
  return ObjectUtils.getPositionWorld(object, position);
}
function getPositionWorld(object, position = Vec3Utils.create()) {
  object.getPositionWorld(position);
  return position;
}
function getPositionLocal(object, position = Vec3Utils.create()) {
  object.getPositionLocal(position);
  return position;
}
function getRotation4(object, rotation) {
  return ObjectUtils.getRotationWorld(object, rotation);
}
function getRotationDegrees3(object, rotation) {
  return ObjectUtils.getRotationWorldDegrees(object, rotation);
}
function getRotationRadians3(object, rotation) {
  return ObjectUtils.getRotationWorldRadians(object, rotation);
}
function getRotationMatrix(object, rotation) {
  return ObjectUtils.getRotationWorldMatrix(object, rotation);
}
function getRotationQuat3(object, rotation) {
  return ObjectUtils.getRotationWorldQuat(object, rotation);
}
function getRotationWorld(object, rotation) {
  return ObjectUtils.getRotationWorldDegrees(object, rotation);
}
function getRotationWorldDegrees(object, rotation) {
  rotation = ObjectUtils.getRotationWorldRadians(object, rotation);
  rotation = Vec3Utils.toDegrees(rotation, rotation);
  return rotation;
}
var getRotationWorldRadians = function() {
  let quat = QuatUtils.create();
  return function getRotationWorldRadians2(object, rotation = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.toRadians(quat, rotation);
    return rotation;
  };
}();
var getRotationWorldMatrix = function() {
  let quat = QuatUtils.create();
  return function getRotationWorldMatrix2(object, rotation = Mat3Utils.create()) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.toMatrix(quat, rotation);
    return rotation;
  };
}();
function getRotationWorldQuat(object, rotation = QuatUtils.create()) {
  object.getRotationWorld(rotation);
  return rotation;
}
function getRotationLocal(object, rotation) {
  return ObjectUtils.getRotationLocalDegrees(object, rotation);
}
function getRotationLocalDegrees(object, rotation) {
  rotation = ObjectUtils.getRotationLocalRadians(object, rotation);
  rotation = Vec3Utils.toDegrees(rotation, rotation);
  return rotation;
}
var getRotationLocalRadians = function() {
  let quat = QuatUtils.create();
  return function getRotationLocalRadians2(object, rotation = Vec3Utils.create()) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.toRadians(quat, rotation);
    return rotation;
  };
}();
var getRotationLocalMatrix = function() {
  let quat = QuatUtils.create();
  return function getRotationLocalMatrix2(object, rotation = Mat3Utils.create()) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.toMatrix(quat, rotation);
    return rotation;
  };
}();
function getRotationLocalQuat(object, rotation = QuatUtils.create()) {
  object.getRotationLocal(rotation);
  return rotation;
}
function getScale2(object, scale11) {
  return ObjectUtils.getScaleWorld(object, scale11);
}
function getScaleWorld(object, scale11 = Vec3Utils.create()) {
  object.getScalingWorld(scale11);
  return scale11;
}
function getScaleLocal(object, scale11 = Vec3Utils.create()) {
  object.getScalingLocal(scale11);
  return scale11;
}
function getTransform(object, transform) {
  return ObjectUtils.getTransformWorld(object, transform);
}
function getTransformMatrix(object, transform) {
  return ObjectUtils.getTransformWorldMatrix(object, transform);
}
function getTransformQuat(object, transform) {
  return ObjectUtils.getTransformWorldQuat(object, transform);
}
function getTransformWorld(object, transform) {
  return ObjectUtils.getTransformWorldMatrix(object, transform);
}
var getTransformWorldMatrix = function() {
  let transformQuat4 = Quat2Utils.create();
  let scale11 = Vec3Utils.create();
  return function getTransformWorldMatrix2(object, transform = Mat4Utils.create()) {
    ObjectUtils.getTransformWorldQuat(object, transformQuat4);
    ObjectUtils.getScaleWorld(object, scale11);
    Mat4Utils.fromQuat(transformQuat4, transform);
    Mat4Utils.scale(transform, scale11, transform);
    return transform;
  };
}();
function getTransformWorldQuat(object, transform = Quat2Utils.create()) {
  object.getTransformWorld(transform);
  return transform;
}
function getTransformLocal(object, transform) {
  return ObjectUtils.getTransformLocalMatrix(object, transform);
}
var getTransformLocalMatrix = function() {
  let transformQuat4 = Quat2Utils.create();
  let scale11 = Vec3Utils.create();
  return function getTransformLocalMatrix2(object, transform = Mat4Utils.create()) {
    ObjectUtils.getTransformLocalQuat(object, transformQuat4);
    ObjectUtils.getScaleLocal(object, scale11);
    Mat4Utils.fromQuat(transformQuat4, transform);
    Mat4Utils.scale(transform, scale11, transform);
    return transform;
  };
}();
function getTransformLocalQuat(object, transform = Quat2Utils.create()) {
  object.getTransformLocal(transform);
  return transform;
}
function getAxes4(object, axes) {
  return ObjectUtils.getAxesWorld(object, axes);
}
function getAxesWorld(object, axes = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
  ObjectUtils.getLeftWorld(object, axes[0]);
  ObjectUtils.getUpWorld(object, axes[1]);
  ObjectUtils.getForwardWorld(object, axes[2]);
  return axes;
}
function getAxesLocal(object, axes = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
  ObjectUtils.getLeftLocal(object, axes[0]);
  ObjectUtils.getUpLocal(object, axes[1]);
  ObjectUtils.getForwardLocal(object, axes[2]);
  return axes;
}
function getForward4(object, forward) {
  return ObjectUtils.getForwardWorld(object, forward);
}
var getForwardWorld = function() {
  let rotation = Mat3Utils.create();
  return function getForwardWorld2(object, forward = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldMatrix(object, rotation);
    forward[0] = rotation[6];
    forward[1] = rotation[7];
    forward[2] = rotation[8];
    return forward;
  };
}();
var getForwardLocal = function() {
  let rotation = Mat3Utils.create();
  return function getForwardLocal2(object, forward = Vec3Utils.create()) {
    ObjectUtils.getRotationLocalMatrix(object, rotation);
    forward[0] = rotation[6];
    forward[1] = rotation[7];
    forward[2] = rotation[8];
    return forward;
  };
}();
function getBackward4(object, backward) {
  return ObjectUtils.getBackwardWorld(object, backward);
}
var getBackwardWorld = function() {
  let rotation = Mat3Utils.create();
  return function getBackwardWorld2(object, backward = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldMatrix(object, rotation);
    backward[0] = -rotation[6];
    backward[1] = -rotation[7];
    backward[2] = -rotation[8];
    return backward;
  };
}();
var getBackwardLocal = function() {
  let rotation = Mat3Utils.create();
  return function getBackwardLocal2(object, backward = Vec3Utils.create()) {
    ObjectUtils.getRotationLocalMatrix(object, rotation);
    backward[0] = -rotation[6];
    backward[1] = -rotation[7];
    backward[2] = -rotation[8];
    return backward;
  };
}();
function getUp4(object, up) {
  return ObjectUtils.getUpWorld(object, up);
}
var getUpWorld = function() {
  let rotation = Mat3Utils.create();
  return function getUpWorld2(object, up = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldMatrix(object, rotation);
    up[0] = rotation[3];
    up[1] = rotation[4];
    up[2] = rotation[5];
    return up;
  };
}();
var getUpLocal = function() {
  let rotation = Mat3Utils.create();
  return function getUpLocal2(object, up = Vec3Utils.create()) {
    ObjectUtils.getRotationLocalMatrix(object, rotation);
    up[0] = rotation[3];
    up[1] = rotation[4];
    up[2] = rotation[5];
    return up;
  };
}();
function getDown4(object, down) {
  return ObjectUtils.getDownWorld(object, down);
}
var getDownWorld = function() {
  let rotation = Mat3Utils.create();
  return function getDownWorld2(object, down = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldMatrix(object, rotation);
    down[0] = -rotation[3];
    down[1] = -rotation[4];
    down[2] = -rotation[5];
    return down;
  };
}();
var getDownLocal = function() {
  let rotation = Mat3Utils.create();
  return function getDownLocal2(object, down = Vec3Utils.create()) {
    ObjectUtils.getRotationLocalMatrix(object, rotation);
    down[0] = -rotation[3];
    down[1] = -rotation[4];
    down[2] = -rotation[5];
    return down;
  };
}();
function getLeft4(object, left) {
  return ObjectUtils.getLeftWorld(object, left);
}
var getLeftWorld = function() {
  let rotation = Mat3Utils.create();
  return function getLeftWorld2(object, left = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldMatrix(object, rotation);
    left[0] = rotation[0];
    left[1] = rotation[1];
    left[2] = rotation[2];
    return left;
  };
}();
var getLeftLocal = function() {
  let rotation = Mat3Utils.create();
  return function getLeftLocal2(object, left = Vec3Utils.create()) {
    ObjectUtils.getRotationLocalMatrix(object, rotation);
    left[0] = rotation[0];
    left[1] = rotation[1];
    left[2] = rotation[2];
    return left;
  };
}();
function getRight4(object, right) {
  return ObjectUtils.getRightWorld(object, right);
}
var getRightWorld = function() {
  let rotation = Mat3Utils.create();
  return function getRightWorld2(object, right = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldMatrix(object, rotation);
    right[0] = -rotation[0];
    right[1] = -rotation[1];
    right[2] = -rotation[2];
    return right;
  };
}();
var getRightLocal = function() {
  let rotation = Mat3Utils.create();
  return function getRightLocal2(object, right = Vec3Utils.create()) {
    ObjectUtils.getRotationLocalMatrix(object, rotation);
    right[0] = -rotation[0];
    right[1] = -rotation[1];
    right[2] = -rotation[2];
    return right;
  };
}();
function setPosition3(object, position) {
  ObjectUtils.setPositionWorld(object, position);
}
function setPositionWorld(object, position) {
  object.setTranslationWorld(position);
}
function setPositionLocal(object, position) {
  object.setTranslationLocal(position);
}
function setRotation3(object, rotation) {
  ObjectUtils.setRotationWorld(object, rotation);
}
function setRotationDegrees3(object, rotation) {
  ObjectUtils.setRotationWorldDegrees(object, rotation);
}
function setRotationRadians3(object, rotation) {
  ObjectUtils.setRotationWorldRadians(object, rotation);
}
function setRotationMatrix(object, rotation) {
  ObjectUtils.setRotationWorldMatrix(object, rotation);
}
function setRotationQuat3(object, rotation) {
  ObjectUtils.setRotationWorldQuat(object, rotation);
}
function setRotationWorld(object, rotation) {
  ObjectUtils.setRotationWorldDegrees(object, rotation);
}
var setRotationWorldDegrees = function() {
  let quat = QuatUtils.create();
  return function setRotationWorldDegrees2(object, rotation) {
    Vec3Utils.degreesToQuat(rotation, quat);
    ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
var setRotationWorldRadians = function() {
  let degreesRotation = Vec3Utils.create();
  return function setRotationWorldRadians2(object, rotation) {
    degreesRotation = Vec3Utils.toDegrees(rotation, degreesRotation);
    ObjectUtils.setRotationWorldDegrees(object, degreesRotation);
  };
}();
var setRotationWorldMatrix = function() {
  let quat = QuatUtils.create();
  return function setRotationWorldMatrix2(object, rotation) {
    Mat3Utils.toQuat(rotation, quat);
    ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
function setRotationWorldQuat(object, rotation) {
  object.setRotationWorld(rotation);
}
function setRotationLocal(object, rotation) {
  ObjectUtils.setRotationLocalDegrees(object, rotation);
}
var setRotationLocalDegrees = function() {
  let quat = QuatUtils.create();
  return function setRotationLocalDegrees2(object, rotation) {
    Vec3Utils.degreesToQuat(rotation, quat);
    ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
var setRotationLocalRadians = function() {
  let degreesRotation = Vec3Utils.create();
  return function setRotationLocalRadians2(object, rotation) {
    degreesRotation = Vec3Utils.toDegrees(rotation, degreesRotation);
    ObjectUtils.setRotationLocalDegrees(object, degreesRotation);
  };
}();
var setRotationLocalMatrix = function() {
  let quat = QuatUtils.create();
  return function setRotationLocalMatrix2(object, rotation) {
    Mat3Utils.toQuat(rotation, quat);
    ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
function setRotationLocalQuat(object, rotation) {
  object.setRotationLocal(rotation);
}
function setScale2(object, scale11) {
  ObjectUtils.setScaleWorld(object, scale11);
}
var setScaleWorld = function() {
  let vector = Vec3Utils.create();
  return function setScaleWorld2(object, scale11) {
    if (isNaN(scale11)) {
      object.setScalingWorld(scale11);
    } else {
      Vec3Utils.set(vector, scale11);
      object.setScalingWorld(vector);
    }
  };
}();
var setScaleLocal = function() {
  let vector = Vec3Utils.create();
  return function setScaleLocal2(object, scale11) {
    if (isNaN(scale11)) {
      object.setScalingLocal(scale11);
    } else {
      Vec3Utils.set(vector, scale11);
      object.setScalingLocal(vector);
    }
  };
}();
function setAxes3(object, left, up, forward) {
  ObjectUtils.setAxesWorld(object, left, up, forward);
}
function setAxesWorld(object, left, up, forward) {
  if (forward != null) {
    ObjectUtils.setForwardWorld(object, forward, up, left);
  } else if (up != null) {
    ObjectUtils.setUpWorld(object, up, forward, left);
  } else {
    ObjectUtils.setLeftWorld(object, left, up, forward);
  }
}
function setAxesLocal(object, left, up, forward) {
  if (forward != null) {
    ObjectUtils.setForwardLocal(object, forward, up, left);
  } else if (up != null) {
    ObjectUtils.setUpLocal(object, up, forward, left);
  } else {
    ObjectUtils.setLeftLocal(object, left, up, forward);
  }
}
function setForward2(object, forward, up, left) {
  ObjectUtils.setForwardWorld(object, forward, up, left);
}
var setForwardWorld = function() {
  let quat = QuatUtils.create();
  return function setForwardWorld2(object, forward, up = null, left = null) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.setForward(quat, forward, up, left);
    ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
var setForwardLocal = function() {
  let quat = QuatUtils.create();
  return function setForwardLocal2(object, forward, up = null, left = null) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.setForward(quat, forward, up, left);
    ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
function setBackward2(object, backward, up, left) {
  ObjectUtils.setBackwardWorld(object, backward, up, left);
}
var setBackwardWorld = function() {
  let quat = QuatUtils.create();
  return function setBackwardWorld2(object, backward, up = null, left = null) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.setBackward(quat, backward, up, left);
    ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
var setBackwardLocal = function() {
  let quat = QuatUtils.create();
  return function setBackwardLocal2(object, backward, up = null, left = null) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.setBackward(quat, backward, up, left);
    ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
function setUp2(object, up, forward, left) {
  ObjectUtils.setUpWorld(object, up, forward, left);
}
var setUpWorld = function() {
  let quat = QuatUtils.create();
  return function setUpWorld2(object, up, forward = null, left = null) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.setUp(quat, up, forward, left);
    ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
var setUpLocal = function() {
  let quat = QuatUtils.create();
  return function setUpLocal2(object, up, forward = null, left = null) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.setUp(quat, up, forward, left);
    ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
function setDown2(object, down, forward, left) {
  ObjectUtils.setDownWorld(object, down, forward, left);
}
var setDownWorld = function() {
  let quat = QuatUtils.create();
  return function setDownWorld2(object, down, forward = null, left = null) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.setDown(quat, down, forward, left);
    ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
var setDownLocal = function() {
  let quat = QuatUtils.create();
  return function setDownLocal2(object, down, forward = null, left = null) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.setDown(quat, down, forward, left);
    ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
function setLeft2(object, left, up, forward) {
  ObjectUtils.setLeftWorld(object, left, up, forward);
}
var setLeftWorld = function() {
  let quat = QuatUtils.create();
  return function setLeftWorld2(object, left, up = null, forward = null) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.setLeft(quat, left, up, forward);
    ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
var setLeftLocal = function() {
  let quat = QuatUtils.create();
  return function setLeftLocal2(object, left, up = null, forward = null) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.setLeft(quat, left, up, forward);
    ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
function setRight2(object, right, up, forward) {
  ObjectUtils.setRightWorld(object, right, up, forward);
}
var setRightWorld = function() {
  let quat = QuatUtils.create();
  return function setRightWorld2(object, right, up = null, forward = null) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.setRight(quat, right, up, forward);
    ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
var setRightLocal = function() {
  let quat = QuatUtils.create();
  return function setRightLocal2(object, right, up = null, forward = null) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.setRight(quat, right, up, forward);
    ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
function setTransform(object, transform) {
  ObjectUtils.setTransformWorld(object, transform);
}
function setTransformMatrix(object, transform) {
  ObjectUtils.setTransformWorldMatrix(object, transform);
}
function setTransformQuat(object, transform) {
  ObjectUtils.setTransformWorldQuat(object, transform);
}
function setTransformWorld(object, transform) {
  return ObjectUtils.setTransformWorldMatrix(object, transform);
}
var setTransformWorldMatrix = function() {
  let position = Vec3Utils.create();
  let rotation = QuatUtils.create();
  let scale11 = Vec3Utils.create();
  let transformMatrixNoScale = Mat4Utils.create();
  let inverseScale = Vec3Utils.create();
  let one = Vec3Utils.create(1);
  return function setTransformWorldMatrix2(object, transform) {
    Mat4Utils.getPosition(transform, position);
    Mat4Utils.getScale(transform, scale11);
    Vec3Utils.div(one, scale11, inverseScale);
    Mat4Utils.scale(transform, inverseScale, transformMatrixNoScale);
    Mat4Utils.getRotationQuat(transformMatrixNoScale, rotation);
    QuatUtils.normalize(rotation, rotation);
    ObjectUtils.setScaleWorld(object, scale11);
    ObjectUtils.setRotationWorldQuat(object, rotation);
    ObjectUtils.setPositionWorld(object, position);
  };
}();
function setTransformWorldQuat(object, transform) {
  object.setTransformWorld(transform);
}
function setTransformLocal(object, transform) {
  return ObjectUtils.setTransformLocalMatrix(object, transform);
}
var setTransformLocalMatrix = function() {
  let position = Vec3Utils.create();
  let rotation = QuatUtils.create();
  let scale11 = Vec3Utils.create();
  let transformMatrixNoScale = Mat4Utils.create();
  let inverseScale = Vec3Utils.create();
  let one = Vec3Utils.create(1);
  return function setTransformLocalMatrix2(object, transform) {
    Mat4Utils.getPosition(transform, position);
    Mat4Utils.getScale(transform, scale11);
    Vec3Utils.div(one, scale11, inverseScale);
    Mat4Utils.scale(transform, inverseScale, transformMatrixNoScale);
    Mat4Utils.getRotationQuat(transformMatrixNoScale, rotation);
    QuatUtils.normalize(rotation, rotation);
    ObjectUtils.setScaleLocal(object, scale11);
    ObjectUtils.setRotationLocalQuat(object, rotation);
    ObjectUtils.setPositionLocal(object, position);
  };
}();
function setTransformLocalQuat(object, transform) {
  object.setTransformLocal(transform);
}
function resetPosition(object) {
  ObjectUtils.resetPositionWorld(object);
}
var resetPositionWorld = function() {
  let zero7 = Vec3Utils.create();
  return function resetPositionWorld2(object) {
    ObjectUtils.setPositionWorld(object, zero7);
  };
}();
var resetPositionLocal = function() {
  let zero7 = Vec3Utils.create();
  return function resetPositionLocal2(object) {
    ObjectUtils.setPositionLocal(object, zero7);
  };
}();
function resetRotation(object) {
  ObjectUtils.resetRotationWorld(object);
}
var resetRotationWorld = function() {
  let identity8 = QuatUtils.create();
  return function resetRotationWorld2(object) {
    ObjectUtils.setRotationWorldQuat(object, identity8);
  };
}();
var resetRotationLocal = function() {
  let identity8 = QuatUtils.create();
  return function resetRotationLocal2(object) {
    ObjectUtils.setRotationLocalQuat(object, identity8);
  };
}();
function resetScale(object) {
  ObjectUtils.resetScaleWorld(object);
}
var resetScaleWorld = function() {
  let one = Vec3Utils.create(1);
  return function resetScaleWorld2(object) {
    ObjectUtils.setScaleWorld(object, one);
  };
}();
var resetScaleLocal = function() {
  let one = Vec3Utils.create(1);
  return function resetScaleLocal2(object) {
    ObjectUtils.setScaleLocal(object, one);
  };
}();
function resetTransform(object) {
  ObjectUtils.resetTransformWorld(object);
}
function resetTransformWorld(object) {
  ObjectUtils.resetScaleWorld(object);
  ObjectUtils.resetRotationWorld(object);
  ObjectUtils.resetPositionWorld(object);
}
function resetTransformLocal(object) {
  ObjectUtils.resetScaleLocal(object);
  ObjectUtils.resetRotationLocal(object);
  ObjectUtils.resetPositionLocal(object);
}
function translate4(object, translation) {
  ObjectUtils.translateWorld(object, translation);
}
function translateWorld(object, translation) {
  object.translateWorld(translation);
}
function translateLocal(object, translation) {
  object.translate(translation);
}
function translateObject(object, translation) {
  object.translateObject(translation);
}
function translateAxis(object, amount, direction2) {
  ObjectUtils.translateAxisWorld(object, amount, direction2);
}
var translateAxisWorld = function() {
  let translation = Vec3Utils.create();
  return function translateAxisWorld2(object, amount, direction2) {
    Vec3Utils.scale(direction2, amount, translation);
    ObjectUtils.translateWorld(object, translation);
  };
}();
var translateAxisLocal = function() {
  let translation = Vec3Utils.create();
  return function translateAxisLocal2(object, amount, direction2) {
    Vec3Utils.scale(direction2, amount, translation);
    ObjectUtils.translateLocal(object, translation);
  };
}();
var translateAxisObject = function() {
  let translation = Vec3Utils.create();
  return function translateAxisObject2(object, amount, direction2) {
    Vec3Utils.scale(direction2, amount, translation);
    ObjectUtils.translateObject(object, translation);
  };
}();
function rotate6(object, rotation) {
  ObjectUtils.rotateWorld(object, rotation);
}
function rotateDegrees3(object, rotation) {
  ObjectUtils.rotateWorldDegrees(object, rotation);
}
function rotateRadians3(object, rotation) {
  ObjectUtils.rotateWorldRadians(object, rotation);
}
function rotateMatrix(object, rotation) {
  ObjectUtils.rotateWorldMatrix(object, rotation);
}
function rotateQuat3(object, rotation) {
  ObjectUtils.rotateWorldQuat(object, rotation);
}
function rotateWorld(object, rotation) {
  ObjectUtils.rotateWorldDegrees(object, rotation);
}
var rotateWorldDegrees = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateWorldDegrees2(object, rotation) {
    Vec3Utils.degreesToQuat(rotation, rotationQuat);
    ObjectUtils.rotateWorldQuat(object, rotationQuat);
  };
}();
var rotateWorldRadians = function() {
  let degreesRotation = Vec3Utils.create();
  return function rotateWorldRadians2(object, rotation) {
    degreesRotation = Vec3Utils.toDegrees(rotation, degreesRotation);
    ObjectUtils.rotateWorldDegrees(object, degreesRotation);
  };
}();
var rotateWorldMatrix = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateWorldMatrix2(object, rotation) {
    Mat3Utils.toQuat(rotation, rotationQuat);
    QuatUtils.normalize(rotationQuat, rotationQuat);
    ObjectUtils.rotateWorldQuat(object, rotationQuat);
  };
}();
var rotateWorldQuat = function() {
  let currentRotationQuat = QuatUtils.create();
  return function rotateWorldQuat2(object, rotation) {
    ObjectUtils.getRotationWorldQuat(object, currentRotationQuat);
    QuatUtils.mul(rotation, currentRotationQuat, currentRotationQuat);
    QuatUtils.normalize(currentRotationQuat, currentRotationQuat);
    ObjectUtils.setRotationWorldQuat(object, currentRotationQuat);
  };
}();
function rotateLocal(object, rotation) {
  ObjectUtils.rotateLocalDegrees(object, rotation);
}
var rotateLocalDegrees = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateLocalDegrees2(object, rotation) {
    Vec3Utils.degreesToQuat(rotation, rotationQuat);
    ObjectUtils.rotateLocalQuat(object, rotationQuat);
  };
}();
var rotateLocalRadians = function() {
  let degreesRotation = Vec3Utils.create();
  return function rotateLocalRadians2(object, rotation) {
    degreesRotation = Vec3Utils.toDegrees(rotation, degreesRotation);
    ObjectUtils.rotateLocalDegrees(object, degreesRotation);
  };
}();
var rotateLocalMatrix = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateLocalMatrix2(object, rotation) {
    Mat3Utils.toQuat(rotation, rotationQuat);
    QuatUtils.normalize(rotationQuat, rotationQuat);
    ObjectUtils.rotateLocalQuat(object, rotationQuat);
  };
}();
var rotateLocalQuat = function() {
  let currentRotationQuat = QuatUtils.create();
  return function rotateLocalQuat2(object, rotation) {
    ObjectUtils.getRotationLocalQuat(object, currentRotationQuat);
    QuatUtils.mul(rotation, currentRotationQuat, currentRotationQuat);
    QuatUtils.normalize(currentRotationQuat, currentRotationQuat);
    ObjectUtils.setRotationLocalQuat(object, currentRotationQuat);
  };
}();
function rotateObject(object, rotation) {
  ObjectUtils.rotateObjectDegrees(object, rotation);
}
var rotateObjectDegrees = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateObjectDegrees2(object, rotation) {
    Vec3Utils.degreesToQuat(rotation, rotationQuat);
    ObjectUtils.rotateObjectQuat(object, rotationQuat);
  };
}();
var rotateObjectRadians = function() {
  let degreesRotation = Vec3Utils.create();
  return function rotateObjectRadians2(object, rotation) {
    degreesRotation = Vec3Utils.toDegrees(rotation, degreesRotation);
    ObjectUtils.rotateObjectDegrees(object, degreesRotation);
  };
}();
var rotateObjectMatrix = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateObjectMatrix2(object, rotation) {
    Mat3Utils.toQuat(rotation, rotationQuat);
    QuatUtils.normalize(rotationQuat, rotationQuat);
    ObjectUtils.rotateObjectQuat(object, rotationQuat);
  };
}();
function rotateObjectQuat(object, rotation) {
  object.rotateObject(rotation);
}
function rotateAxis4(object, angle4, axis) {
  ObjectUtils.rotateAxisWorld(object, angle4, axis);
}
function rotateAxisDegrees4(object, angle4, axis) {
  ObjectUtils.rotateAxisWorldDegrees(object, angle4, axis);
}
function rotateAxisRadians4(object, angle4, axis) {
  ObjectUtils.rotateAxisWorldRadians(object, angle4, axis);
}
function rotateAxisWorld(object, angle4, axis) {
  ObjectUtils.rotateAxisWorldDegrees(object, angle4, axis);
}
function rotateAxisWorldDegrees(object, angle4, axis) {
  ObjectUtils.rotateAxisWorldRadians(object, MathUtils.toRadians(angle4), axis);
}
var rotateAxisWorldRadians = function() {
  let rotation = QuatUtils.create();
  return function rotateAxisWorldRadians2(object, angle4, axis) {
    QuatUtils.fromAxisRadians(angle4, axis, rotation);
    ObjectUtils.rotateWorldQuat(object, rotation);
  };
}();
function rotateAxisLocal(object, angle4, axis) {
  ObjectUtils.rotateAxisLocalDegrees(object, angle4, axis);
}
function rotateAxisLocalDegrees(object, angle4, axis) {
  ObjectUtils.rotateAxisLocalRadians(object, MathUtils.toRadians(angle4), axis);
}
var rotateAxisLocalRadians = function() {
  let rotation = QuatUtils.create();
  return function rotateAxisLocalRadians2(object, angle4, axis) {
    QuatUtils.fromAxisRadians(angle4, axis, rotation);
    ObjectUtils.rotateLocalQuat(object, rotation);
  };
}();
function rotateAxisObject(object, angle4, axis) {
  ObjectUtils.rotateAxisObjectDegrees(object, angle4, axis);
}
function rotateAxisObjectDegrees(object, angle4, axis) {
  ObjectUtils.rotateAxisObjectRadians(object, MathUtils.toRadians(angle4), axis);
}
var rotateAxisObjectRadians = function() {
  let rotation = QuatUtils.create();
  return function rotateAxisObjectRadians2(object, angle4, axis) {
    QuatUtils.fromAxisRadians(angle4, axis, rotation);
    ObjectUtils.rotateObjectQuat(object, rotation);
  };
}();
function rotateAround2(object, rotation, origin) {
  ObjectUtils.rotateAroundWorld(object, rotation, origin);
}
function rotateAroundDegrees2(object, rotation, origin) {
  ObjectUtils.rotateAroundWorldDegrees(object, rotation, origin);
}
function rotateAroundRadians2(object, rotation, origin) {
  ObjectUtils.rotateAroundWorldRadians(object, rotation, origin);
}
function rotateAroundMatrix(object, rotation, origin) {
  ObjectUtils.rotateAroundWorldMatrix(object, rotation, origin);
}
function rotateAroundQuat2(object, rotation, origin) {
  ObjectUtils.rotateAroundWorldQuat(object, rotation, origin);
}
function rotateAroundWorld(object, rotation, origin) {
  ObjectUtils.rotateAroundWorldDegrees(object, rotation, origin);
}
var rotateAroundWorldDegrees = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateAroundWorldDegrees2(object, rotation, origin) {
    Vec3Utils.degreesToQuat(rotation, rotationQuat);
    ObjectUtils.rotateAroundWorldQuat(object, rotationQuat, origin);
  };
}();
var rotateAroundWorldRadians = function() {
  let degreesRotation = Vec3Utils.create();
  return function rotateAroundWorldRadians2(object, rotation, origin) {
    degreesRotation = Vec3Utils.toDegrees(rotation, degreesRotation);
    ObjectUtils.rotateAroundWorldDegrees(object, degreesRotation, origin);
  };
}();
var rotateAroundWorldMatrix = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateAroundWorldMatrix2(object, rotation, origin) {
    Mat3Utils.toQuat(rotation, rotationQuat);
    QuatUtils.normalize(rotationQuat, rotationQuat);
    ObjectUtils.rotateAroundWorldQuat(object, rotationQuat, origin);
  };
}();
var rotateAroundWorldQuat = function() {
  let axis = Vec3Utils.create();
  return function rotateAroundWorldQuat2(object, rotation, origin) {
    QuatUtils.getAxis(rotation, axis);
    let angle4 = QuatUtils.getAngleRadians(rotation);
    ObjectUtils.rotateAroundAxisWorldRadians(object, angle4, axis, origin);
  };
}();
function rotateAroundLocal(object, rotation, origin) {
  ObjectUtils.rotateAroundLocalDegrees(object, rotation, origin);
}
var rotateAroundLocalDegrees = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateAroundLocalDegrees2(object, rotation, origin) {
    Vec3Utils.degreesToQuat(rotation, rotationQuat);
    ObjectUtils.rotateAroundLocalQuat(object, rotationQuat, origin);
  };
}();
var rotateAroundLocalRadians = function() {
  let degreesRotation = Vec3Utils.create();
  return function rotateAroundLocalRadians2(object, rotation, origin) {
    degreesRotation = Vec3Utils.toDegrees(rotation, degreesRotation);
    ObjectUtils.rotateAroundLocalDegrees(object, degreesRotation, origin);
  };
}();
var rotateAroundLocalMatrix = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateAroundLocalMatrix2(object, rotation, origin) {
    Mat3Utils.toQuat(rotation, rotationQuat);
    QuatUtils.normalize(rotationQuat, rotationQuat);
    ObjectUtils.rotateAroundLocalQuat(object, rotationQuat, origin);
  };
}();
var rotateAroundLocalQuat = function() {
  let axis = Vec3Utils.create();
  return function rotateAroundLocalQuat2(object, rotation, origin) {
    QuatUtils.getAxis(rotation, axis);
    let angle4 = QuatUtils.getAngleRadians(rotation);
    ObjectUtils.rotateAroundAxisLocalRadians(object, angle4, axis, origin);
  };
}();
function rotateAroundObject(object, rotation, origin) {
  ObjectUtils.rotateAroundObjectDegrees(object, rotation, origin);
}
var rotateAroundObjectDegrees = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateAroundObjectDegrees2(object, rotation, origin) {
    Vec3Utils.degreesToQuat(rotation, rotationQuat);
    ObjectUtils.rotateAroundObjectQuat(object, rotationQuat, origin);
  };
}();
var rotateAroundObjectRadians = function() {
  let degreesRotation = Vec3Utils.create();
  return function rotateAroundObjectRadians2(object, rotation, origin) {
    degreesRotation = Vec3Utils.toDegrees(rotation, degreesRotation);
    ObjectUtils.rotateAroundObjectDegrees(object, degreesRotation, origin);
  };
}();
var rotateAroundObjectMatrix = function() {
  let rotationQuat = QuatUtils.create();
  return function rotateAroundObjectMatrix2(object, rotation, origin) {
    Mat3Utils.toQuat(rotation, rotationQuat);
    QuatUtils.normalize(rotationQuat, rotationQuat);
    ObjectUtils.rotateAroundObjectQuat(object, rotationQuat, origin);
  };
}();
var rotateAroundObjectQuat = function() {
  let axis = Vec3Utils.create();
  return function rotateAroundObjectQuat2(object, rotation, origin) {
    QuatUtils.getAxis(rotation, axis);
    let angle4 = QuatUtils.getAngleRadians(rotation);
    ObjectUtils.rotateAroundAxisObjectRadians(object, angle4, axis, origin);
  };
}();
function rotateAroundAxis3(object, angle4, axis, origin) {
  ObjectUtils.rotateAroundAxisWorld(object, angle4, axis, origin);
}
function rotateAroundAxisDegrees2(object, angle4, axis, origin) {
  ObjectUtils.rotateAroundAxisWorldDegrees(object, angle4, axis, origin);
}
function rotateAroundAxisRadians2(object, angle4, axis, origin) {
  ObjectUtils.rotateAroundAxisWorldRadians(object, angle4, axis, origin);
}
function rotateAroundAxisWorld(object, angle4, axis, origin) {
  ObjectUtils.rotateAroundAxisWorldDegrees(object, angle4, axis, origin);
}
function rotateAroundAxisWorldDegrees(object, angle4, axis, origin) {
  ObjectUtils.rotateAroundAxisWorldRadians(object, MathUtils.toRadians(angle4), axis, origin);
}
var rotateAroundAxisWorldRadians = function() {
  let transformToRotate = Quat2Utils.create();
  let transformToRotateConjugate = Quat2Utils.create();
  let transformQuat4 = Quat2Utils.create();
  let defaultQuat = QuatUtils.create();
  return function rotateAroundAxisWorldRadians2(object, angle4, axis, origin) {
    Quat2Utils.setPositionRotationQuat(transformToRotate, origin, defaultQuat);
    ObjectUtils.getTransformWorldQuat(object, transformQuat4);
    Quat2Utils.conjugate(transformToRotate, transformToRotateConjugate);
    Quat2Utils.mul(transformToRotateConjugate, transformQuat4, transformQuat4);
    Quat2Utils.rotateAxisRadians(transformToRotate, angle4, axis, transformToRotate);
    Quat2Utils.mul(transformToRotate, transformQuat4, transformQuat4);
    ObjectUtils.setTransformWorldQuat(object, transformQuat4);
  };
}();
function rotateAroundAxisLocal(object, angle4, axis, origin) {
  ObjectUtils.rotateAroundAxisLocalDegrees(object, angle4, axis, origin);
}
function rotateAroundAxisLocalDegrees(object, angle4, axis, origin) {
  ObjectUtils.rotateAroundAxisLocalRadians(object, MathUtils.toRadians(angle4), axis, origin);
}
var rotateAroundAxisLocalRadians = function() {
  let convertedPosition = Vec3Utils.create();
  let convertedAxis = Vec3Utils.create();
  return function rotateAroundAxisLocalRadians2(object, angle4, axis, origin) {
    ObjectUtils.convertPositionLocalToWorld(object, origin, convertedPosition);
    ObjectUtils.convertDirectionLocalToWorld(object, axis, convertedAxis);
    ObjectUtils.rotateAroundAxisWorldRadians(object, angle4, convertedAxis, convertedPosition);
  };
}();
function rotateAroundAxisObject(object, angle4, axis, origin) {
  ObjectUtils.rotateAroundAxisObjectDegrees(object, angle4, axis, origin);
}
function rotateAroundAxisObjectDegrees(object, angle4, axis, origin) {
  ObjectUtils.rotateAroundAxisObjectRadians(object, MathUtils.toRadians(angle4), axis, origin);
}
var rotateAroundAxisObjectRadians = function() {
  let convertedPosition = Vec3Utils.create();
  let convertedAxis = Vec3Utils.create();
  return function rotateAroundAxisObjectRadians2(object, angle4, axis, origin) {
    ObjectUtils.convertPositionObjectToWorld(object, origin, convertedPosition);
    ObjectUtils.convertDirectionObjectToWorld(object, axis, convertedAxis);
    ObjectUtils.rotateAroundAxisWorldRadians(object, angle4, convertedAxis, convertedPosition);
  };
}();
var scaleObject = function() {
  let vector = Vec3Utils.create();
  return function scaleObject2(object, scale11) {
    if (isNaN(scale11)) {
      object.scale(scale11);
    } else {
      Vec3Utils.set(vector, scale11);
      object.scale(vector);
    }
  };
}();
function lookAt2(object, position, up) {
  ObjectUtils.lookAtWorld(object, position, up);
}
var lookAtWorld = function() {
  let direction2 = Vec3Utils.create();
  return function lookAtWorld2(object, position, up) {
    ObjectUtils.getPositionWorld(object, direction2);
    Vec3Utils.sub(position, direction2, direction2);
    ObjectUtils.lookToWorld(object, direction2, up);
  };
}();
var lookAtLocal = function() {
  let direction2 = Vec3Utils.create();
  return function lookAtLocal2(object, position, up) {
    ObjectUtils.getPositionLocal(object, direction2);
    Vec3Utils.sub(position, direction2, direction2);
    ObjectUtils.lookToLocal(object, direction2, up);
  };
}();
function lookTo(object, direction2, up) {
  ObjectUtils.lookToWorld(object, direction2, up);
}
var lookToWorld = function() {
  let internalUp = Vec3Utils.create();
  return function lookToWorld2(object, direction2, up = ObjectUtils.getUpWorld(object, internalUp)) {
    ObjectUtils.setForwardWorld(object, direction2, up);
  };
}();
var lookToLocal = function() {
  let internalUp = Vec3Utils.create();
  return function lookToLocal2(object, direction2, up = ObjectUtils.getUpLocal(object, internalUp)) {
    ObjectUtils.setForwardLocal(object, direction2, up);
  };
}();
var setParent = function() {
  let position = Vec3Utils.create();
  let rotation = QuatUtils.create();
  let scale11 = Vec3Utils.create();
  return function setParent2(object, newParent, keepTransformWorld = true) {
    if (!keepTransformWorld) {
      object.parent = newParent;
    } else {
      ObjectUtils.getPositionWorld(object, position);
      ObjectUtils.getRotationWorldQuat(object, rotation);
      ObjectUtils.getScaleWorld(object, scale11);
      object.parent = newParent;
      ObjectUtils.setScaleWorld(object, scale11);
      ObjectUtils.setRotationWorldQuat(object, rotation);
      ObjectUtils.setPositionWorld(object, position);
    }
  };
}();
function getParent(object) {
  return object.parent;
}
var convertPositionObjectToWorld = function() {
  let matrix = Mat4Utils.create();
  return function convertPositionObjectToWorld2(object, position, resultPosition = Vec3Utils.create()) {
    ObjectUtils.getTransformWorldMatrix(object, matrix);
    Vec3Utils.transformMat4(position, matrix, resultPosition);
    return resultPosition;
  };
}();
var convertDirectionObjectToWorld = function() {
  let rotation = QuatUtils.create();
  return function convertDirectionObjectToWorld2(object, direction2, resultDirection = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldQuat(object, rotation);
    Vec3Utils.transformQuat(direction2, rotation, resultDirection);
    return resultDirection;
  };
}();
var convertPositionWorldToObject = function() {
  let matrix = Mat4Utils.create();
  return function convertPositionWorldToObject2(object, position, resultPosition = Vec3Utils.create()) {
    ObjectUtils.getTransformWorldMatrix(object, matrix);
    Mat4Utils.invert(matrix, matrix);
    Vec3Utils.transformMat4(position, matrix, resultPosition);
    return resultPosition;
  };
}();
var convertDirectionWorldToObject = function() {
  let rotation = QuatUtils.create();
  return function convertDirectionWorldToObject2(object, direction2, resultDirection = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldQuat(object, rotation);
    QuatUtils.conjugate(rotation, rotation);
    Vec3Utils.transformQuat(direction2, rotation, resultDirection);
    return resultDirection;
  };
}();
function convertPositionLocalToWorld(object, position, resultPosition = Vec3Utils.create()) {
  if (ObjectUtils.getParent(object)) {
    ObjectUtils.convertPositionObjectToWorld(ObjectUtils.getParent(object), position, resultPosition);
  } else {
    Vec3Utils.copy(position, resultPosition);
  }
  return resultPosition;
}
function convertDirectionLocalToWorld(object, direction2, resultDirection = Vec3Utils.create()) {
  if (ObjectUtils.getParent(object)) {
    ObjectUtils.convertDirectionObjectToWorld(ObjectUtils.getParent(object), direction2, resultDirection);
  } else {
    Vec3Utils.copy(direction2, resultDirection);
  }
  return resultDirection;
}
function convertPositionWorldToLocal(object, position, resultPosition = Vec3Utils.create()) {
  if (ObjectUtils.getParent(object)) {
    ObjectUtils.convertPositionWorldToObject(ObjectUtils.getParent(object), position, resultPosition);
  } else {
    Vec3Utils.copy(position, resultPosition);
  }
  return resultPosition;
}
function convertDirectionWorldToLocal(object, direction2, resultDirection = Vec3Utils.create()) {
  if (ObjectUtils.getParent(object)) {
    ObjectUtils.convertDirectionWorldToObject(ObjectUtils.getParent(object), direction2, resultDirection);
  } else {
    Vec3Utils.copy(direction2, resultDirection);
  }
  return resultDirection;
}
function convertPositionObjectToLocal(object, position, resultPosition = Vec3Utils.create()) {
  ObjectUtils.convertPositionObjectToWorld(object, position, resultPosition);
  ObjectUtils.convertPositionWorldToLocal(object, resultPosition, resultPosition);
  return resultPosition;
}
function convertDirectionObjectToLocal(object, direction2, resultDirection = Vec3Utils.create()) {
  ObjectUtils.convertDirectionObjectToWorld(object, direction2, resultDirection);
  ObjectUtils.convertDirectionWorldToLocal(object, resultDirection, resultDirection);
  return resultDirection;
}
function convertPositionLocalToObject(object, position, resultPosition = Vec3Utils.create()) {
  ObjectUtils.convertPositionLocalToWorld(object, position, resultPosition);
  ObjectUtils.convertPositionWorldToObject(object, resultPosition, resultPosition);
  return resultPosition;
}
function convertDirectionLocalToObject(object, direction2, resultDirection = Vec3Utils.create()) {
  ObjectUtils.convertDirectionLocalToWorld(object, direction2, resultDirection);
  ObjectUtils.convertDirectionWorldToObject(object, resultDirection, resultDirection);
  return resultDirection;
}
function convertTransformObjectToWorld(object, transform, resultTransform) {
  return ObjectUtils.convertTransformObjectToWorldMatrix(object, transform, resultTransform);
}
var convertTransformObjectToWorldMatrix = function() {
  let convertTransform = Mat4Utils.create();
  let position = Vec3Utils.create();
  let scale11 = Vec3Utils.create();
  let inverseScale = Vec3Utils.create();
  let one = Vec3Utils.create(1);
  return function convertTransformObjectToWorldMatrix2(object, transform, resultTransform = Mat4Utils.create()) {
    ObjectUtils.getTransformWorldMatrix(object, convertTransform);
    if (ObjectUtils.hasUniformScaleWorld(object)) {
      Mat4Utils.mul(convertTransform, transform, resultTransform);
    } else {
      Vec3Utils.set(position, transform[12], transform[13], transform[14]);
      ObjectUtils.convertPositionObjectToWorld(object, position, position);
      Mat4Utils.getScale(convertTransform, scale11);
      Vec3Utils.div(one, scale11, inverseScale);
      Mat4Utils.scale(convertTransform, inverseScale, convertTransform);
      Mat4Utils.mul(convertTransform, transform, resultTransform);
      Mat4Utils.scale(resultTransform, scale11, resultTransform);
      resultTransform[12] = position[0];
      resultTransform[13] = position[1];
      resultTransform[14] = position[2];
      resultTransform[15] = 1;
    }
    return resultTransform;
  };
}();
var convertTransformObjectToWorldQuat = function() {
  let position = Vec3Utils.create();
  let rotation = QuatUtils.create();
  return function convertTransformObjectToWorldQuat2(object, transform, resultTransform = Quat2Utils.create()) {
    ObjectUtils.getRotationWorldQuat(object, rotation);
    QuatUtils.mul(rotation, transform, rotation);
    Quat2Utils.getPosition(transform, position);
    ObjectUtils.convertPositionObjectToWorld(object, position, position);
    Quat2Utils.setPositionRotationQuat(resultTransform, position, rotation);
    return resultTransform;
  };
}();
function convertTransformWorldToObject(object, transform, resultTransform) {
  return ObjectUtils.convertTransformWorldToObjectMatrix(object, transform, resultTransform);
}
var convertTransformWorldToObjectMatrix = function() {
  let convertTransform = Mat4Utils.create();
  let position = Vec3Utils.create();
  let scale11 = Vec3Utils.create();
  let inverseScale = Vec3Utils.create();
  let one = Vec3Utils.create(1);
  return function convertTransformWorldToObjectMatrix2(object, transform, resultTransform = Mat4Utils.create()) {
    ObjectUtils.getTransformWorldMatrix(object, convertTransform);
    if (ObjectUtils.hasUniformScaleWorld(object)) {
      Mat4Utils.invert(convertTransform, convertTransform);
      Mat4Utils.mul(convertTransform, transform, resultTransform);
    } else {
      Vec3Utils.set(position, transform[12], transform[13], transform[14]);
      ObjectUtils.convertPositionWorldToObject(object, position, position);
      Mat4Utils.getScale(convertTransform, scale11);
      Vec3Utils.div(one, scale11, inverseScale);
      Mat4Utils.scale(convertTransform, inverseScale, convertTransform);
      Mat4Utils.invert(convertTransform, convertTransform);
      Mat4Utils.mul(convertTransform, transform, resultTransform);
      Mat4Utils.scale(resultTransform, inverseScale, resultTransform);
      resultTransform[12] = position[0];
      resultTransform[13] = position[1];
      resultTransform[14] = position[2];
      resultTransform[15] = 1;
    }
    return resultTransform;
  };
}();
var convertTransformWorldToObjectQuat = function() {
  let position = Vec3Utils.create();
  let rotation = QuatUtils.create();
  return function convertTransformWorldToObjectQuat2(object, transform, resultTransform = Quat2Utils.create()) {
    ObjectUtils.getRotationWorldQuat(object, rotation);
    QuatUtils.conjugate(rotation, rotation);
    QuatUtils.mul(rotation, transform, rotation);
    Quat2Utils.getPosition(transform, position);
    ObjectUtils.convertPositionWorldToObject(object, position, position);
    Quat2Utils.setPositionRotationQuat(resultTransform, position, rotation);
    return resultTransform;
  };
}();
function convertTransformLocalToWorld(object, transform, resultTransform) {
  return ObjectUtils.convertTransformLocalToWorldMatrix(object, transform, resultTransform);
}
function convertTransformLocalToWorldMatrix(object, transform, resultTransform = Mat4Utils.create()) {
  if (ObjectUtils.getParent(object)) {
    ObjectUtils.convertTransformObjectToWorldMatrix(ObjectUtils.getParent(object), transform, resultTransform);
  } else {
    Mat4Utils.copy(transform, resultTransform);
  }
  return resultTransform;
}
function convertTransformLocalToWorldQuat(object, transform, resultTransform = Quat2Utils.create()) {
  if (ObjectUtils.getParent(object)) {
    ObjectUtils.convertTransformObjectToWorldQuat(ObjectUtils.getParent(object), transform, resultTransform);
  } else {
    Quat2Utils.copy(transform, resultTransform);
  }
  return resultTransform;
}
function convertTransformWorldToLocal(object, transform, resultTransform) {
  return ObjectUtils.convertTransformWorldToLocalMatrix(object, transform, resultTransform);
}
function convertTransformWorldToLocalMatrix(object, transform, resultTransform = Mat4Utils.create()) {
  if (ObjectUtils.getParent(object)) {
    ObjectUtils.convertTransformWorldToObjectMatrix(ObjectUtils.getParent(object), transform, resultTransform);
  } else {
    Mat4Utils.copy(transform, resultTransform);
  }
  return resultTransform;
}
function convertTransformWorldToLocalQuat(object, transform, resultTransform = Quat2Utils.create()) {
  if (ObjectUtils.getParent(object)) {
    ObjectUtils.convertTransformWorldToObjectQuat(ObjectUtils.getParent(object), transform, resultTransform);
  } else {
    Quat2Utils.copy(transform, resultTransform);
  }
  return resultTransform;
}
function convertTransformObjectToLocal(object, transform, resultTransform) {
  return ObjectUtils.convertTransformObjectToLocalMatrix(object, transform, resultTransform);
}
function convertTransformObjectToLocalMatrix(object, transform, resultTransform = Mat4Utils.create()) {
  ObjectUtils.convertTransformObjectToWorldMatrix(object, transform, resultTransform);
  ObjectUtils.convertTransformWorldToLocalMatrix(object, resultTransform, resultTransform);
  return resultTransform;
}
function convertTransformObjectToLocalQuat(object, transform, resultTransform = Quat2Utils.create()) {
  ObjectUtils.convertTransformObjectToWorldQuat(object, transform, resultTransform);
  ObjectUtils.convertTransformWorldToLocalQuat(object, resultTransform, resultTransform);
  return resultTransform;
}
function convertTransformLocalToObject(object, transform, resultTransform) {
  return ObjectUtils.convertTransformLocalToObjectMatrix(object, transform, resultTransform);
}
function convertTransformLocalToObjectMatrix(object, transform, resultTransform = Mat4Utils.create()) {
  ObjectUtils.convertTransformLocalToWorldMatrix(object, transform, resultTransform);
  ObjectUtils.convertTransformWorldToObjectMatrix(object, resultTransform, resultTransform);
  return resultTransform;
}
function convertTransformLocalToObjectQuat(object, transform, resultTransform = Quat2Utils.create()) {
  ObjectUtils.convertTransformLocalToWorldQuat(object, transform, resultTransform);
  ObjectUtils.convertTransformWorldToObjectQuat(object, resultTransform, resultTransform);
  return resultTransform;
}
function addComponent(object, typeOrClass, paramsOrActive, active = null) {
  let params = null;
  if (typeof paramsOrActive == "boolean") {
    params = {};
    params["active"] = paramsOrActive;
  } else {
    params = paramsOrActive;
    if (active != null) {
      if (params == null) {
        params = {};
      }
      params["active"] = active;
    }
  }
  return object.addComponent(typeOrClass, params);
}
function getComponent(object, typeOrClass, index = 0) {
  return ObjectUtils.getComponentHierarchy(object, typeOrClass, index);
}
function getComponentSelf(object, typeOrClass, index = 0) {
  return object.getComponent(typeOrClass, index);
}
function getComponentHierarchy(object, typeOrClass, index = 0) {
  return ObjectUtils.getComponentHierarchyBreadth(object, typeOrClass, index);
}
function getComponentHierarchyBreadth(object, typeOrClass, index = 0) {
  let objects = ObjectUtils.getHierarchyBreadth(object);
  return ObjectUtils.getComponentObjects(objects, typeOrClass, index);
}
function getComponentHierarchyDepth(object, typeOrClass, index = 0) {
  let objects = ObjectUtils.getHierarchyDepth(object);
  return ObjectUtils.getComponentObjects(objects, typeOrClass, index);
}
function getComponentDescendants(object, typeOrClass, index = 0) {
  return ObjectUtils.getComponentDescendantsBreadth(object, typeOrClass, index);
}
function getComponentDescendantsBreadth(object, typeOrClass, index = 0) {
  let objects = ObjectUtils.getDescendantsBreadth(object);
  return ObjectUtils.getComponentObjects(objects, typeOrClass, index);
}
function getComponentDescendantsDepth(object, typeOrClass, index = 0) {
  let objects = ObjectUtils.getDescendantsDepth(object);
  return ObjectUtils.getComponentObjects(objects, typeOrClass, index);
}
function getComponentChildren(object, typeOrClass, index = 0) {
  let objects = ObjectUtils.getChildren(object);
  return ObjectUtils.getComponentObjects(objects, typeOrClass, index);
}
function getComponents(object, typeOrClass) {
  return ObjectUtils.getComponentsHierarchy(object, typeOrClass);
}
function getComponentsSelf(object, typeOrClass) {
  return object.getComponents(typeOrClass);
}
function getComponentsHierarchy(object, typeOrClass) {
  return ObjectUtils.getComponentsHierarchyBreadth(object, typeOrClass);
}
function getComponentsHierarchyBreadth(object, typeOrClass) {
  let objects = ObjectUtils.getHierarchyBreadth(object);
  return ObjectUtils.getComponentsObjects(objects, typeOrClass);
}
function getComponentsHierarchyDepth(object, typeOrClass) {
  let objects = ObjectUtils.getHierarchyDepth(object);
  return ObjectUtils.getComponentsObjects(objects, typeOrClass);
}
function getComponentsDescendants(object, typeOrClass) {
  return ObjectUtils.getComponentsDescendantsBreadth(object, typeOrClass);
}
function getComponentsDescendantsBreadth(object, typeOrClass) {
  let objects = ObjectUtils.getDescendantsBreadth(object);
  return ObjectUtils.getComponentsObjects(objects, typeOrClass);
}
function getComponentsDescendantsDepth(object, typeOrClass) {
  let objects = ObjectUtils.getDescendantsDepth(object);
  return ObjectUtils.getComponentsObjects(objects, typeOrClass);
}
function getComponentsChildren(object, typeOrClass) {
  let objects = ObjectUtils.getChildren(object);
  return ObjectUtils.getComponentsObjects(objects, typeOrClass);
}
function setActive(object, active) {
  ObjectUtils.setActiveHierarchy(object, active);
}
function setActiveSelf(object, active) {
  object.active = active;
}
function setActiveHierarchy(object, active) {
  ObjectUtils.setActiveHierarchyBreadth(object, active);
}
function setActiveHierarchyBreadth(object, active) {
  let objects = ObjectUtils.getHierarchyBreadth(object);
  ObjectUtils.setActiveObjects(objects, active);
}
function setActiveHierarchyDepth(object, active) {
  let objects = ObjectUtils.getHierarchyDepth(object);
  ObjectUtils.setActiveObjects(objects, active);
}
function setActiveDescendants(object, active) {
  ObjectUtils.setActiveDescendantsBreadth(object, active);
}
function setActiveDescendantsBreadth(object, active) {
  let objects = ObjectUtils.getDescendantsBreadth(object);
  ObjectUtils.setActiveObjects(objects, active);
}
function setActiveDescendantsDepth(object, active) {
  let objects = ObjectUtils.getDescendantsDepth(object);
  ObjectUtils.setActiveObjects(objects, active);
}
function setActiveChildren(object, active) {
  let objects = ObjectUtils.getChildren(object);
  ObjectUtils.setActiveObjects(objects, active);
}
function hasUniformScale2(object) {
  return ObjectUtils.hasUniformScaleWorld(object);
}
var hasUniformScaleWorld = function() {
  let scale11 = Vec3Utils.create();
  return function hasUniformScaleWorld2(object) {
    ObjectUtils.getScaleWorld(object, scale11);
    return Math.abs(scale11[0] - scale11[1]) < MathUtils.EPSILON && Math.abs(scale11[1] - scale11[2]) < MathUtils.EPSILON && Math.abs(scale11[0] - scale11[2]) < MathUtils.EPSILON;
  };
}();
var hasUniformScaleLocal = function() {
  let scale11 = Vec3Utils.create();
  return function hasUniformScaleLocal2(object) {
    ObjectUtils.getScaleLocal(object, scale11);
    return Math.abs(scale11[0] - scale11[1]) < MathUtils.EPSILON && Math.abs(scale11[1] - scale11[2]) < MathUtils.EPSILON && Math.abs(scale11[0] - scale11[2]) < MathUtils.EPSILON;
  };
}();
var clone12 = function() {
  let scale11 = Vec3Utils.create();
  let transformQuat4 = Quat2Utils.create();
  return function clone17(object, cloneParams = new CloneParams()) {
    let clonedObject = null;
    let cloneParent = cloneParams.myCloneParent === void 0 ? ObjectUtils.getParent(object) : cloneParams.myCloneParent;
    if (cloneParams.myUseDefaultObjectClone) {
      clonedObject = object.clone(cloneParent);
      if (cloneParams.myDefaultComponentCloneAutoStartIfNotActive) {
        let clonedComponents = clonedObject.pp_getComponents();
        for (let clonedComponent of clonedComponents) {
          if (cloneParams.myDefaultComponentCloneAutoStartIfNotActive && !clonedComponent.active) {
            clonedComponent.active = true;
            clonedComponent.active = false;
          }
        }
      }
    } else if (ObjectUtils.isCloneable(object, cloneParams)) {
      let objectsToCloneData = [];
      objectsToCloneData.push([cloneParent, object]);
      let objectsToCloneComponentsData = [];
      while (objectsToCloneData.length > 0) {
        let cloneData = objectsToCloneData.shift();
        let parent = cloneData[0];
        let objectToClone = cloneData[1];
        let currentClonedObject = parent != null ? ObjectUtils.addObject(parent) : SceneUtils.addObject(Globals.getScene(ObjectUtils.getEngine(object)));
        ObjectUtils.setName(currentClonedObject, ObjectUtils.getName(objectToClone));
        ObjectUtils.setScaleLocal(currentClonedObject, ObjectUtils.getScaleLocal(objectToClone, scale11));
        ObjectUtils.setTransformLocalQuat(currentClonedObject, ObjectUtils.getTransformLocalQuat(objectToClone, transformQuat4));
        if (!cloneParams.myIgnoreComponents) {
          objectsToCloneComponentsData.push([objectToClone, currentClonedObject]);
        }
        if (!cloneParams.myIgnoreDescendants) {
          for (let child of ObjectUtils.getChildren(objectToClone)) {
            let cloneDescendant = false;
            if (cloneParams.myDescendantsToInclude.length > 0) {
              cloneDescendant = cloneParams.myDescendantsToInclude.find((descendantToInclude) => ObjectUtils.equals(descendantToInclude, child)) != null;
            } else {
              cloneDescendant = cloneParams.myDescendantsToIgnore.find((descendantToIgnore) => ObjectUtils.equals(descendantToIgnore, child)) == null;
            }
            if (cloneDescendant && cloneParams.myIgnoreDescendantCallback != null) {
              cloneDescendant = !cloneParams.myIgnoreDescendantCallback(child);
            }
            if (cloneDescendant) {
              objectsToCloneData.push([currentClonedObject, child]);
            }
          }
        }
        if (clonedObject == null) {
          clonedObject = currentClonedObject;
        }
      }
      let componentsToCloneData = [];
      while (objectsToCloneComponentsData.length > 0) {
        let cloneData = objectsToCloneComponentsData.shift();
        let objectToClone = cloneData[0];
        let currentClonedObject = cloneData[1];
        let components = ObjectUtils.getComponentsSelf(objectToClone);
        for (let component of components) {
          if (ComponentUtils.isCloneable(component.type, cloneParams.myUseDefaultComponentClone || cloneParams.myUseDefaultComponentCloneAsFallback, ObjectUtils.getEngine(object))) {
            let cloneComponent = false;
            if (cloneParams.myComponentsToInclude.length > 0) {
              cloneComponent = cloneParams.myComponentsToInclude.indexOf(component.type) != -1;
            } else {
              cloneComponent = cloneParams.myComponentsToIgnore.indexOf(component.type) == -1;
            }
            if (cloneComponent && cloneParams.myIgnoreComponentCallback != null) {
              cloneComponent = !cloneParams.myIgnoreComponentCallback(component);
            }
            if (cloneComponent) {
              componentsToCloneData.push([component, currentClonedObject]);
            }
          }
        }
      }
      let componentsToPostProcessData = [];
      while (componentsToCloneData.length > 0) {
        let cloneData = componentsToCloneData.shift();
        let componentToClone = cloneData[0];
        let currentClonedObject = cloneData[1];
        let clonedComponent = null;
        if (!cloneParams.myUseDefaultComponentClone) {
          clonedComponent = ComponentUtils.clone(componentToClone, currentClonedObject, cloneParams.myComponentDeepCloneParams, cloneParams.myComponentCustomCloneParams, cloneParams.myUseDefaultComponentCloneAsFallback, cloneParams.myDefaultComponentCloneAutoStartIfNotActive);
        } else {
          clonedComponent = ComponentUtils.cloneDefault(componentToClone, currentClonedObject, cloneParams.myDefaultComponentCloneAutoStartIfNotActive);
        }
        if (clonedComponent != null) {
          if (ComponentUtils.hasClonePostProcess(componentToClone.type, ObjectUtils.getEngine(object))) {
            componentsToPostProcessData.push([componentToClone, clonedComponent]);
          }
        }
      }
      while (componentsToPostProcessData.length > 0) {
        let cloneData = componentsToPostProcessData.shift();
        let componentToClone = cloneData[0];
        let currentClonedComponent = cloneData[1];
        ComponentUtils.clonePostProcess(componentToClone, currentClonedComponent, cloneParams.myComponentDeepCloneParams, cloneParams.myComponentCustomCloneParams);
      }
    } else if (cloneParams.myUseDefaultObjectCloneAsFallback) {
      clonedObject = object.clone(cloneParent);
      if (cloneParams.myDefaultComponentCloneAutoStartIfNotActive) {
        let clonedComponents = clonedObject.pp_getComponents();
        for (let clonedComponent of clonedComponents) {
          if (cloneParams.myDefaultComponentCloneAutoStartIfNotActive && !clonedComponent.active) {
            clonedComponent.active = true;
            clonedComponent.active = false;
          }
        }
      }
    }
    return clonedObject;
  };
}();
function isCloneable(object, cloneParams = new CloneParams()) {
  if (cloneParams.myIgnoreNonCloneable || cloneParams.myIgnoreComponents || cloneParams.myUseDefaultComponentClone || cloneParams.myUseDefaultComponentCloneAsFallback) {
    return true;
  }
  let cloneable = true;
  let objectsToClone = [];
  objectsToClone.push(object);
  while (cloneable && objectsToClone.length > 0) {
    let objectToClone = objectsToClone.shift();
    let components = ObjectUtils.getComponentsSelf(objectToClone);
    for (let component of components) {
      let cloneComponent = false;
      if (cloneParams.myComponentsToInclude.length > 0) {
        cloneComponent = cloneParams.myComponentsToInclude.indexOf(component.type) != -1;
      } else {
        cloneComponent = cloneParams.myComponentsToIgnore.indexOf(component.type) == -1;
      }
      if (cloneComponent && cloneParams.myIgnoreComponentCallback != null) {
        cloneComponent = !cloneParams.myIgnoreComponentCallback(component);
      }
      if (cloneComponent && !ComponentUtils.isCloneable(component.type, false, ObjectUtils.getEngine(object))) {
        cloneable = false;
        break;
      }
    }
    if (cloneable && !cloneParams.myIgnoreDescendants) {
      for (let child of ObjectUtils.getChildren(objectToClone)) {
        let cloneDescendant = false;
        if (cloneParams.myDescendantsToInclude.length > 0) {
          cloneDescendant = cloneParams.myDescendantsToInclude.find((descendantToInclude) => ObjectUtils.equals(descendantToInclude, child)) != null;
        } else {
          cloneDescendant = cloneParams.myDescendantsToIgnore.find((descendantToInclude) => ObjectUtils.equals(descendantToInclude, child)) == null;
        }
        if (cloneDescendant && cloneParams.myIgnoreDescendantCallback != null) {
          cloneDescendant = !cloneParams.myIgnoreDescendantCallback(child);
        }
        if (cloneDescendant) {
          objectsToClone.push(child);
        }
      }
    }
  }
  return cloneable;
}
function toString(object) {
  return ObjectUtils.toStringCompact(object);
}
var toStringExtended = function() {
  let tab = "    ";
  let newLine = "\n";
  let startObject = "{";
  let endObject = "}";
  let nameLabel = "name: ";
  let idLabel = "id: ";
  let componentsLabel = "components: ";
  let typeLabel = "type: ";
  let childrenLabel = "children: ";
  let startComponents = "[";
  let endComponents = "]";
  let startChildren = startComponents;
  let endChildren = endComponents;
  let separator = ",";
  let newLineTab = newLine.concat(tab, tab);
  return function toStringExtended3(object) {
    let objectString = "";
    objectString = objectString.concat(startObject, newLine);
    let components = ObjectUtils.getComponentsSelf(object);
    let children = ObjectUtils.getChildren(object);
    let name = ObjectUtils.getName(object);
    if (components.length > 0 || children.length > 0 || name.length > 0) {
      objectString = objectString.concat(tab, idLabel, ObjectUtils.getID(object), separator, newLine);
    } else {
      objectString = objectString.concat(tab, idLabel, ObjectUtils.getID(object), newLine);
    }
    if (name.length > 0) {
      if (components.length > 0 || children.length > 0) {
        objectString = objectString.concat(tab, nameLabel, ObjectUtils.getName(object), separator, newLine);
      } else {
        objectString = objectString.concat(tab, nameLabel, ObjectUtils.getName(object), newLine);
      }
    }
    if (components.length > 0) {
      objectString = objectString.concat(tab, componentsLabel, newLine, tab, startComponents, newLine);
      for (let i = 0; i < components.length; i++) {
        let component = components[i];
        objectString = objectString.concat(tab, tab, startObject, newLine);
        objectString = objectString.concat(tab, tab, tab, typeLabel, component.type, separator, newLine);
        objectString = objectString.concat(tab, tab, tab, idLabel, component._id, separator, newLine);
        objectString = objectString.concat(tab, tab, endObject);
        if (i != components.length - 1) {
          objectString = objectString.concat(separator, newLine);
        } else {
          objectString = objectString.concat(newLine);
        }
      }
      if (children.length > 0) {
        objectString = objectString.concat(tab, endComponents, separator, newLine);
      } else {
        objectString = objectString.concat(tab, endComponents, newLine);
      }
    }
    if (children.length > 0) {
      objectString = objectString.concat(tab, childrenLabel, newLine, tab, startChildren, newLine);
      for (let i = 0; i < children.length; i++) {
        let child = children[i];
        let childString = ObjectUtils.toStringExtended(child);
        childString = childString.replaceAll(newLine, newLineTab);
        childString = tab.concat(tab, childString);
        objectString = objectString.concat(childString);
        if (i != children.length - 1) {
          objectString = objectString.concat(separator, newLine);
        } else {
          objectString = objectString.concat(newLine);
        }
      }
      objectString = objectString.concat(tab, endChildren, newLine);
    }
    objectString = objectString.concat(endObject);
    return objectString;
  };
}();
var toStringCompact = function() {
  let tab = "    ";
  let newLine = "\n";
  let emptyName = "<none>";
  let nameLabel = "name: ";
  let componentsLabel = "components: ";
  let separator = ", ";
  let newLineTab = newLine.concat(tab);
  return function toStringCompact3(object) {
    let objectString = "";
    let name = ObjectUtils.getName(object);
    if (name.length > 0) {
      objectString = objectString.concat(nameLabel, name);
    } else {
      objectString = objectString.concat(nameLabel, emptyName);
    }
    let components = ObjectUtils.getComponentsSelf(object);
    if (components.length > 0) {
      objectString = objectString.concat(separator, componentsLabel);
      for (let i = 0; i < components.length; i++) {
        let component = components[i];
        objectString = objectString.concat(component.type);
        if (i != components.length - 1) {
          objectString = objectString.concat(separator);
        }
      }
    }
    let children = ObjectUtils.getChildren(object);
    if (children.length > 0) {
      objectString = objectString.concat(newLine);
      for (let i = 0; i < children.length; i++) {
        let child = children[i];
        let childString = ObjectUtils.toStringCompact(child);
        childString = childString.replaceAll(newLine, newLineTab);
        childString = tab.concat(childString);
        objectString = objectString.concat(childString);
        if (i != children.length - 1) {
          objectString = objectString.concat(newLine);
        }
      }
    }
    return objectString;
  };
}();
function getObjectByName(object, name, isRegex = false, index = 0) {
  return ObjectUtils.getObjectByNameHierarchy(object, name, isRegex, index);
}
function getObjectByNameHierarchy(object, name, isRegex = false, index = 0) {
  return ObjectUtils.getObjectByNameHierarchyBreadth(object, name, isRegex, index);
}
function getObjectByNameHierarchyBreadth(object, name, isRegex = false, index = 0) {
  let objects = ObjectUtils.getHierarchyBreadth(object);
  return ObjectUtils.getObjectByNameObjects(objects, name, isRegex, index);
}
function getObjectByNameHierarchyDepth(object, name, isRegex = false, index = 0) {
  let objects = ObjectUtils.getHierarchyDepth(object);
  return ObjectUtils.getObjectByNameObjects(objects, name, isRegex, index);
}
function getObjectByNameDescendants(object, name, isRegex = false, index = 0) {
  return ObjectUtils.getObjectByNameDescendantsBreadth(object, name, isRegex, index);
}
function getObjectByNameDescendantsBreadth(object, name, isRegex = false, index = 0) {
  let objects = ObjectUtils.getDescendantsBreadth(object);
  return ObjectUtils.getObjectByNameObjects(objects, name, isRegex, index);
}
function getObjectByNameDescendantsDepth(object, name, isRegex = false, index = 0) {
  let objects = ObjectUtils.getDescendantsDepth(object);
  return ObjectUtils.getObjectByNameObjects(objects, name, isRegex, index);
}
function getObjectByNameChildren(object, name, isRegex = false, index = 0) {
  let objects = ObjectUtils.getChildren(object);
  return ObjectUtils.getObjectByNameObjects(objects, name, isRegex, index);
}
function getObjectsByName(object, name, isRegex = false) {
  return ObjectUtils.getObjectsByNameHierarchy(object, name, isRegex);
}
function getObjectsByNameHierarchy(object, name, isRegex = false) {
  return ObjectUtils.getObjectsByNameHierarchyBreadth(object, name, isRegex);
}
function getObjectsByNameHierarchyBreadth(object, name, isRegex = false) {
  let objects = ObjectUtils.getHierarchyBreadth(object);
  return ObjectUtils.getObjectsByNameObjects(objects, name, isRegex);
}
function getObjectsByNameHierarchyDepth(object, name, isRegex = false) {
  let objects = ObjectUtils.getHierarchyDepth(object);
  return ObjectUtils.getObjectsByNameObjects(objects, name, isRegex);
}
function getObjectsByNameDescendants(object, name, isRegex = false) {
  return ObjectUtils.getObjectsByNameDescendantsBreadth(object, name, isRegex);
}
function getObjectsByNameDescendantsBreadth(object, name, isRegex = false) {
  let objects = ObjectUtils.getDescendantsBreadth(object);
  return ObjectUtils.getObjectsByNameObjects(objects, name, isRegex);
}
function getObjectsByNameDescendantsDepth(object, name, isRegex = false) {
  let objects = ObjectUtils.getDescendantsDepth(object);
  return ObjectUtils.getObjectsByNameObjects(objects, name, isRegex);
}
function getObjectsByNameChildren(object, name, isRegex = false) {
  let objects = ObjectUtils.getChildren(object);
  return ObjectUtils.getObjectsByNameObjects(objects, name, isRegex);
}
function getObjectByID(object, id) {
  return ObjectUtils.getObjectByIDHierarchy(object, id);
}
function getObjectByIDHierarchy(object, id) {
  return ObjectUtils.getObjectByIDHierarchyBreadth(object, id);
}
function getObjectByIDHierarchyBreadth(object, id) {
  let objects = ObjectUtils.getHierarchyBreadth(object);
  return ObjectUtils.getObjectByIDObjects(objects, id);
}
function getObjectByIDHierarchyDepth(object, id) {
  let objects = ObjectUtils.getHierarchyDepth(object);
  return ObjectUtils.getObjectByIDObjects(objects, id);
}
function getObjectByIDDescendants(object, id) {
  return ObjectUtils.getObjectByIDDescendantsBreadth(object, id);
}
function getObjectByIDDescendantsBreadth(object, id) {
  let objects = ObjectUtils.getDescendantsBreadth(object);
  return ObjectUtils.getObjectByIDObjects(objects, id);
}
function getObjectByIDDescendantsDepth(object, id) {
  let objects = ObjectUtils.getDescendantsDepth(object);
  return ObjectUtils.getObjectByIDObjects(objects, id);
}
function getObjectByIDChildren(object, id) {
  let objects = ObjectUtils.getChildren(object);
  return ObjectUtils.getObjectByIDObjects(objects, id);
}
function getHierarchy(object) {
  return ObjectUtils.getHierarchyBreadth(object);
}
function getHierarchyBreadth(object) {
  let hierarchy = ObjectUtils.getDescendantsBreadth(object);
  hierarchy.unshift(object);
  return hierarchy;
}
function getHierarchyDepth(object) {
  let hierarchy = ObjectUtils.getDescendantsDepth(object);
  hierarchy.unshift(object);
  return hierarchy;
}
function getDescendants(object) {
  return ObjectUtils.getDescendantsBreadth(object);
}
function getDescendantsBreadth(object) {
  let descendants = [];
  let descendantsQueue = ObjectUtils.getChildren(object);
  while (descendantsQueue.length > 0) {
    let descendant = descendantsQueue.shift();
    descendants.push(descendant);
    for (let child of ObjectUtils.getChildren(descendant)) {
      descendantsQueue.push(child);
    }
  }
  return descendants;
}
function getDescendantsDepth(object) {
  let descendants = [];
  let children = ObjectUtils.getChildren(object);
  for (let child of children) {
    descendants.push(child);
    let childDescendants = ObjectUtils.getDescendantsDepth(child);
    for (let i = 0; i < childDescendants.length; i++) {
      descendants.push(childDescendants[i]);
    }
  }
  return descendants;
}
function getChildren(object) {
  return object.children;
}
function getSelf(object) {
  return object;
}
function addObject(object) {
  return Globals.getScene(ObjectUtils.getEngine(object)).addObject(object);
}
function getName(object) {
  return object.name;
}
function setName(object, name) {
  object.name = name;
}
function getEngine(object) {
  return object.engine;
}
function getID(object) {
  return object.objectId;
}
function markDirty(object) {
  return object.setDirty();
}
function isTransformChanged(object) {
  return object.changed;
}
function equals10(object, otherObject) {
  return object.equals(otherObject);
}
function destroy(object) {
  let destroyReturnValue = void 0;
  try {
    destroyReturnValue = object.destroy();
  } catch (error3) {
  }
  return destroyReturnValue;
}
function reserveObjects(object, count) {
  ObjectUtils.reserveObjectsHierarchy(object, count);
}
function reserveObjectsSelf(object, count) {
  let componentsAmountMap = ObjectUtils.getComponentsAmountMapSelf(object);
  _reserveObjects(count, componentsAmountMap, Globals.getScene(ObjectUtils.getEngine(object)));
}
function reserveObjectsHierarchy(object, count) {
  let componentsAmountMap = ObjectUtils.getComponentsAmountMapHierarchy(object);
  _reserveObjects(count, componentsAmountMap, Globals.getScene(ObjectUtils.getEngine(object)));
}
function reserveObjectsDescendants(object, count) {
  let componentsAmountMap = ObjectUtils.getComponentsAmountMapDescendants(object);
  _reserveObjects(count, componentsAmountMap, Globals.getScene(ObjectUtils.getEngine(object)));
}
function reserveObjectsChildren(object, count) {
  let componentsAmountMap = ObjectUtils.getComponentsAmountMapChildren(object);
  _reserveObjects(count, componentsAmountMap, Globals.getScene(ObjectUtils.getEngine(object)));
}
function getComponentsAmountMap(object, amountMap = /* @__PURE__ */ new Map()) {
  return ObjectUtils.getComponentsAmountMapHierarchy(object, amountMap);
}
function getComponentsAmountMapSelf(object, amountMap = /* @__PURE__ */ new Map()) {
  let objectsAmount = amountMap.get("object");
  if (objectsAmount == null) {
    objectsAmount = 0;
  }
  objectsAmount += 1;
  amountMap.set("object", objectsAmount);
  let components = ObjectUtils.getComponentsSelf(object);
  for (let component of components) {
    let type = component.type;
    let typeAmount = amountMap.get(type);
    if (typeAmount == null) {
      typeAmount = 0;
    }
    typeAmount += 1;
    amountMap.set(type, typeAmount);
  }
  return amountMap;
}
function getComponentsAmountMapHierarchy(object, amountMap = /* @__PURE__ */ new Map()) {
  let hierarchy = ObjectUtils.getHierarchy(object);
  for (let hierarchyObject of hierarchy) {
    ObjectUtils.getComponentsAmountMapSelf(hierarchyObject, amountMap);
  }
  return amountMap;
}
function getComponentsAmountMapDescendants(object, amountMap = /* @__PURE__ */ new Map()) {
  let descendants = ObjectUtils.getDescendants(object);
  for (let descendant of descendants) {
    ObjectUtils.getComponentsAmountMapSelf(descendant, amountMap);
  }
  return amountMap;
}
function getComponentsAmountMapChildren(object, amountMap = /* @__PURE__ */ new Map()) {
  let children = ObjectUtils.getChildren(object);
  for (let child of children) {
    ObjectUtils.getComponentsAmountMapSelf(child, amountMap);
  }
  return amountMap;
}
function getComponentObjects(objects, typeOrClass, index = 0) {
  let component = null;
  for (let object of objects) {
    component = object.getComponent(typeOrClass, index);
    if (component != null) {
      break;
    }
  }
  return component;
}
function getComponentsObjects(objects, typeOrClass) {
  let components = [];
  for (let currentObject of objects) {
    let currentObjectComponents = currentObject.getComponents(typeOrClass);
    for (let i = 0; i < currentObjectComponents.length; i++) {
      components.push(currentObjectComponents[i]);
    }
  }
  return components;
}
function setActiveObjects(objects, active) {
  for (let currentObject of objects) {
    currentObject.active = active;
  }
}
function getObjectByNameObjects(objects, name, isRegex = false, index = 0) {
  let objectFound = null;
  let currentIndex = index;
  for (let currentObject of objects) {
    let objectName = ObjectUtils.getName(currentObject);
    if (!isRegex && objectName == name || isRegex && objectName.match(name) != null) {
      if (currentIndex == 0) {
        objectFound = currentObject;
        break;
      }
      currentIndex--;
    }
  }
  return objectFound;
}
function getObjectsByNameObjects(objects, name, isRegex = false) {
  let objectsFound = [];
  for (let currentObject of objects) {
    let objectName = ObjectUtils.getName(currentObject);
    if (!isRegex && objectName == name || isRegex && objectName.match(name) != null) {
      objectsFound.push(currentObject);
    }
  }
  return objectsFound;
}
function getObjectByIDObjects(objects, id, index = 0) {
  let objectFound = null;
  let currentIndex = index;
  for (let currentObject of objects) {
    if (ObjectUtils.getID(currentObject) == id) {
      if (currentIndex == 0) {
        objectFound = currentObject;
        break;
      }
      currentIndex--;
    }
  }
  return objectFound;
}
function getObjectsByIDObjects(objects, id) {
  let objectsFound = [];
  for (let currentObject of objects) {
    if (ObjectUtils.getID(currentObject) == id) {
      objectsFound.push(currentObject);
    }
  }
  return objectsFound;
}
function wrapObject(id, engine2 = Globals.getMainEngine()) {
  return engine2.wrapObject(id);
}
var ObjectUtils = {
  getPosition: getPosition3,
  getPositionWorld,
  getPositionLocal,
  getRotation: getRotation4,
  getRotationDegrees: getRotationDegrees3,
  getRotationRadians: getRotationRadians3,
  getRotationMatrix,
  getRotationQuat: getRotationQuat3,
  getRotationWorld,
  getRotationWorldDegrees,
  getRotationWorldRadians,
  getRotationWorldMatrix,
  getRotationWorldQuat,
  getRotationLocal,
  getRotationLocalDegrees,
  getRotationLocalRadians,
  getRotationLocalMatrix,
  getRotationLocalQuat,
  getScale: getScale2,
  getScaleWorld,
  getScaleLocal,
  getTransform,
  getTransformMatrix,
  getTransformQuat,
  getTransformWorld,
  getTransformWorldMatrix,
  getTransformWorldQuat,
  getTransformLocal,
  getTransformLocalMatrix,
  getTransformLocalQuat,
  getAxes: getAxes4,
  getAxesWorld,
  getAxesLocal,
  getForward: getForward4,
  getForwardWorld,
  getForwardLocal,
  getBackward: getBackward4,
  getBackwardWorld,
  getBackwardLocal,
  getUp: getUp4,
  getUpWorld,
  getUpLocal,
  getDown: getDown4,
  getDownWorld,
  getDownLocal,
  getLeft: getLeft4,
  getLeftWorld,
  getLeftLocal,
  getRight: getRight4,
  getRightWorld,
  getRightLocal,
  setPosition: setPosition3,
  setPositionWorld,
  setPositionLocal,
  setRotation: setRotation3,
  setRotationDegrees: setRotationDegrees3,
  setRotationRadians: setRotationRadians3,
  setRotationMatrix,
  setRotationQuat: setRotationQuat3,
  setRotationWorld,
  setRotationWorldDegrees,
  setRotationWorldRadians,
  setRotationWorldMatrix,
  setRotationWorldQuat,
  setRotationLocal,
  setRotationLocalDegrees,
  setRotationLocalRadians,
  setRotationLocalMatrix,
  setRotationLocalQuat,
  setScale: setScale2,
  setScaleWorld,
  setScaleLocal,
  setAxes: setAxes3,
  setAxesWorld,
  setAxesLocal,
  setForward: setForward2,
  setForwardWorld,
  setForwardLocal,
  setBackward: setBackward2,
  setBackwardWorld,
  setBackwardLocal,
  setUp: setUp2,
  setUpWorld,
  setUpLocal,
  setDown: setDown2,
  setDownWorld,
  setDownLocal,
  setLeft: setLeft2,
  setLeftWorld,
  setLeftLocal,
  setRight: setRight2,
  setRightWorld,
  setRightLocal,
  setTransform,
  setTransformMatrix,
  setTransformQuat,
  setTransformWorld,
  setTransformWorldMatrix,
  setTransformWorldQuat,
  setTransformLocal,
  setTransformLocalMatrix,
  setTransformLocalQuat,
  resetPosition,
  resetPositionWorld,
  resetPositionLocal,
  resetRotation,
  resetRotationWorld,
  resetRotationLocal,
  resetScale,
  resetScaleWorld,
  resetScaleLocal,
  resetTransform,
  resetTransformWorld,
  resetTransformLocal,
  translate: translate4,
  translateWorld,
  translateLocal,
  translateObject,
  translateAxis,
  translateAxisWorld,
  translateAxisLocal,
  translateAxisObject,
  rotate: rotate6,
  rotateDegrees: rotateDegrees3,
  rotateRadians: rotateRadians3,
  rotateMatrix,
  rotateQuat: rotateQuat3,
  rotateWorld,
  rotateWorldDegrees,
  rotateWorldRadians,
  rotateWorldMatrix,
  rotateWorldQuat,
  rotateLocal,
  rotateLocalDegrees,
  rotateLocalRadians,
  rotateLocalMatrix,
  rotateLocalQuat,
  rotateObject,
  rotateObjectDegrees,
  rotateObjectRadians,
  rotateObjectMatrix,
  rotateObjectQuat,
  rotateAxis: rotateAxis4,
  rotateAxisDegrees: rotateAxisDegrees4,
  rotateAxisRadians: rotateAxisRadians4,
  rotateAxisWorld,
  rotateAxisWorldDegrees,
  rotateAxisWorldRadians,
  rotateAxisLocal,
  rotateAxisLocalDegrees,
  rotateAxisLocalRadians,
  rotateAxisObject,
  rotateAxisObjectDegrees,
  rotateAxisObjectRadians,
  rotateAround: rotateAround2,
  rotateAroundDegrees: rotateAroundDegrees2,
  rotateAroundRadians: rotateAroundRadians2,
  rotateAroundMatrix,
  rotateAroundQuat: rotateAroundQuat2,
  rotateAroundWorld,
  rotateAroundWorldDegrees,
  rotateAroundWorldRadians,
  rotateAroundWorldMatrix,
  rotateAroundWorldQuat,
  rotateAroundLocal,
  rotateAroundLocalDegrees,
  rotateAroundLocalRadians,
  rotateAroundLocalMatrix,
  rotateAroundLocalQuat,
  rotateAroundObject,
  rotateAroundObjectDegrees,
  rotateAroundObjectRadians,
  rotateAroundObjectMatrix,
  rotateAroundObjectQuat,
  rotateAroundAxis: rotateAroundAxis3,
  rotateAroundAxisDegrees: rotateAroundAxisDegrees2,
  rotateAroundAxisRadians: rotateAroundAxisRadians2,
  rotateAroundAxisWorld,
  rotateAroundAxisWorldDegrees,
  rotateAroundAxisWorldRadians,
  rotateAroundAxisLocal,
  rotateAroundAxisLocalDegrees,
  rotateAroundAxisLocalRadians,
  rotateAroundAxisObject,
  rotateAroundAxisObjectDegrees,
  rotateAroundAxisObjectRadians,
  scaleObject,
  lookAt: lookAt2,
  lookAtWorld,
  lookAtLocal,
  lookTo,
  lookToWorld,
  lookToLocal,
  setParent,
  getParent,
  convertPositionObjectToWorld,
  convertDirectionObjectToWorld,
  convertPositionWorldToObject,
  convertDirectionWorldToObject,
  convertPositionLocalToWorld,
  convertDirectionLocalToWorld,
  convertPositionWorldToLocal,
  convertDirectionWorldToLocal,
  convertPositionObjectToLocal,
  convertDirectionObjectToLocal,
  convertPositionLocalToObject,
  convertDirectionLocalToObject,
  convertTransformObjectToWorld,
  convertTransformObjectToWorldMatrix,
  convertTransformObjectToWorldQuat,
  convertTransformWorldToObject,
  convertTransformWorldToObjectMatrix,
  convertTransformWorldToObjectQuat,
  convertTransformLocalToWorld,
  convertTransformLocalToWorldMatrix,
  convertTransformLocalToWorldQuat,
  convertTransformWorldToLocal,
  convertTransformWorldToLocalMatrix,
  convertTransformWorldToLocalQuat,
  convertTransformObjectToLocal,
  convertTransformObjectToLocalMatrix,
  convertTransformObjectToLocalQuat,
  convertTransformLocalToObject,
  convertTransformLocalToObjectMatrix,
  convertTransformLocalToObjectQuat,
  addComponent,
  getComponent,
  getComponentSelf,
  getComponentHierarchy,
  getComponentHierarchyBreadth,
  getComponentHierarchyDepth,
  getComponentDescendants,
  getComponentDescendantsBreadth,
  getComponentDescendantsDepth,
  getComponentChildren,
  getComponents,
  getComponentsSelf,
  getComponentsHierarchy,
  getComponentsHierarchyBreadth,
  getComponentsHierarchyDepth,
  getComponentsDescendants,
  getComponentsDescendantsBreadth,
  getComponentsDescendantsDepth,
  getComponentsChildren,
  setActive,
  setActiveSelf,
  setActiveHierarchy,
  setActiveHierarchyBreadth,
  setActiveHierarchyDepth,
  setActiveDescendants,
  setActiveDescendantsBreadth,
  setActiveDescendantsDepth,
  setActiveChildren,
  hasUniformScale: hasUniformScale2,
  hasUniformScaleWorld,
  hasUniformScaleLocal,
  clone: clone12,
  isCloneable,
  toString,
  toStringExtended,
  toStringCompact,
  getObjectByName,
  getObjectByNameHierarchy,
  getObjectByNameHierarchyBreadth,
  getObjectByNameHierarchyDepth,
  getObjectByNameDescendants,
  getObjectByNameDescendantsBreadth,
  getObjectByNameDescendantsDepth,
  getObjectByNameChildren,
  getObjectsByName,
  getObjectsByNameHierarchy,
  getObjectsByNameHierarchyBreadth,
  getObjectsByNameHierarchyDepth,
  getObjectsByNameDescendants,
  getObjectsByNameDescendantsBreadth,
  getObjectsByNameDescendantsDepth,
  getObjectsByNameChildren,
  getObjectByID,
  getObjectByIDHierarchy,
  getObjectByIDHierarchyBreadth,
  getObjectByIDHierarchyDepth,
  getObjectByIDDescendants,
  getObjectByIDDescendantsBreadth,
  getObjectByIDDescendantsDepth,
  getObjectByIDChildren,
  getHierarchy,
  getHierarchyBreadth,
  getHierarchyDepth,
  getDescendants,
  getDescendantsBreadth,
  getDescendantsDepth,
  getChildren,
  getSelf,
  addObject,
  getName,
  setName,
  getEngine,
  getID,
  markDirty,
  isTransformChanged,
  equals: equals10,
  destroy,
  reserveObjects,
  reserveObjectsSelf,
  reserveObjectsHierarchy,
  reserveObjectsDescendants,
  reserveObjectsChildren,
  getComponentsAmountMap,
  getComponentsAmountMapSelf,
  getComponentsAmountMapHierarchy,
  getComponentsAmountMapDescendants,
  getComponentsAmountMapChildren,
  getComponentObjects,
  getComponentsObjects,
  setActiveObjects,
  getObjectByNameObjects,
  getObjectsByNameObjects,
  getObjectByIDObjects,
  getObjectsByIDObjects,
  wrapObject
};
function _reserveObjects(count, componentsAmountMap, scene) {
  let objectsToReserve = componentsAmountMap.get("object") * count;
  componentsAmountMap.delete("object");
  let componentsToReserve = {};
  for (let [componentName, componentCount] of componentsAmountMap.entries()) {
    componentsToReserve[componentName] = componentCount * count;
  }
  scene.reserveObjects(objectsToReserve, componentsToReserve);
}

// js/pp/cauldron/wl/utils/scene_utils.js
function getRoot(scene) {
  return ObjectUtils.wrapObject(0, scene.engine);
}
function addObject2(scene) {
  return ObjectUtils.addObject(SceneUtils.getRoot(scene));
}
function getObjects(scene) {
  return SceneUtils.getObjectsBreadth(scene);
}
function getObjectsBreadth(scene) {
  return ObjectUtils.getHierarchyBreadth(SceneUtils.getRoot(scene));
}
function getObjectsDepth(scene) {
  return ObjectUtils.getHierarchyDepth(SceneUtils.getRoot(scene));
}
function getComponent2(scene, typeOrClass, index = 0) {
  return SceneUtils.getComponentBreadth(scene, typeOrClass, index);
}
function getComponentBreadth(scene, typeOrClass, index = 0) {
  return ObjectUtils.getComponentHierarchyBreadth(SceneUtils.getRoot(scene), typeOrClass, index);
}
function getComponentDepth(scene, typeOrClass, index = 0) {
  return ObjectUtils.getComponentHierarchyDepth(SceneUtils.getRoot(scene), typeOrClass, index);
}
function getComponents2(scene, typeOrClass) {
  return SceneUtils.getComponentsBreadth(scene, typeOrClass);
}
function getComponentsBreadth(scene, typeOrClass) {
  return ObjectUtils.getComponentsHierarchyBreadth(SceneUtils.getRoot(scene), typeOrClass);
}
function getComponentsDepth(scene, typeOrClass) {
  return ObjectUtils.getComponentsHierarchyDepth(SceneUtils.getRoot(scene), typeOrClass);
}
function getObjectByName2(scene, name, isRegex = false, index = 0) {
  return SceneUtils.getObjectByNameBreadth(scene, name, isRegex, index);
}
function getObjectByNameBreadth(scene, name, isRegex = false, index = 0) {
  return ObjectUtils.getObjectByNameHierarchyBreadth(SceneUtils.getRoot(scene), name, isRegex, index);
}
function getObjectByNameDepth(scene, name, isRegex = false, index = 0) {
  return ObjectUtils.getObjectByNameHierarchyDepth(SceneUtils.getRoot(scene), name, isRegex, index);
}
function getObjectsByName2(scene, name, isRegex = false) {
  return SceneUtils.getObjectsByNameBreadth(scene, name, isRegex);
}
function getObjectsByNameBreadth(scene, name, isRegex = false) {
  return ObjectUtils.getObjectsByNameHierarchyBreadth(SceneUtils.getRoot(scene), name, isRegex);
}
function getObjectsByNameDepth(scene, name, isRegex = false) {
  return ObjectUtils.getObjectsByNameHierarchyDepth(SceneUtils.getRoot(scene), name, isRegex);
}
function getObjectByID2(scene, id) {
  return SceneUtils.getObjectByIDBreadth(scene, id);
}
function getObjectByIDBreadth(scene, id) {
  return ObjectUtils.getObjectByIDHierarchyBreadth(SceneUtils.getRoot(scene), id);
}
function getObjectByIDDepth(scene, id) {
  return ObjectUtils.getObjectByIDHierarchyDepth(SceneUtils.getRoot(scene), id);
}
function toString2(scene) {
  return SceneUtils.toStringCompact(scene);
}
function toStringCompact2(scene) {
  return ObjectUtils.toStringCompact(SceneUtils.getRoot(scene));
}
function toStringExtended2(scene) {
  return ObjectUtils.toStringExtended(SceneUtils.getRoot(scene));
}
function getComponentsAmountMap2(scene, amountMap = /* @__PURE__ */ new Map()) {
  return ObjectUtils.getComponentsAmountMap(SceneUtils.getRoot(scene), amountMap);
}
var SceneUtils = {
  getRoot,
  addObject: addObject2,
  getObjects,
  getObjectsBreadth,
  getObjectsDepth,
  getComponent: getComponent2,
  getComponentBreadth,
  getComponentDepth,
  getComponents: getComponents2,
  getComponentsBreadth,
  getComponentsDepth,
  getObjectByName: getObjectByName2,
  getObjectByNameBreadth,
  getObjectByNameDepth,
  getObjectsByName: getObjectsByName2,
  getObjectsByNameBreadth,
  getObjectsByNameDepth,
  getObjectByID: getObjectByID2,
  getObjectByIDBreadth,
  getObjectByIDDepth,
  toString: toString2,
  toStringCompact: toStringCompact2,
  toStringExtended: toStringExtended2,
  getComponentsAmountMap: getComponentsAmountMap2
};

// js/pp/cauldron/wl/engine_globals.js
var _myMainEngine = null;
var _myEngines = [];
function initEngine(engine2) {
  if (engine2 != null) {
    addEngine(engine2);
    if (getMainEngine() == null) {
      setMainEngine(engine2);
    }
  }
}
function getMainEngine() {
  return _myMainEngine;
}
function setMainEngine(engine2) {
  if (hasEngine(engine2)) {
    _myMainEngine = engine2;
  }
}
function removeMainEngine() {
  _myMainEngine = null;
}
function getEngines() {
  return _myEngines;
}
function addEngine(engine2) {
  removeEngine(engine2);
  _myEngines.push(engine2);
}
function removeEngine(engine2) {
  let index = _myEngines.indexOf(engine2);
  if (index >= 0) {
    _myEngines.splice(index, 1);
    if (getMainEngine() == engine2) {
      removeMainEngine();
    }
  }
}
function hasEngine(engine2) {
  return _myEngines.indexOf(engine2) >= 0;
}
function getScene(engine2 = getMainEngine()) {
  let scene = null;
  if (engine2 != null) {
    scene = engine2.scene;
  }
  return scene;
}
function getRoot2(engine2 = getMainEngine()) {
  let root = null;
  let scene = getScene(engine2);
  if (scene != null) {
    root = SceneUtils.getRoot(scene);
  }
  return root;
}
function getPhysics(engine2 = getMainEngine()) {
  let physics = null;
  if (engine2 != null) {
    physics = engine2.physics;
  }
  return physics;
}
function getCanvas(engine2 = getMainEngine()) {
  let canvas2 = null;
  if (engine2 != null) {
    canvas2 = engine2.canvas;
  }
  return canvas2;
}
function getWASM(engine2 = getMainEngine()) {
  let wasm = null;
  if (engine2 != null) {
    wasm = engine2.wasm;
  }
  return wasm;
}
function getXR(engine2 = getMainEngine()) {
  let xr = null;
  if (engine2 != null) {
    xr = engine2.xr;
  }
  return xr;
}

// js/pp/debug/debug_globals.js
var debug_globals_exports = {};
__export(debug_globals_exports, {
  getDebugManager: () => getDebugManager,
  getDebugVisualManager: () => getDebugVisualManager,
  hasDebugEnabled: () => hasDebugEnabled,
  hasDebugManager: () => hasDebugManager,
  isDebugEnabled: () => isDebugEnabled,
  removeDebugEnabled: () => removeDebugEnabled,
  removeDebugManager: () => removeDebugManager,
  setDebugEnabled: () => setDebugEnabled,
  setDebugManager: () => setDebugManager
});
var _myDebugManagers = /* @__PURE__ */ new WeakMap();
var _myDebugEnableds = /* @__PURE__ */ new WeakMap();
function getDebugManager(engine2 = Globals.getMainEngine()) {
  return _myDebugManagers.get(engine2);
}
function setDebugManager(debugManager, engine2 = Globals.getMainEngine()) {
  _myDebugManagers.set(engine2, debugManager);
}
function removeDebugManager(engine2 = Globals.getMainEngine()) {
  _myDebugManagers.delete(engine2);
}
function hasDebugManager(engine2 = Globals.getMainEngine()) {
  return _myDebugManagers.has(engine2);
}
function getDebugVisualManager(engine2 = Globals.getMainEngine()) {
  let debugManager = getDebugManager(engine2);
  if (debugManager != null) {
    return debugManager.getDebugVisualManager();
  }
  return null;
}
function isDebugEnabled(engine2 = Globals.getMainEngine()) {
  return _myDebugEnableds.get(engine2);
}
function setDebugEnabled(debugEnabled, engine2 = Globals.getMainEngine()) {
  _myDebugEnableds.set(engine2, debugEnabled);
}
function removeDebugEnabled(engine2 = Globals.getMainEngine()) {
  _myDebugEnableds.delete(engine2);
}
function hasDebugEnabled(engine2 = Globals.getMainEngine()) {
  return _myDebugEnableds.has(engine2);
}

// js/pp/gameplay/experimental/character_controller/collision/character_collision_system_globals.js
var character_collision_system_globals_exports = {};
__export(character_collision_system_globals_exports, {
  getCharacterCollisionSystem: () => getCharacterCollisionSystem,
  hasCharacterCollisionSystem: () => hasCharacterCollisionSystem,
  removeCharacterCollisionSystem: () => removeCharacterCollisionSystem,
  setCharacterCollisionSystem: () => setCharacterCollisionSystem
});
var _myCharacterCollisionSystems = /* @__PURE__ */ new WeakMap();
function getCharacterCollisionSystem(engine2 = Globals.getMainEngine()) {
  return _myCharacterCollisionSystems.get(engine2);
}
function setCharacterCollisionSystem(characterCollisionSystem, engine2 = Globals.getMainEngine()) {
  _myCharacterCollisionSystems.set(engine2, characterCollisionSystem);
}
function removeCharacterCollisionSystem(engine2 = Globals.getMainEngine()) {
  _myCharacterCollisionSystems.delete(engine2);
}
function hasCharacterCollisionSystem(engine2 = Globals.getMainEngine()) {
  return _myCharacterCollisionSystems.has(engine2);
}

// js/pp/input/cauldron/input_globals.js
var input_globals_exports = {};
__export(input_globals_exports, {
  getGamepad: () => getGamepad,
  getGamepads: () => getGamepads,
  getGamepadsManager: () => getGamepadsManager,
  getHandPose: () => getHandPose,
  getHandPoses: () => getHandPoses,
  getHeadPose: () => getHeadPose,
  getInputManager: () => getInputManager,
  getKeyboard: () => getKeyboard,
  getLeftGamepad: () => getLeftGamepad,
  getLeftHandPose: () => getLeftHandPose,
  getLeftTrackedHandPose: () => getLeftTrackedHandPose,
  getMouse: () => getMouse,
  getRightGamepad: () => getRightGamepad,
  getRightHandPose: () => getRightHandPose,
  getRightTrackedHandPose: () => getRightTrackedHandPose,
  getTrackedHandPose: () => getTrackedHandPose,
  getTrackedHandPoses: () => getTrackedHandPoses,
  hasInputManager: () => hasInputManager,
  hasPoseForwardFixed: () => hasPoseForwardFixed,
  isPoseForwardFixed: () => isPoseForwardFixed,
  removeInputManager: () => removeInputManager,
  removePoseForwardFixed: () => removePoseForwardFixed,
  setInputManager: () => setInputManager,
  setPoseForwardFixed: () => setPoseForwardFixed
});
var _myInputManagers = /* @__PURE__ */ new WeakMap();
var _myPoseForwardFixeds = /* @__PURE__ */ new WeakMap();
function getInputManager(engine2 = Globals.getMainEngine()) {
  return _myInputManagers.get(engine2);
}
function setInputManager(inputManager, engine2 = Globals.getMainEngine()) {
  _myInputManagers.set(engine2, inputManager);
}
function removeInputManager(engine2 = Globals.getMainEngine()) {
  _myInputManagers.delete(engine2);
}
function hasInputManager(engine2 = Globals.getMainEngine()) {
  return _myInputManagers.has(engine2);
}
function getMouse(engine2 = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine2);
  if (inputManager != null) {
    return inputManager.getMouse();
  }
  return null;
}
function getKeyboard(engine2 = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine2);
  if (inputManager != null) {
    return inputManager.getKeyboard();
  }
  return null;
}
function getGamepadsManager(engine2 = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine2);
  if (inputManager != null) {
    return inputManager.getGamepadsManager();
  }
  return null;
}
function getGamepad(handedness, engine2 = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine2);
  if (inputManager != null) {
    return inputManager.getGamepadsManager().getGamepad(handedness);
  }
  return null;
}
function getGamepads(engine2 = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine2);
  if (inputManager != null) {
    return inputManager.getGamepadsManager().getGamepads();
  }
  return null;
}
function getLeftGamepad(engine2 = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine2);
  if (inputManager != null) {
    return inputManager.getGamepadsManager().getLeftGamepad();
  }
  return null;
}
function getRightGamepad(engine2 = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine2);
  if (inputManager != null) {
    return inputManager.getGamepadsManager().getRightGamepad();
  }
  return null;
}
function getHeadPose(engine2 = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine2);
  if (inputManager != null) {
    return inputManager.getHeadPose();
  }
  return null;
}
function getHandPose(handedness, engine2 = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine2);
  if (inputManager != null) {
    return inputManager.getHandPose(handedness);
  }
  return null;
}
function getHandPoses(engine2 = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine2);
  if (inputManager != null) {
    return inputManager.getHandPoses();
  }
  return null;
}
function getLeftHandPose(engine2 = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine2);
  if (inputManager != null) {
    return inputManager.getLeftHandPose();
  }
  return null;
}
function getRightHandPose(engine2 = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine2);
  if (inputManager != null) {
    return inputManager.getRightHandPose();
  }
  return null;
}
function getTrackedHandPose(handedness, engine2 = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine2);
  if (inputManager != null) {
    return inputManager.getTrackedHandPose(handedness);
  }
  return null;
}
function getTrackedHandPoses(engine2 = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine2);
  if (inputManager != null) {
    return inputManager.getTrackedHandPoses();
  }
  return null;
}
function getLeftTrackedHandPose(engine2 = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine2);
  if (inputManager != null) {
    return inputManager.getLeftTrackedHandPose();
  }
  return null;
}
function getRightTrackedHandPose(engine2 = Globals.getMainEngine()) {
  let inputManager = getInputManager(engine2);
  if (inputManager != null) {
    return inputManager.getRightTrackedHandPose();
  }
  return null;
}
function isPoseForwardFixed(engine2 = Globals.getMainEngine()) {
  return _myPoseForwardFixeds.get(engine2);
}
function setPoseForwardFixed(toolEnabled, engine2 = Globals.getMainEngine()) {
  _myPoseForwardFixeds.set(engine2, toolEnabled);
}
function removePoseForwardFixed(engine2 = Globals.getMainEngine()) {
  _myPoseForwardFixeds.delete(engine2);
}
function hasPoseForwardFixed(engine2 = Globals.getMainEngine()) {
  return _myPoseForwardFixeds.has(engine2);
}

// js/pp/tool/cauldron/tool_globals.js
var tool_globals_exports = {};
__export(tool_globals_exports, {
  hasToolEnabled: () => hasToolEnabled,
  isToolEnabled: () => isToolEnabled,
  removeToolEnabled: () => removeToolEnabled,
  setToolEnabled: () => setToolEnabled
});
var _myToolEnableds = /* @__PURE__ */ new WeakMap();
function isToolEnabled(engine2 = Globals.getMainEngine()) {
  return _myToolEnableds.get(engine2);
}
function setToolEnabled(toolEnabled, engine2 = Globals.getMainEngine()) {
  _myToolEnableds.set(engine2, toolEnabled);
}
function removeToolEnabled(engine2 = Globals.getMainEngine()) {
  _myToolEnableds.delete(engine2);
}
function hasToolEnabled(engine2 = Globals.getMainEngine()) {
  return _myToolEnableds.has(engine2);
}

// js/pp/tool/console_vr/console_vr_globals.js
var console_vr_globals_exports = {};
__export(console_vr_globals_exports, {
  getConsoleVR: () => getConsoleVR,
  hasConsoleVR: () => hasConsoleVR,
  removeConsoleVR: () => removeConsoleVR,
  setConsoleVR: () => setConsoleVR
});
var _myConsoleVRs = /* @__PURE__ */ new WeakMap();
function getConsoleVR(engine2 = Globals.getMainEngine()) {
  return _myConsoleVRs.get(engine2);
}
function setConsoleVR(consoleVR, engine2 = Globals.getMainEngine()) {
  _myConsoleVRs.set(engine2, consoleVR);
}
function removeConsoleVR(engine2 = Globals.getMainEngine()) {
  _myConsoleVRs.delete(engine2);
}
function hasConsoleVR(engine2 = Globals.getMainEngine()) {
  return _myConsoleVRs.has(engine2);
}

// js/pp/tool/easy_tune/easy_tune_globals.js
var easy_tune_globals_exports = {};
__export(easy_tune_globals_exports, {
  getEasyTuneTarget: () => getEasyTuneTarget,
  getEasyTuneVariables: () => getEasyTuneVariables,
  hasEasyTuneTarget: () => hasEasyTuneTarget,
  hasEasyTuneVariables: () => hasEasyTuneVariables,
  removeEasyTuneTarget: () => removeEasyTuneTarget,
  removeEasyTuneVariables: () => removeEasyTuneVariables,
  setEasyTuneTarget: () => setEasyTuneTarget,
  setEasyTuneVariables: () => setEasyTuneVariables
});
var _myEasyTuneVariablesList = /* @__PURE__ */ new WeakMap();
var _myEasyTuneTargets = /* @__PURE__ */ new WeakMap();
function getEasyTuneVariables(engine2 = Globals.getMainEngine()) {
  return _myEasyTuneVariablesList.get(engine2);
}
function setEasyTuneVariables(easyTuneVariables, engine2 = Globals.getMainEngine()) {
  _myEasyTuneVariablesList.set(engine2, easyTuneVariables);
}
function removeEasyTuneVariables(engine2 = Globals.getMainEngine()) {
  _myEasyTuneVariablesList.delete(engine2);
}
function hasEasyTuneVariables(engine2 = Globals.getMainEngine()) {
  return _myEasyTuneVariablesList.has(engine2);
}
function getEasyTuneTarget(engine2 = Globals.getMainEngine()) {
  return _myEasyTuneTargets.get(engine2);
}
function setEasyTuneTarget(easyTuneTarget, engine2 = Globals.getMainEngine()) {
  _myEasyTuneTargets.set(engine2, easyTuneTarget);
}
function removeEasyTuneTarget(engine2 = Globals.getMainEngine()) {
  _myEasyTuneTargets.delete(engine2);
}
function hasEasyTuneTarget(engine2 = Globals.getMainEngine()) {
  return _myEasyTuneTargets.has(engine2);
}

// js/pp/pp/default_resources_globals.js
var default_resources_globals_exports = {};
__export(default_resources_globals_exports, {
  getDefaultMaterials: () => getDefaultMaterials,
  getDefaultMeshes: () => getDefaultMeshes,
  getDefaultResources: () => getDefaultResources,
  hasDefaultResources: () => hasDefaultResources,
  removeDefaultResources: () => removeDefaultResources,
  setDefaultResources: () => setDefaultResources
});
var _myDefaultResourcesContainer = /* @__PURE__ */ new WeakMap();
function getDefaultResources(engine2 = Globals.getMainEngine()) {
  return _myDefaultResourcesContainer.get(engine2);
}
function setDefaultResources(defaultResources, engine2 = Globals.getMainEngine()) {
  _myDefaultResourcesContainer.set(engine2, defaultResources);
}
function removeDefaultResources(engine2 = Globals.getMainEngine()) {
  _myDefaultResourcesContainer.delete(engine2);
}
function hasDefaultResources(engine2 = Globals.getMainEngine()) {
  return _myDefaultResourcesContainer.has(engine2);
}
function getDefaultMeshes(engine2 = Globals.getMainEngine()) {
  let defaultResources = getDefaultResources(engine2);
  if (defaultResources != null) {
    return defaultResources.myMeshes;
  }
  return null;
}
function getDefaultMaterials(engine2 = Globals.getMainEngine()) {
  let defaultResources = getDefaultResources(engine2);
  if (defaultResources != null) {
    return defaultResources.myMaterials;
  }
  return null;
}

// js/pp/pp/scene_objects_globals.js
var scene_objects_globals_exports = {};
__export(scene_objects_globals_exports, {
  getPlayerObjects: () => getPlayerObjects,
  getSceneObjects: () => getSceneObjects,
  hasSceneObjects: () => hasSceneObjects,
  removeSceneObjects: () => removeSceneObjects,
  setSceneObjects: () => setSceneObjects
});
var _mySceneObjectsContainer = /* @__PURE__ */ new WeakMap();
function getSceneObjects(engine2 = Globals.getMainEngine()) {
  return _mySceneObjectsContainer.get(engine2);
}
function setSceneObjects(sceneObjects, engine2 = Globals.getMainEngine()) {
  _mySceneObjectsContainer.set(engine2, sceneObjects);
}
function removeSceneObjects(engine2 = Globals.getMainEngine()) {
  _mySceneObjectsContainer.delete(engine2);
}
function hasSceneObjects(engine2 = Globals.getMainEngine()) {
  return _mySceneObjectsContainer.has(engine2);
}
function getPlayerObjects(engine2 = Globals.getMainEngine()) {
  let sceneObjects = getSceneObjects(engine2);
  if (sceneObjects != null) {
    return sceneObjects.myPlayerObjects;
  }
  return null;
}

// js/pp/pp/globals.js
var Globals = {
  ...engine_globals_exports,
  ...scene_objects_globals_exports,
  ...default_resources_globals_exports,
  ...audio_globals_exports,
  ...visual_globals_exports,
  ...debug_globals_exports,
  ...window_globals_exports,
  ...object_pool_globals_exports,
  ...character_collision_system_globals_exports,
  ...input_globals_exports,
  ...tool_globals_exports,
  ...console_vr_globals_exports,
  ...easy_tune_globals_exports
};

// js/pp/cauldron/js/utils/vec2_utils.js
function create13(x, y) {
  let out = vec2_exports.create();
  if (x !== void 0) {
    set13(out, x, y);
  }
  return out;
}
function set13(vector, x, y) {
  if (y === void 0) {
    vec2_exports.set(vector, x, x);
  } else {
    vec2_exports.set(vector, x, y);
  }
  return vector;
}
function length9(vector) {
  return vec2_exports.length(vector);
}
function normalize9(vector, out = create13()) {
  vec2_exports.normalize(out, vector);
  return out;
}
function copy13(from, to) {
  vec2_exports.copy(to, from);
  return to;
}
function clone13(vector, out = create13()) {
  Vec2Utils.copy(vector, out);
  return out;
}
function zero5(vector) {
  vec2_exports.zero(vector);
  return vector;
}
function isZero2(vector, epsilon = 0) {
  return Vec2Utils.length(vector) <= epsilon;
}
var Vec2Utils = {
  create: create13,
  set: set13,
  length: length9,
  normalize: normalize9,
  copy: copy13,
  clone: clone13,
  zero: zero5,
  isZero: isZero2
};

// js/pp/cauldron/js/utils/vec4_utils.js
function create14(x, y, z, w) {
  let out = vec4_exports.create();
  if (x !== void 0) {
    set14(out, x, y, z, w);
  }
  return out;
}
function set14(vector, x, y, z, w) {
  if (y === void 0) {
    vec4_exports.set(vector, x, x, x, x);
  } else {
    vec4_exports.set(vector, x, y, z, w);
  }
  return vector;
}
function copy14(from, to) {
  vec4_exports.copy(to, from);
  return to;
}
function clone14(vector, out = create14()) {
  Vec4Utils.copy(vector, out);
  return out;
}
var Vec4Utils = {
  create: create14,
  set: set14,
  copy: copy14,
  clone: clone14
};

// js/pp/cauldron/js/utils/vec_utils.js
function zero6(vector, out = null) {
  out = _prepareOut(vector, out);
  for (let i = 0; i < out.length; i++) {
    out[i] = 0;
  }
  return out;
}
function isZero3(vector, epsilon = 0) {
  let zero7 = true;
  for (let i = 0; i < vector.length && zero7; i++) {
    zero7 = zero7 && Math.abs(vector[i]) <= epsilon;
  }
  return zero7;
}
function scale10(vector, value, out = null) {
  out = _prepareOut(vector, out);
  for (let i = 0; i < out.length; i++) {
    out[i] = out[i] * value;
  }
  return out;
}
function round4(vector, out = null) {
  out = _prepareOut(vector, out);
  for (let i = 0; i < out.length; i++) {
    out[i] = Math.round(out[i]);
  }
  return out;
}
function floor4(vector, out = null) {
  out = _prepareOut(vector, out);
  for (let i = 0; i < out.length; i++) {
    out[i] = Math.floor(out[i]);
  }
  return out;
}
function ceil4(vector, out = null) {
  out = _prepareOut(vector, out);
  for (let i = 0; i < out.length; i++) {
    out[i] = Math.ceil(out[i]);
  }
  return out;
}
function clamp4(vector, start, end, out = null) {
  out = _prepareOut(vector, out);
  let fixedStart = start != null ? start : -Number.MAX_VALUE;
  let fixedEnd = end != null ? end : Number.MAX_VALUE;
  let min4 = Math.min(fixedStart, fixedEnd);
  let max4 = Math.max(fixedStart, fixedEnd);
  for (let i = 0; i < out.length; i++) {
    out[i] = MathUtils.clamp(out[i], min4, max4);
  }
  return out;
}
function equals11(vector, other, epsilon = 0) {
  let equals12 = vector.length == other.length;
  for (let i = 0; i < vector.length && equals12; i++) {
    equals12 = equals12 && Math.abs(vector[i] - other[i]) <= epsilon;
  }
  return equals12;
}
function toString3(vector, decimalPlaces = null) {
  let message = _buildConsoleMessage(vector, decimalPlaces);
  return message;
}
function log(vector, decimalPlaces = 4) {
  let message = _buildConsoleMessage(vector, decimalPlaces);
  console.log(message);
}
function error(vector, decimalPlaces = 4) {
  let message = _buildConsoleMessage(vector, decimalPlaces);
  console.error(message);
}
function warn(vector, decimalPlaces = 4) {
  let message = _buildConsoleMessage(vector, decimalPlaces);
  console.warn(message);
}
var VecUtils = {
  zero: zero6,
  isZero: isZero3,
  scale: scale10,
  round: round4,
  floor: floor4,
  ceil: ceil4,
  clamp: clamp4,
  equals: equals11,
  toString: toString3,
  log,
  error,
  warn
};
function _buildConsoleMessage(vector, decimalPlaces) {
  let message = "[";
  for (let i = 0; i < vector.length; i++) {
    if (i != 0) {
      message = message.concat(", ");
    }
    if (decimalPlaces != null) {
      message = message.concat(vector[i].toFixed(decimalPlaces));
    } else {
      message = message.concat(vector[i].toString());
    }
  }
  message = message.concat("]");
  return message;
}
function _prepareOut(vector, out) {
  if (out == null) {
    out = ArrayUtils.clone(vector);
  } else if (out != vector) {
    ArrayUtils.copy(vector, out);
  }
  return out;
}

// js/pp/cauldron/js/utils/js_utils.js
function getObjectPrototypes(object) {
  let prototypes = [];
  prototypes.push(object);
  let objectProto = Object.getPrototypeOf(object);
  while (objectProto != null) {
    ArrayUtils.pushUnique(prototypes, objectProto);
    objectProto = Object.getPrototypeOf(objectProto);
  }
  let prototypesToCheck = [object];
  while (prototypesToCheck.length > 0) {
    let prototypeToCheck = prototypesToCheck.shift();
    if (prototypeToCheck != null) {
      ArrayUtils.pushUnique(prototypes, prototypeToCheck);
      ArrayUtils.pushUnique(prototypesToCheck, Object.getPrototypeOf(prototypeToCheck));
      ArrayUtils.pushUnique(prototypesToCheck, prototypeToCheck.prototype);
    }
  }
  return prototypes;
}
function getObjectPropertyNames(object) {
  let propertyNames = [];
  let prototypes = JSUtils.getObjectPrototypes(object);
  for (let prototype of prototypes) {
    if (prototype != null) {
      let ownPropertyNames = Object.getOwnPropertyNames(prototype);
      for (let ownPropertyName of ownPropertyNames) {
        ArrayUtils.pushUnique(propertyNames, ownPropertyName);
      }
    }
  }
  return propertyNames;
}
function getObjectPropertyDescriptor(object, propertyName) {
  let propertyDescriptor = null;
  let propertyParent = JSUtils.getObjectPropertyOwnParent(object, propertyName);
  if (propertyParent != null) {
    propertyDescriptor = Object.getOwnPropertyDescriptor(propertyParent, propertyName);
  }
  return propertyDescriptor;
}
function getObjectProperty(object, propertyName) {
  let property2 = void 0;
  let propertyDescriptor = JSUtils.getObjectPropertyDescriptor(object, propertyName);
  if (propertyDescriptor != null) {
    if (propertyDescriptor.get != null) {
      property2 = propertyDescriptor.get.bind(object)();
    } else {
      property2 = propertyDescriptor.value;
    }
  }
  return property2;
}
function setObjectProperty(valueToSet, object, propertyName) {
  let propertyDescriptor = JSUtils.getObjectPropertyDescriptor(object, propertyName);
  let setUsed = false;
  if (propertyDescriptor != null) {
    if (propertyDescriptor.set != null) {
      setUsed = true;
      propertyDescriptor.set.bind(object)(valueToSet);
    }
  }
  if (!setUsed) {
    let propertyParent = JSUtils.getObjectPropertyOwnParent(object, propertyName);
    if (propertyParent == null) {
      propertyParent = object;
    }
    Object.defineProperty(propertyParent, propertyName, {
      value: valueToSet
    });
  }
}
function getObjectPropertyOwnParent(object, propertyName) {
  let parent = null;
  let parents = JSUtils.getObjectPropertyOwnParents(object, propertyName);
  if (parents.length > 0) {
    parent = parents[0];
  }
  return parent;
}
function getObjectPropertyOwnParents(object, propertyName) {
  let parents = [];
  let possibleParents = JSUtils.getObjectPrototypes(object);
  for (let possibleParent of possibleParents) {
    let propertyNames = Object.getOwnPropertyNames(possibleParent);
    if (ArrayUtils.hasEqual(propertyNames, propertyName)) {
      parents.push(possibleParent);
    }
  }
  return parents;
}
function getObjectFromPath(path, pathStartObject = Globals.getWindow()) {
  let object = null;
  let objectName = JSUtils.getObjectNameFromPath(path);
  if (objectName != null) {
    object = JSUtils.getObjectProperty(JSUtils.getObjectParentFromPath(path, pathStartObject), objectName);
  }
  return object;
}
function getObjectNameFromPath(path) {
  let objectName = null;
  if (path != null) {
    let pathSplit = path.split(".");
    if (pathSplit.length > 0) {
      objectName = pathSplit[pathSplit.length - 1];
    }
  }
  return objectName;
}
function getObjectParentFromPath(path, pathStartObject = Globals.getWindow()) {
  let pathSplit = path.split(".");
  let currentParent = pathStartObject;
  for (let i = 0; i < pathSplit.length - 1; i++) {
    currentParent = JSUtils.getObjectProperty(currentParent, pathSplit[i]);
  }
  return currentParent;
}
function overwriteObjectProperty(newProperty, object, propertyName, overwriteOnOwnParent = true, jsObjectFunctionsSpecialOverwrite = false, logEnabled = false) {
  let success = false;
  try {
    let propertyOwnParent = JSUtils.getObjectPropertyOwnParent(object, propertyName);
    if (propertyOwnParent != null) {
      let originalPropertyDescriptor = Object.getOwnPropertyDescriptor(propertyOwnParent, propertyName);
      if (originalPropertyDescriptor != null) {
        let originalProperty = JSUtils.getObjectProperty(propertyOwnParent, propertyName);
        JSUtils.copyObjectProperties(originalProperty, newProperty, true, jsObjectFunctionsSpecialOverwrite, logEnabled);
        let overwriteTarget = object;
        if (overwriteOnOwnParent) {
          overwriteTarget = propertyOwnParent;
        }
        Object.defineProperty(overwriteTarget, propertyName, {
          value: newProperty,
          enumerable: originalPropertyDescriptor.enumerable,
          writable: originalPropertyDescriptor.writable,
          configurable: originalPropertyDescriptor.configurable
        });
        success = true;
      } else {
        Object.defineProperty(object, propertyName, {
          value: newProperty
        });
        success = true;
      }
    } else {
      Object.defineProperty(object, propertyName, {
        value: newProperty
      });
      success = true;
    }
  } catch (error3) {
    if (logEnabled) {
      console.error("Property:", propertyName, "of:", object, "can't be overwritten.");
    }
  }
  return success;
}
function copyObjectProperties(fromObject, toObject, cleanCopy = false, jsObjectFunctionsSpecialCopy = false, logEnabled = false) {
  if (fromObject != null) {
    if (cleanCopy) {
      JSUtils.cleanObjectProperties(toObject);
    }
    Object.setPrototypeOf(toObject, Object.getPrototypeOf(fromObject));
    let fromObjectPropertyNames = Object.getOwnPropertyNames(fromObject);
    for (let fromObjectPropertyName of fromObjectPropertyNames) {
      try {
        let fromObjectPropertyDescriptor = Object.getOwnPropertyDescriptor(fromObject, fromObjectPropertyName);
        Object.defineProperty(toObject, fromObjectPropertyName, {
          value: fromObjectPropertyDescriptor.value,
          enumerable: fromObjectPropertyDescriptor.enumerable,
          writable: fromObjectPropertyDescriptor.writable,
          configurable: fromObjectPropertyDescriptor.configurable
        });
      } catch (error3) {
        if (logEnabled) {
          console.error("Property:", fromObjectPropertyName, "of:", fromObject.name, "can't be overwritten.");
        }
      }
    }
    if (jsObjectFunctionsSpecialCopy) {
      _jsObjectFunctionsSpecialCopy(fromObject, toObject);
    }
  }
}
function cleanObjectProperties(object) {
  let objectNames = Object.getOwnPropertyNames(object);
  ArrayUtils.pushUnique(objectNames, "__proto__");
  for (let objectName of objectNames) {
    try {
      Object.defineProperty(object, objectName, {
        value: void 0
      });
    } catch (error3) {
    }
    try {
      delete object[objectName];
    } catch (error3) {
    }
  }
  Object.setPrototypeOf(object, null);
}
function doesObjectPropertyUseAccessors(object, propertyName) {
  let propertyUseAccessors = false;
  let propertyDescriptor = JSUtils.getObjectPropertyDescriptor(object, propertyName);
  if (propertyDescriptor != null && (propertyDescriptor.get != null || propertyDescriptor.set != null)) {
    propertyUseAccessors = true;
  }
  return propertyUseAccessors;
}
function isFunctionByName(functionParent, functionName) {
  let isFunctionResult = false;
  let functionProperty = JSUtils.getObjectProperty(functionParent, functionName);
  if (functionProperty != null) {
    isFunctionResult = JSUtils.isFunction(functionProperty);
  }
  return isFunctionResult;
}
function isClassByName(classParent, className) {
  let isClassResult = false;
  let classProperty = JSUtils.getObjectProperty(classParent, className);
  if (classProperty != null) {
    isClassResult = JSUtils.isClass(classProperty);
  }
  return isClassResult;
}
function isObjectByName(objectParent, objectName) {
  let isObjectResult = false;
  let objectProperty = JSUtils.getObjectProperty(objectParent, objectName);
  if (objectProperty != null) {
    isObjectResult = JSUtils.isObject(objectProperty);
  }
  return isObjectResult;
}
function isFunction(property2) {
  return typeof property2 == "function" && !JSUtils.isClass(property2);
}
var isClass = function() {
  let checkClassRegex = new RegExp("^class");
  return function isClass2(property2) {
    return typeof property2 == "function" && property2.prototype != null && typeof property2.prototype.constructor == "function" && property2.toString != null && typeof property2.toString == "function" && property2.toString()?.match(checkClassRegex) != null;
  };
}();
function isObject(property2) {
  return typeof property2 == "object";
}
var JSUtils = {
  getObjectPrototypes,
  getObjectPropertyNames,
  getObjectPropertyDescriptor,
  getObjectProperty,
  setObjectProperty,
  getObjectPropertyOwnParent,
  getObjectPropertyOwnParents,
  getObjectFromPath,
  getObjectNameFromPath,
  getObjectParentFromPath,
  overwriteObjectProperty,
  copyObjectProperties,
  cleanObjectProperties,
  doesObjectPropertyUseAccessors,
  isFunctionByName,
  isClassByName,
  isObjectByName,
  isFunction,
  isClass,
  isObject
};
function _jsObjectFunctionsSpecialCopy(fromObject, toObject) {
  try {
    if (typeof toObject == "function" && typeof fromObject == "function") {
      let functionsToOverwrite = ["toString", "toLocaleString", "valueOf"];
      for (let functionToOverwrite of functionsToOverwrite) {
        let propertyDescriptorToOverwrite = JSUtils.getObjectPropertyDescriptor(fromObject, functionToOverwrite);
        if (propertyDescriptorToOverwrite != null && propertyDescriptorToOverwrite.value != null && propertyDescriptorToOverwrite.value == Object[functionToOverwrite]) {
          let valueToReturn = Object[functionToOverwrite].bind(fromObject)();
          let overwrittenFunction = function() {
            return valueToReturn;
          };
          JSUtils.overwriteObjectProperty(overwrittenFunction, toObject, functionToOverwrite, false, false);
        }
      }
    }
  } catch (error3) {
  }
}

// js/pp/plugin/utils/plugin_utils.js
function injectProperties(fromReference, toReference, enumerable2 = true, writable = true, configurable = true, keepOriginalDescriptorAttributes = true, bindThisAsFirstParam = false, prefix = null, functionNamesToExclude = []) {
  let ownPropertyNames = Object.getOwnPropertyNames(fromReference);
  for (let ownPropertyName of ownPropertyNames) {
    if (functionNamesToExclude.includes(ownPropertyName))
      continue;
    let enumerableToUse = enumerable2;
    let writableToUse = writable;
    let configurableToUse = configurable;
    if (keepOriginalDescriptorAttributes) {
      let originalDescriptor = Object.getOwnPropertyDescriptor(toReference, ownPropertyName);
      if (originalDescriptor != null) {
        enumerableToUse = originalDescriptor.enumerable;
        writableToUse = originalDescriptor.writable;
        configurableToUse = originalDescriptor.configurable;
      }
    }
    let adjustedPropertyName = ownPropertyName;
    if (prefix != null) {
      if (adjustedPropertyName.length > 0 && adjustedPropertyName[0] == adjustedPropertyName[0].toUpperCase()) {
        adjustedPropertyName = prefix.toUpperCase() + adjustedPropertyName;
      } else {
        adjustedPropertyName = prefix + adjustedPropertyName;
      }
    }
    let propertyDescriptor = Object.getOwnPropertyDescriptor(fromReference, ownPropertyName);
    let useAccessors = propertyDescriptor != null && (propertyDescriptor.get != null || propertyDescriptor.set != null);
    if (!useAccessors) {
      let adjustedProperyValue = fromReference[ownPropertyName];
      if (bindThisAsFirstParam && JSUtils.isFunction(adjustedProperyValue)) {
        let originalFunction = fromReference[ownPropertyName];
        adjustedProperyValue = function() {
          return originalFunction(this, ...arguments);
        };
        Object.defineProperty(adjustedProperyValue, "name", {
          value: adjustedPropertyName
        });
      }
      Object.defineProperty(toReference, adjustedPropertyName, {
        value: adjustedProperyValue,
        enumerable: enumerableToUse,
        writable: writableToUse,
        configurable: configurableToUse
      });
    } else {
      Object.defineProperty(toReference, adjustedPropertyName, {
        get: propertyDescriptor.get,
        set: propertyDescriptor.set,
        enumerable: enumerableToUse,
        configurable: configurableToUse
      });
    }
  }
}
var PluginUtils = {
  injectProperties
};

// js/pp/plugin/js/extensions/array_extension.js
function initArrayExtension() {
  initArrayExtensionProtoype();
}
function vec2_create(x, y) {
  return Vec2Utils.create(x, y);
}
function vec3_create(x, y, z) {
  return Vec3Utils.create(x, y, z);
}
function vec4_create(x, y, z, w) {
  return Vec4Utils.create(x, y, z, w);
}
function quat_create(x, y, z, w) {
  return QuatUtils.create(x, y, z, w);
}
function quat2_create(x1, y1, z1, w1, x2, y2, z2, w2) {
  return Quat2Utils.create(x1, y1, z1, w1, x2, y2, z2, w2);
}
function mat3_create(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  return Mat3Utils.create(
    m00,
    m01,
    m02,
    m10,
    m11,
    m12,
    m20,
    m21,
    m22
  );
}
function mat4_create(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  return Mat4Utils.create(
    m00,
    m01,
    m02,
    m03,
    m10,
    m11,
    m12,
    m13,
    m20,
    m21,
    m22,
    m23,
    m30,
    m31,
    m32,
    m33
  );
}
function initArrayExtensionProtoype() {
  let arrayExtension = {};
  arrayExtension.pp_first = function pp_first() {
    return ArrayUtils.first(this);
  };
  arrayExtension.pp_last = function pp_last() {
    return ArrayUtils.last(this);
  };
  arrayExtension.pp_has = function pp_has(callback) {
    return ArrayUtils.has(this, callback);
  };
  arrayExtension.pp_hasEqual = function pp_hasEqual(elementToFind, elementsEqualCallback = null) {
    return ArrayUtils.hasEqual(this, elementToFind, elementsEqualCallback);
  };
  arrayExtension.pp_find = function pp_find(callback) {
    return ArrayUtils.find(this, callback);
  };
  arrayExtension.pp_findIndex = function pp_findIndex(callback) {
    return ArrayUtils.findIndex(this, callback);
  };
  arrayExtension.pp_findAll = function pp_findAll(callback) {
    return ArrayUtils.findAll(this, callback);
  };
  arrayExtension.pp_findAllIndexes = function pp_findAllIndexes(callback) {
    return ArrayUtils.findAllIndexes(this, callback);
  };
  arrayExtension.pp_findEqual = function pp_findEqual(elementToFind, elementsEqualCallback = null) {
    return ArrayUtils.findEqual(this, elementToFind, elementsEqualCallback);
  };
  arrayExtension.pp_findAllEqual = function pp_findAllEqual(elementToFind, elementsEqualCallback = null) {
    return ArrayUtils.findAllEqual(this, elementToFind, elementsEqualCallback);
  };
  arrayExtension.pp_findIndexEqual = function pp_findIndexEqual(elementToFind, elementsEqualCallback = null) {
    return ArrayUtils.findIndexEqual(this, elementToFind, elementsEqualCallback);
  };
  arrayExtension.pp_findAllIndexesEqual = function pp_findAllIndexesEqual(elementToFind, elementsEqualCallback = null) {
    return ArrayUtils.findAllIndexesEqual(this, elementToFind, elementsEqualCallback);
  };
  arrayExtension.pp_removeIndex = function pp_removeIndex(index) {
    return ArrayUtils.removeIndex(this, index);
  };
  arrayExtension.pp_removeAllIndexes = function pp_removeAllIndexes(indexes) {
    return ArrayUtils.removeAllIndexes(this, indexes);
  };
  arrayExtension.pp_remove = function pp_remove(callback) {
    return ArrayUtils.remove(this, callback);
  };
  arrayExtension.pp_removeAll = function pp_removeAll(callback) {
    return ArrayUtils.removeAll(this, callback);
  };
  arrayExtension.pp_removeEqual = function pp_removeEqual(elementToRemove, elementsEqualCallback = null) {
    return ArrayUtils.removeEqual(this, elementToRemove, elementsEqualCallback);
  };
  arrayExtension.pp_removeAllEqual = function pp_removeAllEqual(elementToRemove, elementsEqualCallback = null) {
    return ArrayUtils.removeAllEqual(this, elementToRemove, elementsEqualCallback);
  };
  arrayExtension.pp_pushUnique = function pp_pushUnique(element, elementsEqualCallback = null) {
    return ArrayUtils.pushUnique(this, element, elementsEqualCallback);
  };
  arrayExtension.pp_unshiftUnique = function pp_unshiftUnique(element, elementsEqualCallback = null) {
    return ArrayUtils.unshiftUnique(this, element, elementsEqualCallback);
  };
  arrayExtension.pp_copy = function pp_copy(array, copyCallback = null) {
    return ArrayUtils.copy(array, this, copyCallback);
  };
  arrayExtension.pp_clone = function pp_clone(cloneCallback = null) {
    return ArrayUtils.clone(this, cloneCallback);
  };
  arrayExtension.pp_equals = function pp_equals(array, elementsEqualCallback = null) {
    return ArrayUtils.equals(this, array, elementsEqualCallback);
  };
  arrayExtension.pp_clear = function pp_clear() {
    return ArrayUtils.clear(this);
  };
  let vecExtension = {};
  vecExtension.vec_zero = function vec_zero(out = null) {
    return VecUtils.zero(this, out);
  };
  vecExtension.vec_isZero = function vec_isZero(epsilon = 0) {
    return VecUtils.isZero(this, epsilon);
  };
  vecExtension.vec_scale = function vec_scale(value, out = null) {
    return VecUtils.scale(this, value, out);
  };
  vecExtension.vec_round = function vec_round(out = null) {
    return VecUtils.round(this, out);
  };
  vecExtension.vec_floor = function vec_floor(out = null) {
    return VecUtils.floor(this, out);
  };
  vecExtension.vec_ceil = function vec_ceil(out = null) {
    return VecUtils.ceil(this, out);
  };
  vecExtension.vec_clamp = function vec_clamp(start, end, out = null) {
    return VecUtils.clamp(this, start, end, out);
  };
  vecExtension.vec_equals = function vec_equals(vector, epsilon = 0) {
    return VecUtils.equals(this, vector, epsilon);
  };
  vecExtension.vec_toString = function vec_toString(decimalPlaces = null) {
    return VecUtils.toString(this, decimalPlaces);
  };
  vecExtension.vec_log = function vec_log(decimalPlaces = 4) {
    return VecUtils.log(this, decimalPlaces);
  };
  vecExtension.vec_error = function vec_error(decimalPlaces = 4) {
    return VecUtils.error(this, decimalPlaces);
  };
  vecExtension.vec_warn = function vec_warn(decimalPlaces = 4) {
    return VecUtils.warn(this, decimalPlaces);
  };
  let vec2Extension = {};
  vec2Extension.vec2_set = function vec2_set(x, y) {
    return Vec2Utils.set(this, x, y);
  };
  vec2Extension.vec2_length = function vec2_length() {
    return Vec2Utils.length(this);
  };
  vec2Extension.vec2_normalize = function vec2_normalize(out = Vec2Utils.create()) {
    return Vec2Utils.normalize(this, out);
  };
  vec2Extension.vec2_copy = function vec2_copy(vector) {
    return Vec2Utils.copy(vector, this);
  };
  vec2Extension.vec2_clone = function vec2_clone(out = Vec2Utils.create()) {
    return Vec2Utils.clone(this, out);
  };
  vec2Extension.vec2_zero = function vec2_zero() {
    return Vec2Utils.zero(this);
  };
  vec2Extension.vec2_isZero = function vec2_isZero(epsilon = 0) {
    return Vec2Utils.isZero(this, epsilon);
  };
  let vec3Extension = {};
  vec3Extension.vec3_set = function vec3_set(x, y, z) {
    return Vec3Utils.set(this, x, y, z);
  };
  vec3Extension.vec3_normalize = function vec3_normalize(out = Vec3Utils.create()) {
    return Vec3Utils.normalize(this, out);
  };
  vec3Extension.vec3_copy = function vec3_copy(vector) {
    return Vec3Utils.copy(vector, this);
  };
  vec3Extension.vec3_clone = function vec3_clone(out = Vec3Utils.create()) {
    return Vec3Utils.clone(this, out);
  };
  vec3Extension.vec3_zero = function vec3_zero() {
    return Vec3Utils.zero(this);
  };
  vec3Extension.vec3_angle = function vec3_angle(vector) {
    return Vec3Utils.angle(this, vector);
  };
  vec3Extension.vec3_angleDegrees = function vec3_angleDegrees(vector) {
    return Vec3Utils.angleDegrees(this, vector);
  };
  vec3Extension.vec3_angleRadians = function vec3_angleRadians(vector) {
    return Vec3Utils.angleRadians(this, vector);
  };
  vec3Extension.vec3_equals = function vec3_equals(vector, epsilon = 0) {
    return Vec3Utils.equals(this, vector, epsilon);
  };
  vec3Extension.vec3_length = function vec3_length() {
    return Vec3Utils.length(this);
  };
  vec3Extension.vec3_lengthSquared = function vec3_lengthSquared() {
    return Vec3Utils.lengthSquared(this);
  };
  vec3Extension.vec3_distance = function vec3_distance(vector) {
    return Vec3Utils.distance(this, vector);
  };
  vec3Extension.vec3_distanceSquared = function vec3_distanceSquared(vector) {
    return Vec3Utils.distanceSquared(this, vector);
  };
  vec3Extension.vec3_add = function vec3_add(vector, out = Vec3Utils.create()) {
    return Vec3Utils.add(this, vector, out);
  };
  vec3Extension.vec3_sub = function vec3_sub(vector, out = Vec3Utils.create()) {
    return Vec3Utils.sub(this, vector, out);
  };
  vec3Extension.vec3_mul = function vec3_mul(vector, out = Vec3Utils.create()) {
    return Vec3Utils.mul(this, vector, out);
  };
  vec3Extension.vec3_div = function vec3_div(vector, out = Vec3Utils.create()) {
    return Vec3Utils.div(this, vector, out);
  };
  vec3Extension.vec3_scale = function vec3_scale(value, out = Vec3Utils.create()) {
    return Vec3Utils.scale(this, value, out);
  };
  vec3Extension.vec3_dot = function vec3_dot(vector) {
    return Vec3Utils.dot(this, vector);
  };
  vec3Extension.vec3_negate = function vec3_negate(out = Vec3Utils.create()) {
    return Vec3Utils.negate(this, out);
  };
  vec3Extension.vec3_cross = function vec3_cross(vector, out = Vec3Utils.create()) {
    return Vec3Utils.cross(this, vector, out);
  };
  vec3Extension.vec3_transformQuat = function vec3_transformQuat(quat, out = Vec3Utils.create()) {
    return Vec3Utils.transformQuat(this, quat, out);
  };
  vec3Extension.vec3_transformMat3 = function vec3_transformMat3(matrix, out = Vec3Utils.create()) {
    return Vec3Utils.transformMat3(this, matrix, out);
  };
  vec3Extension.vec3_transformMat4 = function vec3_transformMat4(matrix, out = Vec3Utils.create()) {
    return Vec3Utils.transformMat4(this, matrix, out);
  };
  vec3Extension.vec3_lengthSigned = function vec3_lengthSigned(positiveDirection) {
    return Vec3Utils.lengthSigned(this, positiveDirection);
  };
  vec3Extension.vec3_angleSigned = function vec3_angleSigned(vector, referenceAxis) {
    return Vec3Utils.angleSigned(this, vector, referenceAxis);
  };
  vec3Extension.vec3_angleSignedDegrees = function vec3_angleSignedDegrees(vector, referenceAxis) {
    return Vec3Utils.angleSignedDegrees(this, vector, referenceAxis);
  };
  vec3Extension.vec3_angleSignedRadians = function vec3_angleSignedRadians(vector, referenceAxis) {
    return Vec3Utils.angleSignedRadians(this, vector, referenceAxis);
  };
  vec3Extension.vec3_anglePivoted = function vec3_anglePivoted(vector, referenceAxis) {
    return Vec3Utils.anglePivoted(this, vector, referenceAxis);
  };
  vec3Extension.vec3_anglePivotedDegrees = function vec3_anglePivotedDegrees(vector, referenceAxis) {
    return Vec3Utils.anglePivotedDegrees(this, vector, referenceAxis);
  };
  vec3Extension.vec3_anglePivotedRadians = function vec3_anglePivotedRadians(vector, referenceAxis) {
    return Vec3Utils.anglePivotedRadians(this, vector, referenceAxis);
  };
  vec3Extension.vec3_anglePivotedSigned = function vec3_anglePivotedSigned(vector, referenceAxis) {
    return Vec3Utils.anglePivotedSigned(this, vector, referenceAxis);
  };
  vec3Extension.vec3_anglePivotedSignedDegrees = function vec3_anglePivotedSignedDegrees(vector, referenceAxis) {
    return Vec3Utils.anglePivotedSignedDegrees(this, vector, referenceAxis);
  };
  vec3Extension.vec3_anglePivotedSignedRadians = function vec3_anglePivotedSignedRadians(vector, referenceAxis) {
    return Vec3Utils.anglePivotedSignedRadians(this, vector, referenceAxis);
  };
  vec3Extension.vec3_toRadians = function vec3_toRadians(out = Vec3Utils.create()) {
    return Vec3Utils.toRadians(this, out);
  };
  vec3Extension.vec3_toDegrees = function vec3_toDegrees(out = Vec3Utils.create()) {
    return Vec3Utils.toDegrees(this, out);
  };
  vec3Extension.vec3_toQuat = function vec3_toQuat(out) {
    return Vec3Utils.toQuat(this, out);
  };
  vec3Extension.vec3_radiansToQuat = function vec3_radiansToQuat(out = QuatUtils.create()) {
    return Vec3Utils.radiansToQuat(this, out);
  };
  vec3Extension.vec3_degreesToQuat = function vec3_degreesToQuat(out = QuatUtils.create()) {
    return Vec3Utils.degreesToQuat(this, out);
  };
  vec3Extension.vec3_isNormalized = function vec3_isNormalized(epsilon = MathUtils.EPSILON) {
    return Vec3Utils.isNormalized(this, epsilon);
  };
  vec3Extension.vec3_isZero = function vec3_isZero(epsilon = 0) {
    return Vec3Utils.isZero(this, epsilon);
  };
  vec3Extension.vec3_componentAlongAxis = function vec3_componentAlongAxis(axis, out = Vec3Utils.create()) {
    return Vec3Utils.componentAlongAxis(this, axis, out);
  };
  vec3Extension.vec3_valueAlongAxis = function vec3_valueAlongAxis(axis) {
    return Vec3Utils.valueAlongAxis(this, axis);
  };
  vec3Extension.vec3_removeComponentAlongAxis = function vec3_removeComponentAlongAxis(axis, out = Vec3Utils.create()) {
    return Vec3Utils.removeComponentAlongAxis(this, axis, out);
  };
  vec3Extension.vec3_copyComponentAlongAxis = function vec3_copyComponentAlongAxis(vector, axis, out = Vec3Utils.create()) {
    return Vec3Utils.copyComponentAlongAxis(vector, this, axis, out);
  };
  vec3Extension.vec3_isConcordant = function vec3_isConcordant(vector) {
    return Vec3Utils.isConcordant(this, vector);
  };
  vec3Extension.vec3_isFartherAlongAxis = function vec3_isFartherAlongAxis(vector, axis) {
    return Vec3Utils.isFartherAlongAxis(this, vector, axis);
  };
  vec3Extension.vec3_isToTheRight = function vec3_isToTheRight(vector, referenceAxis) {
    return Vec3Utils.isToTheRight(this, vector, referenceAxis);
  };
  vec3Extension.vec3_signTo = function vec3_signTo(vector, referenceAxis, zeroSign = 1) {
    return Vec3Utils.signTo(this, vector, referenceAxis, zeroSign);
  };
  vec3Extension.vec3_projectOnAxis = function vec3_projectOnAxis(axis, out = Vec3Utils.create()) {
    return Vec3Utils.projectOnAxis(this, axis, out);
  };
  vec3Extension.vec3_projectOnAxisAlongAxis = function vec3_projectOnAxisAlongAxis(axis, projectAlongAxis, out = Vec3Utils.create()) {
    return Vec3Utils.projectOnAxisAlongAxis(this, axis, projectAlongAxis, out);
  };
  vec3Extension.vec3_projectOnPlane = function vec3_projectOnPlane(planeNormal, out = Vec3Utils.create()) {
    return Vec3Utils.projectOnPlane(this, planeNormal, out);
  };
  vec3Extension.vec3_projectOnPlaneAlongAxis = function vec3_projectOnPlaneAlongAxis(planeNormal, projectAlongAxis, out = Vec3Utils.create()) {
    return Vec3Utils.projectOnPlaneAlongAxis(this, planeNormal, projectAlongAxis, out);
  };
  vec3Extension.vec3_isOnAxis = function vec3_isOnAxis(axis) {
    return Vec3Utils.isOnAxis(this, axis);
  };
  vec3Extension.vec3_isOnPlane = function vec3_isOnPlane(planeNormal) {
    return Vec3Utils.isOnPlane(this, planeNormal);
  };
  vec3Extension.vec3_rotate = function vec3_rotate(rotation, out) {
    return Vec3Utils.rotate(this, rotation, out);
  };
  vec3Extension.vec3_rotateDegrees = function vec3_rotateDegrees(rotation, out) {
    return Vec3Utils.rotateDegrees(this, rotation, out);
  };
  vec3Extension.vec3_rotateRadians = function vec3_rotateRadians(rotation, out) {
    return Vec3Utils.rotateRadians(this, rotation, out);
  };
  vec3Extension.vec3_rotateQuat = function vec3_rotateQuat(rotation, out) {
    return Vec3Utils.rotateQuat(this, rotation, out);
  };
  vec3Extension.vec3_rotateAxis = function vec3_rotateAxis(angle4, axis, out) {
    return Vec3Utils.rotateAxis(this, angle4, axis, out);
  };
  vec3Extension.vec3_rotateAxisDegrees = function vec3_rotateAxisDegrees(angle4, axis, out) {
    return Vec3Utils.rotateAxisDegrees(this, angle4, axis, out);
  };
  vec3Extension.vec3_rotateAxisRadians = function vec3_rotateAxisRadians(angle4, axis, out) {
    return Vec3Utils.rotateAxisRadians(this, angle4, axis, out);
  };
  vec3Extension.vec3_rotateAround = function vec3_rotateAround(rotation, origin, out) {
    return Vec3Utils.rotateAround(this, rotation, origin, out);
  };
  vec3Extension.vec3_rotateAroundDegrees = function vec3_rotateAroundDegrees(rotation, origin, out = Vec3Utils.create()) {
    return Vec3Utils.rotateAroundDegrees(this, rotation, origin, out);
  };
  vec3Extension.vec3_rotateAroundRadians = function vec3_rotateAroundRadians(rotation, origin, out = Vec3Utils.create()) {
    return Vec3Utils.rotateAroundRadians(this, rotation, origin, out);
  };
  vec3Extension.vec3_rotateAroundQuat = function vec3_rotateAroundQuat(rotation, origin, out = Vec3Utils.create()) {
    return Vec3Utils.rotateAroundQuat(this, rotation, origin, out);
  };
  vec3Extension.vec3_rotateAroundAxis = function vec3_rotateAroundAxis(angle4, axis, origin, out) {
    return Vec3Utils.rotateAroundAxis(this, angle4, axis, origin, out);
  };
  vec3Extension.vec3_rotateAroundAxisDegrees = function vec3_rotateAroundAxisDegrees(angle4, axis, origin, out) {
    return Vec3Utils.rotateAroundAxisDegrees(this, angle4, axis, origin, out);
  };
  vec3Extension.vec3_rotateAroundAxisRadians = function vec3_rotateAroundAxisRadians(angle4, axis, origin, out = Vec3Utils.create()) {
    return Vec3Utils.rotateAroundAxisRadians(this, angle4, axis, origin, out);
  };
  vec3Extension.vec3_convertPositionToWorld = function vec3_convertPositionToWorld(parentTransform, out) {
    return Vec3Utils.convertPositionToWorld(this, parentTransform, out);
  };
  vec3Extension.vec3_convertPositionToLocal = function vec3_convertPositionToLocal(parentTransform, out) {
    return Vec3Utils.convertPositionToLocal(this, parentTransform, out);
  };
  vec3Extension.vec3_convertPositionToWorldMatrix = function vec3_convertPositionToWorldMatrix(parentTransform, out = Vec3Utils.create()) {
    return Vec3Utils.convertPositionToWorldMatrix(this, parentTransform, out);
  };
  vec3Extension.vec3_convertPositionToLocalMatrix = function vec3_convertPositionToLocalMatrix(parentTransform, out = Vec3Utils.create()) {
    return Vec3Utils.convertPositionToLocalMatrix(this, parentTransform, out);
  };
  vec3Extension.vec3_convertPositionToWorldQuat = function vec3_convertPositionToWorldQuat(parentTransform, out = Vec3Utils.create()) {
    return Vec3Utils.convertPositionToWorldQuat(this, parentTransform, out);
  };
  vec3Extension.vec3_convertPositionToLocalQuat = function vec3_convertPositionToLocalQuat(parentTransform, out = Vec3Utils.create()) {
    return Vec3Utils.convertPositionToLocalQuat(this, parentTransform, out);
  };
  vec3Extension.vec3_convertDirectionToWorld = function vec3_convertDirectionToWorld(parentTransform, out) {
    return Vec3Utils.convertDirectionToWorld(this, parentTransform, out);
  };
  vec3Extension.vec3_convertDirectionToLocal = function vec3_convertDirectionToLocal(parentTransform, out) {
    return Vec3Utils.convertDirectionToLocal(this, parentTransform, out);
  };
  vec3Extension.vec3_convertDirectionToWorldMatrix = function vec3_convertDirectionToWorldMatrix(parentTransform, out = Vec3Utils.create()) {
    return Vec3Utils.convertDirectionToWorldMatrix(this, parentTransform, out);
  };
  vec3Extension.vec3_convertDirectionToLocalMatrix = function vec3_convertDirectionToLocalMatrix(parentTransform, out = Vec3Utils.create()) {
    return Vec3Utils.convertDirectionToLocalMatrix(this, parentTransform, out);
  };
  vec3Extension.vec3_convertDirectionToWorldQuat = function vec3_convertDirectionToWorldQuat(parentTransform, out = Vec3Utils.create()) {
    return Vec3Utils.convertDirectionToWorldQuat(this, parentTransform, out);
  };
  vec3Extension.vec3_convertDirectionToLocalQuat = function vec3_convertDirectionToLocalQuat(parentTransform, out = Vec3Utils.create()) {
    return Vec3Utils.convertDirectionToLocalQuat(this, parentTransform, out);
  };
  vec3Extension.vec3_addRotation = function vec3_addRotation(rotation, out) {
    return Vec3Utils.addRotation(this, rotation, out);
  };
  vec3Extension.vec3_addRotationDegrees = function vec3_addRotationDegrees(rotation, out) {
    return Vec3Utils.addRotationDegrees(this, rotation, out);
  };
  vec3Extension.vec3_addRotationRadians = function vec3_addRotationRadians(rotation, out) {
    return Vec3Utils.addRotationRadians(this, rotation, out);
  };
  vec3Extension.vec3_addRotationQuat = function vec3_addRotationQuat(rotation, out) {
    return Vec3Utils.addRotationQuat(this, rotation, out);
  };
  vec3Extension.vec3_degreesAddRotation = function vec3_degreesAddRotation(rotation, out) {
    return Vec3Utils.degreesAddRotation(this, rotation, out);
  };
  vec3Extension.vec3_degreesAddRotationDegrees = function vec3_degreesAddRotationDegrees(rotation, out = Vec3Utils.create()) {
    return Vec3Utils.degreesAddRotationDegrees(this, rotation, out);
  };
  vec3Extension.vec3_degreesAddRotationRadians = function vec3_degreesAddRotationRadians(rotation, out = Vec3Utils.create()) {
    return Vec3Utils.degreesAddRotationRadians(this, rotation, out);
  };
  vec3Extension.vec3_degreesAddRotationQuat = function vec3_degreesAddRotationQuat(rotation, out = Vec3Utils.create()) {
    return Vec3Utils.degreesAddRotationQuat(this, rotation, out);
  };
  vec3Extension.vec3_radiansAddRotation = function vec3_radiansAddRotation(rotation, out) {
    return Vec3Utils.radiansAddRotation(this, rotation, out);
  };
  vec3Extension.vec3_radiansAddRotationDegrees = function vec3_radiansAddRotationDegrees(rotation, out = Vec3Utils.create()) {
    return Vec3Utils.radiansAddRotationDegrees(this, rotation, out);
  };
  vec3Extension.vec3_radiansAddRotationRadians = function vec3_radiansAddRotationRadians(rotation, out = Vec3Utils.create()) {
    return Vec3Utils.radiansAddRotationRadians(this, rotation, out);
  };
  vec3Extension.vec3_radiansAddRotationQuat = function vec3_radiansAddRotationQuat(rotation, out = Vec3Utils.create()) {
    return Vec3Utils.radiansAddRotationQuat(this, rotation, out);
  };
  vec3Extension.vec3_toMatrix = function vec3_toMatrix(out = Mat3Utils.create()) {
    return Vec3Utils.toMatrix(this, out);
  };
  vec3Extension.vec3_degreesToMatrix = function vec3_degreesToMatrix(out = Mat3Utils.create()) {
    return Vec3Utils.degreesToMatrix(this, out);
  };
  vec3Extension.vec3_radiansToMatrix = function vec3_radiansToMatrix(out = Mat3Utils.create()) {
    return Vec3Utils.radiansToMatrix(this, out);
  };
  vec3Extension.vec3_rotationTo = function vec3_rotationTo(to, out) {
    return Vec3Utils.rotationTo(this, to, out);
  };
  vec3Extension.vec3_rotationToDegrees = function vec3_rotationToDegrees(to, out = Vec3Utils.create()) {
    return Vec3Utils.rotationToDegrees(this, to, out);
  };
  vec3Extension.vec3_rotationToRadians = function vec3_rotationToRadians(to, out = Vec3Utils.create()) {
    return Vec3Utils.rotationToRadians(this, to, out);
  };
  vec3Extension.vec3_rotationToQuat = function vec3_rotationToQuat(to, out = QuatUtils.create()) {
    return Vec3Utils.rotationToQuat(this, to, out);
  };
  vec3Extension.vec3_rotationToPivoted = function vec3_rotationToPivoted(to, pivotAxis, out) {
    return Vec3Utils.rotationToPivoted(this, to, pivotAxis, out);
  };
  vec3Extension.vec3_rotationToPivotedDegrees = function vec3_rotationToPivotedDegrees(to, pivotAxis, out = Vec3Utils.create()) {
    return Vec3Utils.rotationToPivotedDegrees(this, to, pivotAxis, out);
  };
  vec3Extension.vec3_rotationToPivotedRadians = function vec3_rotationToPivotedRadians(to, pivotAxis, out = Vec3Utils.create()) {
    return Vec3Utils.rotationToPivotedRadians(this, to, pivotAxis, out);
  };
  vec3Extension.vec3_rotationToPivotedQuat = function vec3_rotationToPivotedQuat(to, pivotAxis, out = QuatUtils.create()) {
    return Vec3Utils.rotationToPivotedQuat(this, to, pivotAxis, out);
  };
  vec3Extension.vec3_lerp = function vec3_lerp(to, interpolationFactor, out = Vec3Utils.create()) {
    return Vec3Utils.lerp(this, to, interpolationFactor, out);
  };
  vec3Extension.vec3_interpolate = function vec3_interpolate(to, interpolationFactor, easingFunction = EasingFunction.linear, out = Vec3Utils.create()) {
    return Vec3Utils.interpolate(this, to, interpolationFactor, easingFunction, out);
  };
  vec3Extension.vec3_perpendicularRandom = function vec3_perpendicularRandom(out = Vec3Utils.create()) {
    return Vec3Utils.perpendicularRandom(this, out);
  };
  let vec4Extension = {};
  vec4Extension.vec4_set = function vec4_set(x, y, z, w) {
    return Vec4Utils.set(this, x, y, z, w);
  };
  vec4Extension.vec4_copy = function vec4_copy(vector) {
    return Vec4Utils.copy(vector, this);
  };
  vec4Extension.vec4_clone = function vec4_clone(out = Vec4Utils.create()) {
    return Vec4Utils.clone(this, out);
  };
  let quatExtension = {};
  quatExtension.quat_set = function quat_set(x, y, z, w) {
    return QuatUtils.set(this, x, y, z, w);
  };
  quatExtension.quat_normalize = function quat_normalize(out = QuatUtils.create()) {
    return QuatUtils.normalize(this, out);
  };
  quatExtension.quat_copy = function quat_copy(quat) {
    return QuatUtils.copy(quat, this);
  };
  quatExtension.quat_clone = function quat_clone(out = QuatUtils.create()) {
    return QuatUtils.clone(this, out);
  };
  quatExtension.quat_identity = function quat_identity() {
    return QuatUtils.identity(this);
  };
  quatExtension.quat_length = function quat_length() {
    return QuatUtils.length(this);
  };
  quatExtension.quat_lengthSquared = function quat_lengthSquared() {
    return QuatUtils.lengthSquared(this);
  };
  quatExtension.quat_invert = function quat_invert(out = QuatUtils.create()) {
    return QuatUtils.invert(this, out);
  };
  quatExtension.quat_conjugate = function quat_conjugate(out = QuatUtils.create()) {
    return QuatUtils.conjugate(this, out);
  };
  quatExtension.quat_mul = function quat_mul(rotation, out = QuatUtils.create()) {
    return QuatUtils.mul(this, rotation, out);
  };
  quatExtension.quat_getAxis = function quat_getAxis(out = Vec3Utils.create()) {
    return QuatUtils.getAxis(this, out);
  };
  quatExtension.quat_getAngle = function quat_getAngle() {
    return QuatUtils.getAngle(this);
  };
  quatExtension.quat_getAngleDegrees = function quat_getAngleDegrees() {
    return QuatUtils.getAngleDegrees(this);
  };
  quatExtension.quat_getAngleRadians = function quat_getAngleRadians() {
    return QuatUtils.getAngleRadians(this);
  };
  quatExtension.quat_getAxisScaled = function quat_getAxisScaled(out = Vec3Utils.create()) {
    return QuatUtils.getAxisScaled(this, out);
  };
  quatExtension.quat_getAxisScaledDegrees = function quat_getAxisScaledDegrees(out = Vec3Utils.create()) {
    return QuatUtils.getAxisScaledDegrees(this, out);
  };
  quatExtension.quat_getAxisScaledRadians = function quat_getAxisScaledRadians(out = Vec3Utils.create()) {
    return QuatUtils.getAxisScaledRadians(this, out);
  };
  quatExtension.quat_getAxes = function quat_getAxes(out = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
    return QuatUtils.getAxes(this, out);
  };
  quatExtension.quat_getForward = function quat_getForward(out = Vec3Utils.create()) {
    return QuatUtils.getForward(this, out);
  };
  quatExtension.quat_getBackward = function quat_getBackward(out) {
    return QuatUtils.getBackward(this, out);
  };
  quatExtension.quat_getLeft = function quat_getLeft(out = Vec3Utils.create()) {
    return QuatUtils.getLeft(this, out);
  };
  quatExtension.quat_getRight = function quat_getRight(out) {
    return QuatUtils.getRight(this, out);
  };
  quatExtension.quat_getUp = function quat_getUp(out = Vec3Utils.create()) {
    return QuatUtils.getUp(this, out);
  };
  quatExtension.quat_getDown = function quat_getDown(out) {
    return QuatUtils.getDown(this, out);
  };
  quatExtension.quat_setAxes = function quat_setAxes(left, up, forward) {
    return QuatUtils.setAxes(this, left, up, forward);
  };
  quatExtension.quat_setForward = function quat_setForward(forward, up = null, left = null) {
    return QuatUtils.setForward(this, forward, up, left);
  };
  quatExtension.quat_setBackward = function quat_setBackward(backward, up = null, left = null) {
    return QuatUtils.setBackward(this, backward, up, left);
  };
  quatExtension.quat_setUp = function quat_setUp(up, forward = null, left = null) {
    return QuatUtils.setUp(this, up, forward, left);
  };
  quatExtension.quat_setDown = function quat_setDown(down, forward = null, left = null) {
    return QuatUtils.setDown(this, down, forward, left);
  };
  quatExtension.quat_setLeft = function quat_setLeft(left, up = null, forward = null) {
    return QuatUtils.setLeft(this, left, up, forward);
  };
  quatExtension.quat_setRight = function quat_setRight(right, up = null, forward = null) {
    return QuatUtils.setRight(this, right, up, forward);
  };
  quatExtension.quat_toWorld = function quat_toWorld(parentQuat, out = QuatUtils.create()) {
    return QuatUtils.toWorld(this, parentQuat, out);
  };
  quatExtension.quat_toLocal = function quat_toLocal(parentQuat, out = QuatUtils.create()) {
    return QuatUtils.toLocal(this, parentQuat, out);
  };
  quatExtension.quat_fromAxis = function quat_fromAxis(angle4, axis) {
    return QuatUtils.fromAxis(angle4, axis, this);
  };
  quatExtension.quat_fromAxisDegrees = function quat_fromAxisDegrees(angle4, axis) {
    return QuatUtils.fromAxisDegrees(angle4, axis, this);
  };
  quatExtension.quat_fromAxisRadians = function quat_fromAxisRadians(angle4, axis) {
    return QuatUtils.fromAxisRadians(angle4, axis, this);
  };
  quatExtension.quat_fromAxes = function quat_fromAxes(leftAxis, upAxis, forwardAxis) {
    return QuatUtils.fromAxes(leftAxis, upAxis, forwardAxis, this);
  };
  quatExtension.quat_fromRadians = function quat_fromRadians(radiansRotation) {
    return QuatUtils.fromRadians(radiansRotation, this);
  };
  quatExtension.quat_fromDegrees = function quat_fromDegrees(degreesRotation) {
    return QuatUtils.fromDegrees(degreesRotation, this);
  };
  quatExtension.quat_toRadians = function quat_toRadians(out = Vec3Utils.create()) {
    return QuatUtils.toRadians(this, out);
  };
  quatExtension.quat_toDegrees = function quat_toDegrees(out = Vec3Utils.create()) {
    return QuatUtils.toDegrees(this, out);
  };
  quatExtension.quat_isNormalized = function quat_isNormalized(epsilon = MathUtils.EPSILON) {
    return QuatUtils.isNormalized(this, epsilon);
  };
  quatExtension.quat_addRotation = function quat_addRotation(rotation, out) {
    return QuatUtils.addRotation(this, rotation, out);
  };
  quatExtension.quat_addRotationDegrees = function quat_addRotationDegrees(rotation, out) {
    return QuatUtils.addRotationDegrees(this, rotation, out);
  };
  quatExtension.quat_addRotationRadians = function quat_addRotationRadians(rotation, out) {
    return QuatUtils.addRotationRadians(this, rotation, out);
  };
  quatExtension.quat_addRotationQuat = function quat_addRotationQuat(rotation, out = QuatUtils.create()) {
    return QuatUtils.addRotationQuat(this, rotation, out);
  };
  quatExtension.quat_subRotation = function quat_subRotation(rotation, out) {
    return QuatUtils.subRotation(this, rotation, out);
  };
  quatExtension.quat_subRotationDegrees = function quat_subRotationDegrees(rotation, out) {
    return QuatUtils.subRotationDegrees(this, rotation, out);
  };
  quatExtension.quat_subRotationRadians = function quat_subRotationRadians(rotation, out) {
    return QuatUtils.subRotationRadians(this, rotation, out);
  };
  quatExtension.quat_subRotationQuat = function quat_subRotationQuat(rotation, out = QuatUtils.create()) {
    return QuatUtils.subRotationQuat(this, rotation, out);
  };
  quatExtension.quat_rotationTo = function quat_rotationTo(to, out) {
    return QuatUtils.rotationTo(this, to, out);
  };
  quatExtension.quat_rotationToDegrees = function quat_rotationToDegrees(to, out) {
    return QuatUtils.rotationToDegrees(this, to, out);
  };
  quatExtension.quat_rotationToRadians = function quat_rotationToRadians(to, out) {
    return QuatUtils.rotationToRadians(this, to, out);
  };
  quatExtension.quat_rotationToQuat = function quat_rotationToQuat(to, out) {
    return QuatUtils.rotationToQuat(this, to, out);
  };
  quatExtension.quat_rotationAroundAxis = function quat_rotationAroundAxis(axis, out) {
    return QuatUtils.rotationAroundAxis(this, axis, out);
  };
  quatExtension.quat_rotationAroundAxisDegrees = function quat_rotationAroundAxisDegrees(axis, out = Vec3Utils.create()) {
    return QuatUtils.rotationAroundAxisDegrees(this, axis, out);
  };
  quatExtension.quat_rotationAroundAxisRadians = function quat_rotationAroundAxisRadians(axis, out = Vec3Utils.create()) {
    return QuatUtils.rotationAroundAxisRadians(this, axis, out);
  };
  quatExtension.quat_rotationAroundAxisQuat = function quat_rotationAroundAxisQuat(axis, out = QuatUtils.create()) {
    return QuatUtils.rotationAroundAxisQuat(this, axis, out);
  };
  quatExtension.quat_getTwist = function quat_getTwist(axis, out = QuatUtils.create()) {
    return QuatUtils.getTwist(this, axis, out);
  };
  quatExtension.quat_getSwing = function quat_getSwing(axis, out = QuatUtils.create()) {
    return QuatUtils.getSwing(this, axis, out);
  };
  quatExtension.quat_getSwingFromTwist = function quat_getSwingFromTwist(twist, out = QuatUtils.create()) {
    return QuatUtils.getSwingFromTwist(this, twist, out);
  };
  quatExtension.quat_getTwistFromSwing = function quat_getTwistFromSwing(swing, out = QuatUtils.create()) {
    return QuatUtils.getTwistFromSwing(this, swing, out);
  };
  quatExtension.quat_fromTwistSwing = function quat_fromTwistSwing(twist, swing) {
    return QuatUtils.fromTwistSwing(twist, swing, this);
  };
  quatExtension.quat_toMatrix = function quat_toMatrix(out = Mat3Utils.create()) {
    return QuatUtils.toMatrix(this, out);
  };
  quatExtension.quat_rotate = function quat_rotate(rotation, out) {
    return QuatUtils.rotate(this, rotation, out);
  };
  quatExtension.quat_rotateDegrees = function quat_rotateDegrees(rotation, out) {
    return QuatUtils.rotateDegrees(this, rotation, out);
  };
  quatExtension.quat_rotateRadians = function quat_rotateRadians(rotation, out) {
    return QuatUtils.rotateRadians(this, rotation, out);
  };
  quatExtension.quat_rotateQuat = function quat_rotateQuat(rotation, out) {
    return QuatUtils.rotateQuat(this, rotation, out);
  };
  quatExtension.quat_rotateAxis = function quat_rotateAxis(angle4, axis, out) {
    return QuatUtils.rotateAxis(this, angle4, axis, out);
  };
  quatExtension.quat_rotateAxisDegrees = function quat_rotateAxisDegrees(angle4, axis, out) {
    return QuatUtils.rotateAxisDegrees(this, angle4, axis, out);
  };
  quatExtension.quat_rotateAxisRadians = function quat_rotateAxisRadians(angle4, axis, out) {
    return QuatUtils.rotateAxisRadians(this, angle4, axis, out);
  };
  quatExtension.quat_lerp = function quat_lerp(to, interpolationFactor, out = QuatUtils.create()) {
    return QuatUtils.lerp(this, to, interpolationFactor, out);
  };
  quatExtension.quat_interpolate = function quat_interpolate(to, interpolationFactor, easingFunction = EasingFunction.linear, out = QuatUtils.create()) {
    return QuatUtils.interpolate(this, to, interpolationFactor, easingFunction, out);
  };
  quatExtension.quat_slerp = function quat_slerp(to, interpolationFactor, out = QuatUtils.create()) {
    return QuatUtils.slerp(this, to, interpolationFactor, out);
  };
  quatExtension.quat_sinterpolate = function quat_sinterpolate(to, interpolationFactor, easingFunction = EasingFunction.linear, out = QuatUtils.create()) {
    return QuatUtils.sinterpolate(this, to, interpolationFactor, easingFunction, out);
  };
  let quat2Extension = {};
  quat2Extension.quat2_set = function quat2_set(x1, y1, z1, w1, x2, y2, z2, w2) {
    return Quat2Utils.set(this, x1, y1, z1, w1, x2, y2, z2, w2);
  };
  quat2Extension.quat2_normalize = function quat2_normalize(out = Quat2Utils.create()) {
    return Quat2Utils.normalize(this, out);
  };
  quat2Extension.quat2_invert = function quat2_invert(out = Quat2Utils.create()) {
    return Quat2Utils.invert(this, out);
  };
  quat2Extension.quat2_conjugate = function quat2_conjugate(out = Quat2Utils.create()) {
    return Quat2Utils.conjugate(this, out);
  };
  quat2Extension.quat2_copy = function quat2_copy(quat) {
    return Quat2Utils.copy(quat, this);
  };
  quat2Extension.quat2_identity = function quat2_identity() {
    return Quat2Utils.identity(this);
  };
  quat2Extension.quat2_getPosition = function quat2_getPosition(out = Vec3Utils.create()) {
    return Quat2Utils.getPosition(this, out);
  };
  quat2Extension.quat2_getRotation = function quat2_getRotation(out) {
    return Quat2Utils.getRotation(this, out);
  };
  quat2Extension.quat2_getRotationDegrees = function quat2_getRotationDegrees(out = Vec3Utils.create()) {
    return Quat2Utils.getRotationDegrees(this, out);
  };
  quat2Extension.quat2_getRotationRadians = function quat2_getRotationRadians(out = Vec3Utils.create()) {
    return Quat2Utils.getRotationRadians(this, out);
  };
  quat2Extension.quat2_getRotationQuat = function quat2_getRotationQuat(out = QuatUtils.create()) {
    return Quat2Utils.getRotationQuat(this, out);
  };
  quat2Extension.quat2_setPosition = function quat2_setPosition(position) {
    return Quat2Utils.setPosition(this, position);
  };
  quat2Extension.quat2_setRotation = function quat2_setRotation(rotation) {
    return Quat2Utils.setRotation(this, rotation);
  };
  quat2Extension.quat2_setRotationDegrees = function quat2_setRotationDegrees(rotation) {
    return Quat2Utils.setRotationDegrees(this, rotation);
  };
  quat2Extension.quat2_setRotationRadians = function quat2_setRotationRadians(rotation) {
    return Quat2Utils.setRotationRadians(this, rotation);
  };
  quat2Extension.quat2_setRotationQuat = function quat2_setRotationQuat(rotation) {
    return Quat2Utils.setRotationQuat(this, rotation);
  };
  quat2Extension.quat2_setPositionRotation = function quat2_setPositionRotation(position, rotation) {
    return Quat2Utils.setPositionRotation(this, position, rotation);
  };
  quat2Extension.quat2_setPositionRotationDegrees = function quat2_setPositionRotationDegrees(position, rotation) {
    return Quat2Utils.setPositionRotationDegrees(this, position, rotation);
  };
  quat2Extension.quat2_setPositionRotationRadians = function quat2_setPositionRotationRadians(position, rotation) {
    return Quat2Utils.setPositionRotationRadians(this, position, rotation);
  };
  quat2Extension.quat2_setPositionRotationQuat = function quat2_setPositionRotationQuat(position, rotation) {
    return Quat2Utils.setPositionRotationQuat(this, position, rotation);
  };
  quat2Extension.quat2_isNormalized = function quat2_isNormalized(epsilon = MathUtils.EPSILON) {
    return Quat2Utils.isNormalized(this, epsilon);
  };
  quat2Extension.quat2_length = function quat2_length() {
    return Quat2Utils.length(this);
  };
  quat2Extension.quat2_lengthSquared = function quat2_lengthSquared() {
    return Quat2Utils.lengthSquared(this);
  };
  quat2Extension.quat2_mul = function quat2_mul(quat, out = Quat2Utils.create()) {
    return Quat2Utils.mul(this, quat, out);
  };
  quat2Extension.quat2_getAxes = function quat2_getAxes(out = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
    return Quat2Utils.getAxes(this, out);
  };
  quat2Extension.quat2_getForward = function quat2_getForward(out = Vec3Utils.create()) {
    return Quat2Utils.getForward(this, out);
  };
  quat2Extension.quat2_getBackward = function quat2_getBackward(out) {
    return Quat2Utils.getBackward(this, out);
  };
  quat2Extension.quat2_getLeft = function quat2_getLeft(out = Vec3Utils.create()) {
    return Quat2Utils.getLeft(this, out);
  };
  quat2Extension.quat2_getRight = function quat2_getRight(out) {
    return Quat2Utils.getRight(this, out);
  };
  quat2Extension.quat2_getUp = function quat2_getUp(out = Vec3Utils.create()) {
    return Quat2Utils.getUp(this, out);
  };
  quat2Extension.quat2_getDown = function quat2_getDown(out) {
    return Quat2Utils.getDown(this, out);
  };
  quat2Extension.quat2_toWorld = function quat2_toWorld(parentTransformQuat, out = Quat2Utils.create()) {
    return Quat2Utils.toWorld(this, parentTransformQuat, out);
  };
  quat2Extension.quat2_toLocal = function quat2_toLocal(parentTransformQuat, out = Quat2Utils.create()) {
    return Quat2Utils.toLocal(this, parentTransformQuat, out);
  };
  quat2Extension.quat2_rotateAxis = function quat2_rotateAxis(angle4, axis, out) {
    return Quat2Utils.rotateAxis(this, angle4, axis, out);
  };
  quat2Extension.quat2_rotateAxisDegrees = function quat2_rotateAxisDegrees(angle4, axis, out) {
    return Quat2Utils.rotateAxisDegrees(this, angle4, axis, out);
  };
  quat2Extension.quat2_rotateAxisRadians = function quat2_rotateAxisRadians(angle4, axis, out = Quat2Utils.create()) {
    return Quat2Utils.rotateAxisRadians(this, angle4, axis, out);
  };
  quat2Extension.quat2_toMatrix = function quat2_toMatrix(out = Mat4Utils.create()) {
    return Quat2Utils.toMatrix(this, out);
  };
  quat2Extension.quat2_fromMatrix = function quat2_fromMatrix(matrix) {
    return Quat2Utils.fromMatrix(matrix, this);
  };
  quat2Extension.quat2_lerp = function quat2_lerp(to, interpolationFactor, out = Quat2Utils.create()) {
    return Quat2Utils.lerp(this, to, interpolationFactor, out);
  };
  quat2Extension.quat2_interpolate = function quat2_interpolate(to, interpolationFactor, easingFunction = EasingFunction.linear, out = Quat2Utils.create()) {
    return Quat2Utils.interpolate(this, to, interpolationFactor, easingFunction, out);
  };
  quat2Extension.quat2_slerp = function quat2_slerp(to, interpolationFactor, out = Quat2Utils.create()) {
    return Quat2Utils.slerp(this, to, interpolationFactor, out);
  };
  quat2Extension.quat2_sinterpolate = function quat2_sinterpolate(to, interpolationFactor, easingFunction = EasingFunction.linear, out = Quat2Utils.create()) {
    return Quat2Utils.sinterpolate(this, to, interpolationFactor, easingFunction, out);
  };
  let mat3Extension = {};
  mat3Extension.mat3_set = function mat3_set(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    return Mat3Utils.set(
      this,
      m00,
      m01,
      m02,
      m10,
      m11,
      m12,
      m20,
      m21,
      m22
    );
  };
  mat3Extension.mat3_toDegrees = function mat3_toDegrees(out = Vec3Utils.create()) {
    return Mat3Utils.toDegrees(this, out);
  };
  mat3Extension.mat3_toRadians = function mat3_toRadians(out = Vec3Utils.create()) {
    return Mat3Utils.toRadians(this, out);
  };
  mat3Extension.mat3_toQuat = function mat3_toQuat(out = QuatUtils.create()) {
    return Mat3Utils.toQuat(this, out);
  };
  mat3Extension.mat3_fromAxes = function mat3_fromAxes(leftAxis, upAxis, forwardAxis) {
    return Mat3Utils.fromAxes(leftAxis, upAxis, forwardAxis, this);
  };
  let mat4Extension = {};
  mat4Extension.mat4_set = function mat4_set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    return Mat4Utils.set(
      this,
      m00,
      m01,
      m02,
      m03,
      m10,
      m11,
      m12,
      m13,
      m20,
      m21,
      m22,
      m23,
      m30,
      m31,
      m32,
      m33
    );
  };
  mat4Extension.mat4_copy = function mat4_copy(matrix) {
    return Mat4Utils.copy(matrix, this);
  };
  mat4Extension.mat4_identity = function mat4_identity() {
    return Mat4Utils.identity(this);
  };
  mat4Extension.mat4_invert = function mat4_invert(out = Mat4Utils.create()) {
    return Mat4Utils.invert(this, out);
  };
  mat4Extension.mat4_mul = function mat4_mul(matrix, out = Mat4Utils.create()) {
    return Mat4Utils.mul(this, matrix, out);
  };
  mat4Extension.mat4_scale = function mat4_scale(vector, out = Mat4Utils.create()) {
    return Mat4Utils.scale(this, vector, out);
  };
  mat4Extension.mat4_clone = function mat4_clone(out = Mat4Utils.create()) {
    return Mat4Utils.clone(this, out);
  };
  mat4Extension.mat4_getPosition = function mat4_getPosition(out = Vec3Utils.create()) {
    return Mat4Utils.getPosition(this, out);
  };
  mat4Extension.mat4_getRotation = function mat4_getRotation(out = Vec3Utils.create()) {
    return Mat4Utils.getRotation(this, out);
  };
  mat4Extension.mat4_getRotationDegrees = function mat4_getRotationDegrees(out = Vec3Utils.create()) {
    return Mat4Utils.getRotationDegrees(this, out);
  };
  mat4Extension.mat4_getRotationRadians = function mat4_getRotationRadians(out = Vec3Utils.create()) {
    return Mat4Utils.getRotationRadians(this, out);
  };
  mat4Extension.mat4_getRotationQuat = function mat4_getRotationQuat(out = QuatUtils.create()) {
    return Mat4Utils.getRotationQuat(this, out);
  };
  mat4Extension.mat4_getScale = function mat4_getScale(out = Vec3Utils.create()) {
    return Mat4Utils.getScale(this, out);
  };
  mat4Extension.mat4_setPosition = function mat4_setPosition(position) {
    return Mat4Utils.setPosition(this, position);
  };
  mat4Extension.mat4_setRotation = function mat4_setRotation(rotation) {
    return Mat4Utils.setRotation(this, rotation);
  };
  mat4Extension.mat4_setRotationDegrees = function mat4_setRotationDegrees(rotation) {
    return Mat4Utils.setRotationDegrees(this, rotation);
  };
  mat4Extension.mat4_setRotationRadians = function mat4_setRotationRadians(rotation) {
    return Mat4Utils.setRotationRadians(this, rotation);
  };
  mat4Extension.mat4_setRotationQuat = function mat4_setRotationQuat(rotation) {
    return Mat4Utils.setRotationQuat(this, rotation);
  };
  mat4Extension.mat4_setScale = function mat4_setScale(scale11) {
    return Mat4Utils.setScale(this, scale11);
  };
  mat4Extension.mat4_setPositionRotationScale = function mat4_setPositionRotationScale(position, rotation, scale11) {
    return Mat4Utils.setPositionRotationScale(this, position, rotation, scale11);
  };
  mat4Extension.mat4_setPositionRotationDegreesScale = function mat4_setPositionRotationDegreesScale(position, rotation, scale11) {
    return Mat4Utils.setPositionRotationDegreesScale(this, position, rotation, scale11);
  };
  mat4Extension.mat4_setPositionRotationRadiansScale = function mat4_setPositionRotationRadiansScale(position, rotation, scale11) {
    return Mat4Utils.setPositionRotationRadiansScale(this, position, rotation, scale11);
  };
  mat4Extension.mat4_setPositionRotationQuatScale = function mat4_setPositionRotationQuatScale(position, rotation, scale11) {
    return Mat4Utils.setPositionRotationQuatScale(this, position, rotation, scale11);
  };
  mat4Extension.mat4_setPositionRotation = function mat4_setPositionRotation(position, rotation) {
    return Mat4Utils.setPositionRotation(this, position, rotation);
  };
  mat4Extension.mat4_setPositionRotationDegrees = function mat4_setPositionRotationDegrees(position, rotation) {
    return Mat4Utils.setPositionRotationDegrees(this, position, rotation);
  };
  mat4Extension.mat4_setPositionRotationRadians = function mat4_setPositionRotationRadians(position, rotation) {
    return Mat4Utils.setPositionRotationRadians(this, position, rotation);
  };
  mat4Extension.mat4_setPositionRotationQuat = function mat4_setPositionRotationQuat(position, rotation) {
    return Mat4Utils.setPositionRotationQuat(this, position, rotation);
  };
  mat4Extension.mat4_getAxes = function mat4_getAxes(out = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
    return Mat4Utils.getAxes(this, out);
  };
  mat4Extension.mat4_getForward = function mat4_getForward(out = Vec3Utils.create()) {
    return Mat4Utils.getForward(this, out);
  };
  mat4Extension.mat4_getBackward = function mat4_getBackward(out) {
    return Mat4Utils.getBackward(this, out);
  };
  mat4Extension.mat4_getLeft = function mat4_getLeft(out = Vec3Utils.create()) {
    return Mat4Utils.getLeft(this, out);
  };
  mat4Extension.mat4_getRight = function mat4_getRight(out) {
    return Mat4Utils.getRight(this, out);
  };
  mat4Extension.mat4_getUp = function mat4_getUp(out = Vec3Utils.create()) {
    return Mat4Utils.getUp(this, out);
  };
  mat4Extension.mat4_getDown = function mat4_getDown(out) {
    return Mat4Utils.getDown(this, out);
  };
  mat4Extension.mat4_toWorld = function mat4_toWorld(parentTransformMatrix, out = Mat4Utils.create()) {
    return Mat4Utils.toWorld(this, parentTransformMatrix, out);
  };
  mat4Extension.mat4_toLocal = function mat4_toLocal(parentTransformMatrix, out = Mat4Utils.create()) {
    return Mat4Utils.toLocal(this, parentTransformMatrix, out);
  };
  mat4Extension.mat4_hasUniformScale = function mat4_hasUniformScale() {
    return Mat4Utils.hasUniformScale(this);
  };
  mat4Extension.mat4_toQuat = function mat4_toQuat(out = Quat2Utils.create()) {
    return Mat4Utils.toQuat(this, out);
  };
  mat4Extension.mat4_fromQuat = function mat4_fromQuat(quat) {
    return Mat4Utils.fromQuat(quat, this);
  };
  let arrayPrototypesToExtend = [
    Array.prototype,
    Uint8ClampedArray.prototype,
    Uint8Array.prototype,
    Uint16Array.prototype,
    Uint32Array.prototype,
    Int8Array.prototype,
    Int16Array.prototype,
    Int32Array.prototype,
    Float32Array.prototype,
    Float64Array.prototype
  ];
  for (let arrayPrototypeToExtend of arrayPrototypesToExtend) {
    PluginUtils.injectProperties(arrayExtension, arrayPrototypeToExtend, false, true, true);
    PluginUtils.injectProperties(vecExtension, arrayPrototypeToExtend, false, true, true);
    PluginUtils.injectProperties(vec2Extension, arrayPrototypeToExtend, false, true, true);
    PluginUtils.injectProperties(vec3Extension, arrayPrototypeToExtend, false, true, true);
    PluginUtils.injectProperties(vec4Extension, arrayPrototypeToExtend, false, true, true);
    PluginUtils.injectProperties(quatExtension, arrayPrototypeToExtend, false, true, true);
    PluginUtils.injectProperties(quat2Extension, arrayPrototypeToExtend, false, true, true);
    PluginUtils.injectProperties(mat3Extension, arrayPrototypeToExtend, false, true, true);
    PluginUtils.injectProperties(mat4Extension, arrayPrototypeToExtend, false, true, true);
    PluginUtils.injectProperties(arrayExtension, arrayPrototypeToExtend, false, true, true);
  }
}

// js/pp/cauldron/utils/mesh_utils.js
var MeshCreationVertexParams = class {
  constructor() {
    this.myPosition = null;
    this.myTextureCoordinates = null;
    this.myNormal = null;
    this.myColor = null;
  }
};
var MeshCreationTriangleParams = class {
  constructor() {
    this.myIndexes = new Uint32Array(3);
  }
};
var MeshCreationParams = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this.myVertexes = [];
    this.myTriangles = [];
    this.myEngine = engine2;
  }
};
function create15(meshCreationParams) {
  let indexData = [];
  for (let triangle of meshCreationParams.myTriangles) {
    indexData.push(triangle.myIndexes[0]);
    indexData.push(triangle.myIndexes[1]);
    indexData.push(triangle.myIndexes[2]);
  }
  let indexDataUnsignedInt = new Uint32Array(indexData.length);
  indexDataUnsignedInt.pp_copy(indexData);
  let vertexCount = meshCreationParams.myVertexes.length;
  let mesh = new Mesh(meshCreationParams.myEngine, {
    vertexCount,
    indexData: indexDataUnsignedInt,
    indexType: MeshIndexType.UnsignedInt
  });
  let positionAttribute = null;
  let textureCoordinatesAttribute = null;
  let normalAttribute = null;
  let colorAttribute = null;
  try {
    positionAttribute = mesh.attribute(MeshAttribute.Position);
  } catch (error3) {
    positionAttribute = null;
  }
  try {
    textureCoordinatesAttribute = mesh.attribute(MeshAttribute.TextureCoordinate);
  } catch (error3) {
    textureCoordinatesAttribute = null;
  }
  try {
    normalAttribute = mesh.attribute(MeshAttribute.Normal);
  } catch (error3) {
    normalAttribute = null;
  }
  try {
    colorAttribute = mesh.attribute(MeshAttribute.Color);
  } catch (error3) {
    colorAttribute = null;
  }
  for (let i = 0; i < meshCreationParams.myVertexes.length; i++) {
    let vertex = meshCreationParams.myVertexes[i];
    if (positionAttribute != null && vertex.myPosition) {
      positionAttribute.set(i, vertex.myPosition);
    }
    if (textureCoordinatesAttribute != null && vertex.myTextureCoordinates) {
      textureCoordinatesAttribute.set(i, vertex.myTextureCoordinates);
    }
    if (normalAttribute != null && vertex.myNormal) {
      normalAttribute.set(i, vertex.myNormal);
    }
    if (colorAttribute != null && vertex.myColor) {
      colorAttribute.set(i, vertex.myColor);
    }
  }
  return mesh;
}
var clone15 = function() {
  let position = vec3_create();
  let textureCoordinates = vec2_create();
  let normal2 = vec3_create();
  let color = vec4_create();
  return function clone17(mesh) {
    if (mesh == null) {
      return null;
    }
    let clonedIndexData = mesh.indexData.pp_clone();
    let clonedMesh = new Mesh(mesh.engine, {
      vertexCount: mesh.vertexCount,
      indexData: clonedIndexData,
      indexType: MeshIndexType.UnsignedInt
    });
    let positionAttribute = null;
    let textureCoordinatesAttribute = null;
    let normalAttribute = null;
    let colorAttribute = null;
    let clonedPositionAttribute = null;
    let clonedTextureCoordinatesAttribute = null;
    let clonedNormalAttribute = null;
    let clonedColorAttribute = null;
    try {
      positionAttribute = mesh.attribute(MeshAttribute.Position);
      clonedPositionAttribute = clonedMesh.attribute(MeshAttribute.Position);
    } catch (error3) {
      positionAttribute = null;
      clonedPositionAttribute = null;
    }
    try {
      textureCoordinatesAttribute = mesh.attribute(MeshAttribute.TextureCoordinate);
      clonedTextureCoordinatesAttribute = clonedMesh.attribute(MeshAttribute.TextureCoordinate);
    } catch (error3) {
      textureCoordinatesAttribute = null;
      clonedTextureCoordinatesAttribute = null;
    }
    try {
      normalAttribute = mesh.attribute(MeshAttribute.Normal);
      clonedNormalAttribute = clonedMesh.attribute(MeshAttribute.Normal);
    } catch (error3) {
      normalAttribute = null;
      clonedNormalAttribute = null;
    }
    try {
      colorAttribute = mesh.attribute(MeshAttribute.Color);
      clonedColorAttribute = clonedMesh.attribute(MeshAttribute.Color);
    } catch (error3) {
      colorAttribute = null;
      clonedColorAttribute = null;
    }
    for (let i = 0; i < mesh.vertexCount; i++) {
      if (positionAttribute != null && clonedPositionAttribute != null) {
        clonedPositionAttribute.set(i, positionAttribute.get(i, position));
      }
      if (textureCoordinatesAttribute != null && clonedTextureCoordinatesAttribute != null) {
        clonedTextureCoordinatesAttribute.set(i, textureCoordinatesAttribute.get(i, textureCoordinates));
      }
      if (normalAttribute != null && clonedNormalAttribute != null) {
        clonedNormalAttribute.set(i, normalAttribute.get(i, normal2));
      }
      if (colorAttribute != null && clonedColorAttribute != null) {
        clonedColorAttribute.set(i, colorAttribute.get(i, color));
      }
    }
    return clonedMesh;
  };
}();
var invert8 = function() {
  let position = vec3_create();
  let textureCoordinates = vec2_create();
  let normal2 = vec3_create();
  let color = vec4_create();
  return function invert9(mesh) {
    if (mesh == null) {
      return null;
    }
    let invertedIndexData = new Uint32Array(mesh.indexData.length);
    for (let i = 0; i < mesh.indexData.length / 3; i++) {
      invertedIndexData[i * 3 + 0] = mesh.indexData[i * 3 + 2];
      invertedIndexData[i * 3 + 1] = mesh.indexData[i * 3 + 1];
      invertedIndexData[i * 3 + 2] = mesh.indexData[i * 3 + 0];
    }
    let invertedMesh = new Mesh(mesh.engine, {
      vertexCount: mesh.vertexCount,
      indexData: invertedIndexData,
      indexType: MeshIndexType.UnsignedInt
    });
    let positionAttribute = null;
    let textureCoordinatesAttribute = null;
    let normalAttribute = null;
    let colorAttribute = null;
    let invertedPositionAttribute = null;
    let invertedTextureCoordinatesAttribute = null;
    let invertedNormalAttribute = null;
    let invertedColorAttribute = null;
    try {
      positionAttribute = mesh.attribute(MeshAttribute.Position);
      invertedPositionAttribute = invertedMesh.attribute(MeshAttribute.Position);
    } catch (error3) {
      positionAttribute = null;
      invertedPositionAttribute = null;
    }
    try {
      textureCoordinatesAttribute = mesh.attribute(MeshAttribute.TextureCoordinate);
      invertedTextureCoordinatesAttribute = invertedMesh.attribute(MeshAttribute.TextureCoordinate);
    } catch (error3) {
      textureCoordinatesAttribute = null;
      invertedTextureCoordinatesAttribute = null;
    }
    try {
      normalAttribute = mesh.attribute(MeshAttribute.Normal);
      invertedNormalAttribute = invertedMesh.attribute(MeshAttribute.Normal);
    } catch (error3) {
      normalAttribute = null;
      invertedNormalAttribute = null;
    }
    try {
      colorAttribute = mesh.attribute(MeshAttribute.Color);
      invertedColorAttribute = invertedMesh.attribute(MeshAttribute.Color);
    } catch (error3) {
      colorAttribute = null;
      invertedColorAttribute = null;
    }
    for (let i = 0; i < mesh.vertexCount; i++) {
      if (positionAttribute != null && invertedPositionAttribute != null) {
        invertedPositionAttribute.set(i, positionAttribute.get(i, position));
      }
      if (textureCoordinatesAttribute != null && invertedTextureCoordinatesAttribute != null) {
        invertedTextureCoordinatesAttribute.set(i, textureCoordinatesAttribute.get(i, textureCoordinates));
      }
      if (normalAttribute != null && invertedNormalAttribute != null) {
        normalAttribute.get(i, normal2);
        normal2.vec3_negate(normal2);
        invertedNormalAttribute.set(i, normal2);
      }
      if (colorAttribute != null && invertedColorAttribute != null) {
        invertedColorAttribute.set(i, colorAttribute.get(i, color));
      }
    }
    return invertedMesh;
  };
}();
var makeDoubleSided = function() {
  let position = vec3_create();
  let textureCoordinates = vec2_create();
  let normal2 = vec3_create();
  let color = vec4_create();
  return function makeDoubleSided2(mesh) {
    if (mesh == null) {
      return null;
    }
    let doubleSidedIndexData = new Uint32Array(mesh.indexData.length * 2);
    for (let i = 0; i < doubleSidedIndexData.length / 3; i++) {
      doubleSidedIndexData[i * 3 * 2 + 0] = mesh.indexData[i * 3 + 0] * 2;
      doubleSidedIndexData[i * 3 * 2 + 1] = mesh.indexData[i * 3 + 1] * 2;
      doubleSidedIndexData[i * 3 * 2 + 2] = mesh.indexData[i * 3 + 2] * 2;
      doubleSidedIndexData[i * 3 * 2 + 3] = mesh.indexData[i * 3 + 2] * 2 + 1;
      doubleSidedIndexData[i * 3 * 2 + 4] = mesh.indexData[i * 3 + 1] * 2 + 1;
      doubleSidedIndexData[i * 3 * 2 + 5] = mesh.indexData[i * 3 + 0] * 2 + 1;
    }
    let doubleSidedMesh = new Mesh(mesh.engine, {
      vertexCount: mesh.vertexCount * 2,
      indexData: doubleSidedIndexData,
      indexType: MeshIndexType.UnsignedInt
    });
    let positionAttribute = null;
    let textureCoordinatesAttribute = null;
    let normalAttribute = null;
    let colorAttribute = null;
    let doubleSidedPositionAttribute = null;
    let doubleSidedTextureCoordinatesAttribute = null;
    let doubleSidedNormalAttribute = null;
    let doubleSidedColorAttribute = null;
    try {
      positionAttribute = mesh.attribute(MeshAttribute.Position);
      doubleSidedPositionAttribute = doubleSidedMesh.attribute(MeshAttribute.Position);
    } catch (error3) {
      positionAttribute = null;
      doubleSidedPositionAttribute = null;
    }
    try {
      textureCoordinatesAttribute = mesh.attribute(MeshAttribute.TextureCoordinate);
      doubleSidedTextureCoordinatesAttribute = doubleSidedMesh.attribute(MeshAttribute.TextureCoordinate);
    } catch (error3) {
      textureCoordinatesAttribute = null;
      doubleSidedTextureCoordinatesAttribute = null;
    }
    try {
      normalAttribute = mesh.attribute(MeshAttribute.Normal);
      doubleSidedNormalAttribute = doubleSidedMesh.attribute(MeshAttribute.Normal);
    } catch (error3) {
      normalAttribute = null;
      doubleSidedNormalAttribute = null;
    }
    try {
      colorAttribute = mesh.attribute(MeshAttribute.Color);
      doubleSidedColorAttribute = doubleSidedMesh.attribute(MeshAttribute.Color);
    } catch (error3) {
      colorAttribute = null;
      doubleSidedColorAttribute = null;
    }
    for (let i = 0; i < mesh.vertexCount; i++) {
      if (positionAttribute != null && doubleSidedPositionAttribute != null) {
        doubleSidedPositionAttribute.set(i * 2, positionAttribute.get(i, position));
        doubleSidedPositionAttribute.set(i * 2 + 1, positionAttribute.get(i, position));
      }
      if (textureCoordinatesAttribute != null && doubleSidedTextureCoordinatesAttribute != null) {
        doubleSidedTextureCoordinatesAttribute.set(i * 2, textureCoordinatesAttribute.get(i, textureCoordinates));
        doubleSidedTextureCoordinatesAttribute.set(i * 2 + 1, textureCoordinatesAttribute.get(i, textureCoordinates));
      }
      if (normalAttribute != null && doubleSidedNormalAttribute != null) {
        normalAttribute.get(i, normal2);
        doubleSidedNormalAttribute.set(i * 2, normal2);
        let invertedNormal = normal2.vec3_negate();
        doubleSidedNormalAttribute.set(i * 2 + 1, invertedNormal);
      }
      if (colorAttribute != null && doubleSidedColorAttribute != null) {
        doubleSidedColorAttribute.set(i * 2, colorAttribute.get(i, color));
        doubleSidedColorAttribute.set(i * 2 + 1, colorAttribute.get(i, color));
      }
    }
    return doubleSidedMesh;
  };
}();
function createPlane(engine2 = Globals.getMainEngine()) {
  let vertexCount = 4;
  let meshCreationParams = new MeshCreationParams(engine2);
  for (let i = 0; i < vertexCount; ++i) {
    let vertexCreationParams = new MeshCreationVertexParams();
    vertexCreationParams.myPosition = new vec3_create();
    vertexCreationParams.myPosition[0] = -1 + (i & 1) * 2;
    vertexCreationParams.myPosition[1] = -1 + ((i & 2) >> 1) * 2;
    vertexCreationParams.myPosition[2] = 0;
    vertexCreationParams.myTextureCoordinates = new vec2_create();
    vertexCreationParams.myTextureCoordinates[0] = i & 1;
    vertexCreationParams.myTextureCoordinates[1] = (i & 2) >> 1;
    vertexCreationParams.myNormal = new vec3_create();
    vertexCreationParams.myNormal[0] = 0;
    vertexCreationParams.myNormal[1] = 0;
    vertexCreationParams.myNormal[2] = 1;
    meshCreationParams.myVertexes.push(vertexCreationParams);
  }
  let firstTriangle = new MeshCreationTriangleParams();
  firstTriangle.myIndexes[0] = 0;
  firstTriangle.myIndexes[1] = 1;
  firstTriangle.myIndexes[2] = 2;
  let secondTriangle = new MeshCreationTriangleParams();
  secondTriangle.myIndexes[0] = 2;
  secondTriangle.myIndexes[1] = 1;
  secondTriangle.myIndexes[2] = 3;
  meshCreationParams.myTriangles.push(firstTriangle);
  meshCreationParams.myTriangles.push(secondTriangle);
  let mesh = MeshUtils.create(meshCreationParams);
  return mesh;
}
var MeshUtils = {
  create: create15,
  clone: clone15,
  invert: invert8,
  makeDoubleSided,
  createPlane
};

// js/pp/cauldron/wl/utils/default_wl_component_clone_callbacks.js
function cloneMesh(componentToClone, targetObject, deepCloneParams = new DeepCloneParams(), customCloneParams = null) {
  let clonedComponent = ComponentUtils.cloneDefault(componentToClone, targetObject, true);
  if (deepCloneParams.isDeepCloneComponentVariable(MeshComponent.TypeName, "material")) {
    clonedComponent.material = componentToClone.material.clone();
  }
  if (deepCloneParams.isDeepCloneComponentVariable(MeshComponent.TypeName, "mesh")) {
    clonedComponent.mesh = MeshUtils.clone(componentToClone.mesh);
  }
  return clonedComponent;
}
function cloneCollision(componentToClone, targetObject, deepCloneParams = new DeepCloneParams(), customCloneParams = null) {
  let clonedComponent = ComponentUtils.cloneDefault(componentToClone, targetObject);
  return clonedComponent;
}
function cloneText(componentToClone, targetObject, deepCloneParams = new DeepCloneParams(), customCloneParams = null) {
  let clonedComponent = ComponentUtils.cloneDefault(componentToClone, targetObject);
  if (deepCloneParams.isDeepCloneComponentVariable(TextComponent.TypeName, "material")) {
    clonedComponent.material = componentToClone.material.clone();
  }
  return clonedComponent;
}
function clonePhysX(componentToClone, targetObject, deepCloneParams = new DeepCloneParams(), customCloneParams = null) {
  let clonedComponent = ComponentUtils.cloneDefault(componentToClone, targetObject);
  return clonedComponent;
}
var DefaultWLComponentCloneCallbacks = {
  cloneMesh,
  cloneCollision,
  cloneText,
  clonePhysX
};

// js/pp/cauldron/wl/utils/component_utils.js
var _myCloneCallbacks = /* @__PURE__ */ new WeakMap();
var _myClonePostProcessCallbacks = /* @__PURE__ */ new WeakMap();
var DeepCloneParams = class {
  constructor() {
    this._myDeepCloneComponents = false;
    this._myDeepCloneOverrideComponentsMap = /* @__PURE__ */ new Map();
    this._myDeepCloneOverrideComponentsVariablesMap = /* @__PURE__ */ new Map();
  }
  // The implementation is component dependant, not every component implements the deep clone
  setDeepCloneComponents(deepClone) {
    this._myDeepCloneComponents = deepClone;
  }
  // This value override the deep clone components value
  // The implementation is component dependant, not every component implements the deep clone
  setDeepCloneComponent(componentName, deepClone) {
    this._myDeepCloneOverrideComponentsMap.set(componentName, deepClone);
  }
  // This value override both the deep clone components value and the deep clone component override one
  // The implementation is component dependant, not every component variable override is taken into consideration
  setDeepCloneComponentVariable(componentName, variableName, deepClone) {
    let componentsVariablesMap = null;
    if (!this._myDeepCloneOverrideComponentsVariablesMap.has(componentName)) {
      this._myDeepCloneOverrideComponentsVariablesMap.set(componentName, /* @__PURE__ */ new Map());
    }
    componentsVariablesMap = this._myDeepCloneOverrideComponentsVariablesMap.get(componentName);
    componentsVariablesMap.set(variableName, deepClone);
  }
  isDeepCloneComponent(componentName) {
    let deepCloneOverride = this._myDeepCloneOverrideComponentsMap.get(componentName);
    if (deepCloneOverride != null) {
      return deepCloneOverride;
    }
    return this._myDeepCloneComponents;
  }
  isDeepCloneComponentVariable(componentName, variableName) {
    let componentsVariablesMap = this._myDeepCloneOverrideComponentsVariablesMap.get(componentName);
    if (componentsVariablesMap != null) {
      let deepCloneOverride = componentsVariablesMap.get(variableName);
      if (deepCloneOverride != null) {
        return deepCloneOverride;
      }
    }
    return this.isDeepCloneComponent(componentName);
  }
};
var CustomCloneParams = class {
  constructor() {
    this._myParams = /* @__PURE__ */ new Map();
  }
  addParam(name, value) {
    this._myParams.set(name, value);
  }
  removeParam(name) {
    this._myParams.delete(name);
  }
  getParam(name) {
    this._myParams.get(name);
  }
  hasParam(name) {
    this._myParams.has(name);
  }
};
function isWLComponent(typeOrClass) {
  return ComponentUtils.isWLNativeComponent(typeOrClass) || ComponentUtils.isWLJavascriptComponent(typeOrClass);
}
function isWLNativeComponent(typeOrClass) {
  let wlNative = false;
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  if (ComponentUtils.getWLNativeComponentTypes().includes(type)) {
    wlNative = true;
  }
  return wlNative;
}
function isWLJavascriptComponent(typeOrClass) {
  let wlJavascript = false;
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  if (ComponentUtils.getWLJavascriptComponentTypes().includes(type)) {
    wlJavascript = true;
  }
  return wlJavascript;
}
function getWLNativeComponentTypes() {
  return _myWLNativeComponentTypes;
}
function getWLJavascriptComponentTypes() {
  return _myWLJavascriptComponentTypes;
}
function getTypeFromTypeOrClass(typeOrClass) {
  if (typeOrClass == null)
    return;
  let type = typeOrClass;
  if (typeOrClass.TypeName != null) {
    type = typeOrClass.TypeName;
  }
  return type;
}
function getClassFromType(type, engine2 = Globals.getMainEngine()) {
  let classToReturn = null;
  if (ComponentUtils.isWLNativeComponent(type)) {
    if (ComponentUtils.isWLNativeComponentRegistered(type, engine2)) {
      switch (type) {
        case AnimationComponent.TypeName:
          classToReturn = AnimationComponent;
          break;
        case CollisionComponent.TypeName:
          classToReturn = CollisionComponent;
          break;
        case InputComponent.TypeName:
          classToReturn = InputComponent;
          break;
        case LightComponent.TypeName:
          classToReturn = LightComponent;
          break;
        case MeshComponent.TypeName:
          classToReturn = MeshComponent;
          break;
        case PhysXComponent.TypeName:
          classToReturn = PhysXComponent;
          break;
        case TextComponent.TypeName:
          classToReturn = TextComponent;
          break;
        case ViewComponent.TypeName:
          classToReturn = ViewComponent;
          break;
        default:
          classToReturn = null;
      }
    }
  } else {
    classToReturn = ComponentUtils.getJavascriptComponentClass(type, engine2);
  }
  return classToReturn;
}
function isRegistered(typeOrClass, engine2 = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  return ComponentUtils.getClassFromType(type, engine2) != null;
}
function getJavascriptComponentInstances(engine2 = Globals.getMainEngine()) {
  return Globals.getWASM(engine2)._components;
}
function getJavascriptComponentClass(type, engine2 = Globals.getMainEngine()) {
  return ComponentUtils.getJavascriptComponentClassesByIndex(engine2)[ComponentUtils.getJavascriptComponentTypeIndex(type, engine2)];
}
function getJavascriptComponentClassesByIndex(engine2 = Globals.getMainEngine()) {
  return Globals.getWASM(engine2)._componentTypes;
}
function getJavascriptComponentTypeIndex(typeOrClass, engine2 = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  return ComponentUtils.getJavascriptComponentTypeIndexes(engine2)[type];
}
function getJavascriptComponentTypeIndexes(engine2 = Globals.getMainEngine()) {
  return Globals.getWASM(engine2)._componentTypeIndices;
}
function getJavascriptComponentTypeFromIndex(typeIndex, engine2 = Globals.getMainEngine()) {
  let type = null;
  let componentClass = ComponentUtils.getJavascriptComponentClassesByIndex(engine2)[typeIndex];
  if (componentClass != null) {
    type = componentClass.TypeName;
  }
  return type;
}
function isWLNativeComponentRegistered(typeOrClass, engine2 = Globals.getMainEngine()) {
  let wasm = Globals.getWASM(engine2);
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  return wasm._wl_get_component_manager_index(wasm.tempUTF8(type)) >= 0;
}
function isCloneable2(typeOrClass, defaultCloneValid = false, engine2 = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  return defaultCloneValid || ComponentUtils.hasCloneCallback(type, engine2) || ComponentUtils.getClassFromType(type, engine2)?.prototype.pp_clone != null;
}
function hasClonePostProcess(typeOrClass, engine2 = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  return ComponentUtils.hasClonePostProcessCallback(type, engine2) || ComponentUtils.getClassFromType(type, engine2)?.prototype.pp_clonePostProcess != null;
}
function clone16(componentToClone, targetObject, deeCloneParams, customCloneParams, useDefaultCloneAsFallback = false, defaultCloneAutoStartIfNotActive = true) {
  let clonedComponent = null;
  let cloneCallback = ComponentUtils.getCloneCallback(componentToClone.type, ObjectUtils.getEngine(componentToClone.object));
  if (cloneCallback != null) {
    clonedComponent = cloneCallback(componentToClone, targetObject, deeCloneParams, customCloneParams);
  } else if (componentToClone.pp_clone != null) {
    clonedComponent = componentToClone.pp_clone(targetObject, deeCloneParams, customCloneParams);
  } else if (useDefaultCloneAsFallback) {
    clonedComponent = ComponentUtils.cloneDefault(componentToClone, targetObject, defaultCloneAutoStartIfNotActive);
  }
  return clonedComponent;
}
function clonePostProcess(componentToClone, clonedComponent, deeCloneParams, customCloneParams) {
  let clonePostProcessCallback = ComponentUtils.getClonePostProcessCallback(componentToClone.type, ObjectUtils.getEngine(componentToClone.object));
  if (clonePostProcessCallback != null) {
    clonePostProcessCallback(componentToClone, clonedComponent, deeCloneParams, customCloneParams);
  } else if (componentToClone.pp_clonePostProcess != null) {
    componentToClone.pp_clonePostProcess(clonedComponent, deeCloneParams, customCloneParams);
  }
  return clonedComponent;
}
function cloneDefault(componentToClone, targetObject, autoStartIfNotActive = true) {
  let clonedComponent = ObjectUtils.addComponent(targetObject, componentToClone.type, componentToClone);
  if (autoStartIfNotActive && !clonedComponent.active) {
    clonedComponent.active = true;
    clonedComponent.active = false;
  }
  return clonedComponent;
}
function setCloneCallback(typeOrClass, callback, engine2 = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  if (!_myCloneCallbacks.has(engine2)) {
    _myCloneCallbacks.set(engine2, /* @__PURE__ */ new Map());
  }
  _myCloneCallbacks.get(engine2).set(type, callback);
}
function removeCloneCallback(typeOrClass, engine2 = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  if (_myCloneCallbacks.has(engine2)) {
    _myCloneCallbacks.get(engine2).delete(type);
  }
}
function getCloneCallback(typeOrClass, engine2 = Globals.getMainEngine()) {
  let callback = null;
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  if (_myCloneCallbacks.has(engine2)) {
    callback = _myCloneCallbacks.get(engine2).get(type);
  }
  return callback;
}
function hasCloneCallback(typeOrClass, engine2 = Globals.getMainEngine()) {
  let hasCallback = false;
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  if (_myCloneCallbacks.has(engine2)) {
    hasCallback = _myCloneCallbacks.get(engine2).has(type);
  }
  return hasCallback;
}
function setClonePostProcessCallback(typeOrClass, callback, engine2 = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  if (!_myClonePostProcessCallbacks.has(engine2)) {
    _myClonePostProcessCallbacks.set(engine2, /* @__PURE__ */ new Map());
  }
  _myClonePostProcessCallbacks.get(engine2).set(type, callback);
}
function removeClonePostProcessCallback(typeOrClass, engine2 = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  if (_myClonePostProcessCallbacks.has(engine2)) {
    _myClonePostProcessCallbacks.get(engine2).delete(type);
  }
}
function getClonePostProcessCallback(typeOrClass, engine2 = Globals.getMainEngine()) {
  let callback = null;
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  if (_myClonePostProcessCallbacks.has(engine2)) {
    callback = _myClonePostProcessCallbacks.get(engine2).get(type);
  }
  return callback;
}
function hasClonePostProcessCallback(typeOrClass, engine2 = Globals.getMainEngine()) {
  let hasCallback = false;
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  if (_myClonePostProcessCallbacks.has(engine2)) {
    hasCallback = _myClonePostProcessCallbacks.get(engine2).has(type);
  }
  return hasCallback;
}
function getDefaultWLComponentCloneCallback(typeOrClass) {
  let callback = null;
  let type = ComponentUtils.getTypeFromTypeOrClass(typeOrClass);
  switch (type) {
    case MeshComponent.TypeName:
      callback = DefaultWLComponentCloneCallbacks.cloneMesh;
      break;
    case CollisionComponent.TypeName:
      callback = DefaultWLComponentCloneCallbacks.cloneCollision;
      break;
    case TextComponent.TypeName:
      callback = DefaultWLComponentCloneCallbacks.cloneText;
      break;
    case PhysXComponent.TypeName:
      callback = DefaultWLComponentCloneCallbacks.clonePhysX;
      break;
    default:
      callback = null;
  }
  return callback;
}
function hasDefaultWLComponentCloneCallback(typeOrClass) {
  return ComponentUtils.getDefaultWLComponentCloneCallback(typeOrClass) != null;
}
function setDefaultWLComponentCloneCallbacks(engine2 = Globals.getMainEngine()) {
  for (let nativeType of ComponentUtils.getWLNativeComponentTypes()) {
    let cloneCallback = ComponentUtils.getDefaultWLComponentCloneCallback(nativeType);
    if (cloneCallback != null) {
      ComponentUtils.setCloneCallback(nativeType, cloneCallback, engine2);
    }
  }
  for (let javascriptType of ComponentUtils.getWLJavascriptComponentTypes()) {
    let cloneCallback = ComponentUtils.getDefaultWLComponentCloneCallback(javascriptType);
    if (cloneCallback != null) {
      ComponentUtils.setCloneCallback(javascriptType, cloneCallback, engine2);
    }
  }
}
function removeDefaultWLComponentCloneCallbacks(engine2 = Globals.getMainEngine()) {
  for (let nativeType of ComponentUtils.getWLNativeComponentTypes()) {
    let cloneCallback = ComponentUtils.getDefaultWLComponentCloneCallback(nativeType);
    if (cloneCallback != null) {
      if (ComponentUtils.getCloneCallback(nativeType, engine2) == cloneCallback) {
        ComponentUtils.removeCloneCallback(nativeType, engine2);
      }
    }
  }
  for (let javascriptType of ComponentUtils.getWLNativeComponentTypes()) {
    let cloneCallback = ComponentUtils.getDefaultWLComponentCloneCallback(javascriptType);
    if (cloneCallback != null) {
      if (ComponentUtils.getCloneCallback(javascriptType, engine2) == cloneCallback) {
        ComponentUtils.removeCloneCallback(javascriptType, engine2);
      }
    }
  }
}
var ComponentUtils = {
  isWLComponent,
  isWLNativeComponent,
  isWLJavascriptComponent,
  getWLNativeComponentTypes,
  getWLJavascriptComponentTypes,
  getTypeFromTypeOrClass,
  getClassFromType,
  isRegistered,
  getJavascriptComponentInstances,
  getJavascriptComponentClass,
  getJavascriptComponentClassesByIndex,
  getJavascriptComponentTypeIndex,
  getJavascriptComponentTypeIndexes,
  getJavascriptComponentTypeFromIndex,
  isWLNativeComponentRegistered,
  isCloneable: isCloneable2,
  hasClonePostProcess,
  clone: clone16,
  clonePostProcess,
  cloneDefault,
  setCloneCallback,
  removeCloneCallback,
  getCloneCallback,
  hasCloneCallback,
  setClonePostProcessCallback,
  removeClonePostProcessCallback,
  getClonePostProcessCallback,
  hasClonePostProcessCallback,
  setDefaultWLComponentCloneCallbacks,
  removeDefaultWLComponentCloneCallbacks,
  getDefaultWLComponentCloneCallback,
  hasDefaultWLComponentCloneCallback
};
var _myWLNativeComponentTypes = [
  AnimationComponent.TypeName,
  CollisionComponent.TypeName,
  InputComponent.TypeName,
  LightComponent.TypeName,
  MeshComponent.TypeName,
  PhysXComponent.TypeName,
  TextComponent.TypeName,
  ViewComponent.TypeName
];
var _myWLJavascriptComponentTypes = [
  ARCamera8thwall.TypeName,
  Anchor.TypeName,
  Cursor.TypeName,
  CursorTarget.TypeName,
  DebugObject.TypeName,
  DeviceOrientationLook.TypeName,
  FingerCursor.TypeName,
  FixedFoveation.TypeName,
  HandTracking.TypeName,
  HitTestLocation.TypeName,
  HowlerAudioListener.TypeName,
  HowlerAudioSource.TypeName,
  ImageTexture.TypeName,
  MouseLookComponent.TypeName,
  PlaneDetection.TypeName,
  PlayerHeight.TypeName,
  TargetFramerate.TypeName,
  TeleportComponent.TypeName,
  Trail.TypeName,
  TwoJointIkSolver.TypeName,
  VideoTexture.TypeName,
  VrModeActiveSwitch.TypeName,
  Vrm.TypeName,
  WasdControlsComponent.TypeName
];

// js/pp/plugin/js/extensions/math_extension.js
function initMathExtension() {
  initMathExtensionStatic();
}
function initMathExtensionStatic() {
  let mathExtension = {};
  Object.defineProperty(mathExtension, "PP_EPSILON", {
    get() {
      return MathUtils.EPSILON;
    },
    set(value) {
      MathUtils.EPSILON = value;
    }
  });
  Object.defineProperty(mathExtension, "PP_EPSILON_SQUARED", {
    get() {
      return MathUtils.EPSILON_SQUARED;
    },
    set(value) {
      MathUtils.EPSILON = value;
    }
  });
  Object.defineProperty(mathExtension, "PP_EPSILON_DEGREES", {
    get() {
      return MathUtils.EPSILON_DEGREES;
    },
    set(value) {
      MathUtils.EPSILON = value;
    }
  });
  mathExtension.pp_clamp = function pp_clamp(value, start, end) {
    return MathUtils.clamp(value, start, end);
  };
  mathExtension.pp_sign = function pp_sign(value, zeroSign = 1) {
    return MathUtils.sign(value, zeroSign);
  };
  mathExtension.pp_toDegrees = function pp_toDegrees(angle4) {
    return MathUtils.toDegrees(angle4);
  };
  mathExtension.pp_toRadians = function pp_toRadians(angle4) {
    return MathUtils.toRadians(angle4);
  };
  mathExtension.pp_roundDecimal = function pp_roundDecimal(number, decimalPlaces) {
    return MathUtils.roundDecimal(number, decimalPlaces);
  };
  mathExtension.pp_mapToRange = function pp_mapToRange(value, originRangeStart, originRangeEnd, newRangeStart, newRangeEnd) {
    return MathUtils.mapToRange(value, originRangeStart, originRangeEnd, newRangeStart, newRangeEnd);
  };
  mathExtension.pp_random = function pp_random(start = 0, end = 1) {
    return MathUtils.random(start, end);
  };
  mathExtension.pp_randomInt = function pp_randomInt(start, end) {
    return MathUtils.randomInt(start, end);
  };
  mathExtension.pp_randomBool = function pp_randomBool() {
    return MathUtils.randomBool();
  };
  mathExtension.pp_randomSign = function pp_randomSign() {
    return MathUtils.randomSign();
  };
  mathExtension.pp_randomPick = function pp_randomPick(...args) {
    return MathUtils.randomPick(...args);
  };
  mathExtension.pp_randomUUID = function pp_randomUUID() {
    return MathUtils.randomUUID();
  };
  mathExtension.pp_lerp = function pp_lerp(from, to, interpolationFactor) {
    return MathUtils.lerp(from, to, interpolationFactor);
  };
  mathExtension.pp_interpolate = function pp_interpolate(from, to, interpolationFactor, easingFunction = EasingFunction.linear) {
    return MathUtils.interpolate(from, to, interpolationFactor, easingFunction);
  };
  mathExtension.pp_angleDistance = function pp_angleDistance(from, to) {
    return MathUtils.angleDistance(from, to);
  };
  mathExtension.pp_angleDistanceDegrees = function pp_angleDistanceDegrees(from, to) {
    return MathUtils.angleDistanceDegrees(from, to);
  };
  mathExtension.pp_angleDistanceRadians = function pp_angleDistanceRadians(from, to) {
    return MathUtils.angleDistanceRadians(from, to);
  };
  mathExtension.pp_angleDistanceSigned = function pp_angleDistanceSigned(from, to) {
    return MathUtils.angleDistanceSigned(from, to);
  };
  mathExtension.pp_angleDistanceSignedDegrees = function pp_angleDistanceSignedDegrees(from, to) {
    return MathUtils.angleDistanceSignedDegrees(from, to);
  };
  mathExtension.pp_angleDistanceSignedRadians = function pp_angleDistanceSignedRadians(from, to) {
    return MathUtils.angleDistanceSignedRadians(from, to);
  };
  mathExtension.pp_angleClamp = function pp_angleClamp(angle4, usePositiveRange = false) {
    return MathUtils.angleClamp(angle4, usePositiveRange);
  };
  mathExtension.pp_angleClampDegrees = function pp_angleClampDegrees(angle4, usePositiveRange = false) {
    return MathUtils.angleClampDegrees(angle4, usePositiveRange);
  };
  mathExtension.pp_angleClampRadians = function pp_angleClampRadians(angle4, usePositiveRange = false) {
    return MathUtils.angleClampRadians(angle4, usePositiveRange);
  };
  mathExtension.pp_isInsideAngleRange = function pp_isInsideAngleRange(angle4, start, end, useShortestAngle = false) {
    return MathUtils.isInsideAngleRange(angle4, start, end, useShortestAngle);
  };
  mathExtension.pp_isInsideAngleRangeDegrees = function pp_isInsideAngleRangeDegrees(angle4, start, end, useShortestAngle = false) {
    return MathUtils.isInsideAngleRangeDegrees(angle4, start, end, useShortestAngle);
  };
  mathExtension.pp_isInsideAngleRangeRadians = function pp_isInsideAngleRangeRadians(angle4, start, end, useShortestAngle = false) {
    return MathUtils.isInsideAngleRangeRadians(angle4, start, end, useShortestAngle);
  };
  PluginUtils.injectProperties(mathExtension, Math, false, true, true);
}

// js/pp/plugin/js/extensions/number_extension.js
function initNumberExtension(engine2) {
  initNumberExtensionPrototype();
}
function initNumberExtensionPrototype() {
  let numberExtension = {};
  numberExtension.get = function get() {
    return this.valueOf();
  };
  PluginUtils.injectProperties(numberExtension, Number.prototype, false, true, true);
}

// js/pp/plugin/js/extensions/init_js_extentions.js
function initJSExtensions() {
  initMathExtension();
  initArrayExtension();
  initNumberExtension();
}

// js/pp/plugin/js/init_js_plugins.js
function initJSPlugins(engine2) {
  initJSExtensions(engine2);
}

// js/pp/plugin/wl/extensions/object_extension.js
function initObjectExtension() {
  initObjectExtensionProtoype();
}
function initObjectExtensionProtoype() {
  let objectExtension = {};
  objectExtension.pp_getPosition = function pp_getPosition(position) {
    return ObjectUtils.getPosition(this, position);
  };
  objectExtension.pp_getPositionWorld = function pp_getPositionWorld(position = Vec3Utils.create()) {
    return ObjectUtils.getPositionWorld(this, position);
  };
  objectExtension.pp_getPositionLocal = function pp_getPositionLocal(position = Vec3Utils.create()) {
    return ObjectUtils.getPositionLocal(this, position);
  };
  objectExtension.pp_getRotation = function pp_getRotation(rotation) {
    return ObjectUtils.getRotation(this, rotation);
  };
  objectExtension.pp_getRotationDegrees = function pp_getRotationDegrees(rotation) {
    return ObjectUtils.getRotationDegrees(this, rotation);
  };
  objectExtension.pp_getRotationRadians = function pp_getRotationRadians(rotation) {
    return ObjectUtils.getRotationRadians(this, rotation);
  };
  objectExtension.pp_getRotationMatrix = function pp_getRotationMatrix(rotation) {
    return ObjectUtils.getRotationMatrix(this, rotation);
  };
  objectExtension.pp_getRotationQuat = function pp_getRotationQuat(rotation) {
    return ObjectUtils.getRotationQuat(this, rotation);
  };
  objectExtension.pp_getRotationWorld = function pp_getRotationWorld(rotation) {
    return ObjectUtils.getRotationWorld(this, rotation);
  };
  objectExtension.pp_getRotationWorldDegrees = function pp_getRotationWorldDegrees(rotation) {
    return ObjectUtils.getRotationWorldDegrees(this, rotation);
  };
  objectExtension.pp_getRotationWorldRadians = function pp_getRotationWorldRadians(rotation = Vec3Utils.create()) {
    return ObjectUtils.getRotationWorldRadians(this, rotation);
  };
  objectExtension.pp_getRotationWorldMatrix = function pp_getRotationWorldMatrix(rotation = Mat3Utils.create()) {
    return ObjectUtils.getRotationWorldMatrix(this, rotation);
  };
  objectExtension.pp_getRotationWorldQuat = function pp_getRotationWorldQuat(rotation = QuatUtils.create()) {
    return ObjectUtils.getRotationWorldQuat(this, rotation);
  };
  objectExtension.pp_getRotationLocal = function pp_getRotationLocal(rotation) {
    return ObjectUtils.getRotationLocal(this, rotation);
  };
  objectExtension.pp_getRotationLocalDegrees = function pp_getRotationLocalDegrees(rotation) {
    return ObjectUtils.getRotationLocalDegrees(this, rotation);
  };
  objectExtension.pp_getRotationLocalRadians = function pp_getRotationLocalRadians(rotation = Vec3Utils.create()) {
    return ObjectUtils.getRotationLocalRadians(this, rotation);
  };
  objectExtension.pp_getRotationLocalMatrix = function pp_getRotationLocalMatrix(rotation = Mat3Utils.create()) {
    return ObjectUtils.getRotationLocalMatrix(this, rotation);
  };
  objectExtension.pp_getRotationLocalQuat = function pp_getRotationLocalQuat(rotation = QuatUtils.create()) {
    return ObjectUtils.getRotationLocalQuat(this, rotation);
  };
  objectExtension.pp_getScale = function pp_getScale(scale11) {
    return ObjectUtils.getScale(this, scale11);
  };
  objectExtension.pp_getScaleWorld = function pp_getScaleWorld(scale11 = Vec3Utils.create()) {
    return ObjectUtils.getScaleWorld(this, scale11);
  };
  objectExtension.pp_getScaleLocal = function pp_getScaleLocal(scale11 = Vec3Utils.create()) {
    return ObjectUtils.getScaleLocal(this, scale11);
  };
  objectExtension.pp_getTransform = function pp_getTransform(transform) {
    return ObjectUtils.getTransform(this, transform);
  };
  objectExtension.pp_getTransformMatrix = function pp_getTransformMatrix(transform) {
    return ObjectUtils.getTransformMatrix(this, transform);
  };
  objectExtension.pp_getTransformQuat = function pp_getTransformQuat(transform) {
    return ObjectUtils.getTransformQuat(this, transform);
  };
  objectExtension.pp_getTransformWorld = function pp_getTransformWorld(transform) {
    return ObjectUtils.getTransformWorld(this, transform);
  };
  objectExtension.pp_getTransformWorldMatrix = function pp_getTransformWorldMatrix(transform = Mat4Utils.create()) {
    return ObjectUtils.getTransformWorldMatrix(this, transform);
  };
  objectExtension.pp_getTransformWorldQuat = function pp_getTransformWorldQuat(transform = Quat2Utils.create()) {
    return ObjectUtils.getTransformWorldQuat(this, transform);
  };
  objectExtension.pp_getTransformLocal = function pp_getTransformLocal(transform) {
    return ObjectUtils.getTransformLocal(this, transform);
  };
  objectExtension.pp_getTransformLocalMatrix = function pp_getTransformLocalMatrix(transform = Mat4Utils.create()) {
    return ObjectUtils.getTransformLocalMatrix(this, transform);
  };
  objectExtension.pp_getTransformLocalQuat = function pp_getTransformLocalQuat(transform = Quat2Utils.create()) {
    return ObjectUtils.getTransformLocalQuat(this, transform);
  };
  objectExtension.pp_getAxes = function pp_getAxes(axes) {
    return ObjectUtils.getAxes(this, axes);
  };
  objectExtension.pp_getAxesWorld = function pp_getAxesWorld(axes = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
    return ObjectUtils.getAxesWorld(this, axes);
  };
  objectExtension.pp_getAxesLocal = function pp_getAxesLocal(axes = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
    return ObjectUtils.getAxesLocal(this, axes);
  };
  objectExtension.pp_getForward = function pp_getForward(forward) {
    return ObjectUtils.getForward(this, forward);
  };
  objectExtension.pp_getForwardWorld = function pp_getForwardWorld(forward = Vec3Utils.create()) {
    return ObjectUtils.getForwardWorld(this, forward);
  };
  objectExtension.pp_getForwardLocal = function pp_getForwardLocal(forward = Vec3Utils.create()) {
    return ObjectUtils.getForwardLocal(this, forward);
  };
  objectExtension.pp_getBackward = function pp_getBackward(backward) {
    return ObjectUtils.getBackward(this, backward);
  };
  objectExtension.pp_getBackwardWorld = function pp_getBackwardWorld(backward = Vec3Utils.create()) {
    return ObjectUtils.getBackwardWorld(this, backward);
  };
  objectExtension.pp_getBackwardLocal = function pp_getBackwardLocal(backward = Vec3Utils.create()) {
    return ObjectUtils.getBackwardLocal(this, backward);
  };
  objectExtension.pp_getUp = function pp_getUp(up) {
    return ObjectUtils.getUp(this, up);
  };
  objectExtension.pp_getUpWorld = function pp_getUpWorld(up = Vec3Utils.create()) {
    return ObjectUtils.getUpWorld(this, up);
  };
  objectExtension.pp_getUpLocal = function pp_getUpLocal(up = Vec3Utils.create()) {
    return ObjectUtils.getUpLocal(this, up);
  };
  objectExtension.pp_getDown = function pp_getDown(down) {
    return ObjectUtils.getDown(this, down);
  };
  objectExtension.pp_getDownWorld = function pp_getDownWorld(down = Vec3Utils.create()) {
    return ObjectUtils.getDownWorld(this, down);
  };
  objectExtension.pp_getDownLocal = function pp_getDownLocal(down = Vec3Utils.create()) {
    return ObjectUtils.getDownLocal(this, down);
  };
  objectExtension.pp_getLeft = function pp_getLeft(left) {
    return ObjectUtils.getLeft(this, left);
  };
  objectExtension.pp_getLeftWorld = function pp_getLeftWorld(left = Vec3Utils.create()) {
    return ObjectUtils.getLeftWorld(this, left);
  };
  objectExtension.pp_getLeftLocal = function pp_getLeftLocal(left = Vec3Utils.create()) {
    return ObjectUtils.getLeftLocal(this, left);
  };
  objectExtension.pp_getRight = function pp_getRight(right) {
    return ObjectUtils.getRight(this, right);
  };
  objectExtension.pp_getRightWorld = function pp_getRightWorld(right = Vec3Utils.create()) {
    return ObjectUtils.getRightWorld(this, right);
  };
  objectExtension.pp_getRightLocal = function pp_getRightLocal(right = Vec3Utils.create()) {
    return ObjectUtils.getRightLocal(this, right);
  };
  objectExtension.pp_setPosition = function pp_setPosition(position) {
    return ObjectUtils.setPosition(this, position);
  };
  objectExtension.pp_setPositionWorld = function pp_setPositionWorld(position) {
    return ObjectUtils.setPositionWorld(this, position);
  };
  objectExtension.pp_setPositionLocal = function pp_setPositionLocal(position) {
    return ObjectUtils.setPositionLocal(this, position);
  };
  objectExtension.pp_setRotation = function pp_setRotation(rotation) {
    return ObjectUtils.setRotation(this, rotation);
  };
  objectExtension.pp_setRotationDegrees = function pp_setRotationDegrees(rotation) {
    return ObjectUtils.setRotationDegrees(this, rotation);
  };
  objectExtension.pp_setRotationRadians = function pp_setRotationRadians(rotation) {
    return ObjectUtils.setRotationRadians(this, rotation);
  };
  objectExtension.pp_setRotationMatrix = function pp_setRotationMatrix(rotation) {
    return ObjectUtils.setRotationMatrix(this, rotation);
  };
  objectExtension.pp_setRotationQuat = function pp_setRotationQuat(rotation) {
    return ObjectUtils.setRotationQuat(this, rotation);
  };
  objectExtension.pp_setRotationWorld = function pp_setRotationWorld(rotation) {
    return ObjectUtils.setRotationWorld(this, rotation);
  };
  objectExtension.pp_setRotationWorldDegrees = function pp_setRotationWorldDegrees(rotation) {
    return ObjectUtils.setRotationWorldDegrees(this, rotation);
  };
  objectExtension.pp_setRotationWorldRadians = function pp_setRotationWorldRadians(rotation) {
    return ObjectUtils.setRotationWorldRadians(this, rotation);
  };
  objectExtension.pp_setRotationWorldMatrix = function pp_setRotationWorldMatrix(rotation) {
    return ObjectUtils.setRotationWorldMatrix(this, rotation);
  };
  objectExtension.pp_setRotationWorldQuat = function pp_setRotationWorldQuat(rotation) {
    return ObjectUtils.setRotationWorldQuat(this, rotation);
  };
  objectExtension.pp_setRotationLocal = function pp_setRotationLocal(rotation) {
    return ObjectUtils.setRotationLocal(this, rotation);
  };
  objectExtension.pp_setRotationLocalDegrees = function pp_setRotationLocalDegrees(rotation) {
    return ObjectUtils.setRotationLocalDegrees(this, rotation);
  };
  objectExtension.pp_setRotationLocalRadians = function pp_setRotationLocalRadians(rotation) {
    return ObjectUtils.setRotationLocalRadians(this, rotation);
  };
  objectExtension.pp_setRotationLocalMatrix = function pp_setRotationLocalMatrix(rotation) {
    return ObjectUtils.setRotationLocalMatrix(this, rotation);
  };
  objectExtension.pp_setRotationLocalQuat = function pp_setRotationLocalQuat(rotation) {
    return ObjectUtils.setRotationLocalQuat(this, rotation);
  };
  objectExtension.pp_setScale = function pp_setScale(scale11) {
    return ObjectUtils.setScale(this, scale11);
  };
  objectExtension.pp_setScaleWorld = function pp_setScaleWorld(scale11) {
    return ObjectUtils.setScaleWorld(this, scale11);
  };
  objectExtension.pp_setScaleLocal = function pp_setScaleLocal(scale11) {
    return ObjectUtils.setScaleLocal(this, scale11);
  };
  objectExtension.pp_setAxes = function pp_setAxes(left, up, forward) {
    return ObjectUtils.setAxes(this, left, up, forward);
  };
  objectExtension.pp_setAxesWorld = function pp_setAxesWorld(left, up, forward) {
    return ObjectUtils.setAxesWorld(this, left, up, forward);
  };
  objectExtension.pp_setAxesLocal = function pp_setAxesLocal(left, up, forward) {
    return ObjectUtils.setAxesLocal(this, left, up, forward);
  };
  objectExtension.pp_setForward = function pp_setForward(forward, up, left) {
    return ObjectUtils.setForward(this, forward, up, left);
  };
  objectExtension.pp_setForwardWorld = function pp_setForwardWorld(forward, up = null, left = null) {
    return ObjectUtils.setForwardWorld(this, forward, up, left);
  };
  objectExtension.pp_setForwardLocal = function pp_setForwardLocal(forward, up = null, left = null) {
    return ObjectUtils.setForwardLocal(this, forward, up, left);
  };
  objectExtension.pp_setBackward = function pp_setBackward(backward, up, left) {
    return ObjectUtils.setBackward(this, backward, up, left);
  };
  objectExtension.pp_setBackwardWorld = function pp_setBackwardWorld(backward, up = null, left = null) {
    return ObjectUtils.setBackwardWorld(this, backward, up, left);
  };
  objectExtension.pp_setBackwardLocal = function pp_setBackwardLocal(backward, up = null, left = null) {
    return ObjectUtils.setBackwardLocal(this, backward, up, left);
  };
  objectExtension.pp_setUp = function pp_setUp(up, forward, left) {
    return ObjectUtils.setUp(this, up, forward, left);
  };
  objectExtension.pp_setUpWorld = function pp_setUpWorld(up, forward = null, left = null) {
    return ObjectUtils.setUpWorld(this, up, forward, left);
  };
  objectExtension.pp_setUpLocal = function pp_setUpLocal(up, forward = null, left = null) {
    return ObjectUtils.setUpLocal(this, up, forward, left);
  };
  objectExtension.pp_setDown = function pp_setDown(down, forward, left) {
    return ObjectUtils.setDown(this, down, forward, left);
  };
  objectExtension.pp_setDownWorld = function pp_setDownWorld(down, forward = null, left = null) {
    return ObjectUtils.setDownWorld(this, down, forward, left);
  };
  objectExtension.pp_setDownLocal = function pp_setDownLocal(down, forward = null, left = null) {
    return ObjectUtils.setDownLocal(this, down, forward, left);
  };
  objectExtension.pp_setLeft = function pp_setLeft(left, up, forward) {
    return ObjectUtils.setLeft(this, left, up, forward);
  };
  objectExtension.pp_setLeftWorld = function pp_setLeftWorld(left, up = null, forward = null) {
    return ObjectUtils.setLeftWorld(this, left, up, forward);
  };
  objectExtension.pp_setLeftLocal = function pp_setLeftLocal(left, up = null, forward = null) {
    return ObjectUtils.setLeftLocal(this, left, up, forward);
  };
  objectExtension.pp_setRight = function pp_setRight(right, up, forward) {
    return ObjectUtils.setRight(this, right, up, forward);
  };
  objectExtension.pp_setRightWorld = function pp_setRightWorld(right, up = null, forward = null) {
    return ObjectUtils.setRightWorld(this, right, up, forward);
  };
  objectExtension.pp_setRightLocal = function pp_setRightLocal(right, up = null, forward = null) {
    return ObjectUtils.setRightLocal(this, right, up, forward);
  };
  objectExtension.pp_setTransform = function pp_setTransform(transform) {
    return ObjectUtils.setTransform(this, transform);
  };
  objectExtension.pp_setTransformMatrix = function pp_setTransformMatrix(transform) {
    return ObjectUtils.setTransformMatrix(this, transform);
  };
  objectExtension.pp_setTransformQuat = function pp_setTransformQuat(transform) {
    return ObjectUtils.setTransformQuat(this, transform);
  };
  objectExtension.pp_setTransformWorld = function pp_setTransformWorld(transform) {
    return ObjectUtils.setTransformWorld(this, transform);
  };
  objectExtension.pp_setTransformWorldMatrix = function pp_setTransformWorldMatrix(transform) {
    return ObjectUtils.setTransformWorldMatrix(this, transform);
  };
  objectExtension.pp_setTransformWorldQuat = function pp_setTransformWorldQuat(transform) {
    return ObjectUtils.setTransformWorldQuat(this, transform);
  };
  objectExtension.pp_setTransformLocal = function pp_setTransformLocal(transform) {
    return ObjectUtils.setTransformLocal(this, transform);
  };
  objectExtension.pp_setTransformLocalMatrix = function pp_setTransformLocalMatrix(transform) {
    return ObjectUtils.setTransformLocalMatrix(this, transform);
  };
  objectExtension.pp_setTransformLocalQuat = function pp_setTransformLocalQuat(transform) {
    return ObjectUtils.setTransformLocalQuat(this, transform);
  };
  objectExtension.pp_resetPosition = function pp_resetPosition() {
    return ObjectUtils.resetPosition(this);
  };
  objectExtension.pp_resetPositionWorld = function pp_resetPositionWorld() {
    return ObjectUtils.resetPositionWorld(this);
  };
  objectExtension.pp_resetPositionLocal = function pp_resetPositionLocal() {
    return ObjectUtils.resetPositionLocal(this);
  };
  objectExtension.pp_resetRotation = function pp_resetRotation() {
    return ObjectUtils.resetRotation(this);
  };
  objectExtension.pp_resetRotationWorld = function pp_resetRotationWorld() {
    return ObjectUtils.resetRotationWorld(this);
  };
  objectExtension.pp_resetRotationLocal = function pp_resetRotationLocal() {
    return ObjectUtils.resetRotationLocal(this);
  };
  objectExtension.pp_resetScale = function pp_resetScale() {
    return ObjectUtils.resetScale(this);
  };
  objectExtension.pp_resetScaleWorld = function pp_resetScaleWorld() {
    return ObjectUtils.resetScaleWorld(this);
  };
  objectExtension.pp_resetScaleLocal = function pp_resetScaleLocal() {
    return ObjectUtils.resetScaleLocal(this);
  };
  objectExtension.pp_resetTransform = function pp_resetTransform() {
    return ObjectUtils.resetTransform(this);
  };
  objectExtension.pp_resetTransformWorld = function pp_resetTransformWorld() {
    return ObjectUtils.resetTransformWorld(this);
  };
  objectExtension.pp_resetTransformLocal = function pp_resetTransformLocal() {
    return ObjectUtils.resetTransformLocal(this);
  };
  objectExtension.pp_translate = function pp_translate(translation) {
    return ObjectUtils.translate(this, translation);
  };
  objectExtension.pp_translateWorld = function pp_translateWorld(translation) {
    return ObjectUtils.translateWorld(this, translation);
  };
  objectExtension.pp_translateLocal = function pp_translateLocal(translation) {
    return ObjectUtils.translateLocal(this, translation);
  };
  objectExtension.pp_translateObject = function pp_translateObject(translation) {
    return ObjectUtils.translateObject(this, translation);
  };
  objectExtension.pp_translateAxis = function pp_translateAxis(amount, direction2) {
    return ObjectUtils.translateAxis(this, amount, direction2);
  };
  objectExtension.pp_translateAxisWorld = function pp_translateAxisWorld(amount, direction2) {
    return ObjectUtils.translateAxisWorld(this, amount, direction2);
  };
  objectExtension.pp_translateAxisLocal = function pp_translateAxisLocal(amount, direction2) {
    return ObjectUtils.translateAxisLocal(this, amount, direction2);
  };
  objectExtension.pp_translateAxisObject = function pp_translateAxisObject(amount, direction2) {
    return ObjectUtils.translateAxisObject(this, amount, direction2);
  };
  objectExtension.pp_rotate = function pp_rotate(rotation) {
    return ObjectUtils.rotate(this, rotation);
  };
  objectExtension.pp_rotateDegrees = function pp_rotateDegrees(rotation) {
    return ObjectUtils.rotateDegrees(this, rotation);
  };
  objectExtension.pp_rotateRadians = function pp_rotateRadians(rotation) {
    return ObjectUtils.rotateRadians(this, rotation);
  };
  objectExtension.pp_rotateMatrix = function pp_rotateMatrix(rotation) {
    return ObjectUtils.rotateMatrix(this, rotation);
  };
  objectExtension.pp_rotateQuat = function pp_rotateQuat(rotation) {
    return ObjectUtils.rotateQuat(this, rotation);
  };
  objectExtension.pp_rotateWorld = function pp_rotateWorld(rotation) {
    return ObjectUtils.rotateWorld(this, rotation);
  };
  objectExtension.pp_rotateWorldDegrees = function pp_rotateWorldDegrees(rotation) {
    return ObjectUtils.rotateWorldDegrees(this, rotation);
  };
  objectExtension.pp_rotateWorldRadians = function pp_rotateWorldRadians(rotation) {
    return ObjectUtils.rotateWorldRadians(this, rotation);
  };
  objectExtension.pp_rotateWorldMatrix = function pp_rotateWorldMatrix(rotation) {
    return ObjectUtils.rotateWorldMatrix(this, rotation);
  };
  objectExtension.pp_rotateWorldQuat = function pp_rotateWorldQuat(rotation) {
    return ObjectUtils.rotateWorldQuat(this, rotation);
  };
  objectExtension.pp_rotateLocal = function pp_rotateLocal(rotation) {
    return ObjectUtils.rotateLocal(this, rotation);
  };
  objectExtension.pp_rotateLocalDegrees = function pp_rotateLocalDegrees(rotation) {
    return ObjectUtils.rotateLocalDegrees(this, rotation);
  };
  objectExtension.pp_rotateLocalRadians = function pp_rotateLocalRadians(rotation) {
    return ObjectUtils.rotateLocalRadians(this, rotation);
  };
  objectExtension.pp_rotateLocalMatrix = function pp_rotateLocalMatrix(rotation) {
    return ObjectUtils.rotateLocalMatrix(this, rotation);
  };
  objectExtension.pp_rotateLocalQuat = function pp_rotateLocalQuat(rotation) {
    return ObjectUtils.rotateLocalQuat(this, rotation);
  };
  objectExtension.pp_rotateObject = function pp_rotateObject(rotation) {
    return ObjectUtils.rotateObject(this, rotation);
  };
  objectExtension.pp_rotateObjectDegrees = function pp_rotateObjectDegrees(rotation) {
    return ObjectUtils.rotateObjectDegrees(this, rotation);
  };
  objectExtension.pp_rotateObjectRadians = function pp_rotateObjectRadians(rotation) {
    return ObjectUtils.rotateObjectRadians(this, rotation);
  };
  objectExtension.pp_rotateObjectMatrix = function pp_rotateObjectMatrix(rotation) {
    return ObjectUtils.rotateObjectMatrix(this, rotation);
  };
  objectExtension.pp_rotateObjectQuat = function pp_rotateObjectQuat(rotation) {
    return ObjectUtils.rotateObjectQuat(this, rotation);
  };
  objectExtension.pp_rotateAxis = function pp_rotateAxis(angle4, axis) {
    return ObjectUtils.rotateAxis(this, angle4, axis);
  };
  objectExtension.pp_rotateAxisDegrees = function pp_rotateAxisDegrees(angle4, axis) {
    return ObjectUtils.rotateAxisDegrees(this, angle4, axis);
  };
  objectExtension.pp_rotateAxisRadians = function pp_rotateAxisRadians(angle4, axis) {
    return ObjectUtils.rotateAxisRadians(this, angle4, axis);
  };
  objectExtension.pp_rotateAxisWorld = function pp_rotateAxisWorld(angle4, axis) {
    return ObjectUtils.rotateAxisWorld(this, angle4, axis);
  };
  objectExtension.pp_rotateAxisWorldDegrees = function pp_rotateAxisWorldDegrees(angle4, axis) {
    return ObjectUtils.rotateAxisWorldDegrees(this, angle4, axis);
  };
  objectExtension.pp_rotateAxisWorldRadians = function pp_rotateAxisWorldRadians(angle4, axis) {
    return ObjectUtils.rotateAxisWorldRadians(this, angle4, axis);
  };
  objectExtension.pp_rotateAxisLocal = function pp_rotateAxisLocal(angle4, axis) {
    return ObjectUtils.rotateAxisLocal(this, angle4, axis);
  };
  objectExtension.pp_rotateAxisLocalDegrees = function pp_rotateAxisLocalDegrees(angle4, axis) {
    return ObjectUtils.rotateAxisLocalDegrees(this, angle4, axis);
  };
  objectExtension.pp_rotateAxisLocalRadians = function pp_rotateAxisLocalRadians(angle4, axis) {
    return ObjectUtils.rotateAxisLocalRadians(this, angle4, axis);
  };
  objectExtension.pp_rotateAxisObject = function pp_rotateAxisObject(angle4, axis) {
    return ObjectUtils.rotateAxisObject(this, angle4, axis);
  };
  objectExtension.pp_rotateAxisObjectDegrees = function pp_rotateAxisObjectDegrees(angle4, axis) {
    return ObjectUtils.rotateAxisObjectDegrees(this, angle4, axis);
  };
  objectExtension.pp_rotateAxisObjectRadians = function pp_rotateAxisObjectRadians(angle4, axis) {
    return ObjectUtils.rotateAxisObjectRadians(this, angle4, axis);
  };
  objectExtension.pp_rotateAround = function pp_rotateAround(rotation, origin) {
    return ObjectUtils.rotateAround(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundDegrees = function pp_rotateAroundDegrees(rotation, origin) {
    return ObjectUtils.rotateAroundDegrees(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundRadians = function pp_rotateAroundRadians(rotation, origin) {
    return ObjectUtils.rotateAroundRadians(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundMatrix = function pp_rotateAroundMatrix(rotation, origin) {
    return ObjectUtils.rotateAroundMatrix(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundQuat = function pp_rotateAroundQuat(rotation, origin) {
    return ObjectUtils.rotateAroundQuat(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundWorld = function pp_rotateAroundWorld(rotation, origin) {
    return ObjectUtils.rotateAroundWorld(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundWorldDegrees = function pp_rotateAroundWorldDegrees(rotation, origin) {
    return ObjectUtils.rotateAroundWorldDegrees(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundWorldRadians = function pp_rotateAroundWorldRadians(rotation, origin) {
    return ObjectUtils.rotateAroundWorldRadians(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundWorldMatrix = function pp_rotateAroundWorldMatrix(rotation, origin) {
    return ObjectUtils.rotateAroundWorldMatrix(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundWorldQuat = function pp_rotateAroundWorldQuat(rotation, origin) {
    return ObjectUtils.rotateAroundWorldQuat(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundLocal = function pp_rotateAroundLocal(rotation, origin) {
    return ObjectUtils.rotateAroundLocal(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundLocalDegrees = function pp_rotateAroundLocalDegrees(rotation, origin) {
    return ObjectUtils.rotateAroundLocalDegrees(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundLocalRadians = function pp_rotateAroundLocalRadians(rotation, origin) {
    return ObjectUtils.rotateAroundLocalRadians(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundLocalMatrix = function pp_rotateAroundLocalMatrix(rotation, origin) {
    return ObjectUtils.rotateAroundLocalMatrix(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundLocalQuat = function pp_rotateAroundLocalQuat(rotation, origin) {
    return ObjectUtils.rotateAroundLocalQuat(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundObject = function pp_rotateAroundObject(rotation, origin) {
    return ObjectUtils.rotateAroundObject(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundObjectDegrees = function pp_rotateAroundObjectDegrees(rotation, origin) {
    return ObjectUtils.rotateAroundObjectDegrees(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundObjectRadians = function pp_rotateAroundObjectRadians(rotation, origin) {
    return ObjectUtils.rotateAroundObjectRadians(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundObjectMatrix = function pp_rotateAroundObjectMatrix(rotation, origin) {
    return ObjectUtils.rotateAroundObjectMatrix(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundObjectQuat = function pp_rotateAroundObjectQuat(rotation, origin) {
    return ObjectUtils.rotateAroundObjectQuat(this, rotation, origin);
  };
  objectExtension.pp_rotateAroundAxis = function pp_rotateAroundAxis(angle4, axis, origin) {
    return ObjectUtils.rotateAroundAxis(this, angle4, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisDegrees = function pp_rotateAroundAxisDegrees(angle4, axis, origin) {
    return ObjectUtils.rotateAroundAxisDegrees(this, angle4, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisRadians = function pp_rotateAroundAxisRadians(angle4, axis, origin) {
    return ObjectUtils.rotateAroundAxisRadians(this, angle4, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisWorld = function pp_rotateAroundAxisWorld(angle4, axis, origin) {
    return ObjectUtils.rotateAroundAxisWorld(this, angle4, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisWorldDegrees = function pp_rotateAroundAxisWorldDegrees(angle4, axis, origin) {
    return ObjectUtils.rotateAroundAxisWorldDegrees(this, angle4, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisWorldRadians = function pp_rotateAroundAxisWorldRadians(angle4, axis, origin) {
    return ObjectUtils.rotateAroundAxisWorldRadians(this, angle4, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisLocal = function pp_rotateAroundAxisLocal(angle4, axis, origin) {
    return ObjectUtils.rotateAroundAxisLocal(this, angle4, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisLocalDegrees = function pp_rotateAroundAxisLocalDegrees(angle4, axis, origin) {
    return ObjectUtils.rotateAroundAxisLocalDegrees(this, angle4, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisLocalRadians = function pp_rotateAroundAxisLocalRadians(angle4, axis, origin) {
    return ObjectUtils.rotateAroundAxisLocalRadians(this, angle4, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisObject = function pp_rotateAroundAxisObject(angle4, axis, origin) {
    return ObjectUtils.rotateAroundAxisObject(this, angle4, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisObjectDegrees = function pp_rotateAroundAxisObjectDegrees(angle4, axis, origin) {
    return ObjectUtils.rotateAroundAxisObjectDegrees(this, angle4, axis, origin);
  };
  objectExtension.pp_rotateAroundAxisObjectRadians = function pp_rotateAroundAxisObjectRadians(angle4, axis, origin) {
    return ObjectUtils.rotateAroundAxisObjectRadians(this, angle4, axis, origin);
  };
  objectExtension.pp_scaleObject = function pp_scaleObject(scale11) {
    return ObjectUtils.scaleObject(this, scale11);
  };
  objectExtension.pp_lookAt = function pp_lookAt(position, up) {
    return ObjectUtils.lookAt(this, position, up);
  };
  objectExtension.pp_lookAtWorld = function pp_lookAtWorld(position, up) {
    return ObjectUtils.lookAtWorld(this, position, up);
  };
  objectExtension.pp_lookAtLocal = function pp_lookAtLocal(position, up) {
    return ObjectUtils.lookAtLocal(this, position, up);
  };
  objectExtension.pp_lookTo = function pp_lookTo(direction2, up) {
    return ObjectUtils.lookTo(this, direction2, up);
  };
  objectExtension.pp_lookToWorld = function pp_lookToWorld(direction2, up) {
    return ObjectUtils.lookToWorld(this, direction2, up);
  };
  objectExtension.pp_lookToLocal = function pp_lookToLocal(direction2, up) {
    return ObjectUtils.lookToLocal(this, direction2, up);
  };
  objectExtension.pp_setParent = function pp_setParent(newParent, keepTransformWorld = true) {
    return ObjectUtils.setParent(this, newParent, keepTransformWorld);
  };
  objectExtension.pp_getParent = function pp_getParent() {
    return ObjectUtils.getParent(this);
  };
  objectExtension.pp_convertPositionObjectToWorld = function pp_convertPositionObjectToWorld(position, resultPosition = Vec3Utils.create()) {
    return ObjectUtils.convertPositionObjectToWorld(this, position, resultPosition);
  };
  objectExtension.pp_convertDirectionObjectToWorld = function pp_convertDirectionObjectToWorld(direction2, resultDirection = Vec3Utils.create()) {
    return ObjectUtils.convertDirectionObjectToWorld(this, direction2, resultDirection);
  };
  objectExtension.pp_convertPositionWorldToObject = function pp_convertPositionWorldToObject(position, resultPosition = Vec3Utils.create()) {
    return ObjectUtils.convertPositionWorldToObject(this, position, resultPosition);
  };
  objectExtension.pp_convertDirectionWorldToObject = function pp_convertDirectionWorldToObject(direction2, resultDirection = Vec3Utils.create()) {
    return ObjectUtils.convertDirectionWorldToObject(this, direction2, resultDirection);
  };
  objectExtension.pp_convertPositionLocalToWorld = function pp_convertPositionLocalToWorld(position, resultPosition = Vec3Utils.create()) {
    return ObjectUtils.convertPositionLocalToWorld(this, position, resultPosition);
  };
  objectExtension.pp_convertDirectionLocalToWorld = function pp_convertDirectionLocalToWorld(direction2, resultDirection = Vec3Utils.create()) {
    return ObjectUtils.convertDirectionLocalToWorld(this, direction2, resultDirection);
  };
  objectExtension.pp_convertPositionWorldToLocal = function pp_convertPositionWorldToLocal(position, resultPosition = Vec3Utils.create()) {
    return ObjectUtils.convertPositionWorldToLocal(this, position, resultPosition);
  };
  objectExtension.pp_convertDirectionWorldToLocal = function pp_convertDirectionWorldToLocal(direction2, resultDirection = Vec3Utils.create()) {
    return ObjectUtils.convertDirectionWorldToLocal(this, direction2, resultDirection);
  };
  objectExtension.pp_convertPositionObjectToLocal = function pp_convertPositionObjectToLocal(position, resultPosition = Vec3Utils.create()) {
    return ObjectUtils.convertPositionObjectToLocal(this, position, resultPosition);
  };
  objectExtension.pp_convertDirectionObjectToLocal = function pp_convertDirectionObjectToLocal(direction2, resultDirection = Vec3Utils.create()) {
    return ObjectUtils.convertDirectionObjectToLocal(this, direction2, resultDirection);
  };
  objectExtension.pp_convertPositionLocalToObject = function pp_convertPositionLocalToObject(position, resultPosition = Vec3Utils.create()) {
    return ObjectUtils.convertPositionLocalToObject(this, position, resultPosition);
  };
  objectExtension.pp_convertDirectionLocalToObject = function pp_convertDirectionLocalToObject(direction2, resultDirection = Vec3Utils.create()) {
    return ObjectUtils.convertDirectionLocalToObject(this, direction2, resultDirection);
  };
  objectExtension.pp_convertTransformObjectToWorld = function pp_convertTransformObjectToWorld(transform, resultTransform) {
    return ObjectUtils.convertTransformObjectToWorld(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformObjectToWorldMatrix = function pp_convertTransformObjectToWorldMatrix(transform, resultTransform = Mat4Utils.create()) {
    return ObjectUtils.convertTransformObjectToWorldMatrix(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformObjectToWorldQuat = function pp_convertTransformObjectToWorldQuat(transform, resultTransform = Quat2Utils.create()) {
    return ObjectUtils.convertTransformObjectToWorldQuat(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformWorldToObject = function pp_convertTransformWorldToObject(transform, resultTransform) {
    return ObjectUtils.convertTransformWorldToObject(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformWorldToObjectMatrix = function pp_convertTransformWorldToObjectMatrix(transform, resultTransform = Mat4Utils.create()) {
    return ObjectUtils.convertTransformWorldToObjectMatrix(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformWorldToObjectQuat = function pp_convertTransformWorldToObjectQuat(transform, resultTransform = Quat2Utils.create()) {
    return ObjectUtils.convertTransformWorldToObjectQuat(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformLocalToWorld = function pp_convertTransformLocalToWorld(transform, resultTransform) {
    return ObjectUtils.convertTransformLocalToWorld(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformLocalToWorldMatrix = function pp_convertTransformLocalToWorldMatrix(transform, resultTransform = Mat4Utils.create()) {
    return ObjectUtils.convertTransformLocalToWorldMatrix(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformLocalToWorldQuat = function pp_convertTransformLocalToWorldQuat(transform, resultTransform = Quat2Utils.create()) {
    return ObjectUtils.convertTransformLocalToWorldQuat(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformWorldToLocal = function pp_convertTransformWorldToLocal(transform, resultTransform) {
    return ObjectUtils.convertTransformWorldToLocal(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformWorldToLocalMatrix = function pp_convertTransformWorldToLocalMatrix(transform, resultTransform = Mat4Utils.create()) {
    return ObjectUtils.convertTransformWorldToLocalMatrix(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformWorldToLocalQuat = function pp_convertTransformWorldToLocalQuat(transform, resultTransform = Quat2Utils.create()) {
    return ObjectUtils.convertTransformWorldToLocalQuat(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformObjectToLocal = function pp_convertTransformObjectToLocal(transform, resultTransform) {
    return ObjectUtils.convertTransformObjectToLocal(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformObjectToLocalMatrix = function pp_convertTransformObjectToLocalMatrix(transform, resultTransform = Mat4Utils.create()) {
    return ObjectUtils.convertTransformObjectToLocalMatrix(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformObjectToLocalQuat = function pp_convertTransformObjectToLocalQuat(transform, resultTransform = Quat2Utils.create()) {
    return ObjectUtils.convertTransformObjectToLocalQuat(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformLocalToObject = function pp_convertTransformLocalToObject(transform, resultTransform) {
    return ObjectUtils.convertTransformLocalToObject(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformLocalToObjectMatrix = function pp_convertTransformLocalToObjectMatrix(transform, resultTransform = Mat4Utils.create()) {
    return ObjectUtils.convertTransformLocalToObjectMatrix(this, transform, resultTransform);
  };
  objectExtension.pp_convertTransformLocalToObjectQuat = function pp_convertTransformLocalToObjectQuat(transform, resultTransform = Quat2Utils.create()) {
    return ObjectUtils.convertTransformLocalToObjectQuat(this, transform, resultTransform);
  };
  objectExtension.pp_addComponent = function pp_addComponent(typeOrClass, paramsOrActive, active = null) {
    return ObjectUtils.addComponent(this, typeOrClass, paramsOrActive, active);
  };
  objectExtension.pp_getComponent = function pp_getComponent(typeOrClass, index = 0) {
    return ObjectUtils.getComponent(this, typeOrClass, index);
  };
  objectExtension.pp_getComponentSelf = function pp_getComponentSelf(typeOrClass, index = 0) {
    return ObjectUtils.getComponentSelf(this, typeOrClass, index);
  };
  objectExtension.pp_getComponentHierarchy = function pp_getComponentHierarchy(typeOrClass, index = 0) {
    return ObjectUtils.getComponentHierarchy(this, typeOrClass, index);
  };
  objectExtension.pp_getComponentHierarchyBreadth = function pp_getComponentHierarchyBreadth(typeOrClass, index = 0) {
    return ObjectUtils.getComponentHierarchyBreadth(this, typeOrClass, index);
  };
  objectExtension.pp_getComponentHierarchyDepth = function pp_getComponentHierarchyDepth(typeOrClass, index = 0) {
    return ObjectUtils.getComponentHierarchyDepth(this, typeOrClass, index);
  };
  objectExtension.pp_getComponentDescendants = function pp_getComponentDescendants(typeOrClass, index = 0) {
    return ObjectUtils.getComponentDescendants(this, typeOrClass, index);
  };
  objectExtension.pp_getComponentDescendantsBreadth = function pp_getComponentDescendantsBreadth(typeOrClass, index = 0) {
    return ObjectUtils.getComponentDescendantsBreadth(this, typeOrClass, index);
  };
  objectExtension.pp_getComponentDescendantsDepth = function pp_getComponentDescendantsDepth(typeOrClass, index = 0) {
    return ObjectUtils.getComponentDescendantsDepth(this, typeOrClass, index);
  };
  objectExtension.pp_getComponentChildren = function pp_getComponentChildren(typeOrClass, index = 0) {
    return ObjectUtils.getComponentChildren(this, typeOrClass, index);
  };
  objectExtension.pp_getComponents = function pp_getComponents(typeOrClass) {
    return ObjectUtils.getComponents(this, typeOrClass);
  };
  objectExtension.pp_getComponentsSelf = function pp_getComponentsSelf(typeOrClass) {
    return ObjectUtils.getComponentsSelf(this, typeOrClass);
  };
  objectExtension.pp_getComponentsHierarchy = function pp_getComponentsHierarchy(typeOrClass) {
    return ObjectUtils.getComponentsHierarchy(this, typeOrClass);
  };
  objectExtension.pp_getComponentsHierarchyBreadth = function pp_getComponentsHierarchyBreadth(typeOrClass) {
    return ObjectUtils.getComponentsHierarchyBreadth(this, typeOrClass);
  };
  objectExtension.pp_getComponentsHierarchyDepth = function pp_getComponentsHierarchyDepth(typeOrClass) {
    return ObjectUtils.getComponentsHierarchyDepth(this, typeOrClass);
  };
  objectExtension.pp_getComponentsDescendants = function pp_getComponentsDescendants(typeOrClass) {
    return ObjectUtils.getComponentsDescendants(this, typeOrClass);
  };
  objectExtension.pp_getComponentsDescendantsBreadth = function pp_getComponentsDescendantsBreadth(typeOrClass) {
    return ObjectUtils.getComponentsDescendantsBreadth(this, typeOrClass);
  };
  objectExtension.pp_getComponentsDescendantsDepth = function pp_getComponentsDescendantsDepth(typeOrClass) {
    return ObjectUtils.getComponentsDescendantsDepth(this, typeOrClass);
  };
  objectExtension.pp_getComponentsChildren = function pp_getComponentsChildren(typeOrClass) {
    return ObjectUtils.getComponentsChildren(this, typeOrClass);
  };
  objectExtension.pp_setActive = function pp_setActive(active) {
    return ObjectUtils.setActive(this, active);
  };
  objectExtension.pp_setActiveSelf = function pp_setActiveSelf(active) {
    return ObjectUtils.setActiveSelf(this, active);
  };
  objectExtension.pp_setActiveHierarchy = function pp_setActiveHierarchy(active) {
    return ObjectUtils.setActiveHierarchy(this, active);
  };
  objectExtension.pp_setActiveHierarchyBreadth = function pp_setActiveHierarchyBreadth(active) {
    return ObjectUtils.setActiveHierarchyBreadth(this, active);
  };
  objectExtension.pp_setActiveHierarchyDepth = function pp_setActiveHierarchyDepth(active) {
    return ObjectUtils.setActiveHierarchyDepth(this, active);
  };
  objectExtension.pp_setActiveDescendants = function pp_setActiveDescendants(active) {
    return ObjectUtils.setActiveDescendants(this, active);
  };
  objectExtension.pp_setActiveDescendantsBreadth = function pp_setActiveDescendantsBreadth(active) {
    return ObjectUtils.setActiveDescendantsBreadth(this, active);
  };
  objectExtension.pp_setActiveDescendantsDepth = function pp_setActiveDescendantsDepth(active) {
    return ObjectUtils.setActiveDescendantsDepth(this, active);
  };
  objectExtension.pp_setActiveChildren = function pp_setActiveChildren(active) {
    return ObjectUtils.setActiveChildren(this, active);
  };
  objectExtension.pp_hasUniformScale = function pp_hasUniformScale() {
    return ObjectUtils.hasUniformScale(this);
  };
  objectExtension.pp_hasUniformScaleWorld = function pp_hasUniformScaleWorld() {
    return ObjectUtils.hasUniformScaleWorld(this);
  };
  objectExtension.pp_hasUniformScaleLocal = function pp_hasUniformScaleLocal() {
    return ObjectUtils.hasUniformScaleLocal(this);
  };
  objectExtension.pp_clone = function pp_clone(cloneParams = new CloneParams()) {
    return ObjectUtils.clone(this, cloneParams);
  };
  objectExtension.pp_isCloneable = function pp_isCloneable(cloneParams = new CloneParams()) {
    return ObjectUtils.isCloneable(this, cloneParams);
  };
  objectExtension.pp_toString = function pp_toString() {
    return ObjectUtils.toString(this);
  };
  objectExtension.pp_toStringExtended = function pp_toStringExtended() {
    return ObjectUtils.toStringExtended(this);
  };
  objectExtension.pp_toStringCompact = function pp_toStringCompact() {
    return ObjectUtils.toStringCompact(this);
  };
  objectExtension.pp_getObjectByName = function pp_getObjectByName(name, isRegex = false, index = 0) {
    return ObjectUtils.getObjectByName(this, name, isRegex, index);
  };
  objectExtension.pp_getObjectByNameHierarchy = function pp_getObjectByNameHierarchy(name, isRegex = false, index = 0) {
    return ObjectUtils.getObjectByNameHierarchy(this, name, isRegex, index);
  };
  objectExtension.pp_getObjectByNameHierarchyBreadth = function pp_getObjectByNameHierarchyBreadth(name, isRegex = false, index = 0) {
    return ObjectUtils.getObjectByNameHierarchyBreadth(this, name, isRegex, index);
  };
  objectExtension.pp_getObjectByNameHierarchyDepth = function pp_getObjectByNameHierarchyDepth(name, isRegex = false, index = 0) {
    return ObjectUtils.getObjectByNameHierarchyDepth(this, name, isRegex, index);
  };
  objectExtension.pp_getObjectByNameDescendants = function pp_getObjectByNameDescendants(name, isRegex = false, index = 0) {
    return ObjectUtils.getObjectByNameDescendants(this, name, isRegex, index);
  };
  objectExtension.pp_getObjectByNameDescendantsBreadth = function pp_getObjectByNameDescendantsBreadth(name, isRegex = false, index = 0) {
    return ObjectUtils.getObjectByNameDescendantsBreadth(this, name, isRegex, index);
  };
  objectExtension.pp_getObjectByNameDescendantsDepth = function pp_getObjectByNameDescendantsDepth(name, isRegex = false, index = 0) {
    return ObjectUtils.getObjectByNameDescendantsDepth(this, name, isRegex, index);
  };
  objectExtension.pp_getObjectByNameChildren = function pp_getObjectByNameChildren(name, isRegex = false, index = 0) {
    return ObjectUtils.getObjectByNameChildren(this, name, isRegex, index);
  };
  objectExtension.pp_getObjectsByName = function pp_getObjectsByName(name, isRegex = false) {
    return ObjectUtils.getObjectsByName(this, name, isRegex);
  };
  objectExtension.pp_getObjectsByNameHierarchy = function pp_getObjectsByNameHierarchy(name, isRegex = false) {
    return ObjectUtils.getObjectsByNameHierarchy(this, name, isRegex);
  };
  objectExtension.pp_getObjectsByNameHierarchyBreadth = function pp_getObjectsByNameHierarchyBreadth(name, isRegex = false) {
    return ObjectUtils.getObjectsByNameHierarchyBreadth(this, name, isRegex);
  };
  objectExtension.pp_getObjectsByNameHierarchyDepth = function pp_getObjectsByNameHierarchyDepth(name, isRegex = false) {
    return ObjectUtils.getObjectsByNameHierarchyDepth(this, name, isRegex);
  };
  objectExtension.pp_getObjectsByNameDescendants = function pp_getObjectsByNameDescendants(name, isRegex = false) {
    return ObjectUtils.getObjectsByNameDescendants(this, name, isRegex);
  };
  objectExtension.pp_getObjectsByNameDescendantsBreadth = function pp_getObjectsByNameDescendantsBreadth(name, isRegex = false) {
    return ObjectUtils.getObjectsByNameDescendantsBreadth(this, name, isRegex);
  };
  objectExtension.pp_getObjectsByNameDescendantsDepth = function pp_getObjectsByNameDescendantsDepth(name, isRegex = false) {
    return ObjectUtils.getObjectsByNameDescendantsDepth(this, name, isRegex);
  };
  objectExtension.pp_getObjectsByNameChildren = function pp_getObjectsByNameChildren(name, isRegex = false) {
    return ObjectUtils.getObjectsByNameChildren(this, name, isRegex);
  };
  objectExtension.pp_getObjectByID = function pp_getObjectByID(id) {
    return ObjectUtils.getObjectByID(this, id);
  };
  objectExtension.pp_getObjectByIDHierarchy = function pp_getObjectByIDHierarchy(id) {
    return ObjectUtils.getObjectByIDHierarchy(this, id);
  };
  objectExtension.pp_getObjectByIDHierarchyBreadth = function pp_getObjectByIDHierarchyBreadth(id) {
    return ObjectUtils.getObjectByIDHierarchyBreadth(this, id);
  };
  objectExtension.pp_getObjectByIDHierarchyDepth = function pp_getObjectByIDHierarchyDepth(id) {
    return ObjectUtils.getObjectByIDHierarchyDepth(this, id);
  };
  objectExtension.pp_getObjectByIDDescendants = function pp_getObjectByIDDescendants(id) {
    return ObjectUtils.getObjectByIDDescendants(this, id);
  };
  objectExtension.pp_getObjectByIDDescendantsBreadth = function pp_getObjectByIDDescendantsBreadth(id) {
    return ObjectUtils.getObjectByIDDescendantsBreadth(this, id);
  };
  objectExtension.pp_getObjectByIDDescendantsDepth = function pp_getObjectByIDDescendantsDepth(id) {
    return ObjectUtils.getObjectByIDDescendantsDepth(this, id);
  };
  objectExtension.pp_getObjectByIDChildren = function pp_getObjectByIDChildren(id) {
    return ObjectUtils.getObjectByIDChildren(this, id);
  };
  objectExtension.pp_getHierarchyBreadth = function pp_getHierarchyBreadth() {
    return ObjectUtils.getHierarchyBreadth(this);
  };
  objectExtension.pp_getHierarchyDepth = function pp_getHierarchyDepth() {
    return ObjectUtils.getHierarchyDepth(this);
  };
  objectExtension.pp_getDescendants = function pp_getDescendants() {
    return ObjectUtils.getDescendants(this);
  };
  objectExtension.pp_getDescendantsBreadth = function pp_getDescendantsBreadth() {
    return ObjectUtils.getDescendantsBreadth(this);
  };
  objectExtension.pp_getDescendantsDepth = function pp_getDescendantsDepth() {
    return ObjectUtils.getDescendantsDepth(this);
  };
  objectExtension.pp_getChildren = function pp_getChildren() {
    return ObjectUtils.getChildren(this);
  };
  objectExtension.pp_getSelf = function pp_getSelf() {
    return ObjectUtils.getSelf(this);
  };
  objectExtension.pp_addObject = function pp_addObject() {
    return ObjectUtils.addObject(this);
  };
  objectExtension.pp_getName = function pp_getName() {
    return ObjectUtils.getName(this);
  };
  objectExtension.pp_setName = function pp_setName(name) {
    return ObjectUtils.setName(this, name);
  };
  objectExtension.pp_getEngine = function pp_getEngine() {
    return ObjectUtils.getEngine(this);
  };
  objectExtension.pp_getID = function pp_getID() {
    return ObjectUtils.getID(this);
  };
  objectExtension.pp_markDirty = function pp_markDirty() {
    return ObjectUtils.markDirty(this);
  };
  objectExtension.pp_isTransformChanged = function pp_isTransformChanged() {
    return ObjectUtils.isTransformChanged(this);
  };
  objectExtension.pp_equals = function pp_equals(otherObject) {
    return ObjectUtils.equals(this, otherObject);
  };
  objectExtension.pp_destroy = function pp_destroy() {
    return ObjectUtils.destroy(this);
  };
  objectExtension.pp_reserveObjects = function pp_reserveObjects(count) {
    return ObjectUtils.reserveObjects(this, count);
  };
  objectExtension.pp_reserveObjectsSelf = function pp_reserveObjectsSelf(count) {
    return ObjectUtils.reserveObjectsSelf(this, count);
  };
  objectExtension.pp_reserveObjectsHierarchy = function pp_reserveObjectsHierarchy(count) {
    return ObjectUtils.reserveObjectsHierarchy(this, count);
  };
  objectExtension.pp_reserveObjectsDescendants = function pp_reserveObjectsDescendants(count) {
    return ObjectUtils.reserveObjectsDescendants(this, count);
  };
  objectExtension.pp_reserveObjectsChildren = function pp_reserveObjectsChildren(count) {
    return ObjectUtils.reserveObjectsChildren(this, count);
  };
  objectExtension.pp_getComponentsAmountMap = function pp_getComponentsAmountMap(amountMap = /* @__PURE__ */ new Map()) {
    return ObjectUtils.getComponentsAmountMap(this, amountMap);
  };
  objectExtension.pp_getComponentsAmountMapSelf = function pp_getComponentsAmountMapSelf(amountMap = /* @__PURE__ */ new Map()) {
    return ObjectUtils.getComponentsAmountMapSelf(this, amountMap);
  };
  objectExtension.pp_getComponentsAmountMapHierarchy = function pp_getComponentsAmountMapHierarchy(amountMap = /* @__PURE__ */ new Map()) {
    return ObjectUtils.getComponentsAmountMapHierarchy(this, amountMap);
  };
  objectExtension.pp_getComponentsAmountMapDescendants = function pp_getComponentsAmountMapDescendants(amountMap = /* @__PURE__ */ new Map()) {
    return ObjectUtils.getComponentsAmountMapDescendants(this, amountMap);
  };
  objectExtension.pp_getComponentsAmountMapChildren = function pp_getComponentsAmountMapChildren(amountMap = /* @__PURE__ */ new Map()) {
    return ObjectUtils.getComponentsAmountMapChildren(this, amountMap);
  };
  PluginUtils.injectProperties(objectExtension, Object3D.prototype, false, true, true);
}

// js/pp/plugin/wl/extensions/scene_extension.js
function initSceneExtension(engine2) {
  initSceneExtensionPrototype();
}
function initSceneExtensionPrototype() {
  let sceneExtension = {};
  sceneExtension.pp_getRoot = function pp_getRoot() {
    return SceneUtils.getRoot(this);
  };
  sceneExtension.pp_addObject = function pp_addObject() {
    return SceneUtils.addObject(this);
  };
  sceneExtension.pp_getObjects = function pp_getObjects() {
    return SceneUtils.getObjects(this);
  };
  sceneExtension.pp_getObjectsBreadth = function pp_getObjectsBreadth() {
    return SceneUtils.getObjectsBreadth(this);
  };
  sceneExtension.pp_getObjectsDepth = function pp_getObjectsDepth() {
    return SceneUtils.getObjectsDepth(this);
  };
  sceneExtension.pp_getComponent = function pp_getComponent(typeOrClass, index = 0) {
    return SceneUtils.getComponent(this, typeOrClass, index);
  };
  sceneExtension.pp_getComponentBreadth = function pp_getComponentBreadth(typeOrClass, index = 0) {
    return SceneUtils.getComponentBreadth(this, typeOrClass, index);
  };
  sceneExtension.pp_getComponentDepth = function pp_getComponentDepth(typeOrClass, index = 0) {
    return SceneUtils.getComponentDepth(this, typeOrClass, index);
  };
  sceneExtension.pp_getComponents = function pp_getComponents(typeOrClass) {
    return SceneUtils.getComponents(this, typeOrClass);
  };
  sceneExtension.pp_getComponentsBreadth = function pp_getComponentsBreadth(typeOrClass) {
    return SceneUtils.getComponentsBreadth(this, typeOrClass);
  };
  sceneExtension.pp_getComponentsDepth = function pp_getComponentsDepth(typeOrClass) {
    return SceneUtils.getComponentsDepth(this, typeOrClass);
  };
  sceneExtension.pp_getObjectByName = function pp_getObjectByName(name, isRegex = false, index = 0) {
    return SceneUtils.getObjectByName(this, name, isRegex, index);
  };
  sceneExtension.pp_getObjectByNameBreadth = function pp_getObjectByNameBreadth(name, isRegex = false, index = 0) {
    return SceneUtils.getObjectByNameBreadth(this, name, isRegex, index);
  };
  sceneExtension.pp_getObjectByNameDepth = function pp_getObjectByNameDepth(name, isRegex = false, index = 0) {
    return SceneUtils.getObjectByNameDepth(this, name, isRegex, index);
  };
  sceneExtension.pp_getObjectsByName = function pp_getObjectsByName(name, isRegex = false) {
    return SceneUtils.getObjectsByName(this, name, isRegex);
  };
  sceneExtension.pp_getObjectsByNameBreadth = function pp_getObjectsByNameBreadth(name, isRegex = false) {
    return SceneUtils.getObjectsByNameBreadth(this, name, isRegex);
  };
  sceneExtension.pp_getObjectsByNameDepth = function pp_getObjectsByNameDepth(name, isRegex = false) {
    return SceneUtils.getObjectsByNameDepth(this, name, isRegex);
  };
  sceneExtension.pp_getObjectByID = function pp_getObjectByID(id) {
    return SceneUtils.getObjectByID(this, id);
  };
  sceneExtension.pp_getObjectByIDBreadth = function pp_getObjectByIDBreadth(id) {
    return SceneUtils.getObjectByIDBreadth(this, id);
  };
  sceneExtension.pp_getObjectByIDDepth = function pp_getObjectByIDDepth(id) {
    return SceneUtils.getObjectByIDDepth(this, id);
  };
  sceneExtension.pp_toString = function pp_toString() {
    return SceneUtils.toString(this);
  };
  sceneExtension.pp_toStringCompact = function pp_toStringCompact() {
    return SceneUtils.toStringCompact(this);
  };
  sceneExtension.pp_toStringExtended = function pp_toStringExtended() {
    return SceneUtils.toStringExtended(this);
  };
  sceneExtension.pp_getComponentsAmountMap = function pp_getComponentsAmountMap(amountMap = /* @__PURE__ */ new Map()) {
    return SceneUtils.getComponentsAmountMap(this, amountMap);
  };
  PluginUtils.injectProperties(sceneExtension, Scene.prototype, false, true, true);
}

// js/pp/plugin/wl/extensions/init_wl_extentions.js
function initWLExtensions(engine2) {
  initObjectExtension();
  initSceneExtension(engine2);
}

// js/pp/cauldron/utils/browser_utils.js
var isMobile = function() {
  let checkMobileRegex = new RegExp("Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini", "i");
  return function isMobile2() {
    let userAgent = window.navigator.userAgent;
    return userAgent != null && userAgent.match(checkMobileRegex) != null;
  };
}();
function isDesktop() {
  return !BrowserUtils.isMobile();
}
var isLocalhost = function() {
  let localhostRegex = new RegExp("(localhost|127\\.0\\.0\\.1)(:(\\d{4}))?");
  return function isLocalhost2(port = null, isRegex = false) {
    let isLocalhost3 = false;
    let localhostMatch = window.location.origin.match(localhostRegex);
    if (localhostMatch != null) {
      if (port == null) {
        isLocalhost3 = true;
      } else if (localhostMatch.length >= 4 && localhostMatch[3] != null) {
        let portMatch = localhostMatch[3];
        if (isRegex) {
          isLocalhost3 = portMatch.match(port) != null;
        } else {
          isLocalhost3 = portMatch == port;
        }
      }
    }
    return isLocalhost3;
  };
}();
function openLink(url, newTab = true, exitXRSessionBeforeOpen = true, exitXRSessionOnSuccess = true, tryOpenLinkOnClickOnFailure = false, onSuccessCallback = null, onFailureCallback = null, engine2 = Globals.getMainEngine()) {
  let element = document.createElement("a");
  element.style.display = "none";
  document.body.appendChild(element);
  element.addEventListener("click", function() {
    let targetPage = void 0;
    if (newTab) {
      targetPage = "_blank";
    } else {
      targetPage = "_top";
    }
    let result = window.open(url, targetPage);
    if (result != null) {
      if (!exitXRSessionBeforeOpen && exitXRSessionOnSuccess) {
        XRUtils.exitSession(engine2);
      }
      if (onSuccessCallback != null) {
        onSuccessCallback();
      }
    } else {
      if (tryOpenLinkOnClickOnFailure) {
        setTimeout(function() {
          BrowserUtils.openLinkOnClick(url, newTab, exitXRSessionOnSuccess, onSuccessCallback, onFailureCallback);
        }, 100);
      } else if (onFailureCallback != null) {
        onFailureCallback();
      }
    }
  });
  if (exitXRSessionBeforeOpen) {
    XRUtils.exitSession(engine2);
  }
  element.click();
  document.body.removeChild(element);
}
function openLinkOnClick(url, newTab = true, exitXRSessionOnSuccess = true, onSuccessCallback = null, onFailureCallback = null, engine2 = Globals.getMainEngine()) {
  document.addEventListener("click", function() {
    let targetPage = void 0;
    if (newTab) {
      targetPage = "_blank";
    } else {
      targetPage = "_top";
    }
    let result = window.open(url, targetPage);
    if (result != null) {
      if (exitXRSessionOnSuccess) {
        XRUtils.exitSession(engine2);
      }
      if (onSuccessCallback != null) {
        onSuccessCallback();
      }
    } else {
      if (onFailureCallback != null) {
        onFailureCallback();
      }
    }
  }, { once: true });
}
var BrowserUtils = {
  isMobile,
  isDesktop,
  isLocalhost,
  openLink,
  openLinkOnClick
};

// js/pp/cauldron/utils/xr_utils.js
function getSession(engine2 = Globals.getMainEngine()) {
  let xr = Globals.getXR(engine2);
  return xr != null ? xr.session : null;
}
function getSessionMode(engine2 = Globals.getMainEngine()) {
  let xr = Globals.getXR(engine2);
  return xr != null ? xr.sessionMode : null;
}
function getReferenceSpace(engine2 = Globals.getMainEngine()) {
  let xr = Globals.getXR(engine2);
  return xr != null ? xr.currentReferenceSpace : null;
}
function getReferenceSpaceType(engine2 = Globals.getMainEngine()) {
  let type = "local";
  try {
    let xr = Globals.getXR(engine2);
    type = xr != null ? xr.currentReferenceSpaceType : null;
  } catch (error3) {
  }
  return type;
}
function getFrame(engine2 = Globals.getMainEngine()) {
  let xr = Globals.getXR(engine2);
  return xr != null ? xr.frame : null;
}
function isSessionActive(engine2 = Globals.getMainEngine()) {
  return XRUtils.getSession(engine2) != null;
}
function isReferenceSpaceFloorBased(engine2 = Globals.getMainEngine()) {
  return XRUtils.getReferenceSpaceType(engine2).includes("floor");
}
function exitSession(engine2 = Globals.getMainEngine()) {
  let xrSession = XRUtils.getSession(engine2);
  if (xrSession != null) {
    xrSession.end();
  }
}
function registerSessionStartEventListener(id, listener, manuallyCallSessionStartIfSessionAlreadyActive = false, addManualCallFlagToStartListener = false, engine2 = Globals.getMainEngine()) {
  if (listener != null) {
    if (addManualCallFlagToStartListener) {
      engine2.onXRSessionStart.add(listener.bind(void 0, false), { id, immediate: false });
    } else {
      engine2.onXRSessionStart.add(listener, { id, immediate: false });
    }
    if (manuallyCallSessionStartIfSessionAlreadyActive && XRUtils.isSessionActive(engine2)) {
      if (addManualCallFlagToStartListener) {
        listener(true, XRUtils.getSession(engine2), XRUtils.getSessionMode(engine2));
      } else {
        listener(XRUtils.getSession(engine2), XRUtils.getSessionMode(engine2));
      }
    }
  }
}
function unregisterSessionStartEventListener(id, engine2 = Globals.getMainEngine()) {
  engine2.onXRSessionStart.remove(id);
}
function registerSessionEndEventListener(id, listener, engine2 = Globals.getMainEngine()) {
  if (listener != null) {
    engine2.onXRSessionEnd.add(listener, { id });
  }
}
function unregisterSessionEndEventListener(id, engine2 = Globals.getMainEngine()) {
  return engine2.onXRSessionEnd.remove(id);
}
function registerSessionStartEndEventListeners(id, startListener, endListener, manuallyCallSessionStartIfSessionAlreadyActive = false, addManualCallFlagToStartListener = false, engine2 = Globals.getMainEngine()) {
  XRUtils.registerSessionEndEventListener(id, endListener, engine2);
  XRUtils.registerSessionStartEventListener(id, startListener, manuallyCallSessionStartIfSessionAlreadyActive, addManualCallFlagToStartListener, engine2);
}
function unregisterSessionStartEndEventListeners(id, engine2 = Globals.getMainEngine()) {
  XRUtils.unregisterSessionEndEventListener(id, engine2);
  XRUtils.unregisterSessionStartEventListener(id, engine2);
}
function isXRSupported(engine2 = Globals.getMainEngine()) {
  return XRUtils.isVRSupported(engine2) || XRUtils.isARSupported(engine2);
}
function isVRSupported(engine2 = Globals.getMainEngine()) {
  return engine2.vrSupported;
}
function isARSupported(engine2 = Globals.getMainEngine()) {
  return engine2.arSupported;
}
function isDeviceEmulated(onlyOnLocalhost = true) {
  let emulated = window.CustomWebXRPolyfill != null && (!onlyOnLocalhost || BrowserUtils.isLocalhost());
  return emulated;
}
var XRUtils = {
  getSession,
  getSessionMode,
  getReferenceSpace,
  getReferenceSpaceType,
  getFrame,
  isSessionActive,
  exitSession,
  registerSessionStartEventListener,
  unregisterSessionStartEventListener,
  registerSessionEndEventListener,
  unregisterSessionEndEventListener,
  registerSessionStartEndEventListeners,
  unregisterSessionStartEndEventListeners,
  isReferenceSpaceFloorBased,
  isXRSupported,
  isVRSupported,
  isARSupported,
  isDeviceEmulated
};

// js/pp/input/cauldron/input_types.js
var Handedness = {
  LEFT: "left",
  RIGHT: "right"
};
var HandednessIndex = {
  LEFT: 0,
  RIGHT: 1
};
var InputSourceType = {
  GAMEPAD: 0,
  TRACKED_HAND: 1
};
var TrackedHandJointID = {
  WRIST: "wrist",
  THUMB_METACARPAL: "thumb-metacarpal",
  THUMB_PHALANX_PROXIMAL: "thumb-phalanx-proximal",
  THUMB_PHALANX_DISTAL: "thumb-phalanx-distal",
  THUMB_TIP: "thumb-tip",
  INDEX_FINGER_METACARPAL: "index-finger-metacarpal",
  INDEX_FINGER_PHALANX_PROXIMAL: "index-finger-phalanx-proximal",
  INDEX_FINGER_PHALANX_INTERMEDIATE: "index-finger-phalanx-intermediate",
  INDEX_FINGER_PHALANX_DISTAL: "index-finger-phalanx-distal",
  INDEX_FINGER_TIP: "index-finger-tip",
  MIDDLE_FINGER_METACARPAL: "middle-finger-metacarpal",
  MIDDLE_FINGER_PHALANX_PROXIMAL: "middle-finger-phalanx-proximal",
  MIDDLE_FINGER_PHALANX_INTERMEDIATE: "middle-finger-phalanx-intermediate",
  MIDDLE_FINGER_PHALANX_DISTAL: "middle-finger-phalanx-distal",
  MIDDLE_FINGER_TIP: "middle-finger-tip",
  RING_FINGER_METACARPAL: "ring-finger-metacarpal",
  RING_FINGER_PHALANX_PROXIMAL: "ring-finger-phalanx-proximal",
  RING_FINGER_PHALANX_INTERMEDIATE: "ring-finger-phalanx-intermediate",
  RING_FINGER_PHALANX_DISTAL: "ring-finger-phalanx-distal",
  RING_FINGER_TIP: "ring-finger-tip",
  PINKY_FINGER_METACARPAL: "pinky-finger-metacarpal",
  PINKY_FINGER_PHALANX_PROXIMAL: "pinky-finger-phalanx-proximal",
  PINKY_FINGER_PHALANX_INTERMEDIATE: "pinky-finger-phalanx-intermediate",
  PINKY_FINGER_PHALANX_DISTAL: "pinky-finger-phalanx-distal",
  PINKY_FINGER_TIP: "pinky-finger-tip"
};
var TrackedHandJointIDIndex = {
  WRIST: 0,
  THUMB_METACARPAL: 1,
  THUMB_PHALANX_PROXIMAL: 2,
  THUMB_PHALANX_DISTAL: 3,
  THUMB_TIP: 4,
  INDEX_FINGER_METACARPAL: 5,
  INDEX_FINGER_PHALANX_PROXIMAL: 6,
  INDEX_FINGER_PHALANX_INTERMEDIATE: 7,
  INDEX_FINGER_PHALANX_DISTAL: 8,
  INDEX_FINGER_TIP: 9,
  MIDDLE_FINGER_METACARPAL: 10,
  MIDDLE_FINGER_PHALANX_PROXIMAL: 11,
  MIDDLE_FINGER_PHALANX_INTERMEDIATE: 12,
  MIDDLE_FINGER_PHALANX_DISTAL: 13,
  MIDDLE_FINGER_TIP: 14,
  RING_FINGER_METACARPAL: 15,
  RING_FINGER_PHALANX_PROXIMAL: 16,
  RING_FINGER_PHALANX_INTERMEDIATE: 17,
  RING_FINGER_PHALANX_DISTAL: 18,
  RING_FINGER_TIP: 19,
  PINKY_FINGER_METACARPAL: 20,
  PINKY_FINGER_PHALANX_PROXIMAL: 21,
  PINKY_FINGER_PHALANX_INTERMEDIATE: 22,
  PINKY_FINGER_PHALANX_DISTAL: 23,
  PINKY_FINGER_TIP: 24
};

// js/pp/input/cauldron/input_utils.js
function getHandednessByIndex(index) {
  let handedness = null;
  switch (index) {
    case HandednessIndex.LEFT:
      handedness = Handedness.LEFT;
      break;
    case HandednessIndex.RIGHT:
      handedness = Handedness.RIGHT;
      break;
  }
  return handedness;
}
function getInputSource(handedness, inputSourceType = null, engine2 = Globals.getMainEngine()) {
  let inputSource = null;
  let xrSession = XRUtils.getSession(engine2);
  if (xrSession != null && xrSession.inputSources != null) {
    for (let i = 0; i < xrSession.inputSources.length; i++) {
      let input = xrSession.inputSources[i];
      let correctType = !inputSourceType || inputSourceType == InputSourceType.GAMEPAD && !input.hand || inputSourceType == InputSourceType.TRACKED_HAND && input.hand;
      if (correctType && input.handedness == handedness) {
        inputSource = input;
        break;
      }
    }
  }
  return inputSource;
}
function getInputSourceTypeByHandedness(handedness, engine2) {
  let inputSource = InputUtils.getInputSource(handedness, void 0, engine2);
  return InputUtils.getInputSourceType(inputSource);
}
function getInputSourceType(inputSource) {
  let inputSourceType = null;
  if (inputSource) {
    if (inputSource.hand) {
      inputSourceType = InputSourceType.TRACKED_HAND;
    } else {
      inputSourceType = InputSourceType.GAMEPAD;
    }
  }
  return inputSourceType;
}
function getOppositeHandedness(handedness) {
  let oppositeHandedness = null;
  switch (handedness) {
    case Handedness.LEFT:
      oppositeHandedness = Handedness.RIGHT;
      break;
    case Handedness.RIGHT:
      oppositeHandedness = Handedness.LEFT;
      break;
  }
  return oppositeHandedness;
}
function getJointIDByIndex(index) {
  let jointID = null;
  let jointIDKey = null;
  for (let jointIDIndexKey in TrackedHandJointIDIndex) {
    if (TrackedHandJointIDIndex[jointIDIndexKey] == index) {
      jointIDKey = jointIDIndexKey;
      break;
    }
  }
  if (jointIDKey != null) {
    jointID = TrackedHandJointID[jointIDKey];
  }
  return jointID;
}
var InputUtils = {
  getHandednessByIndex,
  getInputSource,
  getInputSourceTypeByHandedness,
  getInputSourceType,
  getOppositeHandedness,
  getJointIDByIndex
};

// js/pp/plugin/wl/mods/components/cursor_component_mod.js
function initCursorComponentMod() {
  initCursorComponentModPrototype();
}
function initCursorComponentModPrototype() {
  let cursorComponentMod = {};
  cursorComponentMod.init = function init() {
    this.maxDistance = 100;
    this.visible = false;
    this.globalTarget = this.object.pp_addComponent(CursorTarget);
    this.hitTestTarget = this.object.pp_addComponent(CursorTarget);
    this.hoveringObject = null;
    this.hoveringObjectTarget = null;
    this.cursorPos = vec3_create();
    this._collisionMask = 1 << this.collisionGroup;
    this._doubleClickTimer = 0;
    this._tripleClickTimer = 0;
    this._multipleClickObject = null;
    this._multipleClickDelay = 0.3;
    this._onDestroyCallbacks = [];
    this._prevHitLocationLocalToTarget = vec3_create();
    this._pointerID = null;
    this._updatePointerStyle = false;
    this._lastClientX = null;
    this._lastClientY = null;
    this._lastWidth = null;
    this._lastHeight = null;
    this._lastPointerID = null;
    this._lastOriginalMouseEvent = null;
    this._lastOriginalGamepadEvent = null;
    this._pointerLeaveToProcess = false;
    this._pointerLeaveMouseEvent = null;
    this._transformQuat = quat2_create();
    this._origin = vec3_create();
    this._direction = vec3_create();
    this._isHovering = false;
    this._isDown = false;
    this._lastIsDown = false;
    this._isRealDown = false;
    this._isDownForUpWithDown = false;
    this._isUpWithNoDown = false;
    this._tempVec = vec3_create();
    this._viewComponent = null;
    this._cursorRayOrigin = vec3_create();
    this._cursorRayScale = vec3_create();
    this._projectionMatrix = mat4_create();
    this._hitTestLocation = null;
    this._hitTestObject = null;
    this._rayHitLocation = vec3_create();
    this._hitObjectData = [null, null, null];
    this._myViewEventListenersRegistered = false;
  };
  cursorComponentMod.start = function start() {
    if (this.handedness == 0) {
      let inputComp = this.object.pp_getComponent(InputComponent);
      if (!inputComp) {
        console.warn("cursor component on object " + this.object.pp_getName() + ' was configured with handedness "input component", but object has no input component.');
      } else {
        this.handedness = inputComp.handedness;
        this.input = inputComp;
      }
    } else {
      this.handedness = InputUtils.getHandednessByIndex(this.handedness - 1);
    }
    this.pp_setViewComponent(this.object.pp_getComponent(ViewComponent));
    XRUtils.registerSessionStartEventListener(this, this.setupVREvents.bind(this), true, false, this.engine);
    this._onDestroyCallbacks.push(() => {
      XRUtils.unregisterSessionStartEventListener(this, this.engine);
    });
    if (this.cursorRayObject) {
      this.cursorRayObject.pp_setActive(false);
      this._cursorRayScale.set(this.cursorRayObject.pp_getScaleLocal());
      this._setCursorRayTransform(null);
    }
    this._setCursorVisibility(false);
    if (this.useWebXRHitTest) {
      this._hitTestObject = this.object.pp_addObject();
      this._hitTestLocation = this.hitTestObject.pp_addComponent(HitTestLocation, { scaleObject: false });
    }
  };
  cursorComponentMod.update = function update(dt) {
    if (this._doubleClickTimer > 0) {
      this._doubleClickTimer -= dt;
    }
    if (this._tripleClickTimer > 0) {
      this._tripleClickTimer -= dt;
    }
    if (XRUtils.isSessionActive(this.engine) && this._viewComponent == null) {
      if (this.arTouchDown && this._pp_isAR()) {
        let axes = XRUtils.getSession(this.engine).inputSources[0].gamepad.axes;
        this._direction.vec3_set(axes[0], -axes[1], -1);
        this.updateDirection();
      } else {
        this.object.pp_getPosition(this._origin);
        this.object.pp_getForward(this._direction);
      }
      let hitObjectData = this._pp_rayCast();
      this._pp_hoverBehaviour(hitObjectData[0], hitObjectData[1], hitObjectData[2], this._lastOriginalGamepadEvent);
    } else if (!XRUtils.isSessionActive(this.engine) && this._viewComponent != null) {
      if (this._lastPointerID != null) {
        this._pp_updateMousePos(this._lastClientX, this._lastClientY, this._lastWidth, this._lastHeight);
        let hitObjectData = this._pp_rayCast();
        this._pp_hoverBehaviour(hitObjectData[0], hitObjectData[1], hitObjectData[2], this._lastOriginalMouseEvent);
        if (this.hoveringObject != null) {
          this._pointerID = this._lastPointerID;
        } else {
          this._pointerID = null;
        }
      } else if (this.hoveringObject != null) {
        this._pp_hoverBehaviour(null, null, null, this._lastOriginalMouseEvent, true);
      }
    } else if (this.hoveringObject != null) {
      this._pp_hoverBehaviour(null, null, null, null, true);
    }
    this._pp_processPointerLeave();
    if (this.hoveringObject != null && (this.cursorPos[0] != 0 || this.cursorPos[1] != 0 || this.cursorPos[2] != 0)) {
      if (this.cursorObject) {
        this._setCursorVisibility(true);
        this.cursorObject.pp_setPosition(this.cursorPos);
        this.cursorObject.pp_setTransformLocalQuat(this.cursorObject.pp_getTransformLocalQuat(this._transformQuat).quat2_normalize(this._transformQuat));
      }
      if (this.cursorRayObject) {
        this._setCursorRayTransform(this.cursorPos);
      }
    } else {
      if (this.cursorObject) {
        this._setCursorVisibility(false);
      }
      if (this.cursorRayObject) {
        this._setCursorRayTransform(null);
      }
    }
    if (this.cursorRayObject) {
      if (XRUtils.isSessionActive(this.engine) && this._viewComponent == null || !XRUtils.isSessionActive(this.engine) && this._viewComponent != null && this.handedness != Handedness.LEFT && this.handedness != Handedness.RIGHT) {
        this.cursorRayObject.pp_setActive(true);
      } else {
        this.cursorRayObject.pp_setActive(false);
      }
    }
    if (this.hoveringObject == null) {
      this._pointerID = null;
    }
    this._updatePointerStyle = false;
    this._lastOriginalMouseEvent = null;
    this._lastOriginalGamepadEvent = null;
  };
  cursorComponentMod.onActivate = function onActivate() {
    this._isDown = false;
    this._lastIsDown = false;
    this._isDownForUpWithDown = false;
    this._isUpWithNoDown = false;
  };
  cursorComponentMod.onDeactivate = function onDeactivate() {
    if (this.hoveringObject != null) {
      this._pp_hoverBehaviour(null, null, null, null, true);
    }
    this.hoveringObject = null;
    this.hoveringObjectTarget = null;
    this._pp_updateCursorStyle();
    this._setCursorVisibility(false);
    if (this.cursorRayObject) {
      this.cursorRayObject.pp_setActive(false);
    }
    this._isDown = false;
    this._lastIsDown = false;
    this._isRealDown = false;
    this._isDownForUpWithDown = false;
    this._isUpWithNoDown = false;
    this._pointerID = null;
    this._lastPointerID = null;
    this._lastClientX = null;
    this._lastClientY = null;
    this._lastWidth = null;
    this._lastHeight = null;
    this._lastOriginalMouseEvent = null;
    this._lastOriginalGamepadEvent = null;
    this._pointerLeaveToProcess = false;
    this._pointerLeaveMouseEvent = null;
  };
  cursorComponentMod.onDestroy = function onDestroy() {
    if (this._hitTestObject != null) {
      this._hitTestObject.pp_destroy();
    }
    for (let callback of this._onDestroyCallbacks) {
      callback();
    }
  };
  cursorComponentMod.updateDirection = function() {
    let transformWorld = quat2_create();
    return function updateDirection() {
      this.object.pp_getPosition(this._origin);
      this._direction.vec3_transformMat4(this._projectionMatrix, this._direction);
      this._direction.vec3_normalize(this._direction);
      this._direction.vec3_transformQuat(this.object.pp_getTransformQuat(transformWorld), this._direction);
    };
  }();
  cursorComponentMod.setupVREvents = function setupVREvents(session) {
    let onSelect = this.onSelect.bind(this);
    session.addEventListener("select", onSelect);
    let onSelectStart = this.onSelectStart.bind(this);
    session.addEventListener("selectstart", onSelectStart);
    let onSelectEnd = this.onSelectEnd.bind(this);
    session.addEventListener("selectend", onSelectEnd);
    this._onDestroyCallbacks.push(() => {
      if (!XRUtils.isSessionActive(this.engine))
        return;
      let session2 = XRUtils.getSession(this.engine);
      session2.removeEventListener("select", onSelect);
      session2.removeEventListener("selectstart", onSelectStart);
      session2.removeEventListener("selectend", onSelectEnd);
    });
    this._onViewportResize();
  };
  cursorComponentMod.onSelect = function onSelect(e) {
  };
  cursorComponentMod.onSelectStart = function onSelectStart(e) {
    if (this.active) {
      if (this._pp_isAR()) {
        this.arTouchDown = true;
        this._lastOriginalGamepadEvent = e;
      } else if (e.inputSource.handedness == this.handedness) {
        this._isDown = true;
        this._isRealDown = true;
        if (!this._lastIsDown) {
          this._isDownForUpWithDown = true;
        }
        this._lastOriginalGamepadEvent = e;
      }
    }
  };
  cursorComponentMod.onSelectEnd = function onSelectEnd(e) {
    if (this.active) {
      if (this._pp_isAR()) {
        this.arTouchDown = false;
        this._lastOriginalGamepadEvent = e;
      } else if (e.inputSource.handedness == this.handedness) {
        if (!this._isDownForUpWithDown) {
          this._isUpWithNoDown = true;
        }
        this._isDown = false;
        this._isRealDown = false;
        this._isDownForUpWithDown = false;
        this._lastOriginalGamepadEvent = e;
      }
    }
  };
  cursorComponentMod.onPointerMove = function onPointerMove(e) {
    if (this.active && !this._pointerLeaveToProcess) {
      if (this._pointerID != null && this._pointerID != e.pointerId)
        return;
      let bounds = Globals.getBody(this.engine).getBoundingClientRect();
      this._pp_updateMouseData(e, e.clientX, e.clientY, bounds.width, bounds.height, e.pointerId);
    }
  };
  cursorComponentMod.onClick = function onClick(e) {
  };
  cursorComponentMod.onPointerDown = function onPointerDown(e) {
    if (this.active && !this._pointerLeaveToProcess) {
      if (this._pointerID != null && this._pointerID != e.pointerId || e.button !== 0)
        return;
      let bounds = Globals.getBody(this.engine).getBoundingClientRect();
      this._pp_updateMouseData(e, e.clientX, e.clientY, bounds.width, bounds.height, e.pointerId);
      this._isDown = true;
      this._isRealDown = true;
      if (!this._lastIsDown) {
        this._isDownForUpWithDown = true;
      }
    }
  };
  cursorComponentMod.onPointerUp = function onPointerUp(e) {
    if (this.active && !this._pointerLeaveToProcess) {
      if (this._pointerID != null && this._pointerID != e.pointerId || e.button !== 0)
        return;
      let bounds = Globals.getBody(this.engine).getBoundingClientRect();
      this._pp_updateMouseData(e, e.clientX, e.clientY, bounds.width, bounds.height, e.pointerId);
      if (!this._isDownForUpWithDown) {
        this._isUpWithNoDown = true;
      }
      this._isDown = false;
      this._isRealDown = false;
      this._isDownForUpWithDown = false;
      this._updatePointerStyle = true;
    }
  };
  cursorComponentMod._onViewportResize = function _onViewportResize() {
    if (!this._viewComponent)
      return;
    this._viewComponent.projectionMatrix.mat4_invert(this._projectionMatrix);
  };
  cursorComponentMod._setCursorRayTransform = function _setCursorRayTransform(hitPosition) {
    if (!this.cursorRayObject)
      return;
    if (this.cursorRayScalingAxis != 4) {
      this.cursorRayObject.pp_resetScaleLocal();
      if (hitPosition != null) {
        this.cursorRayObject.pp_getPosition(this._cursorRayOrigin);
        let dist4 = this._cursorRayOrigin.vec3_distance(hitPosition);
        this._cursorRayScale[this.cursorRayScalingAxis] = dist4;
        this.cursorRayObject.pp_scaleObject(this._cursorRayScale);
      }
    }
  };
  cursorComponentMod._setCursorVisibility = function _setCursorVisibility(visible) {
    this.visible = visible;
    if (!this.cursorObject)
      return;
    this.cursorObject.pp_setActive(visible);
  };
  cursorComponentMod._pp_hoverBehaviour = function _pp_hoverBehaviour(hitObject, hitLocation, hitTestResults, originalEvent = null, forceUnhover = false) {
    if (!forceUnhover && hitObject != null) {
      let hoveringObjectChanged = false;
      if (this.hoveringObject == null || !this.hoveringObject.pp_equals(hitObject)) {
        if (this.hoveringObject != null) {
          if (!this.hoveringReality) {
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onUnhover.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onUnhover.notify(this.hoveringObject, this, originalEvent);
          } else {
            this.hitTestTarget.onUnhover.notify(null, this, originalEvent);
          }
        }
        hoveringObjectChanged = true;
        this.hoveringObject = hitObject;
        this.hoveringObjectTarget = this.hoveringObject.pp_getComponent(CursorTarget);
        if (!this.hoveringReality) {
          if (this.hoveringObjectTarget)
            this.hoveringObjectTarget.onHover.notify(this.hoveringObject, this, originalEvent);
          this.globalTarget.onHover.notify(this.hoveringObject, this, originalEvent);
        } else {
          this.hitTestTarget.onHover.notify(hitTestResults, this, originalEvent);
        }
        this._pp_updateCursorStyle();
        if (!this._pp_isDownToProcess() && this._isRealDown) {
          this._isDown = true;
          this._lastIsDown = true;
          this._isDownForUpWithDown = false;
          this._isUpWithNoDown = false;
          if (!this.hoveringReality) {
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onDownOnHover.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onDownOnHover.notify(this.hoveringObject, this, originalEvent);
          } else {
            this.hitTestTarget.onDownOnHover.notify(hitTestResults, this, originalEvent);
          }
        }
      }
      if (this._updatePointerStyle) {
        this._pp_updateCursorStyle();
      }
      if (!hoveringObjectChanged && this._pp_isMoving(hitLocation)) {
        if (!this.hoveringReality) {
          if (this.hoveringObjectTarget)
            this.hoveringObjectTarget.onMove.notify(this.hoveringObject, this, originalEvent);
          this.globalTarget.onMove.notify(this.hoveringObject, this, originalEvent);
        } else {
          this.hitTestTarget.onMove.notify(hitTestResults, this, originalEvent);
        }
      }
      if (this._pp_isDownToProcess()) {
        if (!this.hoveringReality) {
          if (this.hoveringObjectTarget)
            this.hoveringObjectTarget.onDown.notify(this.hoveringObject, this, originalEvent);
          this.globalTarget.onDown.notify(this.hoveringObject, this, originalEvent);
        } else {
          this.hitTestTarget.onDown.notify(hitTestResults, this, originalEvent);
        }
        if (!this.hoveringReality) {
          if (this.hoveringObjectTarget)
            this.hoveringObjectTarget.onClick.notify(this.hoveringObject, this, originalEvent);
          this.globalTarget.onClick.notify(this.hoveringObject, this, originalEvent);
        } else {
          this.hitTestTarget.onClick.notify(hitTestResults, this, originalEvent);
        }
        if (this._tripleClickTimer > 0 && this._multipleClickObject && this._multipleClickObject.pp_equals(this.hoveringObject)) {
          if (!this.hoveringReality) {
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onTripleClick.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onTripleClick.notify(this.hoveringObject, this, originalEvent);
          } else {
            this.hitTestTarget.onTripleClick.notify(hitTestResults, this, originalEvent);
          }
          this._tripleClickTimer = 0;
        } else if (this._doubleClickTimer > 0 && this._multipleClickObject && this._multipleClickObject.pp_equals(this.hoveringObject)) {
          if (!this.hoveringReality) {
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onDoubleClick.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onDoubleClick.notify(this.hoveringObject, this, originalEvent);
          } else {
            this.hitTestTarget.onDoubleClick.notify(hitTestResults, this, originalEvent);
          }
          this._tripleClickTimer = this._multipleClickDelay;
          this._doubleClickTimer = 0;
        } else {
          if (!this.hoveringReality) {
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onSingleClick.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onSingleClick.notify(this.hoveringObject, this, originalEvent);
          } else {
            this.hitTestTarget.onSingleClick.notify(hitTestResults, this, originalEvent);
          }
          this._tripleClickTimer = 0;
          this._doubleClickTimer = this._multipleClickDelay;
          this._multipleClickObject = this.hoveringObject;
        }
      } else {
        if (!this._isUpWithNoDown && !hoveringObjectChanged && this._pp_isUpToProcess()) {
          if (!this.hoveringReality) {
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onUp.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onUp.notify(this.hoveringObject, this, originalEvent);
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onUpWithDown.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onUpWithDown.notify(this.hoveringObject, this, originalEvent);
          } else {
            this.hitTestTarget.onUp.notify(hitTestResults, this, originalEvent);
            this.hitTestTarget.onUpWithDown.notify(hitTestResults, this, originalEvent);
          }
        } else if (this._isUpWithNoDown || hoveringObjectChanged && this._pp_isUpToProcess()) {
          if (!this.hoveringReality) {
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onUp.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onUp.notify(this.hoveringObject, this, originalEvent);
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onUpWithNoDown.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onUpWithNoDown.notify(this.hoveringObject, this, originalEvent);
          } else {
            this.hitTestTarget.onUp.notify(hitTestResults, this, originalEvent);
            this.hitTestTarget.onUpWithNoDown.notify(hitTestResults, this, originalEvent);
          }
        }
      }
      this._prevHitLocationLocalToTarget = this.hoveringObject.pp_convertPositionWorldToLocal(hitLocation, this._prevHitLocationLocalToTarget);
    } else if (this.hoveringObject != null && (forceUnhover || hitObject == null)) {
      if (!this.hoveringReality) {
        if (this.hoveringObjectTarget)
          this.hoveringObjectTarget.onUnhover.notify(this.hoveringObject, this, originalEvent);
        this.globalTarget.onUnhover.notify(this.hoveringObject, this, originalEvent);
      } else {
        this.hitTestTarget.onUnhover.notify(null, this, originalEvent);
      }
      this.hoveringObject = null;
      this.hoveringObjectTarget = null;
      this._pp_updateCursorStyle();
    }
    if (this.hoveringObject != null) {
      this._lastIsDown = this._isDown;
    } else {
      this._isDown = false;
      this._lastIsDown = false;
      this._isDownForUpWithDown = false;
    }
    this._isUpWithNoDown = false;
  };
  cursorComponentMod._pp_rayCast = function _pp_rayCast() {
    let rayHit = this.rayCastMode == 0 ? Globals.getScene(this.engine).rayCast(
      this._origin,
      this._direction,
      this._collisionMask
    ) : Globals.getPhysics(this.engine).rayCast(
      this._origin,
      this._direction,
      this._collisionMask,
      this.maxDistance
    );
    let rayHitCollisionDistanceValid = true;
    if (this.rayCastMode == 0 && rayHit.hitCount > 0 && rayHit.distances[0] > this.maxDistance) {
      rayHitCollisionDistanceValid = false;
    }
    this._hitObjectData[0] = null;
    this._hitObjectData[1] = null;
    this._hitObjectData[2] = null;
    let hitTestResultDistance = Infinity;
    if (this._hitTestLocation != null && this._hitTestLocation.visible) {
      this._hitTestObject.pp_getPositionWorld(this.cursorPos);
      this._rayHitLocation.vec3_copy(this.cursorPos);
      hitTestResultDistance = this.cursorPos.vec3_distance(this.object.pp_getPositionWorld(this._tempVec));
      this._hitObjectData[0] = this._hitTestObject;
      this._hitObjectData[1] = this._rayHitLocation;
    }
    this.hoveringReality = false;
    if (rayHit.hitCount > 0 && rayHitCollisionDistanceValid) {
      let rayHitDistance = rayHit.distances[0];
      if (rayHitDistance <= hitTestResultDistance) {
        this.cursorPos.vec3_copy(rayHit.locations[0]);
        this._rayHitLocation.vec3_copy(this.cursorPos);
        this._hitObjectData[0] = rayHit.objects[0];
        this._hitObjectData[1] = this._rayHitLocation;
      } else {
        this.hoveringReality = true;
      }
    } else if (hitTestResultDistance == Infinity) {
      this.cursorPos.vec3_zero();
      this._hitObjectData[0] = null;
      this._hitObjectData[1] = null;
    }
    let xrFrame = XRUtils.getFrame(this.engine);
    if (this.hoveringReality && xrFrame != null) {
      this._hitObjectData[2] = this._hitTestLocation.getHitTestResults(xrFrame)[0];
    }
    return this._hitObjectData;
  };
  cursorComponentMod._pp_updateMouseData = function _pp_updateMouseData(e, clientX, clientY, w, h, pointerID) {
    this._lastClientX = clientX;
    this._lastClientY = clientY;
    this._lastWidth = w;
    this._lastHeight = h;
    this._lastPointerID = pointerID;
    this._lastOriginalMouseEvent = e;
  };
  cursorComponentMod._pp_updateMousePos = function _pp_updateMousePos(clientX, clientY, w, h) {
    let left = clientX / w;
    let top = clientY / h;
    this._direction.vec3_set(left * 2 - 1, -top * 2 + 1, -1);
    this.updateDirection();
  };
  cursorComponentMod.pp_setViewComponent = function pp_setViewComponent(viewComponent) {
    this._viewComponent = viewComponent;
    if (this._viewComponent != null) {
      this._viewComponent.projectionMatrix.mat4_invert(this._projectionMatrix);
      if (!this._myViewEventListenersRegistered) {
        this._myViewEventListenersRegistered = true;
        let onClick = this.onClick.bind(this);
        Globals.getCanvas(this.engine).addEventListener("click", onClick);
        let onPointerDown = this.onPointerDown.bind(this);
        Globals.getCanvas(this.engine).addEventListener("pointerdown", onPointerDown);
        let onPointerMove = this.onPointerMove.bind(this);
        Globals.getCanvas(this.engine).addEventListener("pointermove", onPointerMove);
        let onPointerUp = this.onPointerUp.bind(this);
        Globals.getCanvas(this.engine).addEventListener("pointerup", onPointerUp);
        let onPointerLeave = this._pp_onPointerLeave.bind(this);
        Globals.getCanvas(this.engine).addEventListener("pointerleave", onPointerLeave);
        let onViewportResize = this._onViewportResize.bind(this);
        this.engine.onResize.add(onViewportResize);
        this._onDestroyCallbacks.push(() => {
          Globals.getCanvas(this.engine).removeEventListener("click", onClick);
          Globals.getCanvas(this.engine).removeEventListener("pointerdown", onPointerDown);
          Globals.getCanvas(this.engine).removeEventListener("pointermove", onPointerMove);
          Globals.getCanvas(this.engine).removeEventListener("pointerup", onPointerUp);
          Globals.getCanvas(this.engine).removeEventListener("pointerleave", onPointerLeave);
          this.engine.onResize.remove(onViewportResize);
          this._myViewEventListenersRegistered = false;
        });
      }
    }
  };
  cursorComponentMod._pp_onPointerLeave = function _pp_onPointerLeave(e) {
    if (this._pointerID == null || this._pointerID == e.pointerId) {
      this._pointerLeaveToProcess = true;
      this._pointerLeaveMouseEvent = e;
    }
  };
  cursorComponentMod._pp_processPointerLeave = function _pp_processPointerLeave() {
    if (this._pointerLeaveToProcess) {
      this._pointerID = null;
      this._lastPointerID = null;
      this._lastClientX = null;
      this._lastClientY = null;
      this._lastWidth = null;
      this._lastHeight = null;
      this._lastOriginalMouseEvent = this._pointerLeaveMouseEvent;
      this._pointerLeaveToProcess = false;
      this._pointerLeaveMouseEvent = null;
      if (this.hoveringObject != null) {
        this._pp_hoverBehaviour(null, null, null, this._lastOriginalMouseEvent, true);
      }
      this._isDown = false;
      this._lastIsDown = false;
      this._isRealDown = false;
      this._isDownForUpWithDown = false;
      this._isUpWithNoDown = false;
    }
  };
  cursorComponentMod._pp_isDownToProcess = function _pp_isDownToProcess() {
    return this._isDown !== this._lastIsDown && this._isDown;
  };
  cursorComponentMod._pp_isUpToProcess = function _pp_isUpToProcess() {
    return this._isDown !== this._lastIsDown && !this._isDown;
  };
  cursorComponentMod._pp_isMoving = function() {
    let hitLocationLocalToTarget = vec3_create();
    return function _pp_isMoving(hitLocation) {
      let moving = false;
      hitLocationLocalToTarget = this.hoveringObject.pp_convertPositionWorldToLocal(hitLocation, hitLocationLocalToTarget);
      if (!hitLocationLocalToTarget.vec_equals(this._prevHitLocationLocalToTarget, 1e-4)) {
        moving = true;
      }
      return moving;
    };
  }();
  cursorComponentMod._pp_isAR = function _pp_isAR() {
    let firstInputSource = XRUtils.getSession(this.engine).inputSources[0];
    return this.input != null && firstInputSource.handedness === "none" && firstInputSource.gamepad != null;
  };
  cursorComponentMod._pp_updateCursorStyle = function _pp_updateCursorStyle() {
    if (this.styleCursor) {
      if (this.hoveringObjectTarget != null && !this.hoveringObjectTarget.isSurface) {
        Globals.getBody(this.engine).style.cursor = "pointer";
      } else if (Globals.getBody(this.engine).style.cursor == "pointer") {
        Globals.getBody(this.engine).style.cursor = "default";
      }
    }
  };
  PluginUtils.injectProperties(cursorComponentMod, Cursor.prototype, false, true, true);
}

// js/pp/plugin/wl/mods/components/cursor_target_component_mod.js
function initCursorTargetComponentMod() {
  initCursorTargetComponentModPrototype();
}
function initCursorTargetComponentModPrototype() {
  let cursorTargetComponentMod = {};
  cursorTargetComponentMod.init = function init() {
    this.onSingleClick = new Emitter();
    this.onDoubleClick = new Emitter();
    this.onTripleClick = new Emitter();
    this.onDownOnHover = new Emitter();
    this.onUpWithDown = new Emitter();
    this.onUpWithNoDown = new Emitter();
    this.isSurface = false;
  };
  cursorTargetComponentMod.start = function start() {
  };
  cursorTargetComponentMod.update = function update(dt) {
  };
  cursorTargetComponentMod.onActivate = function onActivate() {
  };
  cursorTargetComponentMod.onDeactivate = function onDeactivate() {
  };
  cursorTargetComponentMod.onDestroy = function onDestroy() {
  };
  PluginUtils.injectProperties(cursorTargetComponentMod, CursorTarget.prototype, false, true, true);
}

// js/pp/cauldron/cauldron/timer.js
var Timer = class {
  constructor(duration, autoStart = true) {
    this._myDuration = duration;
    this._myOnEndEmitter = new Emitter();
    this._myDone = false;
    this._myJustDone = false;
    this._myStarted = false;
    if (autoStart) {
      this.start();
    } else {
      this.reset();
    }
  }
  start(duration = null) {
    this.reset(duration);
    this._myStarted = true;
  }
  end() {
    this._done();
  }
  reset(duration = null) {
    if (duration != null) {
      this._myDuration = Math.max(0, duration);
    }
    this._myTimeLeft = this._myDuration;
    this._myDone = false;
    this._myJustDone = false;
    this._myStarted = false;
  }
  update(dt) {
    this._myJustDone = false;
    if (this.isRunning()) {
      this._myTimeLeft = Math.max(0, this._myTimeLeft - dt);
      if (this._myTimeLeft == 0) {
        this._done();
      }
    }
  }
  isDone() {
    return this._myDone;
  }
  isJustDone() {
    return this._myJustDone;
  }
  isStarted() {
    return this._myStarted;
  }
  isRunning() {
    return this.isStarted() && !this.isDone();
  }
  getDuration() {
    return this._myDuration;
  }
  setDuration(duration) {
    this._myDuration = Math.max(0, duration);
  }
  getTimeLeft() {
    return this._myTimeLeft;
  }
  getPercentage() {
    let percentage = 1;
    if (this._myTimeLeft > 0 && this._myDuration > 0) {
      percentage = (this._myDuration - this._myTimeLeft) / this._myDuration;
    }
    return Math.pp_clamp(percentage, 0, 1);
  }
  setPercentage(percentage) {
    if (this.isRunning()) {
      let durationPercentage = Math.pp_clamp(1 - percentage, 0, 1);
      this._myTimeLeft = this._myDuration * durationPercentage;
    }
  }
  onEnd(listener, id = null) {
    this._myOnEndEmitter.add(listener, { id });
  }
  unregisterOnEnd(id = null) {
    this._myOnEndEmitter.remove(id);
  }
  _done() {
    this._myTimeLeft = 0;
    this._myDone = true;
    this._myJustDone = true;
    this._myOnEndEmitter.notify();
  }
};

// js/pp/plugin/wl/mods/components/mouse_look_component_mod.js
function initMouseLookComponentMod() {
  initMouseLookComponentModPrototype();
}
function initMouseLookComponentModPrototype() {
  let mouseLookComponentMod = {};
  mouseLookComponentMod.init = function init() {
    this.pointerId = null;
    this.prevMoveEvent = null;
    this.resetMovingDelay = 0.15;
    this.resetMovingTimer = new Timer(this.resetMovingDelay, false);
    this.isMoving = false;
    this.pointerMoveListener = this._onMove.bind(this);
    this.contextMenuListener = function(event) {
      if (this.active) {
        event.preventDefault();
      }
    }.bind(this);
    this.pointerDown = function(event) {
      if (this.active) {
        if (this.pointerId != null)
          return;
        if (!this.mouseDown) {
          if (event.button == this.mouseButtonIndex) {
            this.pointerId = event.pointerId;
            this.mouseDown = true;
            if (event.button == 1) {
              event.preventDefault();
              return false;
            }
          }
        }
      }
    }.bind(this);
    this.pointerUp = function(event) {
      if (this.active) {
        if (event.pointerId != this.pointerId)
          return;
        if (this.mouseDown) {
          if (event.button == this.mouseButtonIndex) {
            this.mouseDown = false;
          }
        }
      }
    }.bind(this);
    this.pointerLeave = function(event) {
      if (this.active) {
        if (event.pointerId != this.pointerId)
          return;
        this.pointerId = null;
        this.prevMoveEvent = null;
        if (this.mouseDown) {
          this.mouseDown = false;
        }
      }
    }.bind(this);
    Globals.getBody(this.engine).addEventListener("pointermove", this.pointerMoveListener);
    if (this.requireMouseDown) {
      if (this.mouseButtonIndex == 2) {
        Globals.getCanvas(this.engine).addEventListener("contextmenu", this.contextMenuListener, false);
      }
      Globals.getCanvas(this.engine).addEventListener("pointerdown", this.pointerDown);
      Globals.getBody(this.engine).addEventListener("pointerup", this.pointerUp);
    }
    Globals.getBody(this.engine).addEventListener("pointerleave", this.pointerLeave);
  };
  mouseLookComponentMod.start = function start() {
  };
  mouseLookComponentMod.onActivate = function onActivate() {
  };
  mouseLookComponentMod.onDeactivate = function onDeactivate() {
    if (this.mouseDown) {
    }
    this.isMoving = false;
    this.mouseDown = false;
    this.pointerId = null;
    this.prevMoveEvent = null;
  };
  mouseLookComponentMod.onDestroy = function onDestroy() {
    Globals.getBody(this.engine).removeEventListener("pointermove", this.pointerMoveListener);
    Globals.getCanvas(this.engine).removeEventListener("contextmenu", this.contextMenuListener);
    Globals.getCanvas(this.engine).removeEventListener("pointerdown", this.pointerDown);
    Globals.getBody(this.engine).removeEventListener("pointerup", this.pointerUp);
    Globals.getBody(this.engine).removeEventListener("pointerleave", this.pointerLeave);
  };
  mouseLookComponentMod.update = function update(dt) {
    if (this.resetMovingTimer.isRunning()) {
      this.resetMovingTimer.update(dt);
      if (this.resetMovingTimer.isDone()) {
        this.resetMovingTimer.reset();
        this.isMoving = false;
      }
    }
    if (!this.isMoving) {
      if (!this.requireMouseDown || !this.mouseDown) {
        this.pointerId = null;
      }
      this.prevMoveEvent = null;
    }
  };
  mouseLookComponentMod._onMove = function() {
    let viewForward = vec3_create();
    let viewUp = vec3_create();
    let referenceUp = vec3_create();
    let referenceUpNegate = vec3_create();
    let referenceRight = vec3_create();
    let newUp = vec3_create();
    return function _onMove(event) {
      if (this.active) {
        if (this.pointerId != null && event.pointerId != this.pointerId)
          return;
        if (this.mouseDown || !this.requireMouseDown) {
          viewForward = this.object.pp_getBackward(viewForward);
          viewUp = this.object.pp_getUp(viewUp);
          referenceUp.vec3_set(0, 1, 0);
          if (this.object.pp_getParent() != null) {
            referenceUp = this.object.pp_getParent().pp_getUp(referenceUp);
          }
          referenceRight = viewForward.vec3_cross(referenceUp, referenceRight);
          let minAngle = 1;
          if (viewForward.vec3_angle(referenceUp) < minAngle) {
            referenceRight = viewUp.vec3_negate(referenceRight).vec3_cross(referenceUp, referenceRight);
          } else if (viewForward.vec3_angle(referenceUp.vec3_negate(referenceUpNegate)) < minAngle) {
            referenceRight = viewUp.vec3_cross(referenceUp, referenceRight);
          } else if (!viewUp.vec3_isConcordant(referenceUp)) {
            referenceRight.vec3_negate(referenceRight);
          }
          referenceRight.vec3_normalize(referenceRight);
          let movementX = event.movementX;
          let movementY = event.movementY;
          if (movementX == null || movementY == null) {
            if (this.prevMoveEvent != null) {
              movementX = event.pageX - this.prevMoveEvent.pageX;
              movementY = event.pageY - this.prevMoveEvent.pageY;
            } else {
              movementX = 0;
              movementY = 0;
            }
          }
          this.rotationX = -this.sensitity * movementX;
          this.rotationY = -this.sensitity * movementY;
          this.object.pp_rotateAxis(this.rotationY, referenceRight);
          let maxVerticalAngle = 90 - 1e-3;
          newUp = this.object.pp_getUp(newUp);
          let angleWithUp = Math.pp_angleClamp(newUp.vec3_angleSigned(referenceUp, referenceRight));
          if (Math.abs(angleWithUp) > maxVerticalAngle) {
            let fixAngle = (Math.abs(angleWithUp) - maxVerticalAngle) * Math.pp_sign(angleWithUp);
            this.object.pp_rotateAxis(fixAngle, referenceRight);
          }
          this.object.pp_rotateAxis(this.rotationX, referenceUp);
          this.prevMoveEvent = event;
          this.pointerId = event.pointerId;
          this.resetMovingTimer.start(this.resetMovingDelay);
          this.isMoving = true;
        }
      }
    };
  }();
  PluginUtils.injectProperties(mouseLookComponentMod, MouseLookComponent.prototype, false, true, true);
}

// js/pp/plugin/wl/mods/components/init_component_mods.js
function initComponentMods() {
  initCursorComponentMod();
  initCursorTargetComponentMod();
  initMouseLookComponentMod();
}

// js/pp/plugin/wl/mods/init_wl_mods.js
function initWLMods() {
  initComponentMods();
}

// js/pp/plugin/wl/init_wl_plugins.js
function initWLPlugins(engine2) {
  initWLExtensions(engine2);
  initWLMods();
}

// js/pp/plugin/init_plugins.js
function initPlugins(engine2) {
  initJSPlugins();
  initWLPlugins(engine2);
}

// js/pp/pp/register_pp_components.js
function registerPPComponents(engine2) {
  engine2.registerComponent(
    AddPPToWindowComponent,
    AddWLToWindowComponent,
    AdjustHierarchyPhysXScaleComponent,
    AudioManagerComponent,
    BenchmarkMaxPhysXComponent,
    BenchmarkMaxVisibleTrianglesComponent,
    CADisplayLeaderboardComponent,
    CharacterCollisionSystemComponent,
    ClearConsoleOnXRSessionStartComponent,
    ConsoleVRToolComponent,
    CopyHandTransformComponent,
    CopyHeadTransformComponent,
    CopyReferenceSpaceTransformComponent,
    CopyPlayerTransformComponent,
    DebugPPArrayCreationPerformanceAnalyzerComponent,
    DebugArrayFunctionsPerformanceAnalyzerComponent,
    DebugFunctionsPerformanceAnalyzerComponent,
    DebugManagerComponent,
    DebugPPFunctionsPerformanceAnalyzerComponent,
    DebugTransformComponent,
    DebugWLComponentsFunctionsPerformanceAnalyzerComponent,
    DebugWLFunctionsPerformanceAnalyzerComponent,
    EasyLightAttenuationComponent,
    EasyLightColorComponent,
    EasyMeshAmbientFactorComponent,
    EasyMeshColorComponent,
    EasyScaleComponent,
    EasySetTuneTargeetGrabComponent,
    EasySetTuneTargetChildNumberComponent,
    EasyTextColorComponent,
    EasyTransformComponent,
    EasyTuneImportVariablesComponent,
    EasyTuneToolComponent,
    EnableDebugComponent,
    EnableToolComponent,
    FingerCursorComponent,
    GamepadControlSchemeComponent,
    GamepadMeshAnimatorComponent,
    GetDefaultResourcesComponent,
    GetSceneObjectsComponent,
    GrabbableComponent,
    GrabberHandComponent,
    InitConsoleVRComponent,
    InitEasyTuneVariablesComponent,
    InputManagerComponent,
    MuteEverythingComponent,
    ObjectPoolManagerComponent,
    PPGatewayComponent,
    PlayerLocomotionComponent,
    SetActiveComponent,
    SetHandLocalTransformComponent,
    SetHeadLocalTransformComponent,
    SetPlayerHeightComponent,
    SetTrackedHandJointLocalTransformComponent,
    ShowFPSComponent,
    SpatialAudioListenerComponent,
    SwitchHandObjectComponent,
    ToolCursorComponent,
    TrackedHandDrawAllJointsComponent,
    TrackedHandDrawJointComponent,
    TrackedHandDrawSkinComponent,
    VirtualGamepadComponent,
    VisualManagerComponent
  );
}

// js/pp/pp/init_pp.js
function initPP(engine2) {
  Globals.initEngine(engine2);
  ComponentUtils.setDefaultWLComponentCloneCallbacks(engine2);
  registerWLComponents(engine2);
  registerPPComponents(engine2);
  initPlugins(engine2);
}

// js/pp/pp/scene_objects.js
var SceneObjects = class {
  constructor() {
    this.myScene = null;
    this.myCauldron = null;
    this.myDynamics = null;
    this.myParticles = null;
    this.myVisualElements = null;
    this.myTools = null;
    this.myPlayerObjects = new PlayerObjects();
  }
};
var PlayerObjects = class {
  constructor() {
    this.myPlayer = null;
    this.myCauldron = null;
    this.myReferenceSpace = null;
    this.myCameraNonXR = null;
    this.myEyes = [];
    this.myEyeLeft = null;
    this.myEyeRight = null;
    this.myHands = [];
    this.myHandLeft = null;
    this.myHandRight = null;
    this.myHead = null;
    this.myHeadDebugs = null;
  }
};

// js/pp/pp/default_resources.js
var DefaultResources = class {
  constructor() {
    this.myMeshes = new DefaultResourcesMeshes();
    this.myMaterials = new DefaultResourcesMaterials();
  }
};
var DefaultResourcesMeshes = class {
  constructor() {
    this.myPlane = null;
    this.myCube = null;
    this.mySphere = null;
    this.myCone = null;
    this.myCylinder = null;
    this.myCircle = null;
    this.myInvertedCube = null;
    this.myInvertedSphere = null;
    this.myInvertedCone = null;
    this.myInvertedCylinder = null;
    this.myDoubleSidedPlane = null;
    this.myDoubleSidedCube = null;
    this.myDoubleSidedSphere = null;
    this.myDoubleSidedCone = null;
    this.myDoubleSidedCylinder = null;
    this.myDoubleSidedCircle = null;
  }
};
var DefaultResourcesMaterials = class {
  constructor() {
    this.myFlatOpaque = null;
    this.myFlatTransparentNoDepth = null;
    this.myPhongOpaque = null;
    this.myText = null;
  }
};

// js/pp/audio/audio_manager.js
var import_howler4 = __toESM(require_howler(), 1);

// js/pp/audio/audio_player.js
var import_howler3 = __toESM(require_howler(), 1);

// js/pp/audio/audio_setup.js
var AudioSetup = class {
  constructor(audioFilePath = null) {
    this.myAudioFilePath = audioFilePath;
    this.myLoop = false;
    this.myAutoPlay = false;
    this.myVolume = 1;
    this._myRate = 1;
    this.myPool = 5;
    this.myPreload = true;
    this.myPreventPlayWhenAudioContextNotRunning = false;
    this.myPosition = null;
    this.mySpatial = true;
    this.myReferenceDistance = Number.MAX_VALUE;
  }
  clone() {
    let audioSetup = new AudioSetup();
    audioSetup.myAudioFilePath = this.myAudioFilePath;
    audioSetup.myLoop = this.myLoop;
    audioSetup.myAutoPlay = this.myAutoPlay;
    audioSetup.myVolume = this.myVolume;
    audioSetup.myPitch = this.myPitch;
    audioSetup.myRate = this.myRate;
    audioSetup.myPool = this.myPool;
    audioSetup.myPreload = this.myPreload;
    audioSetup.myPreventPlayWhenAudioContextNotRunning = this.myPreventPlayWhenAudioContextNotRunning;
    if (this.myPosition != null) {
      audioSetup.myPosition = this.myPosition.vec3_clone();
    } else {
      audioSetup.myPosition = null;
    }
    audioSetup.mySpatial = this.mySpatial;
    audioSetup.myReferenceDistance = this.myReferenceDistance;
    return audioSetup;
  }
  get myPitch() {
    return this._myRate;
  }
  get myRate() {
    return this._myRate;
  }
  set myPitch(pitch) {
    this._myRate = pitch;
  }
  set myRate(rate) {
    this._myRate = rate;
  }
};

// js/pp/audio/audio_player.js
var AudioEvent = {
  END: "end",
  STOP: "stop",
  LOAD: "load",
  LOAD_ERROR: "loaderror",
  PLAY: "play",
  PLAY_ERROR: "playerror",
  PAUSE: "pause",
  MUTE: "mute",
  VOLUME: "volume",
  RATE: "rate",
  SEEK: "seek",
  FADE: "fade",
  UNLOCK: "unlock"
};
var AudioPlayer = class {
  constructor(audioSetupOrAudioFilePath, audioInstance = null) {
    if (audioSetupOrAudioFilePath == null) {
      this._myAudioSetup = new AudioSetup();
    } else if (typeof audioSetupOrAudioFilePath === "string") {
      this._myAudioSetup = new AudioSetup(audioSetupOrAudioFilePath);
    } else {
      this._myAudioSetup = audioSetupOrAudioFilePath.clone();
    }
    this._myAudio = null;
    if (audioInstance == null) {
      this._myAudio = new import_howler3.Howl({
        src: [this._myAudioSetup.myAudioFilePath],
        loop: this._myAudioSetup.myLoop,
        volume: this._myAudioSetup.myVolume,
        autoplay: false,
        rate: this._myAudioSetup.myRate,
        pool: this._myAudioSetup.myPool,
        pos: this._myAudioSetup.mySpatial ? this._myAudioSetup.myPosition : null,
        refDistance: this._myAudioSetup.myReferenceDistance,
        preload: this._myAudioSetup.myPreload
      });
      this._myAudio._pannerAttr.refDistance = this._myAudioSetup.myReferenceDistance;
    } else {
      this._myAudio = audioInstance;
    }
    this._myLastAudioID = null;
    this._myAudioEventEmitters = /* @__PURE__ */ new Map();
    for (let eventKey in AudioEvent) {
      this._myAudioEventEmitters.set(AudioEvent[eventKey], new Emitter());
    }
    this._addListeners();
    if (this._myAudioSetup.myAutoPlay) {
      this.play();
    }
    this._myDestroyed = false;
  }
  isValid() {
    return this._myAudio != null;
  }
  play() {
    if (import_howler3.Howler.state != "running" && this._myAudioSetup.myPreventPlayWhenAudioContextNotRunning) {
      return false;
    }
    let audioID = this._myAudio.play();
    if (audioID != null) {
      this._myLastAudioID = audioID;
      this.updatePosition(this._myAudioSetup.myPosition, true);
      this.updatePitch(this._myAudioSetup.myPitch, true);
      this.updateVolume(this._myAudioSetup.myVolume, true);
    }
    return audioID != null;
  }
  stop() {
    this._myAudio.stop();
  }
  pause() {
    this._myAudio.pause();
  }
  resume() {
    this._myAudio.play();
  }
  isPlaying(checkOnlyLast = false) {
    let playing = false;
    if (checkOnlyLast) {
      playing = this._myAudio.playing(this._myLastAudioID);
    } else {
      playing = this._myAudio.playing();
    }
    return playing;
  }
  isLoaded() {
    return this._myAudio.state() == "loaded";
  }
  fade(fromVolume, toVolume, duration, updateOnlyLast = true, setValueOnPlayer = true) {
    if (setValueOnPlayer) {
      this.setVolume(toVolume);
    }
    if (updateOnlyLast) {
      this._myAudio.fade(fromVolume, toVolume, duration * 1e3, this._myLastAudioID);
    } else {
      this._myAudio.fade(fromVolume, toVolume, duration * 1e3);
    }
  }
  isFading(checkOnlyLast = true) {
    let fading = false;
    if (checkOnlyLast) {
      let lastSound = this._myAudio._soundById(this._myLastAudioID);
      if (lastSound != null) {
        fading = lastSound._fadeTo != null;
      }
    } else {
      for (let sound of this._myAudio._sounds) {
        if (sound._fadeTo != null) {
          fading = true;
          break;
        }
      }
    }
    return fading;
  }
  updatePosition(position, updateOnlyLast = true, setValueOnPlayer = true) {
    if (setValueOnPlayer) {
      this.setPosition(position);
    }
    if (this._myAudioSetup.mySpatial && position) {
      if (updateOnlyLast) {
        this._myAudio.pos(position[0], position[1], position[2], this._myLastAudioID);
      } else {
        this._myAudio.pos(position[0], position[1], position[2]);
      }
    }
  }
  updatePitch(pitch, updateOnlyLast = true, setValueOnPlayer = true) {
    this.updateRate(pitch, updateOnlyLast, setValueOnPlayer);
  }
  updateRate(rate, updateOnlyLast = true, setValueOnPlayer = true) {
    if (setValueOnPlayer) {
      this.setRate(rate);
    }
    if (rate != null) {
      if (updateOnlyLast) {
        this._myAudio.rate(rate, this._myLastAudioID);
      } else {
        this._myAudio.rate(rate);
      }
    }
  }
  updateVolume(volume, updateOnlyLast = true, setValueOnPlayer = true) {
    if (setValueOnPlayer) {
      this.setVolume(volume);
    }
    if (volume != null) {
      if (updateOnlyLast) {
        this._myAudio.volume(volume, this._myLastAudioID);
      } else {
        this._myAudio.volume(volume);
      }
    }
  }
  setSpatial(spatial) {
    this._myAudioSetup.mySpatial = spatial;
  }
  setPosition(position) {
    this._myAudioSetup.myPosition = position;
  }
  setPitch(pitch) {
    this._myAudioSetup.myPitch = pitch;
  }
  setRate(rate) {
    this._myAudioSetup.myRate = rate;
  }
  setVolume(volume) {
    this._myAudioSetup.myVolume = volume;
  }
  getDuration() {
    return this._myAudio.duration();
  }
  getVolume() {
    return this._myAudioSetup.myVolume;
  }
  getPitch() {
    return this._myAudioSetup.myPitch;
  }
  getRate() {
    return this._myAudioSetup.myRate;
  }
  registerAudioEventListener(audioEvent, id, listener, notifyOnce = false) {
    this._myAudioEventEmitters.get(audioEvent).add(listener, { id, once: notifyOnce });
  }
  unregisterAudioEventListener(audioEvent, id) {
    this._myAudioEventEmitters.get(audioEvent).remove(id);
  }
  _addListeners() {
    if (this._myAudio != null) {
      for (let eventKey in AudioEvent) {
        let event = AudioEvent[eventKey];
        this._myAudio.on(event, function(audioID) {
          let emitter = this._myAudioEventEmitters.get(event);
          emitter.notify(audioID);
        }.bind(this));
      }
    }
  }
  destroy() {
    this._myDestroyed = true;
    this._myAudio.unload();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/audio/audio_manager.js
var AudioManager = class {
  constructor(preloadAudio = true, engine2 = Globals.getMainEngine()) {
    this._myEngine = engine2;
    this._myPreloadAudio = preloadAudio;
    this._myAudioSetups = /* @__PURE__ */ new Map();
  }
  createAudioPlayer(audioSetupID) {
    let audioSetup = this.getAudioSetup(audioSetupID);
    if (audioSetup != null) {
      return new AudioPlayer(this.getAudioSetup(audioSetupID));
    }
    return null;
  }
  getAudioSetup(id) {
    return this._myAudioSetups.get(id);
  }
  addAudioSetup(id, audioSetup, preloadAudioOverride = null) {
    this._myAudioSetups.set(id, audioSetup);
    if (this._myPreloadAudio && preloadAudioOverride == null || preloadAudioOverride != null && preloadAudioOverride) {
      this.createAudioPlayer(id);
    }
  }
  removeAudioSetup(id) {
    this._myAudioSetups.delete(id);
  }
  setVolume(volume) {
    import_howler4.Howler.volume(volume);
  }
  setMute(mute) {
    import_howler4.Howler.mute(mute);
  }
  stop() {
    import_howler4.Howler.stop();
  }
  unloadAllAudioSources() {
    import_howler4.Howler.unload();
  }
};

// js/pp/audio/components/audio_manager_component.js
var AudioManagerComponent = class extends Component {
  init() {
    this._myAudioManager = null;
    if (!Globals.hasAudioManager(this.engine)) {
      this._myAudioManager = new AudioManager(this._myPreloadAudio, this.engine);
      if (this._myCleanUpAudioSourcesOnInit) {
        this._myAudioManager.unloadAllAudioSources();
      }
      Globals.setAudioManager(this._myAudioManager, this.engine);
    }
  }
  onDestroy() {
    if (this._myAudioManager != null && Globals.getAudioManager(this.engine) == this._myAudioManager) {
      Globals.removeAudioManager(this.engine);
    }
  }
};
__publicField(AudioManagerComponent, "TypeName", "pp-audio-manager");
__publicField(AudioManagerComponent, "Properties", {
  _myPreloadAudio: Property.bool(true),
  _myCleanUpAudioSourcesOnInit: Property.bool(true)
});

// js/pp/cauldron/object_pool/object_pool_manager.js
var ObjectPoolManager = class {
  constructor() {
    this._myPools = /* @__PURE__ */ new Map();
    this._myDestroyed = false;
  }
  addPool(poolID, pool) {
    if (!this._myPools.has(poolID)) {
      this._myPools.set(poolID, pool);
    } else {
      console.warn("Trying to add a Pool with an ID that has been already used:", poolID);
    }
  }
  destroyPool(poolID) {
    let poolToRemove = this._myPools.get(poolID);
    if (poolToRemove != null) {
      this._myPools.delete(poolID);
      poolToRemove.destroy();
    }
  }
  getPool(poolID) {
    return this._myPools.get(poolID);
  }
  hasPool(poolID) {
    return this._myPools.has(poolID);
  }
  get(poolID) {
    if (this._myPools.has(poolID)) {
      return this._myPools.get(poolID).get();
    }
    return null;
  }
  has(poolIDOrObject, object) {
    let hasObject = false;
    if (object === void 0) {
      for (let pool of this._myPools.values()) {
        if (pool.has(poolIDOrObject)) {
          hasObject = true;
          break;
        }
      }
    } else {
      hasObject = this._myPools.get(poolIDOrObject).has(object);
    }
    return hasObject;
  }
  isBusy(poolIDOrObject, object) {
    let busy = false;
    if (object === void 0) {
      for (let pool of this._myPools.values()) {
        if (pool.isBusy(poolIDOrObject)) {
          busy = true;
          break;
        }
      }
    } else {
      busy = this._myPools.get(poolIDOrObject).isBusy(object);
    }
    return busy;
  }
  isAvailable(poolIDOrObject, object) {
    let available = false;
    if (object === void 0) {
      for (let pool of this._myPools.values()) {
        if (pool.isAvailable(poolIDOrObject)) {
          available = true;
          break;
        }
      }
    } else {
      available = this._myPools.get(poolIDOrObject).isAvailable(object);
    }
    return available;
  }
  release(poolIDOrObject, object) {
    if (object === void 0) {
      for (let pool of this._myPools.values()) {
        pool.release(poolIDOrObject);
      }
    } else {
      this._myPools.get(poolIDOrObject).release(object);
    }
  }
  releaseAll(poolID = void 0) {
    if (poolID === void 0) {
      for (let pool of this._myPools.values()) {
        pool.releaseAll();
      }
    } else {
      this._myPools.get(poolID).releaseAll();
    }
  }
  increase(poolID, amount) {
    let pool = this._myPools.get(poolID);
    if (pool) {
      pool.increase(amount);
    }
  }
  increasePercentage(poolID, percentage) {
    let pool = this._myPools.get(poolID);
    if (pool) {
      pool.increasePercentage(percentage);
    }
  }
  getSize(poolID) {
    if (this._myPools.has(poolID)) {
      return this._myPools.get(poolID).getSize();
    }
    return null;
  }
  getAvailableSize(poolID) {
    if (this._myPools.has(poolID)) {
      return this._myPools.get(poolID).getAvailableSize();
    }
    return null;
  }
  getBusySize(poolID) {
    if (this._myPools.has(poolID)) {
      return this._myPools.get(poolID).getBusySize();
    }
    return null;
  }
  destroy() {
    this._myDestroyed = true;
    for (let pool of this._myPools.values()) {
      pool.destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/cauldron/object_pool/components/object_pool_manager_component.js
var ObjectPoolManagerComponent = class extends Component {
  init() {
    this._myObjectPoolManager = null;
    if (!Globals.hasObjectPoolManager(this.engine)) {
      this._myObjectPoolManager = new ObjectPoolManager();
      Globals.setObjectPoolManager(this._myObjectPoolManager, this.engine);
    }
  }
  onDestroy() {
    if (this._myObjectPoolManager != null && Globals.getObjectPoolManager(this.engine) == this._myObjectPoolManager) {
      Globals.removeObjectPoolManager(this.engine);
    }
  }
};
__publicField(ObjectPoolManagerComponent, "TypeName", "pp-object-pools-manager");
__publicField(ObjectPoolManagerComponent, "Properties", {});

// js/pp/cauldron/object_pool/object_pool.js
var ObjectPoolParams = class {
  constructor() {
    this.myCloneObjectPrototype = true;
    this.myInitialPoolSize = 0;
    this.myAmountToAddWhenEmpty = 0;
    this.myPercentageToAddWhenEmpty = 0;
    this.myCloneParams = void 0;
    this.myOptimizeObjectsAllocation = true;
    this.myCloneCallback = null;
    this.mySetActiveCallback = null;
    this.myEqualCallback = null;
    this.myDestroyCallback = null;
    this.myOptimizeObjectsAllocationCallback = null;
    this.myLogEnabled = false;
  }
};
var ObjectPool = class {
  constructor(objectPrototype, objectPoolParams) {
    this._myObjectPoolParams = objectPoolParams;
    this._myObjectPrototype = objectPrototype;
    if (objectPoolParams.myCloneObjectPrototype) {
      this._myObjectPrototype = this._clone(objectPrototype);
    }
    this._myAvailableObjects = [];
    this._myBusyObjects = [];
    this._addToPool(objectPoolParams.myInitialPoolSize, false);
    this._myDestroyed = false;
  }
  get() {
    let object = this._myAvailableObjects.shift();
    if (object == null) {
      let amountToAdd = Math.ceil(this._myBusyObjects.length * this._myObjectPoolParams.myPercentageToAddWhenEmpty);
      amountToAdd += this._myObjectPoolParams.myAmountToAddWhenEmpty;
      this._addToPool(amountToAdd, this._myObjectPoolParams.myLogEnabled);
      object = this._myAvailableObjects.shift();
    }
    if (object != null) {
      this._myBusyObjects.push(object);
    }
    return object;
  }
  has(object) {
    let hasObject = false;
    if (this.isBusy(object) || this.isAvailable(object)) {
      hasObject = true;
    }
    return hasObject;
  }
  isBusy(object) {
    return this._myBusyObjects.pp_has(this._equals.bind(this, object));
  }
  isAvailable(object) {
    return this._myAvailableObjects.pp_has(this._equals.bind(this, object));
  }
  release(object) {
    let released = this._myBusyObjects.pp_remove(this._equals.bind(this, object));
    if (released != null) {
      this._setActive(released, false);
      this._myAvailableObjects.push(released);
    }
  }
  releaseAll() {
    for (let busyObject of this._myBusyObjects) {
      this._setActive(busyObject, false);
      this._myAvailableObjects.push(busyObject);
    }
  }
  increase(amount) {
    this._addToPool(amount, false);
  }
  increasePercentage(percentage) {
    let amount = Math.ceil(this.getSize() * percentage);
    this._addToPool(amount, false);
  }
  getSize() {
    return this._myBusyObjects.length + this._myAvailableObjects.length;
  }
  getAvailableSize() {
    return this._myAvailableObjects.length;
  }
  getBusySize() {
    return this._myAvailableObjects.length;
  }
  _addToPool(size, logEnabled) {
    if (size <= 0) {
      return;
    }
    if (this._myObjectPoolParams.myOptimizeObjectsAllocation) {
      if (this._myObjectPoolParams.myOptimizeObjectsAllocationCallback != null) {
        this._myObjectPoolParams.myOptimizeObjectsAllocationCallback(this._myObjectPrototype, size);
      } else if (this._myObjectPrototype.pp_reserveObjects != null) {
        this._myObjectPrototype.pp_reserveObjects(size);
      }
    }
    for (let i = 0; i < size; i++) {
      this._myAvailableObjects.push(this._clone(this._myObjectPrototype));
    }
    if (logEnabled) {
      console.warn("Added new elements to the pool:", size);
    }
  }
  _clone(object) {
    let clone17 = null;
    if (this._myObjectPoolParams.myCloneCallback != null) {
      clone17 = this._myObjectPoolParams.myCloneCallback(object, this._myObjectPoolParams.myCloneParams);
    } else if (object.pp_clone != null) {
      clone17 = object.pp_clone(this._myObjectPoolParams.myCloneParams);
    } else if (object.clone != null) {
      clone17 = object.clone(this._myObjectPoolParams.myCloneParams);
    }
    if (clone17 == null) {
      console.error("Object not cloneable, pool will return null");
    } else {
      this._setActive(clone17, false);
    }
    return clone17;
  }
  _setActive(object, active) {
    if (this._myObjectPoolParams.mySetActiveCallback != null) {
      this._myObjectPoolParams.mySetActiveCallback(object, active);
    } else if (object.pp_setActive != null) {
      object.pp_setActive(active);
    } else if (object.setActive != null) {
      object.setActive(active);
    }
  }
  _equals(first2, second) {
    let equals12 = false;
    if (this._myObjectPoolParams.myEqualCallback != null) {
      equals12 = this._myObjectPoolParams.myEqualCallback(first2, second);
    } else if (first2.pp_equals != null) {
      equals12 = first2.pp_equals(second);
    } else if (first2.equals != null) {
      equals12 = first2.equals(second);
    } else {
      equals12 = first2 == second;
    }
    return equals12;
  }
  destroy() {
    this._myDestroyed = true;
    for (let object of this._myAvailableObjects) {
      this._destroyObject(object);
    }
    for (let object of this._myBusyObjects) {
      this._destroyObject(object);
    }
    this._destroyObject(this._myObjectPrototype);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
  _destroyObject(object) {
    if (this._myObjectPoolParams.myDestroyCallback != null) {
      this._myObjectPoolParams.myDestroyCallback(object);
    } else if (object.pp_destroy != null) {
      object.pp_destroy();
    } else if (object.destroy != null) {
      object.destroy();
    }
  }
};

// js/pp/cauldron/visual/elements/visual_element_types.js
var VisualElementType = {
  MESH: 0,
  LINE: 1,
  POINT: 2,
  TEXT: 3,
  ARROW: 4,
  TRANSFORM: 5,
  RAYCAST: 6,
  TORUS: 7
};

// js/pp/cauldron/visual/elements/visual_line.js
var VisualLineParams = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this.myStart = vec3_create();
    this.myDirection = vec3_create(0, 0, 1);
    this.myLength = 0;
    this.myThickness = 5e-3;
    this.myMesh = null;
    this.myMaterial = null;
    this.myColor = null;
    this.myParent = Globals.getSceneObjects(engine2).myVisualElements;
    this.myLocal = false;
    this.myType = VisualElementType.LINE;
  }
  setStartEnd(start, end) {
    end.vec3_sub(start, this.myDirection);
    this.myLength = this.myDirection.vec3_length();
    this.myDirection.vec3_normalize(this.myDirection);
    this.myStart.vec3_copy(start);
    return this;
  }
  copy(other) {
  }
};
var VisualLine = class {
  constructor(params = new VisualLineParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myLineParentObject = null;
    this._myLineObject = null;
    this._myLineMeshComponent = null;
    this._myFlatOpaqueMaterial = null;
    this._myDestroyed = false;
    this._build();
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      this._myLineParentObject.pp_setActive(visible);
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
  }
  _build() {
    this._myLineParentObject = Globals.getSceneObjects(this._myParams.myParent.pp_getEngine()).myVisualElements.pp_addObject();
    this._myLineObject = this._myLineParentObject.pp_addObject();
    this._myLineMeshComponent = this._myLineObject.pp_addComponent(MeshComponent);
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  clone() {
    let clonedParams = new VisualLineParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone17 = new VisualLine(clonedParams);
    clone17.setAutoRefresh(this._myAutoRefresh);
    clone17.setVisible(this._myVisible);
    clone17._myDirty = this._myDirty;
    return clone17;
  }
  _refresh() {
  }
  destroy() {
    this._myDestroyed = true;
    this._myLineParentObject.pp_destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
VisualLine.prototype._refresh = function() {
  let scaleLine = vec3_create();
  let translateLine = vec3_create();
  let forward = vec3_create(0, 1, 0);
  return function _refresh() {
    this._myLineParentObject.pp_setParent(this._myParams.myParent, false);
    if (this._myParams.myLocal) {
      this._myLineParentObject.pp_setPositionLocal(this._myParams.myStart);
    } else {
      this._myLineParentObject.pp_setPosition(this._myParams.myStart);
    }
    scaleLine.vec3_set(this._myParams.myThickness / 2, this._myParams.myLength / 2, this._myParams.myThickness / 2);
    if (this._myParams.myLocal) {
      this._myLineObject.pp_setScaleLocal(scaleLine);
    } else {
      this._myLineObject.pp_setScale(scaleLine);
    }
    if (this._myParams.myLocal) {
      this._myLineObject.pp_setUpLocal(this._myParams.myDirection, forward);
    } else {
      this._myLineObject.pp_setUp(this._myParams.myDirection, forward);
    }
    this._myLineObject.pp_resetPositionLocal();
    translateLine.vec3_set(0, this._myParams.myLength / 2, 0);
    this._myLineObject.pp_translateObject(translateLine);
    if (this._myParams.myMesh != null) {
      this._myLineMeshComponent.mesh = this._myParams.myMesh;
    } else {
      this._myLineMeshComponent.mesh = Globals.getDefaultMeshes(this._myParams.myParent.pp_getEngine()).myCylinder;
    }
    if (this._myParams.myMaterial == null) {
      if (this._myParams.myColor == null) {
        this._myLineMeshComponent.material = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myMesh;
      } else {
        if (this._myFlatOpaqueMaterial == null) {
          this._myFlatOpaqueMaterial = Globals.getDefaultMaterials(this._myParams.myParent.pp_getEngine()).myFlatOpaque.clone();
        }
        this._myLineMeshComponent.material = this._myFlatOpaqueMaterial;
        this._myFlatOpaqueMaterial.color = this._myParams.myColor;
      }
    } else {
      this._myLineMeshComponent.material = this._myParams.myMaterial;
    }
  };
}();
VisualLineParams.prototype.copy = function copy15(other) {
  this.myStart.vec3_copy(other.myStart);
  this.myDirection.vec3_copy(other.myDirection);
  this.myLength = other.myLength;
  this.myThickness = other.myThickness;
  this.myMesh = other.myMesh;
  if (other.myMaterial != null) {
    this.myMaterial = other.myMaterial.clone();
  } else {
    this.myMaterial = null;
  }
  if (other.myColor != null) {
    if (this.myColor != null) {
      this.myColor.vec4_copy(other.myColor);
    } else {
      this.myColor = other.myColor.vec4_clone();
    }
  } else {
    this.myColor = null;
  }
  this.myParent = other.myParent;
  this.myLocal = other.myLocal;
  this.myType = other.myType;
};

// js/pp/cauldron/visual/elements/visual_arrow.js
var VisualArrowParams = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this.myStart = vec3_create();
    this.myDirection = vec3_create(0, 0, 1);
    this.myLength = 0;
    this.myThickness = 5e-3;
    this.myArrowThickness = null;
    this.myArrowLength = null;
    this.myShareArrowLengthWithLineWhenArrowLongerThanLength = true;
    this.myLineMesh = null;
    this.myArrowMesh = null;
    this.myMaterial = null;
    this.myColor = null;
    this.myParent = Globals.getSceneObjects(engine2).myVisualElements;
    this.myLocal = false;
    this.myType = VisualElementType.ARROW;
  }
  setStartEnd(start, end) {
    end.vec3_sub(start, this.myDirection);
    this.myLength = this.myDirection.vec3_length();
    this.myDirection.vec3_normalize(this.myDirection);
    this.myStart.vec3_copy(start);
    return this;
  }
  copy(other) {
  }
};
var VisualArrow = class {
  constructor(params = new VisualArrowParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myVisualLine = new VisualLine(new VisualLineParams(this._myParams.myParent.pp_getEngine()));
    this._myVisualLine.setAutoRefresh(false);
    this._myArrowParentObject = null;
    this._myArrowObject = null;
    this._myArrowMeshComponent = null;
    this._myFlatOpaqueMaterial = null;
    this._myDestroyed = false;
    this._build();
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      this._myVisualLine.setVisible(visible);
      this._myArrowParentObject.pp_setActive(visible);
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
    this._myVisualLine.forceRefresh();
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
    this._myVisualLine.update(dt);
  }
  _build() {
    this._myArrowParentObject = Globals.getSceneObjects(this._myParams.myParent.pp_getEngine()).myVisualElements.pp_addObject();
    this._myArrowObject = this._myArrowParentObject.pp_addObject();
    this._myArrowMeshComponent = this._myArrowObject.pp_addComponent(MeshComponent);
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  clone() {
    let clonedParams = new VisualArrowParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone17 = new VisualArrow(clonedParams);
    clone17.setAutoRefresh(this._myAutoRefresh);
    clone17.setVisible(this._myVisible);
    clone17._myDirty = this._myDirty;
    return clone17;
  }
  _refresh() {
  }
  destroy() {
    this._myDestroyed = true;
    this._myVisualLine.destroy();
    this._myArrowParentObject.pp_destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
VisualArrow.prototype._refresh = function() {
  let arrowPosition = vec3_create();
  let parentTranslate = vec3_create();
  let arrowScale = vec3_create();
  let forward = vec3_create(0, 1, 0);
  return function _refresh() {
    this._myArrowParentObject.pp_setParent(this._myParams.myParent, false);
    let arrowThickness = this._myParams.myArrowThickness != null ? this._myParams.myArrowThickness : this._myParams.myThickness * 1.5;
    let arrowLength = this._myParams.myArrowLength != null ? this._myParams.myArrowLength : this._myParams.myThickness * 3.5;
    if (this._myParams.myShareArrowLengthWithLineWhenArrowLongerThanLength && arrowLength > this._myParams.myLength / 2) {
      arrowLength = this._myParams.myLength / 2;
    }
    arrowLength = Math.min(arrowLength, this._myParams.myLength);
    arrowScale.vec3_set(arrowThickness, arrowLength / 2, arrowThickness);
    let lineLength = this._myParams.myLength - arrowLength;
    this._myParams.myDirection.vec3_scale(lineLength, arrowPosition);
    arrowPosition.vec3_add(this._myParams.myStart, arrowPosition);
    if (this._myParams.myLocal) {
      this._myArrowParentObject.pp_setPositionLocal(arrowPosition);
      this._myArrowParentObject.pp_setUpLocal(this._myParams.myDirection, forward);
    } else {
      this._myArrowParentObject.pp_setPosition(arrowPosition);
      this._myArrowParentObject.pp_setUp(this._myParams.myDirection, forward);
    }
    parentTranslate.vec3_set(0, arrowLength / 2 - 1e-5, 0);
    this._myArrowParentObject.pp_translateObject(parentTranslate);
    if (this._myParams.myLocal) {
      this._myArrowObject.pp_setScaleLocal(arrowScale);
    } else {
      this._myArrowObject.pp_setScale(arrowScale);
    }
    if (this._myParams.myArrowMesh != null) {
      this._myArrowMeshComponent.mesh = this._myParams.myArrowMesh;
    } else {
      this._myArrowMeshComponent.mesh = Globals.getDefaultMeshes(this._myParams.myParent.pp_getEngine()).myCone;
    }
    if (this._myParams.myMaterial == null) {
      if (this._myParams.myColor == null) {
        this._myArrowMeshComponent.material = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myMesh;
      } else {
        if (this._myFlatOpaqueMaterial == null) {
          this._myFlatOpaqueMaterial = Globals.getDefaultMaterials(this._myParams.myParent.pp_getEngine()).myFlatOpaque.clone();
        }
        this._myArrowMeshComponent.material = this._myFlatOpaqueMaterial;
        this._myFlatOpaqueMaterial.color = this._myParams.myColor;
      }
    } else {
      this._myArrowMeshComponent.material = this._myParams.myMaterial;
    }
    let visualLineParams = this._myVisualLine.getParams();
    visualLineParams.myStart.vec3_copy(this._myParams.myStart);
    visualLineParams.myDirection.vec3_copy(this._myParams.myDirection);
    visualLineParams.myLength = lineLength;
    visualLineParams.myThickness = this._myParams.myThickness;
    visualLineParams.myMesh = this._myParams.myLineMesh;
    visualLineParams.myMaterial = this._myArrowMeshComponent.material;
    visualLineParams.myParent = this._myParams.myParent;
    visualLineParams.myLocal = this._myParams.myLocal;
    this._myVisualLine.paramsUpdated();
  };
}();
VisualArrowParams.prototype.copy = function copy16(other) {
  this.myStart.vec3_copy(other.myStart);
  this.myDirection.vec3_copy(other.myDirection);
  this.myLength = other.myLength;
  this.myThickness = other.myThickness;
  this.myArrowThickness = other.myArrowThickness;
  this.myArrowLength = other.myArrowLength;
  this.myShareArrowLengthWithLineWhenArrowLongerThanLength = other.myShareArrowLengthWithLineWhenArrowLongerThanLength;
  this.myArrowMesh = other.myArrowMesh;
  this.myLineMesh = other.myLineMesh;
  if (other.myMaterial != null) {
    this.myMaterial = other.myMaterial.clone();
  } else {
    this.myMaterial = null;
  }
  if (other.myColor != null) {
    if (this.myColor != null) {
      this.myColor.vec4_copy(other.myColor);
    } else {
      this.myColor = other.myColor.vec4_clone();
    }
  } else {
    this.myColor = null;
  }
  this.myParent = other.myParent;
  this.myLocal = other.myLocal;
  this.myType = other.myType;
};

// js/pp/cauldron/visual/elements/visual_mesh.js
var VisualMeshParams = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this.myTransform = mat4_create();
    this.myMesh = null;
    this.myMaterial = null;
    this.myParent = Globals.getSceneObjects(engine2).myVisualElements;
    this.myLocal = false;
    this.myType = VisualElementType.MESH;
  }
  copy(other) {
  }
};
var VisualMesh = class {
  constructor(params = new VisualMeshParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myMeshObject = null;
    this._myMeshComponent = null;
    this._myDestroyed = false;
    this._build();
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      this._myMeshObject.pp_setActive(visible);
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
  }
  _refresh() {
    this._myMeshObject.pp_setParent(this._myParams.myParent, false);
    if (this._myParams.myLocal) {
      this._myMeshObject.pp_setTransformLocal(this._myParams.myTransform);
    } else {
      this._myMeshObject.pp_setTransform(this._myParams.myTransform);
    }
    if (this._myParams.myMesh == null) {
      this._myMeshComponent.mesh = Globals.getDefaultMeshes(this._myParams.myParent.pp_getEngine()).mySphere;
    } else {
      this._myMeshComponent.mesh = this._myParams.myMesh;
    }
    if (this._myParams.myMaterial == null) {
      this._myMeshComponent.material = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myMesh;
    } else {
      this._myMeshComponent.material = this._myParams.myMaterial;
    }
  }
  _build() {
    this._myMeshObject = Globals.getSceneObjects(this._myParams.myParent.pp_getEngine()).myVisualElements.pp_addObject();
    this._myMeshComponent = this._myMeshObject.pp_addComponent(MeshComponent);
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  clone() {
    let clonedParams = new VisualMeshParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone17 = new VisualMesh(clonedParams);
    clone17.setAutoRefresh(this._myAutoRefresh);
    clone17.setVisible(this._myVisible);
    clone17._myDirty = this._myDirty;
    return clone17;
  }
  destroy() {
    this._myDestroyed = true;
    this._myMeshObject.pp_destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
VisualMeshParams.prototype.copy = function copy17(other) {
  this.myTransform.pp_copy(other.myTransform);
  if (other.myMesh != null) {
    this.myMesh = other.myMesh;
  } else {
    this.myMesh = null;
  }
  if (other.myMaterial != null) {
    this.myMaterial = other.myMaterial.clone();
  } else {
    this.myMaterial = null;
  }
  this.myParent = other.myParent;
  this.myLocal = other.myLocal;
  this.myType = other.myType;
};

// js/pp/cauldron/visual/elements/visual_point.js
var VisualPointParams = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this.myPosition = vec3_create();
    this.myRadius = 5e-3;
    this.myMesh = null;
    this.myMaterial = null;
    this.myColor = null;
    this.myParent = Globals.getSceneObjects(engine2).myVisualElements;
    this.myLocal = false;
    this.myType = VisualElementType.POINT;
  }
  copy(other) {
  }
};
var VisualPoint = class {
  constructor(params = new VisualPointParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myPointObject = null;
    this._myPointMeshComponent = null;
    this._myFlatOpaqueMaterial = null;
    this._myDestroyed = false;
    this._build();
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      this._myPointObject.pp_setActive(visible);
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
  }
  _build() {
    this._myPointObject = Globals.getSceneObjects(this._myParams.myParent.pp_getEngine()).myVisualElements.pp_addObject();
    this._myPointMeshComponent = this._myPointObject.pp_addComponent(MeshComponent);
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  clone() {
    let clonedParams = new VisualPointParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone17 = new VisualPoint(clonedParams);
    clone17.setAutoRefresh(this._myAutoRefresh);
    clone17.setVisible(this._myVisible);
    clone17._myDirty = this._myDirty;
    return clone17;
  }
  _refresh() {
  }
  destroy() {
    this._myDestroyed = true;
    this._myPointObject.pp_destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
VisualPoint.prototype._refresh = function() {
  let rotation = vec3_create(0, 0, 0);
  return function _refresh() {
    this._myPointObject.pp_setParent(this._myParams.myParent, false);
    if (this._myParams.myLocal) {
      this._myPointObject.pp_setPositionLocal(this._myParams.myPosition);
      this._myPointObject.pp_setRotationLocal(rotation);
      this._myPointObject.pp_setScaleLocal(this._myParams.myRadius);
    } else {
      this._myPointObject.pp_setPosition(this._myParams.myPosition);
      this._myPointObject.pp_setRotation(rotation);
      this._myPointObject.pp_setScale(this._myParams.myRadius);
    }
    if (this._myParams.myMesh != null) {
      this._myPointMeshComponent.mesh = this._myParams.myMesh;
    } else {
      this._myPointMeshComponent.mesh = Globals.getDefaultMeshes(this._myParams.myParent.pp_getEngine()).mySphere;
    }
    if (this._myParams.myMaterial == null) {
      if (this._myParams.myColor == null) {
        this._myPointMeshComponent.material = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myMesh;
      } else {
        if (this._myFlatOpaqueMaterial == null) {
          this._myFlatOpaqueMaterial = Globals.getDefaultMaterials(this._myParams.myParent.pp_getEngine()).myFlatOpaque.clone();
        }
        this._myPointMeshComponent.material = this._myFlatOpaqueMaterial;
        this._myFlatOpaqueMaterial.color = this._myParams.myColor;
      }
    } else {
      this._myPointMeshComponent.material = this._myParams.myMaterial;
    }
  };
}();
VisualPointParams.prototype.copy = function copy18(other) {
  this.myPosition.vec3_copy(other.myPosition);
  this.myRadius = other.myRadius;
  this.myMesh = other.myMesh;
  if (other.myMaterial != null) {
    this.myMaterial = other.myMaterial.clone();
  } else {
    this.myMaterial = null;
  }
  if (other.myColor != null) {
    if (this.myColor != null) {
      this.myColor.vec4_copy(other.myColor);
    } else {
      this.myColor = other.myColor.vec4_clone();
    }
  } else {
    this.myColor = null;
  }
  this.myParent = other.myParent;
  this.myLocal = other.myLocal;
  this.myType = other.myType;
};

// js/pp/cauldron/physics/physics_utils.js
var _myLayerFlagsNames = ["0", "1", "2", "3", "4", "5", "6", "7"];
function setLayerFlagsNames(layerFlagsNames) {
  _myLayerFlagsNames = layerFlagsNames;
}
function getLayerFlagsNames() {
  return _myLayerFlagsNames;
}
var raycast = function() {
  let insideCheckSubVector = vec3_create();
  let invertedRaycastDirection = vec3_create();
  let objectsEqualCallback = (first2, second) => first2.pp_equals(second);
  return function raycast2(raycastParams, raycastResults = new RaycastResults()) {
    let internalRaycastResults = raycastParams.myPhysics.rayCast(raycastParams.myOrigin, raycastParams.myDirection, raycastParams.myBlockLayerFlags.getMask(), raycastParams.myDistance);
    if (raycastResults.myRaycastParams == null) {
      raycastResults.myRaycastParams = new RaycastParams(raycastParams.myPhysics);
    }
    raycastResults.myRaycastParams.copy(raycastParams);
    let currentValidHitIndex = 0;
    let validHitsCount = 0;
    let hitCount = internalRaycastResults.hitCount;
    if (hitCount != 0) {
      let objects = null;
      let distances = null;
      let locations = null;
      let normals = null;
      invertedRaycastDirection = raycastParams.myDirection.vec3_negate(invertedRaycastDirection);
      for (let i = 0; i < hitCount; i++) {
        if (raycastParams.myObjectsToIgnore.length != 0) {
          if (objects == null) {
            objects = internalRaycastResults.objects;
          }
          if (raycastParams.myObjectsToIgnore.pp_hasEqual(objects[i], objectsEqualCallback)) {
            continue;
          }
        }
        if (distances == null) {
          distances = internalRaycastResults.distances;
        }
        let hitInsideCollision = distances[i] == 0;
        if (hitInsideCollision) {
          if (locations == null) {
            locations = internalRaycastResults.locations;
          }
          hitInsideCollision &&= raycastParams.myOrigin.vec3_sub(locations[i], insideCheckSubVector).vec3_isZero(Math.PP_EPSILON);
          if (hitInsideCollision) {
            if (!normals) {
              normals = internalRaycastResults.normals;
            }
            hitInsideCollision &&= invertedRaycastDirection.vec3_equals(normals[i], Math.PP_EPSILON_DEGREES);
          }
        }
        if (!raycastParams.myIgnoreHitsInsideCollision || !hitInsideCollision) {
          let hit = null;
          if (currentValidHitIndex < raycastResults.myHits.length) {
            hit = raycastResults.myHits[currentValidHitIndex];
          } else if (raycastResults._myUnusedHits != null && raycastResults._myUnusedHits.length > 0) {
            hit = raycastResults._myUnusedHits.pop();
            raycastResults.myHits.push(hit);
          } else {
            hit = new RaycastHit();
            raycastResults.myHits.push(hit);
          }
          if (objects == null) {
            objects = internalRaycastResults.objects;
          }
          if (locations == null) {
            locations = internalRaycastResults.locations;
          }
          if (normals == null) {
            normals = internalRaycastResults.normals;
          }
          hit.myPosition.vec3_copy(locations[i]);
          hit.myNormal.vec3_copy(normals[i]);
          hit.myDistance = distances[i];
          hit.myObject = objects[i];
          hit.myInsideCollision = hitInsideCollision;
          validHitsCount++;
          currentValidHitIndex++;
        }
      }
    }
    if (raycastResults.myHits.length > validHitsCount) {
      if (raycastResults._myUnusedHits == null) {
        raycastResults._myUnusedHits = [];
      }
      let hitsToRemove = raycastResults.myHits.length - validHitsCount;
      for (let i = 0; i < hitsToRemove; i++) {
        raycastResults._myUnusedHits.push(raycastResults.myHits.pop());
      }
    }
    return raycastResults;
  };
}();
var PhysicsUtils = {
  setLayerFlagsNames,
  getLayerFlagsNames,
  raycast
};

// js/pp/cauldron/physics/physics_layer_flags.js
var PhysicsLayerFlags = class {
  constructor() {
    this._myLayerMask = 0;
  }
  setFlagActive(indexOrName, active) {
    let index = indexOrName;
    if (isNaN(indexOrName)) {
      index = PhysicsUtils.getLayerFlagsNames().pp_findIndexEqual(indexOrName);
    }
    if (index >= 0 && index < PhysicsUtils.getLayerFlagsNames().length) {
      let mask = 1 << index;
      if (active) {
        this._myLayerMask = this._myLayerMask | mask;
      } else {
        this._myLayerMask = this._myLayerMask & ~mask;
      }
    }
  }
  isFlagActive(indexOrName) {
    let index = indexOrName;
    if (isNaN(indexOrName)) {
      index = PhysicsUtils.getLayerFlagsNames().pp_findIndexEqual(indexOrName);
    }
    let active = false;
    if (index >= 0 && index < PhysicsUtils.getLayerFlagsNames().length) {
      let mask = 1 << index;
      active = !!(this._myLayerMask & mask);
    }
    return active;
  }
  setAllFlagsActive(active) {
    if (!active) {
      this._myLayerMask = 0;
    } else {
      this._myLayerMask = Math.pow(2, PhysicsUtils.getLayerFlagsNames().length) - 1;
    }
  }
  add(layerFlags) {
    this._myLayerMask = this._myLayerMask | layerFlags.getMask();
  }
  remove(layerFlags) {
    this._myLayerMask = this._myLayerMask & ~layerFlags.getMask();
  }
  intersect(layerFlags) {
    this._myLayerMask = this._myLayerMask & layerFlags.getMask();
  }
  copy(layerFlags) {
    this._myLayerMask = layerFlags._myLayerMask;
  }
  getMask() {
    return this._myLayerMask;
  }
  setMask(layerMask) {
    this._myLayerMask = layerMask;
  }
};

// js/pp/cauldron/physics/physics_raycast_params.js
var RaycastParams = class {
  constructor(physics = Globals.getPhysics()) {
    this.myOrigin = vec3_create();
    this.myDirection = vec3_create();
    this.myDistance = 0;
    this.myBlockLayerFlags = new PhysicsLayerFlags();
    this.myObjectsToIgnore = [];
    this.myIgnoreHitsInsideCollision = false;
    this.myPhysics = physics;
  }
  copy(other) {
    this.myOrigin.vec3_copy(other.myOrigin);
    this.myDirection.vec3_copy(other.myDirection);
    this.myDistance = other.myDistance;
    this.myBlockLayerFlags.copy(other.myBlockLayerFlags);
    this.myObjectsToIgnore.pp_copy(other.myObjectsToIgnore);
    this.myIgnoreHitsInsideCollision = other.myIgnoreHitsInsideCollision;
    this.myPhysics = other.myPhysics;
  }
  reset() {
    this.myOrigin.vec3_zero();
    this.myDirection.vec3_zero();
    this.myDistance = 0;
    this.myBlockLayerFlags.setAllFlagsActive(false);
    this.myObjectsToIgnore.pp_clear();
    this.myIgnoreHitsInsideCollision = false;
  }
};
var RaycastResults = class {
  constructor() {
    this.myRaycastParams = null;
    this.myHits = [];
    this._myUnusedHits = null;
  }
  isColliding(ignoreHitsInsideCollision = false) {
    return ignoreHitsInsideCollision ? this.getFirstHitOutsideCollision() != null : this.myHits.length > 0;
  }
  getFirstHitInsideCollision() {
    let firstHit = null;
    for (let i = 0; i < this.myHits.length; i++) {
      let hit = this.myHits[i];
      if (hit.myInsideCollision) {
        firstHit = hit;
        break;
      }
    }
    return firstHit;
  }
  getFirstHitOutsideCollision() {
    let firstHit = null;
    for (let i = 0; i < this.myHits.length; i++) {
      let hit = this.myHits[i];
      if (!hit.myInsideCollision) {
        firstHit = hit;
        break;
      }
    }
    return firstHit;
  }
  getHitsInsideCollision() {
    let hits = [];
    for (let i = 0; i < this.myHits.length; i++) {
      let hit = this.myHits[i];
      if (hit.myInsideCollision) {
        hits.push(hit);
      }
    }
    return hits;
  }
  getHitsOutsideCollision() {
    let hits = [];
    for (let i = 0; i < this.myHits.length; i++) {
      let hit = this.myHits[i];
      if (!hit.myInsideCollision) {
        hits.push(hit);
      }
    }
    return hits;
  }
  removeHit(hitIndex) {
    let removedHit = this.myHits.pp_removeIndex(hitIndex);
    if (removedHit != null) {
      if (this._myUnusedHits == null) {
        this._myUnusedHits = [];
      }
      this._myUnusedHits.push(removedHit);
    }
    return removedHit;
  }
  removeAllHits() {
    if (this._myUnusedHits == null) {
      this._myUnusedHits = [];
    }
    for (let i = 0; i < this.myHits.length; i++) {
      this._myUnusedHits.push(this.myHits[i]);
    }
    this.myHits.pp_clear();
  }
  copy(other) {
  }
  reset() {
    if (this.myRaycastParams != null) {
      this.myRaycastParams.reset();
    }
    this.removeAllHits();
  }
};
var RaycastHit = class {
  constructor() {
    this.myPosition = vec3_create();
    this.myNormal = vec3_create();
    this.myDistance = 0;
    this.myObject = null;
    this.myInsideCollision = false;
  }
  isValid() {
    return this.myObject != null;
  }
  copy(other) {
    this.myPosition.vec3_copy(other.myPosition);
    this.myNormal.vec3_copy(other.myNormal);
    this.myDistance = other.myDistance;
    this.myObject = other.myObject;
    this.myInsideCollision = other.myInsideCollision;
  }
  reset() {
    this.myPosition.vec3_zero();
    this.myNormal.vec3_zero();
    this.myDistance = 0;
    this.myObject = null;
    this.myInsideCollision = false;
  }
};
RaycastResults.prototype.copy = function() {
  let copyHitCallback = function(currentElement, elementToCopy) {
    if (currentElement == null) {
      currentElement = new RaycastHit();
    }
    currentElement.copy(elementToCopy);
    return currentElement;
  };
  return function copy42(other) {
    if (other.myRaycastParams == null) {
      this.myRaycastParams = null;
    } else {
      if (this.myRaycastParams == null) {
        this.myRaycastParams = new RaycastParams(other.myRaycastParams.myPhysics);
      }
      this.myRaycastParams.copy(other.myRaycastParams);
    }
    if (this.myHits.length > other.myHits.length) {
      if (this._myUnusedHits == null) {
        this._myUnusedHits = [];
      }
      for (let i = 0; i < this.myHits.length - other.myHits.length; i++) {
        this._myUnusedHits.push(this.myHits.pop());
      }
    } else if (this.myHits.length < other.myHits.length) {
      if (this._myUnusedHits != null) {
        let length10 = Math.min(this._myUnusedHits.length, other.myHits.length - this.myHits.length);
        for (let i = 0; i < length10; i++) {
          this.myHits.push(this._myUnusedHits.pop());
        }
      }
    }
    this.myHits.pp_copy(other.myHits, copyHitCallback);
  };
}();

// js/pp/cauldron/visual/elements/visual_raycast.js
var VisualRaycastParams = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this._myRaycastResults = new RaycastResults();
    this.myHitNormalLength = 0.2;
    this.myThickness = 5e-3;
    this.myShowOnlyFirstHit = true;
    this.myRayMaterial = null;
    this.myHitNormalMaterial = null;
    this.myParent = Globals.getSceneObjects(engine2).myVisualElements;
    this.myLocal = false;
    this.myType = VisualElementType.RAYCAST;
  }
  get myRaycastResults() {
    return this._myRaycastResults;
  }
  set myRaycastResults(result) {
    this._myRaycastResults.copy(result);
  }
  copy(other) {
  }
};
var VisualRaycast = class {
  constructor(params = new VisualRaycastParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myVisualRaycast = new VisualArrow(new VisualArrowParams(this._myParams.myParent.pp_getEngine()));
    this._myVisualRaycast.setAutoRefresh(false);
    this._myVisualRaycastHitList = [];
    this._myDestroyed = false;
    this._addVisualRaycastHit();
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      if (this._myVisible) {
        if (this._myParams.myRaycastResults.myRaycastParams != null) {
          this._myVisualRaycast.setVisible(true);
        }
        if (this._myParams.myRaycastResults.myHits.length > 0) {
          let hitsToShow = Math.min(this._myParams.myRaycastResults.myHits.length, this._myVisualRaycastHitList.length);
          for (let i = 0; i < hitsToShow; i++) {
            let visualRaycastHit = this._myVisualRaycastHitList[i];
            visualRaycastHit.setVisible(true);
          }
        }
      } else {
        this._myVisualRaycast.setVisible(false);
        for (let visualRaycastHit of this._myVisualRaycastHitList) {
          visualRaycastHit.setVisible(false);
        }
      }
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
    this._myVisualRaycast.forceRefresh();
    if (this._myParams.myRaycastResults.myHits.length > 0) {
      let hitsToRefresh = Math.min(this._myParams.myRaycastResults.myHits.length, this._myVisualRaycastHitList.length);
      for (let i = 0; i < hitsToRefresh; i++) {
        let visualRaycastHit = this._myVisualRaycastHitList[i];
        visualRaycastHit.forceRefresh();
      }
    }
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
    this._myVisualRaycast.update(dt);
    for (let visualRaycastHit of this._myVisualRaycastHitList) {
      visualRaycastHit.update(dt);
    }
  }
  _refresh() {
    for (let visualRaycastHit of this._myVisualRaycastHitList) {
      visualRaycastHit.setVisible(false);
    }
    if (this._myParams.myRaycastResults.myHits.length > 0) {
      let raycastDistance = this._myParams.myShowOnlyFirstHit ? this._myParams.myRaycastResults.myHits.pp_first().myDistance : this._myParams.myRaycastResults.myHits.pp_last().myDistance;
      {
        let visualRaycastParams = this._myVisualRaycast.getParams();
        visualRaycastParams.myStart.vec3_copy(this._myParams.myRaycastResults.myRaycastParams.myOrigin);
        visualRaycastParams.myDirection.vec3_copy(this._myParams.myRaycastResults.myRaycastParams.myDirection);
        visualRaycastParams.myLength = raycastDistance;
        visualRaycastParams.myThickness = this._myParams.myThickness;
        if (this._myParams.myRayMaterial == null) {
          visualRaycastParams.myMaterial = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myRay;
        } else {
          visualRaycastParams.myMaterial = this._myParams.myRayMaterial;
        }
        visualRaycastParams.myParent = this._myParams.myParent;
        visualRaycastParams.myLocal = this._myParams.myLocal;
        this._myVisualRaycast.paramsUpdated();
        this._myVisualRaycast.setVisible(this._myVisible);
      }
      let hitsToShow = this._myParams.myShowOnlyFirstHit ? 1 : this._myParams.myRaycastResults.myHits.length;
      while (hitsToShow > this._myVisualRaycastHitList.length) {
        this._addVisualRaycastHit();
      }
      for (let i = 0; i < hitsToShow; i++) {
        let visualRaycastHit = this._myVisualRaycastHitList[i];
        {
          let visualRaycastHitParams = visualRaycastHit.getParams();
          visualRaycastHitParams.myStart.vec3_copy(this._myParams.myRaycastResults.myHits[i].myPosition);
          visualRaycastHitParams.myDirection.vec3_copy(this._myParams.myRaycastResults.myHits[i].myNormal);
          visualRaycastHitParams.myLength = this._myParams.myHitNormalLength;
          visualRaycastHitParams.myThickness = this._myParams.myThickness;
          if (this._myParams.myHitNormalMaterial == null) {
            visualRaycastHitParams.myMaterial = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myHitNormal;
          } else {
            visualRaycastHitParams.myMaterial = this._myParams.myHitNormalMaterial;
          }
          visualRaycastHitParams.myParent = this._myParams.myParent;
          visualRaycastHitParams.myLocal = this._myParams.myLocal;
          visualRaycastHit.paramsUpdated();
          visualRaycastHit.setVisible(this._myVisible);
        }
      }
    } else if (this._myParams.myRaycastResults.myRaycastParams != null) {
      {
        let visualRaycastParams = this._myVisualRaycast.getParams();
        visualRaycastParams.myStart.vec3_copy(this._myParams.myRaycastResults.myRaycastParams.myOrigin);
        visualRaycastParams.myDirection.vec3_copy(this._myParams.myRaycastResults.myRaycastParams.myDirection);
        visualRaycastParams.myLength = this._myParams.myRaycastResults.myRaycastParams.myDistance;
        visualRaycastParams.myThickness = this._myParams.myThickness;
        if (this._myParams.myRayMaterial == null) {
          visualRaycastParams.myMaterial = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myRay;
        } else {
          visualRaycastParams.myMaterial = this._myParams.myRayMaterial;
        }
        visualRaycastParams.myParent = this._myParams.myParent;
        visualRaycastParams.myLocal = this._myParams.myLocal;
        this._myVisualRaycast.paramsUpdated();
        this._myVisualRaycast.setVisible(this._myVisible);
      }
    } else {
      this._myVisualRaycast.setVisible(false);
    }
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  clone() {
    let clonedParams = new VisualRaycastParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone17 = new VisualRaycast(clonedParams);
    clone17.setAutoRefresh(this._myAutoRefresh);
    clone17.setVisible(this._myVisible);
    clone17._myDirty = this._myDirty;
    return clone17;
  }
  _addVisualRaycastHit() {
    let visualRaycastHit = new VisualArrow(new VisualArrowParams(this._myParams.myParent.pp_getEngine()));
    visualRaycastHit.setAutoRefresh(false);
    visualRaycastHit.setVisible(false);
    this._myVisualRaycastHitList.push(visualRaycastHit);
  }
  destroy() {
    this._myDestroyed = true;
    this._myVisualRaycast.destroy();
    for (let visualRaycastHit of this._myVisualRaycastHitList) {
      visualRaycastHit.destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
VisualRaycastParams.prototype.copy = function copy19(other) {
  this.myRaycastResults = other.myRaycastResults;
  this.myHitNormalLength = other.myHitNormalLength;
  this.myThickness = other.myThickness;
  this.myShowOnlyFirstHit = other.myShowOnlyFirstHit;
  if (other.myRayMaterial != null) {
    this.myRayMaterial = other.myRayMaterial.clone();
  } else {
    this.myRayMaterial = null;
  }
  if (other.myHitNormalMaterial != null) {
    this.myHitNormalMaterial = other.myHitNormalMaterial.clone();
  } else {
    this.myHitNormalMaterial = null;
  }
  this.myParent = other.myParent;
  this.myLocal = other.myLocal;
  this.myType = other.myType;
};

// js/pp/cauldron/visual/elements/visual_text.js
var VisualTextParams = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this.myText = "";
    this.myAlignment = Alignment.Center;
    this.myJustification = Justification.Middle;
    this.myTransform = mat4_create();
    this.myMaterial = null;
    this.myColor = null;
    this.myParent = Globals.getSceneObjects(engine2).myVisualElements;
    this.myLocal = false;
    this.myLookAtObject = null;
    this.myType = VisualElementType.TEXT;
  }
  copy(other) {
  }
};
var VisualText = class {
  constructor(params = new VisualTextParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myTextObject = null;
    this._myTextComponent = null;
    this._myTextMaterial = null;
    this._myDestroyed = false;
    this._build();
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      this._myTextObject.pp_setActive(visible);
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
  }
  update(dt) {
    if (this._myDirty || this._myParams.myLookAtObject != null) {
      this._refresh();
      this._myDirty = false;
    }
  }
  _refresh() {
  }
  _build() {
    this._myTextObject = Globals.getSceneObjects(this._myParams.myParent.pp_getEngine()).myVisualElements.pp_addObject();
    this._myTextComponent = this._myTextObject.pp_addComponent(TextComponent);
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  clone() {
    let clonedParams = new VisualTextParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone17 = new VisualText(clonedParams);
    clone17.setAutoRefresh(this._myAutoRefresh);
    clone17.setVisible(this._myVisible);
    clone17._myDirty = this._myDirty;
    return clone17;
  }
  destroy() {
    this._myDestroyed = true;
    this._myTextObject.pp_destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
VisualTextParams.prototype.copy = function copy20(other) {
  this.myText = other.myText;
  this.myAlignment = other.myAlignment;
  this.myJustification = other.myJustification;
  this.myTransform.mat4_copy(other.myTransform);
  if (other.myMaterial != null) {
    this.myMaterial = other.myMaterial.clone();
  } else {
    this.myMaterial = null;
  }
  if (other.myColor != null) {
    if (this.myColor != null) {
      this.myColor.vec4_copy(other.myColor);
    } else {
      this.myColor = other.myColor.vec4_clone();
    }
  } else {
    this.myColor = null;
  }
  this.myParent = other.myParent;
  this.myLocal = other.myLocal;
  this.myLookAtObject = other.myLookAtObject;
  this.myType = other.myType;
};
VisualText.prototype._refresh = function() {
  let lookAtPosition = vec3_create();
  return function _refresh() {
    this._myTextObject.pp_setParent(this._myParams.myParent, false);
    if (this._myParams.myLocal) {
      this._myTextObject.pp_setTransformLocal(this._myParams.myTransform);
    } else {
      this._myTextObject.pp_setTransform(this._myParams.myTransform);
    }
    if (this._myParams.myLookAtObject != null) {
      this._myParams.myLookAtObject.pp_getPosition(lookAtPosition);
      this._myTextObject.pp_lookAt(lookAtPosition);
    }
    if (this._myParams.myMaterial == null) {
      if (this._myParams.myColor == null) {
        this._myTextComponent.material = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myText;
      } else {
        if (this._myTextMaterial == null) {
          this._myTextMaterial = Globals.getDefaultMaterials(this._myParams.myParent.pp_getEngine()).myText.clone();
        }
        this._myTextComponent.material = this._myTextMaterial;
        this._myTextMaterial.color = this._myParams.myColor;
      }
    } else {
      this._myTextComponent.material = this._myParams.myMaterial;
    }
    this._myTextComponent.text = " ";
    this._myTextComponent.text = this._myParams.myText;
    this._myTextComponent.alignment = this._myParams.myAlignment;
    this._myTextComponent.justification = this._myParams.myJustification;
    this._myDirty = false;
  };
}();

// js/pp/cauldron/visual/elements/visual_torus.js
var VisualTorusParams = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this.myTransform = mat4_create();
    this.myRadius = 0;
    this.mySegmentsAmount = 12;
    this.mySegmentThickness = 0.05;
    this.mySegmentMesh = null;
    this.myMaterial = null;
    this.myColor = null;
    this.myParent = Globals.getSceneObjects(engine2).myVisualElements;
    this.myLocal = false;
    this.myType = VisualElementType.TORUS;
  }
  copy(other) {
  }
};
var VisualTorus = class {
  constructor(params = new VisualTorusParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myTorusParentObject = null;
    this._myVisualSegmentList = [];
    this._myFlatOpaqueMaterial = null;
    this._myDestroyed = false;
    this._build();
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      if (this._myVisible) {
        let segmentToShow = Math.min(this._myParams.mySegmentsAmount, this._myVisualSegmentList.length);
        for (let i = 0; i < segmentToShow; i++) {
          let visualSegment = this._myVisualSegmentList[i];
          visualSegment.setVisible(true);
        }
      } else {
        for (let visualSegment of this._myVisualSegmentList) {
          visualSegment.setVisible(false);
        }
      }
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
    let segmentToRefresh = Math.min(this._myParams.mySegmentsAmount, this._myVisualSegmentList.length);
    for (let i = 0; i < segmentToRefresh; i++) {
      let visualSegment = this._myVisualSegmentList[i];
      visualSegment.forceRefresh();
    }
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
    for (let visualSegment of this._myVisualSegmentList) {
      visualSegment.update(dt);
    }
  }
  _build() {
    this._myTorusParentObject = Globals.getSceneObjects(this._myParams.myParent.pp_getEngine()).myVisualElements.pp_addObject();
    this._fillSegmentList();
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  _fillSegmentList() {
    while (this._myVisualSegmentList.length < this._myParams.mySegmentsAmount) {
      let visualSegment = new VisualLine(new VisualLineParams(this._myParams.myParent.pp_getEngine()));
      visualSegment.setAutoRefresh(false);
      visualSegment.setVisible(false);
      visualSegment.getParams().myParent = this._myTorusParentObject;
      visualSegment.getParams().myLocal = true;
      this._myVisualSegmentList.push(visualSegment);
    }
  }
  clone() {
    let clonedParams = new VisualTorusParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone17 = new VisualTorus(clonedParams);
    clone17.setAutoRefresh(this._myAutoRefresh);
    clone17.setVisible(this._myVisible);
    clone17._myDirty = this._myDirty;
    return clone17;
  }
  _refresh() {
  }
  destroy() {
    this._myDestroyed = true;
    for (let visualSegment of this._myVisualSegmentList) {
      visualSegment.destroy();
    }
    this._myTorusParentObject.pp_destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
VisualTorus.prototype._refresh = function() {
  let segmentStart = vec3_create();
  let segmentEnd = vec3_create();
  let segmentDirection = vec3_create();
  let fixedSegmentStart = vec3_create();
  let fixedSegmentEnd = vec3_create();
  let up = vec3_create(0, 1, 0);
  return function _refresh() {
    this._fillSegmentList();
    for (let visualSegment of this._myVisualSegmentList) {
      visualSegment.setVisible(false);
    }
    this._myTorusParentObject.pp_setParent(this._myParams.myParent, false);
    if (this._myParams.myLocal) {
      this._myTorusParentObject.pp_setTransformLocal(this._myParams.myTransform);
    } else {
      this._myTorusParentObject.pp_setTransform(this._myParams.myTransform);
    }
    let sliceAngle = 2 * Math.PI / this._myParams.mySegmentsAmount;
    segmentStart.vec3_set(this._myParams.myRadius, 0, 0);
    for (let i = 0; i < this._myParams.mySegmentsAmount; i++) {
      segmentEnd = segmentStart.vec3_rotateAxisRadians(sliceAngle, up, segmentEnd);
      segmentDirection = segmentEnd.vec3_sub(segmentStart, segmentDirection).vec3_normalize(segmentDirection);
      let extraLength = Math.tan(sliceAngle / 2) * this._myParams.mySegmentThickness / 2;
      fixedSegmentStart = segmentStart.vec3_sub(segmentDirection.vec3_scale(extraLength, fixedSegmentStart), fixedSegmentStart);
      fixedSegmentEnd = segmentEnd.vec3_add(segmentDirection.vec3_scale(extraLength, fixedSegmentEnd), fixedSegmentEnd);
      let visualSegment = this._myVisualSegmentList[i];
      let visualSegmentParams = visualSegment.getParams();
      visualSegmentParams.setStartEnd(fixedSegmentStart, fixedSegmentEnd);
      visualSegmentParams.myThickness = this._myParams.mySegmentThickness;
      visualSegmentParams.myMesh = this._myParams.mySegmentMesh;
      if (this._myParams.myMaterial == null) {
        if (this._myParams.myColor == null) {
          visualSegmentParams.myMaterial = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myMesh;
        } else {
          if (this._myFlatOpaqueMaterial == null) {
            this._myFlatOpaqueMaterial = Globals.getDefaultMaterials(this._myParams.myParent.pp_getEngine()).myFlatOpaque.clone();
          }
          visualSegmentParams.myMaterial = this._myFlatOpaqueMaterial;
          this._myFlatOpaqueMaterial.color = this._myParams.myColor;
        }
      } else {
        visualSegmentParams.myMaterial = this._myParams.myMaterial;
      }
      visualSegment.paramsUpdated();
      visualSegment.setVisible(this._myVisible);
      segmentStart.vec3_copy(segmentEnd);
    }
  };
}();
VisualTorusParams.prototype.copy = function copy21(other) {
  this.myRadius = other.myRadius;
  this.mySegmentsAmount = other.mySegmentsAmount;
  this.mySegmentThickness = other.mySegmentThickness;
  this.myTransform.mat4_copy(other.myTransform);
  this.mySegmentMesh = other.mySegmentMesh;
  if (other.myMaterial != null) {
    this.myMaterial = other.myMaterial.clone();
  } else {
    this.myMaterial = null;
  }
  if (other.myColor != null) {
    if (this.myColor != null) {
      this.myColor.vec4_copy(other.myColor);
    } else {
      this.myColor = other.myColor.vec4_clone();
    }
  } else {
    this.myColor = null;
  }
  this.myParent = other.myParent;
  this.myLocal = other.myLocal;
  this.myType = other.myType;
};

// js/pp/cauldron/visual/elements/visual_transform.js
var VisualTransformParams = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this.myTransform = mat4_create();
    this.myLength = 0.2;
    this.myThickness = 5e-3;
    this.myForwardMaterial = null;
    this.myUpMaterial = null;
    this.myRightMaterial = null;
    this.myParent = Globals.getSceneObjects(engine2).myVisualElements;
    this.myLocal = false;
    this.myType = VisualElementType.TRANSFORM;
  }
  copy(other) {
  }
};
var VisualTransform = class {
  constructor(params = new VisualTransformParams()) {
    this._myParams = params;
    this._myVisible = false;
    this._myAutoRefresh = true;
    this._myDirty = false;
    this._myVisualRight = new VisualArrow(new VisualArrowParams(this._myParams.myParent.pp_getEngine()));
    this._myVisualUp = new VisualArrow(new VisualArrowParams(this._myParams.myParent.pp_getEngine()));
    this._myVisualForward = new VisualArrow(new VisualArrowParams(this._myParams.myParent.pp_getEngine()));
    this._myVisualRight.setAutoRefresh(false);
    this._myVisualUp.setAutoRefresh(false);
    this._myVisualForward.setAutoRefresh(false);
    this._myDestroyed = false;
    this.forceRefresh();
    this.setVisible(true);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      this._myVisualRight.setVisible(visible);
      this._myVisualUp.setVisible(visible);
      this._myVisualForward.setVisible(visible);
    }
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this._markDirty();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this._markDirty();
  }
  paramsUpdated() {
    this._markDirty();
  }
  refresh() {
    this.update(0);
  }
  forceRefresh() {
    this._refresh();
    this._myVisualRight.forceRefresh();
    this._myVisualUp.forceRefresh();
    this._myVisualForward.forceRefresh();
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
    this._myVisualRight.update(dt);
    this._myVisualUp.update(dt);
    this._myVisualForward.update(dt);
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  clone() {
    let clonedParams = new VisualTransformParams(this._myParams.myParent.pp_getEngine());
    clonedParams.copy(this._myParams);
    let clone17 = new VisualTransform(clonedParams);
    clone17.setAutoRefresh(this._myAutoRefresh);
    clone17.setVisible(this._myVisible);
    clone17._myDirty = this._myDirty;
    return clone17;
  }
  _refresh() {
  }
  destroy() {
    this._myDestroyed = true;
    this._myVisualRight.destroy();
    this._myVisualUp.destroy();
    this._myVisualForward.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
VisualTransform.prototype._refresh = function() {
  let axes = [vec3_create(), vec3_create(), vec3_create()];
  let scale11 = vec3_create();
  let position = vec3_create();
  return function _refresh() {
    axes = this._myParams.myTransform.mat4_getAxes(axes);
    scale11 = this._myParams.myTransform.mat4_getScale(scale11);
    let maxValue = 0;
    for (let value of scale11) {
      maxValue = Math.max(value, maxValue);
    }
    if (maxValue == 0) {
      scale11[0] = 1;
      scale11[1] = 1;
      scale11[2] = 1;
    } else {
      scale11[0] = scale11[0] / maxValue;
      scale11[1] = scale11[1] / maxValue;
      scale11[2] = scale11[2] / maxValue;
    }
    position = this._myParams.myTransform.mat4_getPosition(position);
    {
      let visualArrowParams = this._myVisualRight.getParams();
      visualArrowParams.myStart.vec3_copy(position);
      visualArrowParams.myDirection = axes[0].vec3_negate(visualArrowParams.myDirection).vec3_normalize(visualArrowParams.myDirection);
      visualArrowParams.myLength = Math.max(this._myParams.myLength * scale11[0], 1e-3);
      visualArrowParams.myThickness = this._myParams.myThickness;
      if (this._myParams.myRightMaterial == null) {
        visualArrowParams.myMaterial = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myRight;
      } else {
        visualArrowParams.myMaterial = this._myParams.myRightMaterial;
      }
      visualArrowParams.myParent = this._myParams.myParent;
      visualArrowParams.myLocal = this._myParams.myLocal;
      this._myVisualRight.paramsUpdated();
    }
    {
      let visualArrowParams = this._myVisualUp.getParams();
      visualArrowParams.myStart.vec3_copy(position);
      visualArrowParams.myDirection = axes[1].vec3_normalize(visualArrowParams.myDirection);
      visualArrowParams.myLength = Math.max(this._myParams.myLength * scale11[1], 1e-3);
      visualArrowParams.myThickness = this._myParams.myThickness;
      if (this._myParams.myUpMaterial == null) {
        visualArrowParams.myMaterial = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myUp;
      } else {
        visualArrowParams.myMaterial = this._myParams.myUpMaterial;
      }
      visualArrowParams.myParent = this._myParams.myParent;
      visualArrowParams.myLocal = this._myParams.myLocal;
      this._myVisualUp.paramsUpdated();
    }
    {
      let visualArrowParams = this._myVisualForward.getParams();
      visualArrowParams.myStart.vec3_copy(position);
      visualArrowParams.myDirection = axes[2].vec3_normalize(visualArrowParams.myDirection);
      visualArrowParams.myLength = Math.max(this._myParams.myLength * scale11[2], 1e-3);
      visualArrowParams.myThickness = this._myParams.myThickness;
      if (this._myParams.myForwardMaterial == null) {
        visualArrowParams.myMaterial = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myForward;
      } else {
        visualArrowParams.myMaterial = this._myParams.myForwardMaterial;
      }
      visualArrowParams.myParent = this._myParams.myParent;
      visualArrowParams.myLocal = this._myParams.myLocal;
      this._myVisualForward.paramsUpdated();
    }
  };
}();
VisualTransformParams.prototype.copy = function copy22(other) {
  this.myTransform.mat4_copy(other.myTransform);
  this.myLength = other.myLength;
  this.myThickness = other.myThickness;
  if (other.myRightMaterial != null) {
    this.myRightMaterial = other.myRightMaterial.clone();
  } else {
    this.myRightMaterial = null;
  }
  if (other.myUpMaterial != null) {
    this.myUpMaterial = other.myUpMaterial.clone();
  } else {
    this.myUpMaterial = null;
  }
  if (other.myForwardMaterial != null) {
    this.myForwardMaterial = other.myForwardMaterial.clone();
  } else {
    this.myForwardMaterial = null;
  }
  this.myParent = other.myParent;
  this.myLocal = other.myLocal;
  this.myType = other.myType;
};

// js/pp/cauldron/visual/visual_manager.js
var VisualManager = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this._myEngine = engine2;
    this._myVisualElementPrototypeCreationCallbacks = /* @__PURE__ */ new Map();
    this._myVisualElementsTypeMap = /* @__PURE__ */ new Map();
    this._myVisualElementLastID = 0;
    this._myVisualElementsToShow = [];
    this._myActive = true;
    this._myDestroyed = false;
    this._myObjectPoolManagerPrefix = this._getClassName() + "_" + Math.pp_randomUUID() + "_visual_element_type_";
    this._myTypePoolIDs = /* @__PURE__ */ new Map();
    this._addStandardVisualElementTypes();
  }
  setActive(active) {
    if (this._myActive != active) {
      this._myActive = active;
      if (!this._myActive) {
        this.clearVisualElement();
      }
    }
  }
  isActive() {
    return this._myActive;
  }
  start() {
  }
  update(dt) {
    if (this._myActive) {
      this._updateDraw(dt);
    }
  }
  // lifetimeSeconds can be null, in that case the element will be drawn until cleared
  draw(visualElementParams, lifetimeSeconds = 0, idToReuse = null) {
    if (!this._myActive) {
      return 0;
    }
    let visualElement = null;
    let idReused = false;
    if (idToReuse != null) {
      if (this._myVisualElementsTypeMap.has(visualElementParams.myType)) {
        let visualElements2 = this._myVisualElementsTypeMap.get(visualElementParams.myType);
        if (visualElements2.has(idToReuse)) {
          visualElement = visualElements2.get(idToReuse)[0];
          visualElement.copyParams(visualElementParams);
          visualElement.setVisible(false);
          idReused = true;
        }
      }
    }
    if (visualElement == null) {
      visualElement = this._getVisualElementFromPool(visualElementParams);
    }
    if (visualElement == null) {
      console.error("Couldn't create the requested visual element");
      return null;
    }
    if (!this._myVisualElementsTypeMap.has(visualElementParams.myType)) {
      this._myVisualElementsTypeMap.set(visualElementParams.myType, /* @__PURE__ */ new Map());
    }
    let visualElements = this._myVisualElementsTypeMap.get(visualElementParams.myType);
    let elementID = null;
    if (!idReused) {
      elementID = this._myVisualElementLastID + 1;
      this._myVisualElementLastID = elementID;
      visualElements.set(elementID, [visualElement, new Timer(lifetimeSeconds, lifetimeSeconds != null)]);
    } else {
      elementID = idToReuse;
      let visualElementPair = visualElements.get(elementID);
      visualElementPair[0] = visualElement;
      visualElementPair[1].reset(lifetimeSeconds);
      if (lifetimeSeconds != null) {
        visualElementPair[1].start();
      }
    }
    this._myVisualElementsToShow.push(visualElement);
    return elementID;
  }
  getVisualElement(elementID) {
    let visualElement = null;
    for (let visualElements of this._myVisualElementsTypeMap.values()) {
      if (visualElements.has(elementID)) {
        let visualElementPair = visualElements.get(elementID);
        visualElement = visualElementPair[0];
        break;
      }
    }
    return visualElement;
  }
  getVisualElementParams(elementID) {
    return this.getVisualElement(elementID).getParams();
  }
  getVisualElementID(visualElement) {
    let elementID = null;
    for (let currentVisualElements of this._myVisualElementsTypeMap.values()) {
      for (let [currentElementID, currentVisualElement] of currentVisualElements.entries()) {
        if (currentVisualElement[0] == visualElement) {
          elementID = currentElementID;
          break;
        }
      }
      if (elementID != null) {
        break;
      }
    }
    return elementID;
  }
  clearVisualElement(elementID = null) {
    if (elementID == null) {
      for (let visualElements of this._myVisualElementsTypeMap.values()) {
        for (let visualElement of visualElements.values()) {
          this._releaseElement(visualElement[0]);
        }
      }
      this._myVisualElementsToShow = [];
      this._myVisualElementsTypeMap = /* @__PURE__ */ new Map();
      this._myVisualElementLastID = 0;
    } else {
      for (let visualElements of this._myVisualElementsTypeMap.values()) {
        if (visualElements.has(elementID)) {
          let visualElementPair = visualElements.get(elementID);
          this._releaseElement(visualElementPair[0]);
          visualElements.delete(elementID);
          this._myVisualElementsToShow.pp_removeEqual(visualElementPair[0]);
          break;
        }
      }
    }
  }
  allocateVisualElementType(visualElementType, amount) {
    if (!Globals.getObjectPoolManager(this._myEngine).hasPool(this._getTypePoolID(visualElementType))) {
      this._addVisualElementTypeToPool(visualElementType);
    }
    let pool = Globals.getObjectPoolManager(this._myEngine).getPool(this._getTypePoolID(visualElementType));
    let difference = pool.getAvailableSize() - amount;
    if (difference < 0) {
      pool.increase(-difference);
    }
  }
  addVisualElementType(visualElementType, visuaElementPrototypeCreationCallback) {
    this._myVisualElementPrototypeCreationCallbacks.set(visualElementType, visuaElementPrototypeCreationCallback);
  }
  removeVisualElementType(visualElementType) {
    this._myVisualElementPrototypeCreationCallbacks.delete(visualElementType);
  }
  _updateDraw(dt) {
    for (let visualElement of this._myVisualElementsToShow) {
      visualElement.setVisible(true);
    }
    this._myVisualElementsToShow.pp_clear();
    for (let visualElements of this._myVisualElementsTypeMap.values()) {
      let idsToRemove = [];
      for (let visualElementsEntry of visualElements.entries()) {
        let visualElement = visualElementsEntry[1];
        if (visualElement[1].isDone()) {
          this._releaseElement(visualElement[0]);
          idsToRemove.push(visualElementsEntry[0]);
        } else {
          visualElement[0].update(dt);
          visualElement[1].update(dt);
        }
      }
      for (let id of idsToRemove) {
        visualElements.delete(id);
      }
    }
  }
  _getVisualElementFromPool(params) {
    let element = null;
    if (!Globals.getObjectPoolManager(this._myEngine).hasPool(this._getTypePoolID(params.myType))) {
      this._addVisualElementTypeToPool(params.myType);
    }
    element = Globals.getObjectPoolManager(this._myEngine).get(this._getTypePoolID(params.myType));
    if (element != null) {
      element.copyParams(params);
    }
    return element;
  }
  _addVisualElementTypeToPool(type) {
    let objectPoolParams = new ObjectPoolParams();
    objectPoolParams.myInitialPoolSize = 10;
    objectPoolParams.myAmountToAddWhenEmpty = 0;
    objectPoolParams.myPercentageToAddWhenEmpty = 0.5;
    objectPoolParams.mySetActiveCallback = function(object, active) {
      object.setVisible(active);
    };
    let visualElementPrototype = null;
    if (this._myVisualElementPrototypeCreationCallbacks.has(type)) {
      visualElementPrototype = this._myVisualElementPrototypeCreationCallbacks.get(type)();
    }
    if (visualElementPrototype != null) {
      visualElementPrototype.setVisible(false);
      visualElementPrototype.setAutoRefresh(true);
      Globals.getObjectPoolManager(this._myEngine).addPool(this._getTypePoolID(type), new ObjectPool(visualElementPrototype, objectPoolParams));
    } else {
      console.error("Visual element type not supported");
    }
  }
  _addStandardVisualElementTypes() {
    this.addVisualElementType(VisualElementType.LINE, () => new VisualLine(new VisualLineParams(this._myEngine)));
    this.addVisualElementType(VisualElementType.MESH, () => new VisualMesh(new VisualMeshParams(this._myEngine)));
    this.addVisualElementType(VisualElementType.POINT, () => new VisualPoint(new VisualPointParams(this._myEngine)));
    this.addVisualElementType(VisualElementType.ARROW, () => new VisualArrow(new VisualArrowParams(this._myEngine)));
    this.addVisualElementType(VisualElementType.TEXT, () => new VisualText(new VisualTextParams(this._myEngine)));
    this.addVisualElementType(VisualElementType.TRANSFORM, () => new VisualTransform(new VisualTransformParams(this._myEngine)));
    this.addVisualElementType(VisualElementType.RAYCAST, () => new VisualRaycast(new VisualRaycastParams(this._myEngine)));
    this.addVisualElementType(VisualElementType.TORUS, () => new VisualTorus(new VisualTorusParams(this._myEngine)));
  }
  _getTypePoolID(type) {
    let typePoolID = this._myTypePoolIDs.get(type);
    if (typePoolID == null) {
      typePoolID = this._myObjectPoolManagerPrefix + type;
      this._myTypePoolIDs.set(type, typePoolID);
    }
    return typePoolID;
  }
  _releaseElement(visualElement) {
    let defaultElementsParent = Globals.getSceneObjects(this._myEngine).myVisualElements;
    if (visualElement.getParams().myParent != defaultElementsParent) {
      visualElement.getParams().myParent = defaultElementsParent;
      visualElement.forceRefresh();
    }
    Globals.getObjectPoolManager(this._myEngine).release(this._getTypePoolID(visualElement.getParams().myType), visualElement);
  }
  _getClassName() {
    return "visual_manager";
  }
  destroy() {
    this._myDestroyed = true;
    for (let poolID of this._myTypePoolIDs.values()) {
      Globals.getObjectPoolManager(this._myEngine)?.destroyPool(poolID);
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/cauldron/visual/visual_resources.js
var VisualResources = class {
  constructor() {
    this.myDefaultMaterials = new VisualResourcesMaterials();
  }
};
var VisualResourcesMaterials = class {
  constructor() {
    this.myMesh = null;
    this.myText = null;
    this.myRight = null;
    this.myUp = null;
    this.myForward = null;
    this.myRay = null;
    this.myHitNormal = null;
  }
};

// js/pp/cauldron/visual/components/visual_manager_component.js
var VisualManagerComponent = class extends Component {
  init() {
    this._myVisualManager = null;
    if (!Globals.hasVisualManager(this.engine)) {
      this._myVisualManager = new VisualManager(this.engine);
      Globals.setVisualManager(this._myVisualManager, this.engine);
    }
    if (!Globals.hasVisualResources(this.engine)) {
      this._myVisualResources = new VisualResources();
      Globals.setVisualResources(this._myVisualResources, this.engine);
    }
  }
  start() {
    if (this._myVisualResources != null) {
      this._myVisualResources.myDefaultMaterials.myMesh = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
      this._myVisualResources.myDefaultMaterials.myText = Globals.getDefaultMaterials(this.engine).myText.clone();
      this._myVisualResources.myDefaultMaterials.myRight = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
      this._myVisualResources.myDefaultMaterials.myRight.color = vec4_create(1, 0, 0, 1);
      this._myVisualResources.myDefaultMaterials.myUp = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
      this._myVisualResources.myDefaultMaterials.myUp.color = vec4_create(0, 1, 0, 1);
      this._myVisualResources.myDefaultMaterials.myForward = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
      this._myVisualResources.myDefaultMaterials.myForward.color = vec4_create(0, 0, 1, 1);
      this._myVisualResources.myDefaultMaterials.myRay = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
      this._myVisualResources.myDefaultMaterials.myRay.color = vec4_create(0, 1, 0, 1);
      this._myVisualResources.myDefaultMaterials.myHitNormal = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
      this._myVisualResources.myDefaultMaterials.myHitNormal.color = vec4_create(1, 0, 0, 1);
    }
    if (this.myVisualManager != null) {
      this.myVisualManager.start();
    }
  }
  update(dt) {
    if (this.myVisualManager != null) {
      this.myVisualManager.update(dt);
    }
  }
  onDestroy() {
    if (this._myVisualManager != null && Globals.getVisualManager(this.engine) == this._myVisualManager) {
      Globals.removeVisualManager(this.engine);
      this._myVisualManager.destroy();
    }
    if (this._myVisualResources != null && Globals.getVisualResources(this.engine) == this._myVisualResources) {
      Globals.removeVisualResources(this.engine);
    }
  }
};
__publicField(VisualManagerComponent, "TypeName", "pp-visual-manager");
__publicField(VisualManagerComponent, "Properties", {});

// js/pp/cauldron/wl/components/add_wl_to_window_component.js
var AddWLToWindowComponent = class extends Component {
  init() {
    if (this._myAdd) {
      Globals.getWindow(this.engine).WL = {};
      this._addProperties(dist_exports);
      this._addProperties(dist_exports2);
    }
  }
  _addProperties(object) {
    let propertyNames = Object.getOwnPropertyNames(object);
    for (let propertyName of propertyNames) {
      if (object[propertyName] != void 0) {
        Globals.getWindow(this.engine).WL[propertyName] = object[propertyName];
      }
    }
  }
  onDestroy() {
    Globals.getWindow(this.engine).WL = void 0;
  }
};
__publicField(AddWLToWindowComponent, "TypeName", "pp-add-wl-to-window");
__publicField(AddWLToWindowComponent, "Properties", {
  _myAdd: Property.bool(true)
});

// js/pp/debug/debug_visual_manager.js
var DebugVisualManager = class extends VisualManager {
  constructor(engine2) {
    super(engine2);
    this._myDefaultColor = vec4_create(1, 0, 1, 1);
    this._myDefaultLineThickness = 5e-3;
    this._myDefaultPointRadius = 0.01;
    this._myDefaultAxisLength = 0.2;
    this._myDefaultTextLookAtPlayer = true;
    this._myDefaultTextAlignment = Alignment.Center;
    this._myDefaultTextJustification = Justification.Middle;
    this._myDefaultUITextAlignment = Alignment.Center;
    this._myDefaultUITextJustification = Justification.Middle;
    this._myDefaultUITextScale = 1;
    this._myDefaultUITextScreenPosition = vec3_create(1, 1, 1);
  }
  drawLine(lifetimeSeconds, start, direction2, length10, color = this._myDefaultColor, thickness = this._myDefaultLineThickness) {
    if (this.isActive()) {
      let visualParams = new VisualLineParams(this._myEngine);
      visualParams.myStart.vec3_copy(start);
      visualParams.myDirection.vec3_copy(direction2);
      visualParams.myLength = length10;
      visualParams.myThickness = thickness;
      visualParams.myColor = vec4_create();
      visualParams.myColor.vec4_copy(color);
      this.draw(visualParams, lifetimeSeconds);
    }
  }
  drawLineEnd(lifetimeSeconds, start, end, color = this._myDefaultColor, thickness = this._myDefaultLineThickness) {
  }
  drawArrow(lifetimeSeconds, start, direction2, length10, color = this._myDefaultColor, thickness = this._myDefaultLineThickness) {
    if (this.isActive()) {
      let visualParams = new VisualArrowParams(this._myEngine);
      visualParams.myStart.vec3_copy(start);
      visualParams.myDirection.vec3_copy(direction2);
      visualParams.myLength = length10;
      visualParams.myThickness = thickness;
      visualParams.myColor = vec4_create();
      visualParams.myColor.vec4_copy(color);
      this.draw(visualParams, lifetimeSeconds);
    }
  }
  drawArrowEnd(lifetimeSeconds, start, end, color = this._myDefaultColor, thickness = this._myDefaultLineThickness) {
  }
  drawPoint(lifetimeSeconds, position, color = this._myDefaultColor, radius = this._myDefaultPointRadius) {
    if (this.isActive()) {
      let visualParams = new VisualPointParams(this._myEngine);
      visualParams.myPosition.vec3_copy(position);
      visualParams.myRadius = radius;
      visualParams.myColor = vec4_create();
      visualParams.myColor.vec4_copy(color);
      this.draw(visualParams, lifetimeSeconds);
    }
  }
  drawText(lifetimeSeconds, text, transform, color = this._myDefaultColor, lookAtPlayer = this._myDefaultTextLookAtPlayer, alignment = this._myDefaultTextAlignment, justification = this._myDefaultTextJustification) {
    if (this.isActive()) {
      let visualParams = new VisualTextParams(this._myEngine);
      visualParams.myText = text;
      visualParams.myAlignment = alignment;
      visualParams.myJustification = justification;
      visualParams.myTransform.mat4_copy(transform);
      visualParams.myColor = vec4_create();
      visualParams.myColor.vec4_copy(color);
      if (lookAtPlayer) {
        visualParams.myLookAtObject = Globals.getPlayerObjects(this._myEngine).myHead;
      }
      this.draw(visualParams, lifetimeSeconds);
    }
  }
  drawRaycast(lifetimeSeconds, raycastResult, showOnlyFirstHit = true, hitNormalLength = this._myDefaultAxisLength, thickness = this._myDefaultLineThickness) {
    if (this.isActive()) {
      let visualParams = new VisualRaycastParams(this._myEngine);
      visualParams.myRaycastResults = raycastResult;
      visualParams.myShowOnlyFirstHit = showOnlyFirstHit;
      visualParams.myHitNormalLength = hitNormalLength;
      visualParams.myThickness = thickness;
      this.draw(visualParams, lifetimeSeconds);
    }
  }
  drawTransform(lifetimeSeconds, transform, length10 = this._myDefaultAxisLength, thickness = this._myDefaultLineThickness) {
    if (this.isActive()) {
      let visualParams = new VisualTransformParams(this._myEngine);
      visualParams.myTransform.mat4_copy(transform);
      visualParams.myLength = length10;
      visualParams.myThickness = thickness;
      this.draw(visualParams, lifetimeSeconds);
    }
  }
  drawUIText(lifetimeSeconds, text, screenPosition, scale11 = this._myDefaultUITextScale, color = this._myDefaultColor, alignment = this._myDefaultUITextAlignment, justification = this._myDefaultUITextJustification) {
  }
  _getClassName() {
    return "debug_visual_manager";
  }
};
DebugVisualManager.prototype.drawLineEnd = function() {
  let direction2 = vec3_create();
  return function drawLineEnd(lifetimeSeconds, start, end, color = this._myDefaultColor, thickness = this._myDefaultLineThickness) {
    if (this.isActive()) {
      direction2 = end.vec3_sub(start, direction2);
      let length10 = direction2.vec3_length();
      direction2.vec3_normalize(direction2);
      this.drawLine(lifetimeSeconds, start, direction2, length10, color, thickness);
    }
  };
}();
DebugVisualManager.prototype.drawArrowEnd = function() {
  let direction2 = vec3_create();
  return function drawArrowEnd(lifetimeSeconds, start, end, color = this._myDefaultColor, thickness = this._myDefaultLineThickness) {
    if (this.isActive()) {
      direction2 = end.vec3_sub(start, direction2);
      let length10 = direction2.vec3_length();
      direction2.vec3_normalize(direction2);
      this.drawArrow(lifetimeSeconds, start, direction2, length10, color, thickness);
    }
  };
}();
DebugVisualManager.prototype.drawUIText = function() {
  let textRotationQuat = quat_create();
  let up = vec3_create(0, 1, 0);
  let lookToForward = vec3_create();
  let screenPositionNormalizedXR = vec3_create(-0.12 * 1, 0.12 * 1, 0.35);
  let screenPositionNormalizedNonXR = vec3_create(-0.27 * 1.15, 0.13 * 1.05, 0.35);
  let textPosition = vec3_create();
  let textRotation = vec3_create();
  let textScale = vec3_create();
  return function drawUIText(lifetimeSeconds, text, screenPosition = this._myDefaultUITextScreenPosition, scale11 = this._myDefaultUITextScale, color = this._myDefaultColor, alignment = this._myDefaultUITextAlignment, justification = this._myDefaultUITextJustification) {
    if (this.isActive()) {
      let visualParams = new VisualTextParams(this._myEngine);
      visualParams.myText = text;
      visualParams.myAlignment = alignment;
      visualParams.myJustification = justification;
      visualParams.myColor = vec4_create();
      visualParams.myColor.vec4_copy(color);
      let scaleNormalized = 0.2;
      if (XRUtils.isSessionActive(this._myEngine)) {
        visualParams.myTransform.mat4_setPositionRotationScale(
          screenPositionNormalizedXR.vec3_mul(screenPosition, textPosition),
          textRotation.vec3_set(0, 180, 0),
          textScale.vec3_set(scaleNormalized * scale11, scaleNormalized * scale11, scaleNormalized * scale11)
        );
        lookToForward = visualParams.myTransform.mat4_getPosition(lookToForward).vec3_negate(lookToForward).vec3_normalize(lookToForward);
        textRotationQuat = visualParams.myTransform.mat4_getRotationQuat(textRotationQuat);
        textRotationQuat.quat_setForward(lookToForward, up, textRotationQuat);
        visualParams.myTransform.mat4_setRotationQuat(textRotationQuat);
      } else {
        visualParams.myTransform.mat4_setPositionRotationScale(
          screenPositionNormalizedNonXR.vec3_mul(screenPosition, textPosition),
          textRotation.vec3_set(0, 180, 0),
          textScale.vec3_set(scaleNormalized * scale11, scaleNormalized * scale11, scaleNormalized * scale11)
        );
      }
      visualParams.myParent = Globals.getPlayerObjects(this._myEngine).myHeadDebugs;
      visualParams.myLocal = true;
      this.draw(visualParams, lifetimeSeconds);
    }
  };
}();

// js/pp/debug/debug_manager.js
var DebugManager = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this._myEngine = engine2;
    this._myDebugVisualManager = new DebugVisualManager(this._myEngine);
    this._myDestroyed = false;
  }
  getDebugVisualManager() {
    return this._myDebugVisualManager;
  }
  start() {
    this._myDebugVisualManager.start();
  }
  update(dt) {
    this._myDebugVisualManager.setActive(Globals.isDebugEnabled(this._myEngine));
    this._myDebugVisualManager.update(dt);
  }
  destroy() {
    this._myDestroyed = true;
    this._myDebugVisualManager.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/debug/components/debug_manager_component.js
var DebugManagerComponent = class extends Component {
  init() {
    this._myDebugManager = null;
    if (!Globals.hasDebugManager(this.engine)) {
      this._myDebugManager = new DebugManager(this.engine);
      Globals.setDebugManager(this._myDebugManager, this.engine);
    }
  }
  start() {
    if (this._myDebugManager != null) {
      this._myDebugManager.start();
    }
  }
  update(dt) {
    if (this._myDebugManager != null) {
      this._myDebugManager.update(dt);
    }
  }
  onDestroy() {
    if (this._myDebugManager != null && Globals.getDebugManager(this.engine) == this._myDebugManager) {
      Globals.removeDebugManager(this.engine);
      this._myDebugManager.destroy();
    }
  }
};
__publicField(DebugManagerComponent, "TypeName", "pp-debug-manager");
__publicField(DebugManagerComponent, "Properties", {});

// js/pp/debug/components/enable_debug_component.js
var EnableDebugComponent = class extends Component {
  init() {
    this._myDebugEnabled = null;
    if (!Globals.hasDebugEnabled(this.engine)) {
      this._myDebugEnabled = this._myEnable;
      Globals.setDebugEnabled(this._myDebugEnabled, this.engine);
    }
  }
  onDestroy() {
    if (this._myDebugEnabled != null && Globals.isDebugEnabled(this.engine) == this._myDebugEnabled) {
      Globals.removeDebugEnabled(this.engine);
    }
  }
};
__publicField(EnableDebugComponent, "TypeName", "pp-enable-debug");
__publicField(EnableDebugComponent, "Properties", {
  _myEnable: Property.bool(true)
});

// js/pp/input/gamepad/gamepad_buttons.js
var GamepadButtonID = {
  SELECT: 0,
  // Trigger
  SQUEEZE: 1,
  // Grip
  TOUCHPAD: 2,
  THUMBSTICK: 3,
  BOTTOM_BUTTON: 4,
  // A or X button on oculus quest gamepad
  TOP_BUTTON: 5,
  // B or Y button on oculus quest gamepad, reverts to TOUCHPAD button for gamepads that does not support TOP_BUTTON
  THUMB_REST: 6
};
var GamepadButtonEvent = {
  PRESS_START: 0,
  PRESS_END: 1,
  PRESSED: 2,
  // Every frame that it is pressed
  NOT_PRESSED: 3,
  // Every frame that it is not pressed
  TOUCH_START: 4,
  TOUCH_END: 5,
  TOUCHED: 6,
  // Every frame that it is touched
  NOT_TOUCHED: 7,
  // Every frame that it is not touched
  VALUE_CHANGED: 8,
  ALWAYS: 9
  // Every frame
};
var GamepadAxesID = {
  THUMBSTICK: 0
};
var GamepadAxesEvent = {
  X_CHANGED: 0,
  Y_CHANGED: 1,
  AXES_CHANGED: 2,
  ALWAYS: 3
};
var GamepadButtonInfo = class {
  constructor(id, handedness) {
    this.myID = id;
    this.myHandedness = handedness;
    this.myPressed = false;
    this.myPrevIsPressed = false;
    this.myTouched = false;
    this.myPrevIsTouched = false;
    this.myValue = 0;
    this.myPrevValue = 0;
    this.myTimePressed = 0;
    this.myPrevTimePressed = 0;
    this.myTimeNotPressed = 0;
    this.myPrevTimeNotPressed = 0;
    this.myTimeTouched = 0;
    this.myPrevTimeTouched = 0;
    this.myTimeNotTouched = 0;
    this.myPrevTimeNotTouched = 0;
    this.myMultiplePressStartCount = 0;
    this.myPrevMultiplePressStartCount = 0;
    this.myMultiplePressEndCount = 0;
    this.myPrevMultiplePressEndCount = 0;
    this.myMultipleTouchStartCount = 0;
    this.myPrevMultipleTouchStartCount = 0;
    this.myMultipleTouchEndCount = 0;
    this.myPrevMultipleTouchEndCount = 0;
  }
  getID() {
    return this.myID;
  }
  getHandedness() {
    return this.myHandedness;
  }
  getValue() {
    return this.myValue;
  }
  isPressed() {
    return this.myPressed;
  }
  isTouched() {
    return this.myTouched;
  }
  isPressStart(multiplePressCount = null) {
    return this.myPressed && !this.myPrevIsPressed && (multiplePressCount == null || this.myMultiplePressStartCount == multiplePressCount);
  }
  isPressEnd(multiplePressCount = null) {
    return !this.myPressed && this.myPrevIsPressed && (multiplePressCount == null || this.myMultiplePressEndCount == multiplePressCount);
  }
  isTouchStart(multipleTouchCount = null) {
    return this.myTouched && !this.myPrevIsTouched && (multipleTouchCount == null || this.myMultipleTouchStartCount == multipleTouchCount);
  }
  isTouchEnd(multipleTouchCount = null) {
    return !this.myTouched && this.myPrevIsTouched && (multipleTouchCount == null || this.myMultipleTouchEndCount == multipleTouchCount);
  }
  clone() {
    let value = new GamepadButtonInfo(this.myID, this.myHandedness);
    value.myPressed = this.myPressed;
    value.myPrevIsPressed = this.myPrevIsPressed;
    value.myTouched = this.myTouched;
    value.myPrevIsTouched = this.myPrevIsTouched;
    value.myValue = this.myValue;
    value.myPrevValue = this.myPrevValue;
    value.myTimePressed = this.myTimePressed;
    value.myPrevTimePressed = this.myPrevTimePressed;
    value.myTimeNotPressed = this.myTimeNotPressed;
    value.myPrevTimeNotPressed = this.myPrevTimeNotPressed;
    value.myTimeTouched = this.myTimeTouched;
    value.myPrevTimeTouched = this.myPrevTimeTouched;
    value.myTimeNotTouched = this.myTimeNotTouched;
    value.myPrevTimeNotTouched = this.myPrevTimeNotTouched;
    value.myMultiplePressStartCount = this.myMultiplePressStartCount;
    value.myPrevMultiplePressStartCount = this.myPrevMultiplePressStartCount;
    value.myMultiplePressEndCount = this.myMultiplePressEndCount;
    value.myPrevMultiplePressEndCount = this.myPrevMultiplePressEndCount;
    value.myMultipleTouchStartCount = this.myMultipleTouchStartCount;
    value.myPrevMultipleTouchStartCount = this.myPrevMultipleTouchStartCount;
    value.myMultipleTouchEndCount = this.myMultipleTouchEndCount;
    value.myPrevMultipleTouchEndCount = this.myPrevMultipleTouchEndCount;
    return value;
  }
};
var GamepadAxesInfo = class {
  constructor(id, handedness) {
    this.myID = id;
    this.myHandedness = handedness;
    this.myAxes = vec2_create(0, 0);
    this.myPrevAxes = vec2_create(0, 0);
  }
  getID() {
    return this.myID;
  }
  getAxes() {
    return this.myAxes;
  }
  getHandedness() {
    return this.myHandedness;
  }
  clone() {
    let value = new GamepadAxesInfo(this.myID, this.myHandedness);
    value.myAxes.vec2_copy(this.myAxes);
    value.myPrevAxes.vec2_copy(this.myPrevAxes);
    return value;
  }
};
var GamepadPulseInfo = class {
  constructor() {
    this.myIntensity = 0;
    this.myDuration = 0;
    this.myDevicePulsing = false;
  }
  clone() {
    let value = new GamepadPulseInfo();
    value.myIntensity = this.myIntensity;
    value.myDuration = this.myDuration;
    value.myDevicePulsing = this.myDevicePulsing;
    return value;
  }
};

// js/pp/input/gamepad/gamepad_cores/gamepad_core.js
var GamepadCore = class {
  constructor(handPose) {
    this._myHandPose = handPose;
    this._myManagingHandPose = false;
    this._myDestroyed = false;
  }
  getHandedness() {
    return this.getHandPose().getHandedness();
  }
  getHandPose() {
    return this._myHandPose;
  }
  getEngine() {
    return this.getHandPose().getEngine();
  }
  isGamepadCoreActive() {
    return true;
  }
  setManageHandPose(manageHandPose) {
    this._myManagingHandPose = manageHandPose;
  }
  isManagingHandPose() {
    return this._myManagingHandPose;
  }
  start() {
    if (this.getHandPose() && this.isManagingHandPose()) {
      this.getHandPose().start();
    }
    this._startHook();
  }
  preUpdate(dt) {
    if (this.getHandPose() && this.isManagingHandPose()) {
      this.getHandPose().update(dt);
    }
    this._preUpdateHook(dt);
  }
  postUpdate(dt) {
    this._postUpdateHook(dt);
  }
  getButtonData(buttonID) {
    let buttonData = this._createButtonData();
    return buttonData;
  }
  getAxesData(axesID) {
    let axesData = this._createAxesData();
    return axesData;
  }
  getHapticActuators() {
    let hapticActuators = [];
    return hapticActuators;
  }
  // Hooks
  _startHook() {
  }
  _preUpdateHook(dt) {
  }
  _postUpdateHook(dt) {
  }
  _destroyHook() {
  }
  // Hooks end
  _createButtonData() {
    return { myPressed: false, myTouched: false, myValue: 0 };
  }
  _createAxesData() {
    return vec2_create(0, 0);
  }
  destroy() {
    this._myDestroyed = true;
    this._destroyHook();
    if (this.isManagingHandPose()) {
      this.getHandPose().destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/input/gamepad/gamepad_cores/classic_gamepad_core.js
var ClassicGamepadCore = class extends GamepadCore {
  constructor(gamepadIndex, handPose) {
    super(handPose);
    this._myGamepadIndex = gamepadIndex;
    this._myCurrentGamepads = window.navigator.getGamepads();
    this._myButtonData = this._createButtonData();
    this._myAxesData = this._createAxesData();
    this._myHapticActuators = [];
  }
  _preUpdateHook(dt) {
    this._myCurrentGamepads = window.navigator.getGamepads();
  }
  isGamepadCoreActive() {
    let classicGamepad = this._getClassicGamepad();
    return classicGamepad != null && (classicGamepad.connected == null || classicGamepad.connected);
  }
  getButtonData(buttonID) {
    this._myButtonData.myPressed = false;
    this._myButtonData.myTouched = false;
    this._myButtonData.myValue = 0;
    let classicGamepad = this._getClassicGamepad();
    if (classicGamepad != null && this.isGamepadCoreActive()) {
      let button = null;
      if (this.getHandedness() == Handedness.LEFT) {
        switch (buttonID) {
          case GamepadButtonID.SELECT:
            button = classicGamepad.buttons[4];
            break;
          case GamepadButtonID.SQUEEZE:
            button = classicGamepad.buttons[6];
            break;
          case GamepadButtonID.TOUCHPAD:
            button = null;
            break;
          case GamepadButtonID.THUMBSTICK:
            button = classicGamepad.buttons[10];
            break;
          case GamepadButtonID.BOTTOM_BUTTON:
            button = classicGamepad.buttons[13];
            break;
          case GamepadButtonID.TOP_BUTTON:
            button = classicGamepad.buttons[12];
            break;
          case GamepadButtonID.THUMB_REST:
            button = null;
            break;
        }
      } else {
        switch (buttonID) {
          case GamepadButtonID.SELECT:
            button = classicGamepad.buttons[5];
            break;
          case GamepadButtonID.SQUEEZE:
            button = classicGamepad.buttons[7];
            break;
          case GamepadButtonID.TOUCHPAD:
            button = null;
            break;
          case GamepadButtonID.THUMBSTICK:
            button = classicGamepad.buttons[11];
            break;
          case GamepadButtonID.BOTTOM_BUTTON:
            button = classicGamepad.buttons[0];
            break;
          case GamepadButtonID.TOP_BUTTON:
            button = classicGamepad.buttons[3];
            break;
          case GamepadButtonID.THUMB_REST:
            button = null;
            break;
        }
      }
      if (button != null) {
        this._myButtonData.myPressed = button.pressed;
        this._myButtonData.myTouched = button.touched;
        this._myButtonData.myValue = button.value;
      }
    }
    return this._myButtonData;
  }
  getAxesData(axesID) {
    this._myAxesData.vec2_zero();
    let classicGamepad = this._getClassicGamepad();
    if (classicGamepad != null && this.isGamepadCoreActive()) {
      if (this.getHandedness() == Handedness.LEFT) {
        this._myAxesData[0] = classicGamepad.axes[0];
        this._myAxesData[1] = classicGamepad.axes[1];
      } else {
        this._myAxesData[0] = classicGamepad.axes[2];
        this._myAxesData[1] = classicGamepad.axes[3];
      }
      this._myAxesData[1] = -this._myAxesData[1];
    }
    return this._myAxesData;
  }
  getHapticActuators() {
    this._myHapticActuators.pp_clear();
    let classicGamepad = this._getClassicGamepad();
    if (classicGamepad != null && this.isGamepadCoreActive()) {
      if (classicGamepad.hapticActuators != null) {
        for (let i = 0; i < classicGamepad.hapticActuators.length; i++) {
          this._myHapticActuators.push(classicGamepad.hapticActuators[i]);
        }
      }
      if (classicGamepad.vibrationActuator != null) {
        this._myHapticActuators.push(classicGamepad.vibrationActuator);
      }
    }
    return this._myHapticActuators;
  }
  _getClassicGamepad() {
    let classicGamepad = null;
    if (this._myGamepadIndex != null) {
      if (this._myGamepadIndex < this._myCurrentGamepads.length) {
        classicGamepad = this._myCurrentGamepads[this._myGamepadIndex];
      }
    } else {
      for (let i = 0; i < this._myCurrentGamepads.length; i++) {
        let gamepad = this._myCurrentGamepads[i];
        if (gamepad != null && (gamepad.connected == null || gamepad.connected)) {
          classicGamepad = gamepad;
          break;
        }
      }
    }
    return classicGamepad;
  }
};

// js/pp/input/cauldron/keyboard.js
var KeyID = {
  _0: "0",
  _1: "1",
  _2: "2",
  _3: "3",
  _4: "4",
  _5: "5",
  _6: "6",
  _7: "7",
  _8: "8",
  _9: "9",
  A: "A",
  B: "B",
  C: "C",
  D: "D",
  E: "E",
  F: "F",
  G: "G",
  H: "H",
  I: "I",
  J: "J",
  K: "K",
  L: "L",
  M: "M",
  N: "N",
  O: "O",
  P: "P",
  Q: "Q",
  R: "R",
  S: "S",
  T: "T",
  U: "U",
  V: "V",
  W: "W",
  X: "X",
  Y: "Y",
  Z: "Z",
  a: "a",
  b: "b",
  c: "c",
  d: "d",
  e: "e",
  f: "f",
  g: "g",
  h: "h",
  i: "i",
  j: "j",
  k: "k",
  l: "l",
  m: "m",
  n: "n",
  o: "o",
  p: "p",
  q: "q",
  r: "r",
  s: "s",
  t: "t",
  u: "u",
  v: "v",
  w: "w",
  x: "x",
  y: "y",
  z: "z",
  UP: "ArrowUp",
  DOWN: "ArrowDown",
  LEFT: "ArrowLeft",
  RIGHT: "ArrowRight",
  SPACE: " ",
  ENTER: "Enter",
  BACKSPACE: "Backspace",
  ESC: "Escape",
  SHIFT_LEFT: "ShiftLeft",
  SHIFT_RIGHT: "ShiftRight",
  CONTROL_LEFT: "ControlLeft",
  CONTROL_RIGHT: "ControlRight",
  ALT_LEFT: "AltLeft",
  ALT_RIGHT: "AltRight"
};
var Keyboard = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this._myEngine = engine2;
    this._myKeyInfos = {};
    this._myKeyInfosIDs = [];
    for (let key in KeyID) {
      this.addKey(KeyID[key]);
    }
    this._myOnKeyDownEventListener = null;
    this._myOnKeyUpEventListener = null;
    this._myDestroyed = false;
  }
  isKeyPressed(keyID) {
    let pressed = false;
    if (this._myKeyInfos[keyID] != null) {
      pressed = this._myKeyInfos[keyID].myPressed;
    }
    return pressed;
  }
  isKeyPressStart(keyID) {
    let pressStart = false;
    if (this._myKeyInfos[keyID] != null) {
      pressStart = this._myKeyInfos[keyID].myPressStart;
    }
    return pressStart;
  }
  isKeyPressEnd(keyID) {
    let pressEnd = false;
    if (this._myKeyInfos[keyID] != null) {
      pressEnd = this._myKeyInfos[keyID].myPressEnd;
    }
    return pressEnd;
  }
  addKey(keyID) {
    this._myKeyInfos[keyID] = this._createKeyInfo();
    this._myKeyInfosIDs.push(keyID);
  }
  start() {
    this._myOnKeyDownEventListener = this._keyDown.bind(this);
    Globals.getWindow(this._myEngine).addEventListener("keydown", this._myOnKeyDownEventListener);
    this._myOnKeyUpEventListener = this._keyUp.bind(this);
    Globals.getWindow(this._myEngine).addEventListener("keyup", this._myOnKeyUpEventListener);
  }
  update(dt) {
    if (!Globals.getDocument(this._myEngine).hasFocus()) {
      for (let i = 0; i < this._myKeyInfosIDs.length; i++) {
        let id = this._myKeyInfosIDs[i];
        let keyInfo = this._myKeyInfos[id];
        if (keyInfo.myPressed) {
          keyInfo.myPressed = false;
          keyInfo.myPressEndToProcess = true;
        }
      }
    }
    for (let i = 0; i < this._myKeyInfosIDs.length; i++) {
      let id = this._myKeyInfosIDs[i];
      let keyInfo = this._myKeyInfos[id];
      keyInfo.myPressStart = keyInfo.myPressStartToProcess;
      keyInfo.myPressEnd = keyInfo.myPressEndToProcess;
      keyInfo.myPressStartToProcess = false;
      keyInfo.myPressEndToProcess = false;
    }
  }
  _keyDown(event) {
    this._keyPressedChanged(event.key, true);
    if (event.key != event.code) {
      this._keyPressedChanged(event.code, true);
    }
  }
  _keyUp(event) {
    this._keyPressedChanged(event.key, false);
    if (event.key != event.code) {
      this._keyPressedChanged(event.code, false);
    }
  }
  _keyPressedChanged(keyID, pressed) {
    if (this._myKeyInfos[keyID] != null) {
      let keyInfo = this._myKeyInfos[keyID];
      if (pressed) {
        keyInfo.myPressed = true;
        keyInfo.myPressStartToProcess = true;
      } else {
        keyInfo.myPressed = false;
        keyInfo.myPressEndToProcess = true;
      }
    }
  }
  _createKeyInfo() {
    return { myPressed: false, myPressStart: false, myPressStartToProcess: false, myPressEnd: false, myPressEndToProcess: false };
  }
  destroy() {
    this._myDestroyed = true;
    Globals.getWindow(this._myEngine).removeEventListener("keydown", this._myOnKeyDownEventListener);
    Globals.getWindow(this._myEngine).removeEventListener("keyup", this._myOnKeyUpEventListener);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/input/gamepad/gamepad_cores/keyboard_gamepad_core.js
var KeyboardGamepadCore = class extends GamepadCore {
  constructor(handPose) {
    super(handPose);
    this._myButtonData = this._createButtonData();
    this._myAxesData = this._createAxesData();
    this._myHapticActuators = [];
  }
  isGamepadCoreActive() {
    return true;
  }
  getButtonData(buttonID) {
    this._myButtonData.myPressed = false;
    this._myButtonData.myTouched = false;
    this._myButtonData.myValue = 0;
    let keyboard = Globals.getKeyboard(this.getEngine());
    if (this.isGamepadCoreActive()) {
      if (this.getHandedness() == Handedness.LEFT) {
        switch (buttonID) {
          case GamepadButtonID.SELECT:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.E) || keyboard.isKeyPressed(KeyID.e);
            break;
          case GamepadButtonID.SQUEEZE:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.Q) || keyboard.isKeyPressed(KeyID.q);
            break;
          case GamepadButtonID.TOUCHPAD:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.X) || keyboard.isKeyPressed(KeyID.x);
            break;
          case GamepadButtonID.THUMBSTICK:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.R) || keyboard.isKeyPressed(KeyID.r);
            break;
          case GamepadButtonID.BOTTOM_BUTTON:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.C) || keyboard.isKeyPressed(KeyID.c);
            break;
          case GamepadButtonID.TOP_BUTTON:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.F) || keyboard.isKeyPressed(KeyID.f);
            break;
          case GamepadButtonID.THUMB_REST:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.V) || keyboard.isKeyPressed(KeyID.v);
            break;
        }
      } else {
        switch (buttonID) {
          case GamepadButtonID.SELECT:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.U) || keyboard.isKeyPressed(KeyID.u);
            break;
          case GamepadButtonID.SQUEEZE:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.O) || keyboard.isKeyPressed(KeyID.o);
            break;
          case GamepadButtonID.TOUCHPAD:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.M) || keyboard.isKeyPressed(KeyID.m);
            break;
          case GamepadButtonID.THUMBSTICK:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.Y) || keyboard.isKeyPressed(KeyID.y);
            break;
          case GamepadButtonID.BOTTOM_BUTTON:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.N) || keyboard.isKeyPressed(KeyID.n);
            break;
          case GamepadButtonID.TOP_BUTTON:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.H) || keyboard.isKeyPressed(KeyID.h);
            break;
          case GamepadButtonID.THUMB_REST:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.B) || keyboard.isKeyPressed(KeyID.b);
            break;
        }
      }
    }
    if (this._myButtonData.myPressed) {
      this._myButtonData.myTouched = true;
      this._myButtonData.myValue = 1;
    }
    return this._myButtonData;
  }
  getAxesData(axesID) {
    this._myAxesData.vec2_zero();
    let keyboard = Globals.getKeyboard(this.getEngine());
    if (this.isGamepadCoreActive()) {
      if (this.getHandedness() == Handedness.LEFT) {
        if (keyboard.isKeyPressed(KeyID.W) || keyboard.isKeyPressed(KeyID.w))
          this._myAxesData[1] += 1;
        if (keyboard.isKeyPressed(KeyID.S) || keyboard.isKeyPressed(KeyID.s))
          this._myAxesData[1] += -1;
        if (keyboard.isKeyPressed(KeyID.D) || keyboard.isKeyPressed(KeyID.d))
          this._myAxesData[0] += 1;
        if (keyboard.isKeyPressed(KeyID.A) || keyboard.isKeyPressed(KeyID.a))
          this._myAxesData[0] += -1;
      } else {
        if (keyboard.isKeyPressed(KeyID.I) || keyboard.isKeyPressed(KeyID.i) || keyboard.isKeyPressed(KeyID.UP))
          this._myAxesData[1] += 1;
        if (keyboard.isKeyPressed(KeyID.K) || keyboard.isKeyPressed(KeyID.k) || keyboard.isKeyPressed(KeyID.DOWN))
          this._myAxesData[1] += -1;
        if (keyboard.isKeyPressed(KeyID.L) || keyboard.isKeyPressed(KeyID.l) || keyboard.isKeyPressed(KeyID.RIGHT))
          this._myAxesData[0] += 1;
        if (keyboard.isKeyPressed(KeyID.J) || keyboard.isKeyPressed(KeyID.j) || keyboard.isKeyPressed(KeyID.LEFT))
          this._myAxesData[0] += -1;
      }
    }
    return this._myAxesData;
  }
  getHapticActuators() {
    return this._myHapticActuators;
  }
};

// js/pp/input/gamepad/gamepad_cores/xr_gamepad_core.js
var XRGamepadCore = class extends GamepadCore {
  constructor(handPose) {
    super(handPose);
    this._mySelectPressed = false;
    this._mySqueezePressed = false;
    this._myXRSessionActive = false;
    this._myInputSource = null;
    this._myGamepad = null;
    this._mySelectStartEventListener = null;
    this._mySelectEndEventListener = null;
    this._mySqueezeStartEventListener = null;
    this._mySqueezeEndEventListener = null;
    this._myButtonData = this._createButtonData();
    this._myAxesData = this._createAxesData();
    this._myHapticActuators = [];
  }
  isGamepadCoreActive() {
    return this._myXRSessionActive && this._myGamepad != null && (this._myGamepad.connected == null || this._myGamepad.connected);
  }
  _startHook() {
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this.getEngine());
  }
  _preUpdateHook(dt) {
    this._myInputSource = this.getHandPose().getInputSource();
    if (this._myInputSource != null) {
      this._myGamepad = this._myInputSource.gamepad;
    } else {
      this._myGamepad = null;
    }
  }
  getButtonData(buttonID) {
    this._myButtonData.myPressed = false;
    this._myButtonData.myTouched = false;
    this._myButtonData.myValue = 0;
    if (this.isGamepadCoreActive()) {
      if (buttonID < this._myGamepad.buttons.length) {
        let gamepadButton = this._myGamepad.buttons[buttonID];
        if (buttonID != GamepadButtonID.SELECT && buttonID != GamepadButtonID.SQUEEZE) {
          this._myButtonData.myPressed = gamepadButton.pressed;
        } else {
          this._myButtonData.myPressed = this._getSpecialButtonPressed(buttonID);
        }
        this._myButtonData.myTouched = gamepadButton.touched;
        this._myButtonData.myValue = gamepadButton.value;
      } else if (buttonID == GamepadButtonID.TOP_BUTTON && this._myGamepad.buttons.length >= 3) {
        let touchButton = this._myGamepad.buttons[2];
        this._myButtonData.myPressed = touchButton.pressed;
        this._myButtonData.myTouched = touchButton.touched;
        this._myButtonData.myValue = touchButton.value;
      }
    }
    return this._myButtonData;
  }
  getAxesData(axesID) {
    this._myAxesData.vec2_zero();
    if (this.isGamepadCoreActive()) {
      let internalAxes = this._myGamepad.axes;
      if (internalAxes.length == 4) {
        if (Math.abs(internalAxes[0]) > Math.abs(internalAxes[2])) {
          this._myAxesData[0] = internalAxes[0];
        } else {
          this._myAxesData[0] = internalAxes[2];
        }
        if (Math.abs(internalAxes[1]) > Math.abs(internalAxes[3])) {
          this._myAxesData[1] = internalAxes[1];
        } else {
          this._myAxesData[1] = internalAxes[3];
        }
      } else if (internalAxes.length == 2) {
        this._myAxesData[0] = internalAxes[0];
        this._myAxesData[1] = internalAxes[1];
      }
      this._myAxesData[1] = -this._myAxesData[1];
    }
    return this._myAxesData;
  }
  getHapticActuators() {
    this._myHapticActuators.pp_clear();
    if (this.isGamepadCoreActive()) {
      if (this._myGamepad.hapticActuators != null) {
        for (let i = 0; i < this._myGamepad.hapticActuators.length; i++) {
          this._myHapticActuators.push(this._myGamepad.hapticActuators[i]);
        }
      }
      if (this._myGamepad.vibrationActuator != null) {
        this._myHapticActuators.push(this._myGamepad.vibrationActuator);
      }
    }
    return this._myHapticActuators;
  }
  // This is to be more compatible
  _getSpecialButtonPressed(buttonID) {
    let pressed = false;
    if (this.isGamepadCoreActive()) {
      if (buttonID == GamepadButtonID.SELECT) {
        pressed = this._mySelectPressed;
      } else if (buttonID == GamepadButtonID.SQUEEZE) {
        pressed = this._mySqueezePressed;
      }
    }
    return pressed;
  }
  _onXRSessionStart(session) {
    this._mySelectStartEventListener = this._selectStart.bind(this);
    this._mySelectEndEventListener = this._selectEnd.bind(this);
    this._mySqueezeStartEventListener = this._squeezeStart.bind(this);
    this._mySqueezeEndEventListener = this._squeezeEnd.bind(this);
    session.addEventListener("selectstart", this._mySelectStartEventListener);
    session.addEventListener("selectend", this._mySelectEndEventListener);
    session.addEventListener("squeezestart", this._mySqueezeStartEventListener);
    session.addEventListener("squeezeend", this._mySqueezeEndEventListener);
    this._myXRSessionActive = true;
  }
  _onXRSessionEnd(session) {
    this._mySelectStartEventListener = null;
    this._mySelectEndEventListener = null;
    this._mySqueezeStartEventListener = null;
    this._mySqueezeEndEventListener = null;
    this._myXRSessionActive = false;
  }
  // Select and Squeeze are managed this way to be more compatible
  _selectStart(event) {
    if (this._myInputSource != null && this._myInputSource == event.inputSource) {
      this._mySelectPressed = true;
    }
  }
  _selectEnd(event) {
    if (this._myInputSource != null && this._myInputSource == event.inputSource) {
      this._mySelectPressed = false;
    }
  }
  _squeezeStart(event) {
    if (this._myInputSource != null && this._myInputSource == event.inputSource) {
      this._mySqueezePressed = true;
    }
  }
  _squeezeEnd(event) {
    if (this._myInputSource != null && this._myInputSource == event.inputSource) {
      this._mySqueezePressed = false;
    }
  }
  _destroyHook() {
    XRUtils.getSession(this.getEngine())?.removeEventListener("selectstart", this._mySelectStartEventListener);
    XRUtils.getSession(this.getEngine())?.removeEventListener("selectend", this._mySelectEndEventListener);
    XRUtils.getSession(this.getEngine())?.removeEventListener("squeezestart", this._mySqueezeStartEventListener);
    XRUtils.getSession(this.getEngine())?.removeEventListener("squeezeend", this._mySqueezeEndEventListener);
    XRUtils.unregisterSessionStartEndEventListeners(this, this.getEngine());
  }
};

// js/pp/input/gamepad/base_gamepad.js
var BaseGamepad = class {
  constructor(handedness) {
    this._myHandedness = handedness;
    this._myButtonInfos = {};
    this._myButtonInfosIDs = [];
    for (let key in GamepadButtonID) {
      this._myButtonInfos[GamepadButtonID[key]] = new GamepadButtonInfo(GamepadButtonID[key], this._myHandedness);
      this._myButtonInfosIDs.push(GamepadButtonID[key]);
    }
    this._myAxesInfos = {};
    this._myAxesInfosIDs = [];
    for (let key in GamepadAxesID) {
      this._myAxesInfos[GamepadAxesID[key]] = new GamepadAxesInfo(GamepadAxesID[key], this._myHandedness);
      this._myAxesInfosIDs.push(GamepadAxesID[key]);
    }
    this._myButtonEmitters = [];
    for (let key in GamepadButtonID) {
      this._myButtonEmitters[GamepadButtonID[key]] = [];
      for (let eventKey in GamepadButtonEvent) {
        this._myButtonEmitters[GamepadButtonID[key]][GamepadButtonEvent[eventKey]] = new Emitter();
      }
    }
    this._myAxesEmitters = [];
    for (let key in GamepadAxesID) {
      this._myAxesEmitters[GamepadAxesID[key]] = [];
      for (let eventKey in GamepadAxesEvent) {
        this._myAxesEmitters[GamepadAxesID[key]][GamepadAxesEvent[eventKey]] = new Emitter();
      }
    }
    this._myPulseInfo = new GamepadPulseInfo();
    this._myDestroyed = false;
    this._myMultiplePressMaxDelay = 0.4;
    this._myMultipleTouchMaxDelay = 0.4;
  }
  getHandedness() {
    return this._myHandedness;
  }
  getButtonInfo(buttonID) {
    return this._myButtonInfos[buttonID];
  }
  registerButtonEventListener(buttonID, buttonEvent, id, listener) {
    this._myButtonEmitters[buttonID][buttonEvent].add(listener, { id });
  }
  unregisterButtonEventListener(buttonID, buttonEvent, id) {
    this._myButtonEmitters[buttonID][buttonEvent].remove(id);
  }
  getAxesInfo(axesID) {
    return this._myAxesInfos[axesID];
  }
  registerAxesEventListener(axesID, axesEvent, id, listener) {
    this._myAxesEmitters[axesID][axesEvent].add(listener, { id });
  }
  unregisterAxesEventListener(axesID, axesEvent, id) {
    this._myAxesEmitters[axesID][axesEvent].remove(id);
  }
  pulse(intensity, duration = 0) {
    this._myPulseInfo.myIntensity = Math.pp_clamp(intensity, 0, 1);
    this._myPulseInfo.myDuration = Math.max(duration, 0);
  }
  stopPulse() {
    this._myPulseInfo.myIntensity = 0;
    this._myPulseInfo.myDuration = 0;
  }
  isPulsing() {
    return this._myPulseInfo.myIntensity > 0 || this._myPulseInfo.myDuration > 0;
  }
  getPulseInfo() {
    return this._myPulseInfo;
  }
  getMultiplePressMaxDelay() {
    return this._myMultiplePressMaxDelay;
  }
  setMultiplePressMaxDelay(maxDelay) {
    this._myMultiplePressMaxDelay = maxDelay;
  }
  getMultipleTouchMaxDelay() {
    return this._myMultipleTouchMaxDelay;
  }
  setMultipleTouchMaxDelay(maxDelay) {
    this._myMultipleTouchMaxDelay = maxDelay;
  }
  // Hooks
  getHandPose() {
    return null;
  }
  _startHook() {
  }
  _preUpdate(dt) {
  }
  _postUpdate(dt) {
  }
  _getButtonData(buttonID) {
    let buttonData = this._createButtonData();
    return buttonData;
  }
  _getAxesData(axesID) {
    let axesData = this._createAxesData();
    return axesData;
  }
  _getHapticActuators() {
    let hapticActuator = [];
    return hapticActuator;
  }
  _destroyHook() {
  }
  // Hooks End
  start() {
    this._startHook();
  }
  update(dt) {
    this._preUpdate(dt);
    this._preUpdateButtonInfos();
    this._updateButtonInfos();
    this._postUpdateButtonInfos(dt);
    this._preUpdateAxesInfos();
    this._updateAxesInfos();
    this._postUpdateAxesInfos();
    this._updatePulse(dt);
    this._postUpdate(dt);
  }
  _preUpdateButtonInfos() {
    for (let i = 0; i < this._myButtonInfosIDs.length; i++) {
      let id = this._myButtonInfosIDs[i];
      let info2 = this._myButtonInfos[id];
      info2.myPrevIsPressed = info2.myPressed;
      info2.myPrevIsTouched = info2.myTouched;
      info2.myPrevValue = info2.myValue;
    }
  }
  _updateButtonInfos() {
    this._updateSingleButtonInfo(GamepadButtonID.SELECT);
    this._updateSingleButtonInfo(GamepadButtonID.SQUEEZE);
    this._updateSingleButtonInfo(GamepadButtonID.TOUCHPAD);
    this._updateSingleButtonInfo(GamepadButtonID.THUMBSTICK);
    this._updateSingleButtonInfo(GamepadButtonID.BOTTOM_BUTTON);
    this._updateSingleButtonInfo(GamepadButtonID.TOP_BUTTON);
    this._updateSingleButtonInfo(GamepadButtonID.THUMB_REST);
  }
  _updateSingleButtonInfo(buttonID) {
    let buttonInfo = this._myButtonInfos[buttonID];
    let buttonData = this._getButtonData(buttonID);
    buttonInfo.myPressed = buttonData.myPressed;
    buttonInfo.myTouched = buttonData.myTouched;
    buttonInfo.myValue = buttonData.myValue;
  }
  _postUpdateButtonInfos(dt) {
    for (let i = 0; i < this._myButtonInfosIDs.length; i++) {
      let id = this._myButtonInfosIDs[i];
      let info2 = this._myButtonInfos[id];
      if (info2.myPressed) {
        info2.myTimePressed += dt;
        if (!info2.myPrevIsPressed) {
          info2.myMultiplePressStartCount += 1;
          info2.myPrevTimeNotPressed = info2.myTimeNotPressed;
          info2.myTimeNotPressed = 0;
        }
        if (info2.myPrevTimeNotPressed + info2.myTimePressed > this._myMultiplePressMaxDelay && info2.myMultiplePressEndCount > 0) {
          info2.myPrevMultiplePressEndCount = info2.myMultiplePressEndCount;
          info2.myMultiplePressEndCount = 0;
        }
        if (info2.myTimePressed > this._myMultiplePressMaxDelay && info2.myMultiplePressStartCount > 0) {
          info2.myPrevMultiplePressStartCount = info2.myMultiplePressStartCount;
          info2.myMultiplePressStartCount = 0;
        }
      } else {
        info2.myTimeNotPressed += dt;
        if (info2.myPrevIsPressed) {
          info2.myMultiplePressEndCount += 1;
          info2.myPrevTimePressed = info2.myTimePressed;
          info2.myTimePressed = 0;
        }
        if (info2.myPrevTimePressed + info2.myTimeNotPressed > this._myMultiplePressMaxDelay && info2.myMultiplePressStartCount > 0) {
          info2.myPrevMultiplePressStartCount = info2.myMultiplePressStartCount;
          info2.myMultiplePressStartCount = 0;
        }
        if (info2.myTimeNotPressed > this._myMultiplePressMaxDelay && info2.myMultiplePressEndCount > 0) {
          info2.myPrevMultiplePressEndCount = info2.myMultiplePressEndCount;
          info2.myMultiplePressEndCount = 0;
        }
      }
      if (info2.myTouched) {
        info2.myTimeTouched += dt;
        if (!info2.myPrevIsTouched) {
          info2.myMultipleTouchStartCount += 1;
          info2.myPrevTimeNotTouched = info2.myTimeNotTouched;
          info2.myTimeNotTouched = 0;
        }
        if (info2.myPrevTimeNotTouched + info2.myTimeTouched > this._myMultipleTouchMaxDelay && info2.myMultipleTouchEndCount > 0) {
          info2.myPrevMultipleTouchEndCount = info2.myMultipleTouchEndCount;
          info2.myMultipleTouchEndCount = 0;
        }
        if (info2.myTimeTouched > this._myMultipleTouchMaxDelay && info2.myMultipleTouchStartCount > 0) {
          info2.myPrevMultipleTouchStartCount = info2.myMultipleTouchStartCount;
          info2.myMultipleTouchStartCount = 0;
        }
      } else {
        info2.myTimeNotTouched += dt;
        if (info2.myPrevIsTouched) {
          info2.myMultipleTouchEndCount += 1;
          info2.myPrevTimeTouched = info2.myTimeTouched;
          info2.myTimeTouched = 0;
        }
        if (info2.myPrevTimeTouched + info2.myTimeNotTouched > this._myMultipleTouchMaxDelay && info2.myMultipleTouchStartCount > 0) {
          info2.myPrevMultipleTouchStartCount = info2.myMultipleTouchStartCount;
          info2.myMultipleTouchStartCount = 0;
        }
        if (info2.myTimeNotTouched > this._myMultipleTouchMaxDelay && info2.myMultipleTouchEndCount > 0) {
          info2.myPrevMultipleTouchEndCount = info2.myMultipleTouchEndCount;
          info2.myMultipleTouchEndCount = 0;
        }
      }
    }
    for (let i = 0; i < this._myButtonInfosIDs.length; i++) {
      let id = this._myButtonInfosIDs[i];
      let buttonInfo = this._myButtonInfos[id];
      let buttonEventEmitters = this._myButtonEmitters[id];
      if (buttonInfo.myPressed && !buttonInfo.myPrevIsPressed) {
        let emitter2 = buttonEventEmitters[GamepadButtonEvent.PRESS_START];
        emitter2.notify(buttonInfo, this);
      }
      if (!buttonInfo.myPressed && buttonInfo.myPrevIsPressed) {
        let emitter2 = buttonEventEmitters[GamepadButtonEvent.PRESS_END];
        emitter2.notify(buttonInfo, this);
      }
      if (buttonInfo.myPressed) {
        let emitter2 = buttonEventEmitters[GamepadButtonEvent.PRESSED];
        emitter2.notify(buttonInfo, this);
      } else {
        let emitter2 = buttonEventEmitters[GamepadButtonEvent.NOT_PRESSED];
        emitter2.notify(buttonInfo, this);
      }
      if (buttonInfo.myTouched && !buttonInfo.myPrevIsTouched) {
        let emitter2 = buttonEventEmitters[GamepadButtonEvent.TOUCH_START];
        emitter2.notify(buttonInfo, this);
      }
      if (!buttonInfo.myTouched && buttonInfo.myPrevIsTouched) {
        let emitter2 = buttonEventEmitters[GamepadButtonEvent.TOUCH_END];
        emitter2.notify(buttonInfo, this);
      }
      if (buttonInfo.myTouched) {
        let emitter2 = buttonEventEmitters[GamepadButtonEvent.TOUCHED];
        emitter2.notify(buttonInfo, this);
      } else {
        let emitter2 = buttonEventEmitters[GamepadButtonEvent.NOT_TOUCHED];
        emitter2.notify(buttonInfo, this);
      }
      if (buttonInfo.myValue != buttonInfo.myPrevValue) {
        let emitter2 = buttonEventEmitters[GamepadButtonEvent.VALUE_CHANGED];
        emitter2.notify(buttonInfo, this);
      }
      let emitter = buttonEventEmitters[GamepadButtonEvent.ALWAYS];
      emitter.notify(buttonInfo, this);
    }
    this._mySelectStart = false;
    this._mySelectEnd = false;
    this._mySqueezeStart = false;
    this._mySqueezeEnd = false;
  }
  _preUpdateAxesInfos() {
    for (let i = 0; i < this._myAxesInfosIDs.length; i++) {
      let id = this._myAxesInfosIDs[i];
      let info2 = this._myAxesInfos[id];
      info2.myPrevAxes[0] = info2.myAxes[0];
      info2.myPrevAxes[1] = info2.myAxes[1];
    }
  }
  _updateAxesInfos() {
    this._updateSingleAxesInfo(GamepadAxesID.THUMBSTICK);
  }
  _updateSingleAxesInfo(axesID) {
    let axesInfo = this._myAxesInfos[axesID];
    let axesData = this._getAxesData(axesID);
    axesInfo.myAxes[0] = axesData[0];
    axesInfo.myAxes[1] = axesData[1];
  }
  _postUpdateAxesInfos() {
    for (let key in GamepadAxesID) {
      let axesInfo = this._myAxesInfos[GamepadAxesID[key]];
      let axesEventEmitters = this._myAxesEmitters[GamepadAxesID[key]];
      if (axesInfo.myAxes[0] != axesInfo.myPrevAxes[0]) {
        let emitter2 = axesEventEmitters[GamepadAxesEvent.X_CHANGED];
        emitter2.notify(axesInfo, this);
      }
      if (axesInfo.myAxes[1] != axesInfo.myPrevAxes[1]) {
        let emitter2 = axesEventEmitters[GamepadAxesEvent.Y_CHANGED];
        emitter2.notify(axesInfo, this);
      }
      if (axesInfo.myAxes[0] != axesInfo.myPrevAxes[0] || axesInfo.myAxes[1] != axesInfo.myPrevAxes[1]) {
        let emitter2 = axesEventEmitters[GamepadAxesEvent.AXES_CHANGED];
        emitter2.notify(axesInfo, this);
      }
      let emitter = axesEventEmitters[GamepadAxesEvent.ALWAYS];
      emitter.notify(axesInfo, this);
    }
  }
  _updatePulse(dt) {
    if (this._myPulseInfo.myDevicePulsing || this._myPulseInfo.myIntensity > 0) {
      let hapticActuators = this._getHapticActuators();
      if (hapticActuators.length > 0) {
        if (this._myPulseInfo.myIntensity > 0) {
          for (let i = 0; i < hapticActuators.length; i++) {
            let hapticActuator = hapticActuators[i];
            hapticActuator.pulse(this._myPulseInfo.myIntensity, Math.max(250, this._myPulseInfo.myDuration * 1e3));
          }
          this._myPulseInfo.myDevicePulsing = true;
        } else if (this._myPulseInfo.myDevicePulsing) {
          for (let i = 0; i < hapticActuators.length; i++) {
            let hapticActuator = hapticActuators[i];
            hapticActuator.pulse(0, 1);
            try {
              hapticActuator.reset();
            } catch (error3) {
            }
          }
          this._myPulseInfo.myDevicePulsing = false;
        }
      } else {
        this._myPulseInfo.myDevicePulsing = false;
      }
    }
    this._myPulseInfo.myDuration -= dt;
    if (this._myPulseInfo.myDuration <= 0) {
      this._myPulseInfo.myIntensity = 0;
      this._myPulseInfo.myDuration = 0;
    }
  }
  _createButtonData() {
    return { myPressed: false, myTouched: false, myValue: 0 };
  }
  _createAxesData() {
    return vec2_create(0, 0);
  }
  destroy() {
    this._myDestroyed = true;
    this._destroyHook();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/input/gamepad/universal_gamepad.js
var UniversalGamepad = class extends BaseGamepad {
  constructor(handedness) {
    super(handedness);
    this._myGamepadCores = {};
    this._myGamepadCoresIDs = [];
    this._myStarted = false;
    this._myButtonData = this._createButtonData();
    this._myAxesData = this._createAxesData();
    this._myHapticActuators = [];
  }
  addGamepadCore(id, gamepadCore) {
    if (gamepadCore.getHandedness() == this.getHandedness()) {
      this._myGamepadCores[id] = gamepadCore;
      this._myGamepadCoresIDs.push(id);
      if (this._myStarted) {
        gamepadCore.start();
      }
    }
  }
  getGamepadCore(id) {
    return this._myGamepadCores[id];
  }
  removeGamepadCore(id) {
    let gamepadCore = this._myGamepadCores[id];
    if (gamepadCore != null) {
      delete this._myGamepadCores[id];
      this._myGamepadCoresIDs.pp_removeEqual(id);
    }
  }
  removeAllGamepadCores() {
    this._myGamepadCores = {};
    this._myGamepadCoresIDs = [];
  }
  getHandPose() {
    let handPose = null;
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      let id = this._myGamepadCoresIDs[i];
      let core = this._myGamepadCores[id];
      if (core.isGamepadCoreActive()) {
        let currentCoreHandPose = core.getHandPose();
        if (handPose == null || currentCoreHandPose != null && currentCoreHandPose.isValid()) {
          handPose = currentCoreHandPose;
        }
      }
      if (handPose != null && handPose.isValid()) {
        break;
      }
    }
    return handPose;
  }
  _startHook() {
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      let id = this._myGamepadCoresIDs[i];
      let core = this._myGamepadCores[id];
      core.start();
    }
    this._myStarted = true;
  }
  _preUpdate(dt) {
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      let id = this._myGamepadCoresIDs[i];
      let core = this._myGamepadCores[id];
      core.preUpdate(dt);
    }
  }
  _postUpdate(dt) {
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      let id = this._myGamepadCoresIDs[i];
      let core = this._myGamepadCores[id];
      core.postUpdate(dt);
    }
  }
  _getButtonData(buttonID) {
    this._myButtonData.myPressed = false;
    this._myButtonData.myTouched = false;
    this._myButtonData.myValue = 0;
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      let id = this._myGamepadCoresIDs[i];
      let core = this._myGamepadCores[id];
      if (core.isGamepadCoreActive()) {
        let coreButtonData = core.getButtonData(buttonID);
        this._myButtonData.myPressed = this._myButtonData.myPressed || coreButtonData.myPressed;
        this._myButtonData.myTouched = this._myButtonData.myTouched || coreButtonData.myTouched;
        if (Math.abs(coreButtonData.myValue) > Math.abs(this._myButtonData.myValue)) {
          this._myButtonData.myValue = coreButtonData.myValue;
        }
      }
    }
    return this._myButtonData;
  }
  _getAxesData(axesID) {
    this._myAxesData.vec2_zero();
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      let id = this._myGamepadCoresIDs[i];
      let core = this._myGamepadCores[id];
      if (core.isGamepadCoreActive()) {
        let coreAxesData = core.getAxesData(axesID);
        if (Math.abs(coreAxesData[0]) > Math.abs(this._myAxesData[0])) {
          this._myAxesData[0] = coreAxesData[0];
        }
        if (Math.abs(coreAxesData[1]) > Math.abs(this._myAxesData[1])) {
          this._myAxesData[1] = coreAxesData[1];
        }
      }
    }
    return this._myAxesData;
  }
  _getHapticActuators() {
    this._myHapticActuators.pp_clear();
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      let id = this._myGamepadCoresIDs[i];
      let core = this._myGamepadCores[id];
      if (core.isGamepadCoreActive()) {
        let coreHapticActuators = core.getHapticActuators();
        for (let j = 0; j < coreHapticActuators.length; j++) {
          this._myHapticActuators.push(coreHapticActuators[j]);
        }
      }
    }
    return this._myHapticActuators;
  }
  _destroyHook() {
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      let id = this._myGamepadCoresIDs[i];
      let core = this._myGamepadCores[id];
      core.destroy();
    }
  }
};

// js/pp/input/gamepad/cauldron/gamepads_manager.js
var GamepadsManager = class {
  constructor() {
    this._myGamepads = [];
    this._myGamepads[Handedness.LEFT] = new UniversalGamepad(Handedness.LEFT);
    this._myGamepads[Handedness.RIGHT] = new UniversalGamepad(Handedness.RIGHT);
    this._myDestroyed = false;
  }
  start() {
    for (let key in this._myGamepads) {
      this._myGamepads[key].start();
    }
  }
  update(dt) {
    for (let key in this._myGamepads) {
      this._myGamepads[key].update(dt);
    }
  }
  getLeftGamepad() {
    return this._myGamepads[Handedness.LEFT];
  }
  getRightGamepad() {
    return this._myGamepads[Handedness.RIGHT];
  }
  getGamepad(handedness) {
    return this._myGamepads[handedness];
  }
  getGamepads() {
    return this._myGamepads;
  }
  destroy() {
    this._myDestroyed = true;
    for (let key in this._myGamepads) {
      this._myGamepads[key].destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/input/pose/base_pose.js
var BasePoseParams = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this.myReferenceObject = null;
    this.myForwardFixed = true;
    this.myUpdateOnViewReset = true;
    this.myForceEmulatedVelocities = false;
    this.myEngine = engine2;
  }
};
var BasePose = class {
  constructor(basePoseParams = new BasePoseParams()) {
    this._myForwardFixed = basePoseParams.myForwardFixed;
    this._myForceEmulatedVelocities = basePoseParams.myForceEmulatedVelocities;
    this._myUpdateOnViewReset = basePoseParams.myUpdateOnViewReset;
    this._myReferenceObject = basePoseParams.myReferenceObject;
    this._myEngine = basePoseParams.myEngine;
    this._myPosition = vec3_create();
    this._myRotationQuat = quat2_create();
    this._myPrevPosition = vec3_create();
    this._myPrevRotationQuat = quat_create();
    this._myLinearVelocity = vec3_create();
    this._myAngularVelocityRadians = vec3_create();
    this._myValid = false;
    this._myLinearVelocityEmulated = true;
    this._myAngularVelocityEmulated = true;
    this._myPoseUpdatedEmitter = new Emitter();
    this._myViewResetEventListener = null;
    this._myDestroyed = false;
  }
  getEngine() {
    return this._myEngine;
  }
  // If the reference object is set, the transform will be converted using it as a parent,
  // otherwise the transform will be local, as if the parent/reference object was the identity transform
  setReferenceObject(referenceObject) {
    this._myReferenceObject = referenceObject;
  }
  getReferenceObject() {
    return this._myReferenceObject;
  }
  setForwardFixed(forwardFixed) {
    this._myForwardFixed = forwardFixed;
  }
  isForwardFixed() {
    return this._myForwardFixed;
  }
  setForceEmulatedVelocities(forceEmulatedVelocities) {
    this._myForceEmulatedVelocities = forceEmulatedVelocities;
  }
  isForceEmulatedVelocities() {
    return this._myForceEmulatedVelocities;
  }
  setUpdateOnViewReset(updateOnViewReset) {
    this._myUpdateOnViewReset = updateOnViewReset;
  }
  isUpdateOnViewReset() {
    return this._myUpdateOnViewReset;
  }
  getReferenceSpace() {
    return XRUtils.getReferenceSpace(this._myEngine);
  }
  getPosition(out = vec3_create(), referenceObjectOverride = void 0) {
  }
  getRotation(out = vec3_create(), referenceObjectOverride = void 0) {
    return this.getRotationDegrees(out, referenceObjectOverride);
  }
  getRotationDegrees(out = vec3_create(), referenceObjectOverride = void 0) {
  }
  getRotationRadians(out = vec3_create(), referenceObjectOverride = void 0) {
  }
  getRotationQuat(out = quat_create(), referenceObjectOverride = void 0) {
  }
  getTransform(out = mat4_create(), referenceObjectOverride = void 0) {
    return this.getTransformMatrix(out, referenceObjectOverride);
  }
  getTransformMatrix(out = mat4_create(), referenceObjectOverride = void 0) {
  }
  getTransformQuat(out = quat2_create(), referenceObjectOverride = void 0) {
  }
  getLinearVelocity(out = vec3_create(), referenceObjectOverride = void 0) {
  }
  getAngularVelocity(out = vec3_create(), referenceObjectOverride = void 0) {
    return this.getAngularVelocityDegrees(out, referenceObjectOverride);
  }
  getAngularVelocityDegrees(out = vec3_create(), referenceObjectOverride = void 0) {
  }
  getAngularVelocityRadians(out = vec3_create(), referenceObjectOverride = void 0) {
  }
  isValid() {
    return this._myValid;
  }
  isLinearVelocityEmulated() {
    return this._myLinearVelocityEmulated;
  }
  isAngularVelocityEmulated() {
    return this._myAngularVelocityEmulated;
  }
  registerPoseUpdatedEventListener(id, listener) {
    this._myPoseUpdatedEmitter.add(listener, { id });
  }
  unregisterPoseUpdatedEventListener(id) {
    this._myPoseUpdatedEmitter.remove(id);
  }
  start() {
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, true, this._myEngine);
  }
  update(dt) {
    this._update(dt, true);
  }
  // Hooks
  _isReadyToGetPose() {
    return true;
  }
  _getPose(xrFrame) {
    return null;
  }
  _updateHook(dt, updateVelocity, xrPose) {
  }
  _onXRSessionStartHook(manualCall, session) {
  }
  _onXRSessionEndHook() {
  }
  _onViewResetHook() {
  }
  _destroyHook() {
  }
  // Hooks End
  _update(dt, updateVelocity) {
    this._myPrevPosition.vec3_copy(this._myPosition);
    this._myPrevRotationQuat.quat_copy(this._myRotationQuat);
    let xrFrame = XRUtils.getFrame(this._myEngine);
    if (xrFrame && this._isReadyToGetPose()) {
      let xrPose = null;
      try {
        xrPose = this._getPose(xrFrame);
      } catch (error3) {
      }
      if (xrPose) {
        this._myPosition[0] = xrPose.transform.position.x;
        this._myPosition[1] = xrPose.transform.position.y;
        this._myPosition[2] = xrPose.transform.position.z;
        this._myRotationQuat[0] = xrPose.transform.orientation.x;
        this._myRotationQuat[1] = xrPose.transform.orientation.y;
        this._myRotationQuat[2] = xrPose.transform.orientation.z;
        this._myRotationQuat[3] = xrPose.transform.orientation.w;
        this._myRotationQuat.quat_normalize(this._myRotationQuat);
        if (updateVelocity) {
          if (xrPose.linearVelocity && !this._myForceEmulatedVelocities) {
            this._myLinearVelocity[0] = xrPose.linearVelocity.x;
            this._myLinearVelocity[1] = xrPose.linearVelocity.y;
            this._myLinearVelocity[2] = xrPose.linearVelocity.z;
            this._myLinearVelocityEmulated = false;
          } else {
            this._computeEmulatedLinearVelocity(dt);
            this._myLinearVelocityEmulated = true;
          }
          if (xrPose.angularVelocity && !this._myForceEmulatedVelocities) {
            this._myAngularVelocityRadians[0] = xrPose.angularVelocity.x;
            this._myAngularVelocityRadians[1] = xrPose.angularVelocity.y;
            this._myAngularVelocityRadians[2] = xrPose.angularVelocity.z;
            this._myAngularVelocityEmulated = false;
          } else {
            this._computeEmulatedAngularVelocity(dt);
            this._myAngularVelocityEmulated = true;
          }
        }
        this._myValid = true;
      } else {
        if (updateVelocity) {
          this._myLinearVelocity[0] = 0;
          this._myLinearVelocity[1] = 0;
          this._myLinearVelocity[2] = 0;
          this._myAngularVelocityRadians[0] = 0;
          this._myAngularVelocityRadians[1] = 0;
          this._myAngularVelocityRadians[2] = 0;
        }
        this._myValid = false;
        this._myLinearVelocityEmulated = true;
        this._myAngularVelocityEmulated = true;
      }
      this._updateHook(dt, updateVelocity, xrPose);
    } else {
      if (updateVelocity) {
        this._myLinearVelocity[0] = 0;
        this._myLinearVelocity[1] = 0;
        this._myLinearVelocity[2] = 0;
        this._myAngularVelocityRadians[0] = 0;
        this._myAngularVelocityRadians[1] = 0;
        this._myAngularVelocityRadians[2] = 0;
      }
      this._myValid = false;
      this._myLinearVelocityEmulated = true;
      this._myAngularVelocityEmulated = true;
      this._updateHook(dt, updateVelocity, null);
    }
    this._myPoseUpdatedEmitter.notify(this);
  }
  _computeEmulatedLinearVelocity(dt) {
    if (dt > 0) {
      this._myPosition.vec3_sub(this._myPrevPosition, this._myLinearVelocity);
      this._myLinearVelocity.vec3_scale(1 / dt, this._myLinearVelocity);
    } else {
      this._myLinearVelocity[0] = 0;
      this._myLinearVelocity[1] = 0;
      this._myLinearVelocity[2] = 0;
    }
  }
  _onXRSessionStart(manualCall, session) {
    let referenceSpace = XRUtils.getReferenceSpace(this._myEngine);
    if (referenceSpace.addEventListener != null) {
      this._myViewResetEventListener = this._onViewReset.bind(this);
      referenceSpace.addEventListener("reset", this._myViewResetEventListener);
    }
    this._onXRSessionStartHook(manualCall, session);
  }
  _onXRSessionEnd() {
    this._onXRSessionEndHook();
    this._myViewResetEventListener = null;
  }
  _onViewReset() {
    if (this._myUpdateOnViewReset) {
      this._update(0, false);
    }
    this._onViewResetHook();
  }
  _computeEmulatedAngularVelocity() {
  }
  destroy() {
    this._myDestroyed = true;
    this._destroyHook();
    XRUtils.getReferenceSpace(this._myEngine)?.removeEventListener?.("reset", this._myViewResetEventListener);
    XRUtils.unregisterSessionStartEndEventListeners(this, this._myEngine);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
BasePose.prototype.getPosition = function() {
  let transform = mat4_create();
  return function getPosition4(out = vec3_create(), referenceObjectOverride = void 0) {
    let referenceObject = referenceObjectOverride === void 0 ? this._myReferenceObject : referenceObjectOverride;
    out.vec3_copy(this._myPosition);
    if (referenceObject == null) {
      return out;
    }
    return out.vec3_convertPositionToWorld(referenceObject.pp_getTransform(transform), out);
  };
}();
BasePose.prototype.getRotationDegrees = function() {
  let rotationQuat = quat_create();
  return function getRotationDegrees4(out = vec3_create(), referenceObjectOverride = void 0) {
    return this.getRotationQuat(rotationQuat, referenceObjectOverride).quat_toDegrees(out);
  };
}();
BasePose.prototype.getRotationRadians = function() {
  let rotationQuat = quat_create();
  return function getRotationRadians4(out = vec3_create(), referenceObjectOverride = void 0) {
    return this.getRotationQuat(rotationQuat, referenceObjectOverride).quat_toRadians(out);
  };
}();
BasePose.prototype.getRotationQuat = function() {
  let playerRotationQuat = quat_create();
  let up = vec3_create();
  return function getRotationQuat4(out = quat_create(), referenceObjectOverride = void 0) {
    let referenceObject = referenceObjectOverride === void 0 ? this._myReferenceObject : referenceObjectOverride;
    out.quat_copy(this._myRotationQuat);
    if (this._myForwardFixed) {
      out.quat_rotateAxisRadians(Math.PI, out.quat_getUp(up), out);
    }
    if (referenceObject == null) {
      return out;
    }
    return out.quat_toWorld(referenceObject.pp_getRotationQuat(playerRotationQuat), out);
  };
}();
BasePose.prototype.getTransformMatrix = function() {
  let transformQuat4 = quat2_create();
  return function getTransformMatrix2(out = mat4_create(), referenceObjectOverride = void 0) {
    return this.getTransformQuat(transformQuat4, referenceObjectOverride).quat2_toMatrix(out);
  };
}();
BasePose.prototype.getTransformQuat = function() {
  let rotationQuat = quat_create();
  let playerTransformQuat = quat2_create();
  return function getTransformQuat2(out = quat2_create(), referenceObjectOverride = void 0) {
    let referenceObject = referenceObjectOverride === void 0 ? this._myReferenceObject : referenceObjectOverride;
    out.quat2_identity();
    out.quat2_setPositionRotationQuat(this._myPosition, this.getRotationQuat(rotationQuat, referenceObjectOverride));
    if (referenceObject == null) {
      return out;
    }
    return out.quat_toWorld(referenceObject.pp_getTransformQuat(playerTransformQuat), out);
  };
}();
BasePose.prototype.getLinearVelocity = function() {
  let transform = mat4_create();
  return function getLinearVelocity(out = vec3_create(), referenceObjectOverride = void 0) {
    let referenceObject = referenceObjectOverride === void 0 ? this._myReferenceObject : referenceObjectOverride;
    out.vec3_copy(this._myLinearVelocity);
    if (referenceObject == null) {
      return out;
    }
    return out.vec3_convertDirectionToWorld(referenceObject.pp_getTransform(transform), out);
  };
}();
BasePose.prototype.getAngularVelocityDegrees = function() {
  let velocityRadians = vec3_create();
  return function getAngularVelocityDegrees(out = vec3_create(), referenceObjectOverride = void 0) {
    return this.getAngularVelocityRadians(velocityRadians, referenceObjectOverride).vec3_toDegrees(out);
  };
}();
BasePose.prototype.getAngularVelocityRadians = function() {
  let transform = mat4_create();
  return function getAngularVelocityRadians(out = vec3_create(), referenceObjectOverride = void 0) {
    let referenceObject = referenceObjectOverride === void 0 ? this._myReferenceObject : referenceObjectOverride;
    out.vec3_copy(this._myAngularVelocityRadians);
    if (referenceObject == null) {
      return out;
    }
    return out.vec3_convertDirectionToWorld(referenceObject.pp_getTransform(transform), out);
  };
}();
BasePose.prototype._computeEmulatedAngularVelocity = function() {
  let rotationRadians = vec3_create();
  let prevRotationRadians = vec3_create();
  return function _computeEmulatedAngularVelocity(dt) {
    if (dt > 0) {
      rotationRadians = this._myRotationQuat.quat_toRadians(rotationRadians);
      prevRotationRadians = this._myPrevRotationQuat.quat_toRadians(prevRotationRadians);
      rotationRadians.vec3_sub(prevRotationRadians, this._myAngularVelocityRadians);
      this._myAngularVelocityRadians.vec3_scale(1 / dt, this._myAngularVelocityRadians);
    } else {
      this._myAngularVelocityRadians[0] = 0;
      this._myAngularVelocityRadians[1] = 0;
      this._myAngularVelocityRadians[2] = 0;
    }
  };
}();

// js/pp/input/pose/hand_pose.js
var HandPoseParams = class extends BasePoseParams {
  constructor(engine2) {
    super(engine2);
    this.myFixTrackedHandRotation = true;
  }
};
var HandPose = class extends BasePose {
  constructor(handedness, handPoseParams = new HandPoseParams()) {
    super(handPoseParams);
    this._myInputSource = null;
    this._myHandedness = handedness;
    this._myFixTrackedHandRotation = handPoseParams.myFixTrackedHandRotation;
    this._myTrackedHand = false;
    this._myInputSourcesChangeEventListener = null;
  }
  getHandedness() {
    return this._myHandedness;
  }
  getInputSource() {
    return this._myInputSource;
  }
  getInputSourceType() {
    if (this._myInputSource == null) {
      return null;
    }
    return InputUtils.getInputSourceType(this._myInputSource);
  }
  isFixTrackedHandRotation() {
    return this._myFixTrackedHandRotation;
  }
  setFixTrackedHandRotation(fixTrackedHandRotation) {
    this.myFixTrackedHandRotation = fixTrackedHandRotation;
  }
  getRotationQuat(referenceObjectOverride = void 0) {
  }
  _isReadyToGetPose() {
    return this._myInputSource != null;
  }
  _getPose(xrFrame) {
    return xrFrame.getPose(this._myInputSource.gripSpace, this.getReferenceSpace());
  }
  _onXRSessionStartHook(manualCall, session) {
    this._myInputSourcesChangeEventListener = function() {
      this._myInputSource = null;
      if (session.inputSources != null && session.inputSources.length > 0) {
        for (let item of session.inputSources) {
          if (item.handedness == this._myHandedness) {
            this._myInputSource = item;
            this._myTrackedHand = InputUtils.getInputSourceType(this._myInputSource) == InputSourceType.TRACKED_HAND;
          }
        }
      }
    }.bind(this);
    this._myInputSourcesChangeEventListener();
    session.addEventListener("inputsourceschange", this._myInputSourcesChangeEventListener);
  }
  _onXRSessionEndHook() {
    this._myInputSource = null;
    this._myInputSourcesChangeEventListener = null;
  }
  _destroyHook() {
    XRUtils.getSession(this.getEngine())?.removeEventListener("inputsourceschange", this._myInputSourcesChangeEventListener);
  }
};
HandPose.prototype.getRotationQuat = function() {
  let playerRotationQuat = quat_create();
  let up = vec3_create();
  let right = vec3_create();
  let forward = vec3_create();
  return function getRotationQuat4(out = quat_create(), referenceObjectOverride = void 0) {
    let referenceObject = referenceObjectOverride === void 0 ? this._myReferenceObject : referenceObjectOverride;
    out.quat_copy(this._myRotationQuat);
    if (this._myForwardFixed) {
      out.quat_rotateAxisRadians(Math.PI, out.quat_getUp(up), out);
    }
    if (this._myFixTrackedHandRotation && this._myTrackedHand) {
      out.quat_rotateAxis(-60, out.quat_getRight(right), out);
      let forwardRotation = 20;
      forwardRotation = this._myHandedness == Handedness.LEFT ? forwardRotation : -forwardRotation;
      out.quat_rotateAxis(forwardRotation, out.quat_getForward(forward), out);
    }
    if (referenceObject == null) {
      return out;
    }
    return out.quat_toWorld(referenceObject.pp_getRotationQuat(playerRotationQuat), out);
  };
}();

// js/pp/input/pose/head_pose.js
var HeadPose = class extends BasePose {
  _getPose(xrFrame) {
    return xrFrame.getViewerPose(this.getReferenceSpace());
  }
};

// js/pp/input/pose/tracked_hand_joint_pose.js
var TrackedHandJointPose = class extends BasePose {
  constructor(handedness, trackedHandJointID, basePoseParams = new BasePoseParams()) {
    super(basePoseParams);
    this._myInputSource = null;
    this._myHandedness = handedness;
    this._myTrackedHandJointID = trackedHandJointID;
    this._myJointRadius = 0;
    this._myInputSourcesChangeEventListener = null;
  }
  getHandedness() {
    return this._myHandedness;
  }
  getTrackedHandJointID() {
    return this._myTrackedHandJointID;
  }
  setTrackedHandJointID(trackedHandJointID) {
    this._myTrackedHandJointID = trackedHandJointID;
  }
  getJointRadius() {
    return this._myJointRadius;
  }
  _isReadyToGetPose() {
    return this._myInputSource != null;
  }
  _getPose(xrFrame) {
    return xrFrame.getJointPose(this._myInputSource.hand.get(this._myTrackedHandJointID), this.getReferenceSpace());
  }
  _updateHook(dt, updateVelocity, xrPose) {
    if (xrPose != null) {
      this._myJointRadius = xrPose.radius;
    }
  }
  _onXRSessionStartHook(manualCall, session) {
    this._myInputSourcesChangeEventListener = function() {
      this._myInputSource = null;
      if (session.inputSources != null && session.inputSources.length > 0) {
        for (let item of session.inputSources) {
          if (item.handedness == this._myHandedness) {
            if (InputUtils.getInputSourceType(item) == InputSourceType.TRACKED_HAND) {
              this._myInputSource = item;
            }
          }
        }
      }
    }.bind(this);
    this._myInputSourcesChangeEventListener();
    session.addEventListener("inputsourceschange", this._myInputSourcesChangeEventListener);
  }
  _onXRSessionEndHook() {
    this._myInputSource = null;
    this._myInputSourcesChangeEventListener = null;
  }
  _destroyHook() {
    XRUtils.getSession(this.getEngine())?.removeEventListener("inputsourceschange", this._myInputSourcesChangeEventListener);
  }
};

// js/pp/input/pose/tracked_hand_pose.js
var TrackedHandPoseParams = class extends BasePoseParams {
  constructor(addAllJointIDs = true, engine2 = Globals.getMainEngine()) {
    super(engine2);
    this.myTrackedHandJointIDList = [];
    if (addAllJointIDs) {
      for (let key in TrackedHandJointID) {
        this.myTrackedHandJointIDList.push([TrackedHandJointID[key]]);
      }
    }
  }
};
var TrackedHandPose = class {
  constructor(handedness, trackedHandPoseParams = new TrackedHandPoseParams()) {
    this._myHandedness = handedness;
    this._myForwardFixed = trackedHandPoseParams.myForwardFixed;
    this._myForceEmulatedVelocities = trackedHandPoseParams.myForceEmulatedVelocities;
    this._myReferenceObject = trackedHandPoseParams.myReferenceObject;
    this._myEngine = trackedHandPoseParams.myEngine;
    this._myTrackedHandJointPoseParams = new BasePoseParams(this._myEngine);
    this._myTrackedHandJointPoseParams.myForwardFixed = this._myForwardFixed;
    this._myTrackedHandJointPoseParams.myForceEmulatedVelocities = this._myForceEmulatedVelocities;
    this._myTrackedHandJointPoseParams.myReferenceObject = this._myReferenceObject;
    this._myTrackedHandJointPoses = [];
    for (let jointID of trackedHandPoseParams.myTrackedHandJointIDList) {
      let trackedHandJointPose = new TrackedHandJointPose(this._myHandedness, jointID, this._myTrackedHandJointPoseParams);
      this._myTrackedHandJointPoses[jointID] = trackedHandJointPose;
    }
  }
  start() {
    for (let jointPoseKey in this._myTrackedHandJointPoses) {
      let jointPose = this._myTrackedHandJointPoses[jointPoseKey];
      jointPose.start();
    }
  }
  update(dt) {
    for (let jointPoseKey in this._myTrackedHandJointPoses) {
      let jointPose = this._myTrackedHandJointPoses[jointPoseKey];
      jointPose.update(dt);
    }
  }
  getEngine() {
    this._myEngine;
  }
  getHandedness() {
    return this._myHandedness;
  }
  getJointPose(jointID) {
    return this._myTrackedHandJointPoses[jointID];
  }
  getJointPoseByIndex(jointIDIndex) {
    return this._myTrackedHandJointPoses[InputUtils.getJointIDByIndex(jointIDIndex)];
  }
  getJointPoses() {
    return this._myTrackedHandJointPoses;
  }
  addTrackedHandJointID(jointID) {
    if (!this._myTrackedHandJointPoses.pp_has((element) => element.getTrackedHandJointID() == jointID)) {
      let trackedHandJointPose = new TrackedHandJointPose(this._myHandedness, jointID, this._myTrackedHandJointPoseParams);
      this._myTrackedHandJointPoses.push(trackedHandJointPose);
    }
  }
  removeTrackedHandJointID(jointID) {
    this._myTrackedHandJointPoses.pp_remove((element) => element.getTrackedHandJointID() == jointID);
  }
  setReferenceObject(referenceObject) {
    this._myReferenceObject = referenceObject;
    this._myTrackedHandJointPoseParams.myReferenceObject = this._myReferenceObject;
    for (let jointPoseKey in this._myTrackedHandJointPoses) {
      let jointPose = this._myTrackedHandJointPoses[jointPoseKey];
      jointPose.setReferenceObject(referenceObject);
    }
  }
  getReferenceObject() {
    return this._myReferenceObject;
  }
  setForwardFixed(forwardFixed) {
    this._myForwardFixed = forwardFixed;
    this._myTrackedHandJointPoseParams.myForwardFixed = this._myForwardFixed;
    for (let jointPoseKey in this._myTrackedHandJointPoses) {
      let jointPose = this._myTrackedHandJointPoses[jointPoseKey];
      jointPose.setForwardFixed(forwardFixed);
    }
  }
  isForwardFixed() {
    return this._myForwardFixed;
  }
  setForceEmulatedVelocities(forceEmulatedVelocities) {
    this._myForceEmulatedVelocities = forceEmulatedVelocities;
    this._myTrackedHandJointPoseParams.myForceEmulatedVelocities = this._myForceEmulatedVelocities;
    for (let jointPoseKey in this._myTrackedHandJointPoses) {
      let jointPose = this._myTrackedHandJointPoses[jointPoseKey];
      jointPose.setForceEmulatedVelocities(forceEmulatedVelocities);
    }
  }
  isForceEmulatedVelocities() {
    return this._myForceEmulatedVelocities;
  }
  destroy() {
    this._myDestroyed = true;
    for (let jointPose of this._myTrackedHandJointPoses) {
      jointPose.destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/input/cauldron/mouse.js
var MouseButtonID = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2
};
var Mouse = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this._myEngine = engine2;
    this._myButtonInfos = {};
    this._myButtonInfosIDs = [];
    for (let key in MouseButtonID) {
      this._myButtonInfos[MouseButtonID[key]] = this._createButtonInfo();
      this._myButtonInfosIDs.push(MouseButtonID[key]);
    }
    this._myPreventContextMenuEventListener = this._preventContextMenu.bind(this);
    this._myPreventMiddleButtonScrollEventListener = this._preventMiddleButtonScroll.bind(this);
    this._myInternalMousePosition = vec2_create();
    this._myScreenSize = vec2_create();
    this._updateScreenSize();
    this._myResetMovingDelay = 0.15;
    this._myResetMovingTimer = new Timer(this._myResetMovingDelay, false);
    this._myMoving = false;
    this._myInsideView = false;
    this._myValid = false;
    this._myPointerUpOnPointerLeave = true;
    this._myContextMenuActive = true;
    this._myMiddleButtonScrollActive = true;
    this._myPointerID = null;
    this._myLastValidPointerEvent = null;
    this._myPointerEventValidCallbacks = {};
    this._myPointerEventValidCallbacksIDs = [];
    this._myPointerMoveEventListener = null;
    this._myPointerDownEventListener = null;
    this._myPointerUpEventListener = null;
    this._myPointerLeaveEventListener = null;
    this._myPointerEnterEventListener = null;
    this._myMouseDownEventListener = null;
    this._myMouseUpEventListener = null;
    this._myDestroyed = false;
    this._myProjectionMatrixInverse = mat4_create();
    this._myRotationQuat = quat_create();
    this._myOriginWorld = vec3_create();
    this._myDirectionWorld = vec3_create();
  }
  start() {
    this._myPointerMoveEventListener = this._onPointerAction.bind(this, this._onPointerMove.bind(this));
    Globals.getBody(this._myEngine).addEventListener("pointermove", this._myPointerMoveEventListener);
    this._myPointerDownEventListener = this._onPointerAction.bind(this, this._onPointerDown.bind(this));
    Globals.getBody(this._myEngine).addEventListener("pointerdown", this._myPointerDownEventListener);
    this._myPointerUpEventListener = this._onPointerAction.bind(this, this._onPointerUp.bind(this));
    Globals.getBody(this._myEngine).addEventListener("pointerup", this._myPointerUpEventListener);
    this._myPointerLeaveEventListener = this._onPointerLeave.bind(this);
    Globals.getBody(this._myEngine).addEventListener("pointerleave", this._myPointerLeaveEventListener);
    this._myPointerEnterEventListener = this._onPointerEnter.bind(this);
    Globals.getBody(this._myEngine).addEventListener("pointerenter", this._myPointerEnterEventListener);
    this._myMouseDownEventListener = this._onMouseAction.bind(this, this._onPointerDown.bind(this));
    Globals.getBody(this._myEngine).addEventListener("mousedown", this._myMouseDownEventListener);
    this._myMouseUpEventListener = this._onMouseAction.bind(this, this._onPointerUp.bind(this));
    Globals.getBody(this._myEngine).addEventListener("mouseup", this._myMouseUpEventListener);
  }
  update(dt) {
    if (this._myResetMovingTimer.isRunning()) {
      this._myResetMovingTimer.update(dt);
      if (this._myResetMovingTimer.isDone()) {
        this._myResetMovingTimer.reset();
        this._myMoving = false;
      }
    }
    for (let i = 0; i < this._myButtonInfosIDs.length; i++) {
      let id = this._myButtonInfosIDs[i];
      let buttonInfo = this._myButtonInfos[id];
      buttonInfo.myPressStart = buttonInfo.myPressStartToProcess;
      buttonInfo.myPressEnd = buttonInfo.myPressEndToProcess;
      buttonInfo.myPressStartToProcess = false;
      buttonInfo.myPressEndToProcess = false;
    }
    this._updateScreenSize();
    if (!this.isAnyButtonPressed() && !this._myMoving) {
      this._myPointerID = null;
    }
    if (this._myLastValidPointerEvent != null) {
      let lastValidPointerEventStillValid = this._isPointerEventValid(this._myLastValidPointerEvent);
      if (!lastValidPointerEventStillValid) {
        if (this._myInsideView) {
          this._onPointerLeave(this._myLastValidPointerEvent);
        }
        this._myLastValidPointerEvent = null;
      }
    }
  }
  isValid() {
    return this._myValid;
  }
  isButtonPressed(buttonID) {
    let pressed = false;
    if (this._myButtonInfosIDs[buttonID] != null) {
      pressed = this._myButtonInfos[buttonID].myPressed;
    }
    return pressed;
  }
  isAnyButtonPressed() {
    let pressed = false;
    for (let i = 0; i < this._myButtonInfosIDs.length; i++) {
      let id = this._myButtonInfosIDs[i];
      let buttonInfo = this._myButtonInfos[id];
      if (buttonInfo.myPressed) {
        pressed = true;
        break;
      }
    }
    return pressed;
  }
  isButtonPressStart(buttonID) {
    let pressStart = false;
    if (this._myButtonInfosIDs[buttonID] != null) {
      pressStart = this._myButtonInfos[buttonID].myPressStart;
    }
    return pressStart;
  }
  isButtonPressEnd(buttonID = null) {
    let pressEnd = false;
    if (this._myButtonInfosIDs[buttonID] != null) {
      pressEnd = this._myButtonInfos[buttonID].myPressEnd;
    }
    return pressEnd;
  }
  isMoving() {
    return this._myMoving;
  }
  isInsideView() {
    return this._myInsideView;
  }
  isTargetingRenderCanvas() {
    return this.isInsideView() && this._myLastValidPointerEvent != null && this._myLastValidPointerEvent.target == Globals.getCanvas(this._myEngine);
  }
  // The origin and direction are set by the mouse
  raycastWorld(raycastParams, raycastResults = new RaycastResults()) {
    this.getOriginWorld(raycastParams.myOrigin);
    this.getDirectionWorld(raycastParams.myDirection);
    raycastResults = PhysicsUtils.raycast(raycastParams, raycastResults, Globals.getPhysics(this._myEngine));
    return raycastResults;
  }
  getPositionScreen(out = vec2_create()) {
    let mousePosition = out;
    mousePosition[0] = this._myInternalMousePosition[0];
    mousePosition[1] = this._myScreenSize[1] - 1 - this._myInternalMousePosition[1];
    return mousePosition;
  }
  getPositionScreenNormalized(out = vec2_create()) {
    let mousePosition = out;
    mousePosition[0] = this._myScreenSize[0] == 0 ? 0 : this._myInternalMousePosition[0] / this._myScreenSize[0] * 2 - 1;
    mousePosition[1] = this._myScreenSize[1] == 0 ? 0 : (this._myScreenSize[1] - 1 - this._myInternalMousePosition[1]) / this._myScreenSize[1] * 2 - 1;
    return mousePosition;
  }
  getScreenSize() {
    return this._myScreenSize;
  }
  getPositionWorld(distanceFromCamera, out = vec3_create()) {
    let originWorld = this.getOriginWorld(this._myOriginWorld);
    let directionWorld = this.getDirectionWorld(this._myDirectionWorld);
    out = originWorld.vec3_add(directionWorld.vec3_scale(distanceFromCamera, out), out);
    return out;
  }
  getOriginWorld(out = vec3_create()) {
    if (XRUtils.isSessionActive(this._myEngine)) {
      Globals.getPlayerObjects(this._myEngine).myEyeLeft.pp_getPosition(out);
    } else {
      Globals.getPlayerObjects(this._myEngine).myCameraNonXR.pp_getPosition(out);
    }
    return out;
  }
  getDirectionWorld(out = vec3_create()) {
    let right = this._myInternalMousePosition[0] / this._myScreenSize[0];
    let up = this._myInternalMousePosition[1] / this._myScreenSize[1];
    let directionLocal = out;
    directionLocal.vec3_set(right * 2 - 1, -up * 2 + 1, -1);
    let projectionMatrixInvert = this._myProjectionMatrixInverse;
    if (XRUtils.isSessionActive(this._myEngine)) {
      projectionMatrixInvert = Globals.getPlayerObjects(this._myEngine).myEyeLeft.pp_getComponent(ViewComponent).projectionMatrix.mat4_invert(projectionMatrixInvert);
    } else {
      projectionMatrixInvert = Globals.getPlayerObjects(this._myEngine).myCameraNonXR.pp_getComponent(ViewComponent).projectionMatrix.mat4_invert(projectionMatrixInvert);
    }
    directionLocal.vec3_transformMat4(projectionMatrixInvert, directionLocal);
    directionLocal.vec3_normalize(directionLocal);
    let directionWorld = directionLocal;
    if (XRUtils.isSessionActive(this._myEngine)) {
      directionWorld = directionLocal.vec3_transformQuat(Globals.getPlayerObjects(this._myEngine).myEyeLeft.pp_getRotationQuat(this._myRotationQuat), directionLocal);
    } else {
      directionWorld = directionLocal.vec3_transformQuat(Globals.getPlayerObjects(this._myEngine).myCameraNonXR.pp_getRotationQuat(this._myRotationQuat), directionLocal);
    }
    directionWorld.vec3_normalize(directionWorld);
    return out;
  }
  setTouchValid(touchValid) {
    let callbackID = "pp_internal_touch_valid_callback";
    if (touchValid) {
      this.removePointerEventValidCallback(callbackID);
    } else {
      this.addPointerEventValidCallback(callbackID, function(event) {
        return event.pointerType == "mouse";
      });
    }
  }
  setTargetOnlyRenderCanvas(targetOnlyRenderCanvas) {
    let callbackID = "pp_internal_target_only_render_canvas_callback";
    if (targetOnlyRenderCanvas) {
      this.addPointerEventValidCallback(callbackID, function(event) {
        return event.target == Globals.getCanvas(this._myEngine);
      });
    } else {
      this.removePointerEventValidCallback(callbackID);
    }
  }
  getLastValidPointerEvent() {
    return this._myLastValidPointerEvent;
  }
  // Can be used to specify that only some pointerType are valid (eg: mouse, touch, pen) or just some target (eg: Globals.getCanvas(this._myEngine))
  addPointerEventValidCallback(id, callback) {
    this._myPointerEventValidCallbacks[id] = callback;
    this._myPointerEventValidCallbacksIDs.push(id);
  }
  removePointerEventValidCallback(id) {
    delete this._myPointerEventValidCallbacks[id];
    this._myPointerEventValidCallbacksIDs.pp_removeEqual(id);
  }
  isPointerUpOnPointerLeave() {
    return this._myPointerUpOnPointerLeave;
  }
  setPointerUpOnPointerLeave(pointerUpOnPointerLeave) {
    this._myPointerUpOnPointerLeave = pointerUpOnPointerLeave;
  }
  isContextMenuActive() {
    return this._myContextMenuActive;
  }
  setContextMenuActive(active) {
    if (this._myContextMenuActive != active) {
      if (active) {
        Globals.getBody(this._myEngine).removeEventListener("contextmenu", this._myPreventContextMenuEventListener);
      } else {
        Globals.getBody(this._myEngine).addEventListener("contextmenu", this._myPreventContextMenuEventListener, false);
      }
      this._myContextMenuActive = active;
    }
  }
  isMiddleButtonScrollActive() {
    return this._myMiddleButtonScrollActive;
  }
  setMiddleButtonScrollActive(active) {
    if (this._myMiddleButtonScrollActive != active) {
      if (active) {
        Globals.getBody(this._myEngine).removeEventListener("mousedown", this._myPreventMiddleButtonScrollEventListener);
      } else {
        Globals.getBody(this._myEngine).addEventListener("mousedown", this._myPreventMiddleButtonScrollEventListener, false);
      }
      this._myMiddleButtonScrollActive = active;
    }
  }
  setResetMovingDelay(delay) {
    this._myResetMovingDelay = delay;
  }
  getResetMovingDelay() {
    return this._myResetMovingDelay;
  }
  _onPointerAction(actionCallback, event) {
    if (!this._isPointerEventIDValid(event))
      return;
    if (!this._isPointerEventValid(event)) {
      if (this._myInsideView) {
        this._onPointerLeave(event);
      }
      return;
    }
    if (!this._myInsideView) {
      this._onPointerEnter(event);
    }
    actionCallback(event);
    this._updatePositionAndScreen(event);
    this._updatePointerData(event);
  }
  _onMouseAction(actionCallback, event) {
    if (!this._myInsideView)
      return;
    if (!this._isMouseAllowed())
      return;
    if (!this._isPointerEventIDValid(this._myLastValidPointerEvent))
      return;
    if (!this._isPointerEventValid(this._myLastValidPointerEvent))
      return;
    actionCallback(event);
  }
  _onPointerMove(event) {
    this._myResetMovingTimer.start(this._myResetMovingDelay);
    this._myMoving = true;
  }
  _onPointerDown(event) {
    let buttonInfo = this._myButtonInfos[event.button];
    if (!buttonInfo.myPressed) {
      buttonInfo.myPressed = true;
      buttonInfo.myPressStartToProcess = true;
    }
  }
  _onPointerUp(event) {
    let buttonInfo = this._myButtonInfos[event.button];
    if (buttonInfo.myPressed) {
      buttonInfo.myPressed = false;
      buttonInfo.myPressEndToProcess = true;
    }
  }
  _onPointerLeave(event) {
    if (!this._myInsideView || this._myLastValidPointerEvent == null || event.pointerId != this._myLastValidPointerEvent.pointerId)
      return;
    this._myInsideView = false;
    this._myMoving = false;
    if (this._myPointerUpOnPointerLeave) {
      for (let i = 0; i < this._myButtonInfosIDs.length; i++) {
        let id = this._myButtonInfosIDs[i];
        let buttonInfo = this._myButtonInfos[id];
        if (buttonInfo.myPressed) {
          buttonInfo.myPressed = false;
          buttonInfo.myPressEndToProcess = true;
        }
      }
    }
    this._myPointerID = null;
  }
  _onPointerEnter(event) {
    if (this._myInsideView && this._myPointerID != null || !this._isPointerEventIDValid(event) || !this._isPointerEventValid(event))
      return;
    this._myInsideView = true;
    this._updatePositionAndScreen(event);
    this._updatePointerData(event);
  }
  _preventContextMenu(event) {
    if (!this._isPointerEventIDValid(event) || !this._isPointerEventValid(event))
      return;
    event.preventDefault();
  }
  _preventMiddleButtonScroll(event) {
    if (!this._isPointerEventIDValid(event) || !this._isPointerEventValid(event))
      return;
    if (event.button == 1) {
      event.preventDefault();
      return false;
    }
  }
  _updatePositionAndScreen(event) {
    this._updateScreenSize();
    this._myInternalMousePosition[0] = event.clientX;
    this._myInternalMousePosition[1] = event.clientY;
    this._myValid = true;
  }
  _updateScreenSize() {
    let bounds = Globals.getBody(this._myEngine).getBoundingClientRect();
    this._myScreenSize[0] = bounds.width;
    this._myScreenSize[1] = bounds.height;
  }
  _updatePointerData(event) {
    this._myPointerID = event.pointerId;
    this._myLastValidPointerEvent = event;
  }
  _isPointerEventIDValid(event) {
    if (event == null)
      return false;
    return this._myPointerID == null || this._myPointerID == event.pointerId;
  }
  _isPointerEventValid(event) {
    if (event == null)
      return false;
    let valid = true;
    for (let i = 0; i < this._myPointerEventValidCallbacksIDs.length; i++) {
      let id = this._myPointerEventValidCallbacksIDs[i];
      let callback = this._myPointerEventValidCallbacks[id];
      if (!callback(event)) {
        valid = false;
        break;
      }
    }
    return valid;
  }
  _isMouseAllowed() {
    return this._myLastValidPointerEvent != null && this._myLastValidPointerEvent.pointerId == 1;
  }
  _createButtonInfo() {
    return { myPressed: false, myPressStart: false, myPressStartToProcess: false, myPressEnd: false, myPressEndToProcess: false };
  }
  destroy() {
    this._myDestroyed = true;
    Globals.getBody(this._myEngine).removeEventListener("pointermove", this._myPointerMoveEventListener);
    Globals.getBody(this._myEngine).removeEventListener("pointerdown", this._myPointerDownEventListener);
    Globals.getBody(this._myEngine).removeEventListener("pointerup", this._myPointerUpEventListener);
    Globals.getBody(this._myEngine).removeEventListener("pointerleave", this._myPointerLeaveEventListener);
    Globals.getBody(this._myEngine).removeEventListener("pointerenter", this._myPointerEnterEventListener);
    Globals.getBody(this._myEngine).removeEventListener("mousedown", this._myMouseDownEventListener);
    Globals.getBody(this._myEngine).removeEventListener("mouseup", this._myMouseUpEventListener);
    Globals.getBody(this._myEngine).removeEventListener("contextmenu", this._myPreventContextMenuEventListener);
    Globals.getBody(this._myEngine).removeEventListener("mousedown", this._myPreventMiddleButtonScrollEventListener);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/input/cauldron/input_manager.js
var InputManager = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this._myEngine = engine2;
    this._myMouse = new Mouse(this._myEngine);
    this._myKeyboard = new Keyboard(this._myEngine);
    this._myHeadPose = new HeadPose(new BasePoseParams(this._myEngine));
    this._myHeadPose.setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myHeadPose.setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
    this._myHandPoses = [];
    this._myHandPoses[Handedness.LEFT] = new HandPose(Handedness.LEFT, new HandPoseParams(this._myEngine));
    this._myHandPoses[Handedness.RIGHT] = new HandPose(Handedness.RIGHT, new HandPoseParams(this._myEngine));
    this._myHandPoses[Handedness.LEFT].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myHandPoses[Handedness.RIGHT].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myHandPoses[Handedness.LEFT].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
    this._myHandPoses[Handedness.RIGHT].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
    this._myTrackedHandPoses = [];
    this._myTrackedHandPoses[Handedness.LEFT] = new TrackedHandPose(Handedness.LEFT, new TrackedHandPoseParams(true, this._myEngine));
    this._myTrackedHandPoses[Handedness.RIGHT] = new TrackedHandPose(Handedness.RIGHT, new TrackedHandPoseParams(true, this._myEngine));
    this._myTrackedHandPoses[Handedness.LEFT].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myTrackedHandPoses[Handedness.RIGHT].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myTrackedHandPoses[Handedness.LEFT].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
    this._myTrackedHandPoses[Handedness.RIGHT].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
    this._myGamepadsManager = new GamepadsManager(this._myEngine);
    this._myStarted = false;
    this._myTrackedHandPosesEnabled = true;
    this._myTrackedHandPosesStarted = false;
    this._myDestroyed = false;
  }
  start() {
    this._myMouse.start();
    this._myKeyboard.start();
    this._myHeadPose.setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myHeadPose.setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
    this._myHeadPose.start();
    for (let key in this._myHandPoses) {
      this._myHandPoses[key].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
      this._myHandPoses[key].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
      this._myHandPoses[key].start();
    }
    if (this._myTrackedHandPosesEnabled) {
      this._startTrackedHandPoses();
    }
    this._myGamepadsManager.start();
    this._myStarted = true;
  }
  update(dt) {
    this._myMouse.update(dt);
    this._myKeyboard.update(dt);
    this._myHeadPose.setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myHeadPose.setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
    this._myHeadPose.update(dt);
    for (let key in this._myHandPoses) {
      this._myHandPoses[key].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
      this._myHandPoses[key].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
      this._myHandPoses[key].update(dt);
    }
    this._updateTrackedHandPoses();
    this._myGamepadsManager.update(dt);
  }
  getMouse() {
    return this._myMouse;
  }
  getKeyboard() {
    return this._myKeyboard;
  }
  getGamepadsManager() {
    return this._myGamepadsManager;
  }
  getHeadPose() {
    return this._myHeadPose;
  }
  getLeftHandPose() {
    return this._myHandPoses[Handedness.LEFT];
  }
  getRightHandPose() {
    return this._myHandPoses[Handedness.RIGHT];
  }
  getHandPose(handedness) {
    return this._myHandPoses[handedness];
  }
  getHandPoses() {
    return this._myHandPoses;
  }
  getLeftTrackedHandPose() {
    return this._myTrackedHandPoses[Handedness.LEFT];
  }
  getRightTrackedHandPose() {
    return this._myTrackedHandPoses[Handedness.RIGHT];
  }
  getTrackedHandPose(handedness) {
    return this._myTrackedHandPoses[handedness];
  }
  getTrackedHandPoses() {
    return this._myTrackedHandPoses;
  }
  areTrackedHandPosesEnabled() {
    return this._myTrackedHandPosesEnabled;
  }
  setTrackedHandPosesEnabled(enabled) {
    this._myTrackedHandPosesEnabled = enabled;
    if (this._myStarted && this._myTrackedHandPosesEnabled) {
      this._startTrackedHandPoses();
    }
  }
  _startTrackedHandPoses() {
    if (!this._myTrackedHandPosesStarted) {
      for (let key in this._myTrackedHandPoses) {
        this._myTrackedHandPoses[key].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
        this._myTrackedHandPoses[key].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
        this._myTrackedHandPoses[key].start();
      }
      this._myTrackedHandPosesStarted = true;
    }
  }
  _updateTrackedHandPoses(dt) {
    if (this._myTrackedHandPosesEnabled && this._myTrackedHandPosesStarted) {
      for (let key in this._myTrackedHandPoses) {
        this._myTrackedHandPoses[key].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
        this._myTrackedHandPoses[key].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
        this._myTrackedHandPoses[key].update(dt);
      }
    }
  }
  destroy() {
    this._myDestroyed = true;
    this._myMouse.destroy();
    this._myKeyboard.destroy();
    this._myHeadPose.destroy();
    for (let key in this._myHandPoses) {
      this._myHandPoses[key].destroy();
    }
    for (let key in this._myTrackedHandPoses) {
      this._myTrackedHandPoses[key].destroy();
    }
    this._myGamepadsManager.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/input/cauldron/components/input_manager_component.js
var InputManagerComponent = class extends Component {
  init() {
    this._myInputManager = null;
    this._myPoseForwardFixedGlobal = null;
    if (!Globals.hasInputManager(this.engine)) {
      this._myInputManager = new InputManager(this.engine);
      this._myInputManager.setTrackedHandPosesEnabled(this._myEnableTrackedHandPoses);
      Globals.setInputManager(this._myInputManager, this.engine);
    }
    if (!Globals.hasPoseForwardFixed(this.engine)) {
      this._myPoseForwardFixedGlobal = this._myPoseForwardFixed;
      Globals.setPoseForwardFixed(this._myPoseForwardFixedGlobal, this.engine);
    }
  }
  start() {
    if (this._myInputManager != null) {
      this._myInputManager.start();
      this._setupMousePrevent();
      this._addGamepadCores();
    }
  }
  update(dt) {
    if (this._myInputManager != null) {
      this._myInputManager.update(dt);
    }
  }
  _setupMousePrevent() {
    if (this._myPreventMouseContextMenu) {
      this._myInputManager.getMouse().setContextMenuActive(false);
    }
    if (this._myPreventMouseMiddleButtonScroll) {
      this._myInputManager.getMouse().setMiddleButtonScrollActive(false);
    }
  }
  _addGamepadCores() {
    let leftHandPose = this._myInputManager.getLeftHandPose();
    let rightHandPose = this._myInputManager.getRightHandPose();
    let leftXRGamepadCore = new XRGamepadCore(leftHandPose);
    let rightXRGamepadCore = new XRGamepadCore(rightHandPose);
    this._myInputManager.getGamepadsManager().getLeftGamepad().addGamepadCore("pp_left_xr_gamepad", leftXRGamepadCore);
    this._myInputManager.getGamepadsManager().getRightGamepad().addGamepadCore("pp_right_xr_gamepad", rightXRGamepadCore);
    let leftKeyboardGamepadCore = new KeyboardGamepadCore(leftHandPose);
    let rightKeyboardGamepadCore = new KeyboardGamepadCore(rightHandPose);
    this._myInputManager.getGamepadsManager().getLeftGamepad().addGamepadCore("pp_left_keyboard_gamepad", leftKeyboardGamepadCore);
    this._myInputManager.getGamepadsManager().getRightGamepad().addGamepadCore("pp_right_keyboard_gamepad", rightKeyboardGamepadCore);
    let leftClassicGamepadCore = new ClassicGamepadCore(null, leftHandPose);
    let rightClassicGamepadCore = new ClassicGamepadCore(null, rightHandPose);
    this._myInputManager.getGamepadsManager().getLeftGamepad().addGamepadCore("pp_left_classic_gamepad", leftClassicGamepadCore);
    this._myInputManager.getGamepadsManager().getRightGamepad().addGamepadCore("pp_right_classic_gamepad", rightClassicGamepadCore);
  }
  onDestroy() {
    if (this._myInputManager != null && Globals.getInputManager(this.engine) == this._myInputManager) {
      Globals.removeInputManager(this.engine);
      this._myInputManager.destroy();
    }
    if (this._myPoseForwardFixedGlobal != null && Globals.isPoseForwardFixed(this.engine) == this._myPoseForwardFixedGlobal) {
      Globals.removePoseForwardFixed(this.engine);
    }
  }
};
__publicField(InputManagerComponent, "TypeName", "pp-input-manager");
__publicField(InputManagerComponent, "Properties", {
  _myPoseForwardFixed: Property.bool(true),
  _myPreventMouseContextMenu: Property.bool(true),
  _myPreventMouseMiddleButtonScroll: Property.bool(true),
  _myEnableTrackedHandPoses: Property.bool(true)
});

// js/pp/tool/cauldron/components/enable_tool_component.js
var EnableToolComponent = class extends Component {
  init() {
    this._myToolEnabled = null;
    if (!Globals.hasToolEnabled(this.engine)) {
      this._myToolEnabled = this._myEnable;
      Globals.setToolEnabled(this._myToolEnabled, this.engine);
    }
  }
  onDestroy() {
    if (this._myToolEnabled != null && Globals.isToolEnabled(this.engine) == this._myToolEnabled) {
      Globals.removeToolEnabled(this.engine);
    }
  }
};
__publicField(EnableToolComponent, "TypeName", "pp-enable-tools");
__publicField(EnableToolComponent, "Properties", {
  _myEnable: Property.bool(true)
});

// js/pp/tool/console_vr/console_original_functions.js
var _myConsoleOriginalLog = console.log;
var _myConsoleOriginalError = console.error;
var _myConsoleOriginalWarn = console.warn;
var _myConsoleOriginalInfo = console.info;
var _myConsoleOriginalDebug = console.debug;
var _myConsoleOriginalAssert = console.assert;
var _myConsoleOriginalClear = console.clear;
function log2(engine2 = Globals.getMainEngine(), ...args) {
  return ConsoleOriginalFunctions.getLog(engine2).apply(console, args);
}
function error2(engine2 = Globals.getMainEngine(), ...args) {
  return ConsoleOriginalFunctions.getError(engine2).apply(console, args);
}
function warn2(engine2 = Globals.getMainEngine(), ...args) {
  return ConsoleOriginalFunctions.getWarn(engine2).apply(console, args);
}
function info(engine2 = Globals.getMainEngine(), ...args) {
  return ConsoleOriginalFunctions.getInfo(engine2).apply(console, args);
}
function debug(engine2 = Globals.getMainEngine(), ...args) {
  return ConsoleOriginalFunctions.getDebug(engine2).apply(console, args);
}
function assert2(engine2 = Globals.getMainEngine(), ...args) {
  return ConsoleOriginalFunctions.getAssert(engine2).apply(console, args);
}
function clear2(engine2 = Globals.getMainEngine(), ...args) {
  return ConsoleOriginalFunctions.getClear(engine2).apply(console, args);
}
function getLog(engine2 = Globals.getMainEngine()) {
  return _myConsoleOriginalLog;
}
function getError(engine2 = Globals.getMainEngine()) {
  return _myConsoleOriginalError;
}
function getWarn(engine2 = Globals.getMainEngine()) {
  return _myConsoleOriginalWarn;
}
function getInfo(engine2 = Globals.getMainEngine()) {
  return _myConsoleOriginalInfo;
}
function getDebug(engine2 = Globals.getMainEngine()) {
  return _myConsoleOriginalDebug;
}
function getAssert(engine2 = Globals.getMainEngine()) {
  return _myConsoleOriginalAssert;
}
function getClear(engine2 = Globals.getMainEngine()) {
  return _myConsoleOriginalClear;
}
var ConsoleOriginalFunctions = {
  log: log2,
  error: error2,
  warn: warn2,
  info,
  debug,
  assert: assert2,
  clear: clear2,
  getLog,
  getError,
  getWarn,
  getInfo,
  getDebug,
  getAssert,
  getClear
};

// js/pp/tool/console_vr/console_vr.js
var ConsoleVR = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this._myEngine = engine2;
    this._myForwardToBrowserConsole = true;
  }
  log(...args) {
    if (this._myForwardToBrowserConsole) {
      ConsoleOriginalFunctions.log(this._myEngine, ...args);
    }
  }
  error(...args) {
    if (this._myForwardToBrowserConsole) {
      ConsoleOriginalFunctions.error(this._myEngine, ...args);
    }
  }
  warn(...args) {
    if (this._myForwardToBrowserConsole) {
      ConsoleOriginalFunctions.warn(this._myEngine, ...args);
    }
  }
  info(...args) {
    if (this._myForwardToBrowserConsole) {
      ConsoleOriginalFunctions.info(this._myEngine, ...args);
    }
  }
  debug(...args) {
    if (this._myForwardToBrowserConsole) {
      ConsoleOriginalFunctions.debug(this._myEngine, ...args);
    }
  }
  assert(...args) {
    if (this._myForwardToBrowserConsole) {
      ConsoleOriginalFunctions.assert(this._myEngine, ...args);
    }
  }
  clear(...args) {
    if (this._myForwardToBrowserConsole) {
      ConsoleOriginalFunctions.clear(this._myEngine, ...args);
    }
  }
  setForwardToBrowserConsole(forwardToBrowserConsole) {
    this._myForwardToBrowserConsole = forwardToBrowserConsole;
  }
  isForwardToBrowserConsole() {
    return this._myForwardToBrowserConsole;
  }
};

// js/pp/tool/console_vr/components/init_console_vr_component.js
var InitConsoleVRComponent = class extends Component {
  init() {
    this._myConsoleVR = null;
    if (this._myInit) {
      if (!Globals.hasConsoleVR(this.engine)) {
        this._myConsoleVR = new ConsoleVR(this.engine);
        Globals.setConsoleVR(this._myConsoleVR, this.engine);
      }
    }
  }
  onDestroy() {
    if (this._myConsoleVR != null && Globals.getConsoleVR(this.engine) == this._myConsoleVR) {
      Globals.removeConsoleVR(this.engine);
    }
  }
};
__publicField(InitConsoleVRComponent, "TypeName", "pp-init-console-vr");
__publicField(InitConsoleVRComponent, "Properties", {
  _myInit: Property.bool(true)
});

// js/pp/tool/easy_tune/easy_tune_variables.js
var EasyTuneVariables = class {
  constructor() {
    this._myVariables = /* @__PURE__ */ new Map();
  }
  add(variable, overwriteCurrentOne = false) {
    if (overwriteCurrentOne || !this._myVariables.has(variable.getName())) {
      this._myVariables.set(variable.getName(), variable);
    }
  }
  remove(variableName) {
    this._myVariables.delete(variableName);
  }
  get(variableName) {
    let variable = this._myVariables.get(variableName);
    if (variable) {
      return variable.getValue();
    }
    return null;
  }
  set(variableName, value, resetDefaultValue = false) {
    let variable = this._myVariables.get(variableName);
    if (variable) {
      variable.setValue(value, resetDefaultValue);
    }
  }
  has(variableName) {
    return this._myVariables.has(variableName);
  }
  length() {
    return this._myVariables.size;
  }
  isWidgetCurrentVariable(variableName) {
    let variable = this._myVariables.get(variableName);
    if (variable) {
      return variable.isWidgetCurrentVariable();
    }
    return false;
  }
  getEasyTuneVariable(variableName) {
    return this._myVariables.get(variableName);
  }
  getEasyTuneVariablesList() {
    return Array.from(this._myVariables.values());
  }
  getEasyTuneVariablesNames() {
    return Array.from(this._myVariables.keys());
  }
  fromJSON(json, resetDefaultValue = false) {
    let objectJSON = JSON.parse(json);
    for (let variable of this._myVariables.values()) {
      let variableValueJSON = objectJSON[variable.getName()];
      if (variableValueJSON !== void 0) {
        variable.fromJSON(variableValueJSON, resetDefaultValue);
      }
    }
  }
  toJSON() {
    let objectJSON = {};
    for (let variable of this._myVariables.values()) {
      objectJSON[variable.getName()] = variable.toJSON();
    }
    return JSON.stringify(objectJSON);
  }
  registerValueChangedEventListener(variableName, callbackID, callback) {
    this._myVariables.get(variableName).registerValueChangedEventListener(callbackID, callback);
  }
  unregisterValueChangedEventListener(variableName, callbackID, callback) {
    this._myVariables.get(variableName).unregisterValueChangedEventListener(callbackID);
  }
};

// js/pp/tool/easy_tune/components/init_easy_tune_variables_component.js
var InitEasyTuneVariablesComponent = class extends Component {
  init() {
    this._myEasyTuneVariables = null;
    if (this._myInit) {
      if (!Globals.hasEasyTuneVariables(this.engine)) {
        this._myEasyTuneVariables = new EasyTuneVariables();
        Globals.setEasyTuneVariables(this._myEasyTuneVariables, this.engine);
      }
    }
  }
  onDestroy() {
    if (this._myEasyTuneVariables != null && Globals.getEasyTuneVariables(this.engine) == this._myEasyTuneVariables) {
      Globals.removeEasyTuneVariables(this.engine);
    }
  }
};
__publicField(InitEasyTuneVariablesComponent, "TypeName", "pp-init-easy-tune-variables");
__publicField(InitEasyTuneVariablesComponent, "Properties", {
  _myInit: Property.bool(true)
});

// js/pp/pp/components/add_pp_to_window_component.js
var AddPPToWindowComponent = class extends Component {
  init() {
    if (this._myAdd) {
      Globals.getWindow(this.engine).PP = {};
      this._addProperties(pp_exports);
    }
  }
  _addProperties(object) {
    let propertyNames = Object.getOwnPropertyNames(object);
    for (let propertyName of propertyNames) {
      if (object[propertyName] != void 0) {
        Globals.getWindow(this.engine).PP[propertyName] = object[propertyName];
      }
    }
  }
  onDestroy() {
    Globals.getWindow(this.engine).PP = void 0;
  }
};
__publicField(AddPPToWindowComponent, "TypeName", "pp-add-pp-to-window");
__publicField(AddPPToWindowComponent, "Properties", {
  _myAdd: Property.bool(true)
});

// js/pp/pp/components/get_default_resources_component.js
var GetDefaultResourcesComponent = class extends Component {
  init() {
    this._myDefaultResources = null;
    if (!Globals.hasDefaultResources(this.engine)) {
      this._myDefaultResources = new DefaultResources();
      this._myDefaultResources.myMeshes.myPlane = MeshUtils.clone(this._myPlane);
      this._myDefaultResources.myMeshes.myCube = MeshUtils.clone(this._myCube);
      this._myDefaultResources.myMeshes.mySphere = MeshUtils.clone(this._mySphere);
      this._myDefaultResources.myMeshes.myCone = MeshUtils.clone(this._myCone);
      this._myDefaultResources.myMeshes.myCylinder = MeshUtils.clone(this._myCylinder);
      this._myDefaultResources.myMeshes.myCircle = MeshUtils.clone(this._myCircle);
      this._myDefaultResources.myMeshes.myInvertedCube = MeshUtils.invert(this._myCube);
      this._myDefaultResources.myMeshes.myInvertedSphere = MeshUtils.invert(this._mySphere);
      this._myDefaultResources.myMeshes.myInvertedCone = MeshUtils.invert(this._myCone);
      this._myDefaultResources.myMeshes.myInvertedCylinder = MeshUtils.invert(this._myCylinder);
      this._myDefaultResources.myMeshes.myDoubleSidedPlane = MeshUtils.makeDoubleSided(this._myPlane);
      this._myDefaultResources.myMeshes.myDoubleSidedCube = MeshUtils.makeDoubleSided(this._myCube);
      this._myDefaultResources.myMeshes.myDoubleSidedSphere = MeshUtils.makeDoubleSided(this._mySphere);
      this._myDefaultResources.myMeshes.myDoubleSidedCone = MeshUtils.makeDoubleSided(this._myCone);
      this._myDefaultResources.myMeshes.myDoubleSidedCylinder = MeshUtils.makeDoubleSided(this._myCylinder);
      this._myDefaultResources.myMeshes.myDoubleSidedCircle = MeshUtils.makeDoubleSided(this._myCircle);
      if (this._myFlatOpaque != null) {
        this._myDefaultResources.myMaterials.myFlatOpaque = this._myFlatOpaque.clone();
      }
      if (this._myFlatTransparentNoDepth != null) {
        this._myDefaultResources.myMaterials.myFlatTransparentNoDepth = this._myFlatTransparentNoDepth.clone();
      }
      if (this._myPhongOpaque != null) {
        this._myDefaultResources.myMaterials.myPhongOpaque = this._myPhongOpaque.clone();
      }
      if (this._myText != null) {
        this._myDefaultResources.myMaterials.myText = this._myText.clone();
      }
      Globals.setDefaultResources(this._myDefaultResources, this.engine);
    }
  }
  onDestroy() {
    if (this._myDefaultResources != null && Globals.getDefaultResources(this.engine) == this._myDefaultResources) {
      Globals.removeDefaultResources(this.engine);
    }
  }
};
__publicField(GetDefaultResourcesComponent, "TypeName", "pp-get-default-resources");
__publicField(GetDefaultResourcesComponent, "Properties", {
  _myPlane: Property.mesh(),
  _myCube: Property.mesh(),
  _mySphere: Property.mesh(),
  _myCone: Property.mesh(),
  _myCylinder: Property.mesh(),
  _myCircle: Property.mesh(),
  _myFlatOpaque: Property.material(),
  _myFlatTransparentNoDepth: Property.material(),
  _myPhongOpaque: Property.material(),
  _myText: Property.material()
});

// js/pp/pp/components/get_scene_objects_component.js
var GetSceneObjectsComponent = class extends Component {
  init() {
    this._mySceneObjects = null;
    if (!Globals.hasSceneObjects(this.engine)) {
      this._mySceneObjects = new SceneObjects();
      this._mySceneObjects.myScene = this._myScene;
      this._mySceneObjects.myPlayerObjects.myPlayer = this._myPlayer;
      this._mySceneObjects.myPlayerObjects.myReferenceSpace = this._myReferenceSpace;
      this._mySceneObjects.myPlayerObjects.myCameraNonXR = this._myCameraNonXR;
      this._mySceneObjects.myPlayerObjects.myEyeLeft = this._myEyeLeft;
      this._mySceneObjects.myPlayerObjects.myEyeRight = this._myEyeRight;
      this._mySceneObjects.myPlayerObjects.myHandLeft = this._myHandLeft;
      this._mySceneObjects.myPlayerObjects.myHandRight = this._myHandRight;
      this._mySceneObjects.myPlayerObjects.myEyes = [];
      this._mySceneObjects.myPlayerObjects.myEyes[Handedness.LEFT] = this._myEyeLeft;
      this._mySceneObjects.myPlayerObjects.myEyes[Handedness.RIGHT] = this._myEyeRight;
      this._mySceneObjects.myPlayerObjects.myHands = [];
      this._mySceneObjects.myPlayerObjects.myHands[Handedness.LEFT] = this._myHandLeft;
      this._mySceneObjects.myPlayerObjects.myHands[Handedness.RIGHT] = this._myHandRight;
      this._mySceneObjects.myPlayerObjects.myHead = this._myHead;
      if (this._mySceneObjects.myPlayerObjects.myReferenceSpace == null) {
        this._mySceneObjects.myPlayerObjects.myReferenceSpace = this._mySceneObjects.myPlayerObjects.myPlayer;
      }
      this._mySceneObjects.myCauldron = this._mySceneObjects.myScene.pp_addObject();
      this._mySceneObjects.myCauldron.pp_setName("Cauldron");
      this._mySceneObjects.myDynamics = this._mySceneObjects.myScene.pp_addObject();
      this._mySceneObjects.myDynamics.pp_setName("Dynamics");
      this._mySceneObjects.myParticles = this._mySceneObjects.myScene.pp_addObject();
      this._mySceneObjects.myParticles.pp_setName("Particles");
      this._mySceneObjects.myVisualElements = this._mySceneObjects.myScene.pp_addObject();
      this._mySceneObjects.myVisualElements.pp_setName("Visual Elements");
      this._mySceneObjects.myTools = this._mySceneObjects.myScene.pp_addObject();
      this._mySceneObjects.myTools.pp_setName("Tools");
      this._mySceneObjects.myPlayerObjects.myCauldron = this._mySceneObjects.myPlayerObjects.myPlayer.pp_addObject();
      this._mySceneObjects.myPlayerObjects.myCauldron.pp_setName("Cauldron");
      this._mySceneObjects.myPlayerObjects.myHeadDebugs = this._mySceneObjects.myPlayerObjects.myHead.pp_addObject();
      this._mySceneObjects.myPlayerObjects.myHeadDebugs.pp_setName("Head Debugs");
      Globals.setSceneObjects(this._mySceneObjects, this.engine);
    }
  }
  onDestroy() {
    if (this._mySceneObjects != null && Globals.getSceneObjects(this.engine) == this._mySceneObjects) {
      Globals.removeSceneObjects(this.engine);
    }
  }
};
__publicField(GetSceneObjectsComponent, "TypeName", "pp-get-scene-objects");
__publicField(GetSceneObjectsComponent, "Properties", {
  _myScene: Property.object(),
  _myPlayer: Property.object(),
  _myReferenceSpace: Property.object(),
  // If u don't have a pivot under the player you set this to null, by default will be the same as the player
  _myCameraNonXR: Property.object(),
  _myEyeLeft: Property.object(),
  _myEyeRight: Property.object(),
  _myHandLeft: Property.object(),
  _myHandRight: Property.object(),
  _myHead: Property.object()
});

// js/pp/pp/components/pp_gateway_component.js
var _myRegisteredEngines = /* @__PURE__ */ new WeakMap();
var PPGatewayComponent = class extends Component {
  static onRegister(engine2) {
    if (!_myRegisteredEngines.has(engine2)) {
      _myRegisteredEngines.set(engine2, null);
      initPP(engine2);
    }
  }
  init() {
    this._myGetDefaultResourcesComponent = this.object.pp_addComponent(GetDefaultResourcesComponent, this._getProperties(GetDefaultResourcesComponent.Properties), false);
    this._myGetSceneObjectsComponent = this.object.pp_addComponent(GetSceneObjectsComponent, this._getProperties(GetSceneObjectsComponent.Properties), false);
    this._myEnableDebugComponent = null;
    if (this._myEnableDebug) {
      this._myEnableDebugComponent = this.object.pp_addComponent(EnableDebugComponent, false);
    }
    this._myEnableToolComponent = null;
    if (this._myEnableTool) {
      this._myEnableToolComponent = this.object.pp_addComponent(EnableToolComponent, false);
    }
    this._myAddPPToWindowComponent = null;
    if (this._myAddPPToWindow) {
      this._myAddPPToWindowComponent = this.object.pp_addComponent(AddPPToWindowComponent, false);
    }
    this._myAddWLToWindowComponent = null;
    if (this._myAddWLToWindow) {
      this._myAddWLToWindowComponent = this.object.pp_addComponent(AddWLToWindowComponent, false);
    }
    this._myInitConsoleVRComponent = this.object.pp_addComponent(InitConsoleVRComponent, false);
    this._myInitEasyTuneVariablesComponent = this.object.pp_addComponent(InitEasyTuneVariablesComponent, false);
    this._myObjectPoolManagerComponent = this.object.pp_addComponent(ObjectPoolManagerComponent, this._getProperties(ObjectPoolManagerComponent.Properties), false);
    this._myInputManagerComponent = this.object.pp_addComponent(InputManagerComponent, this._getProperties(InputManagerComponent.Properties), false);
    this._myAudioManagerComponent = this.object.pp_addComponent(AudioManagerComponent, this._getProperties(AudioManagerComponent.Properties), false);
    this._myVisualManagerComponent = this.object.pp_addComponent(VisualManagerComponent, this._getProperties(VisualManagerComponent.Properties), false);
    this._myDebugManagerComponent = this.object.pp_addComponent(DebugManagerComponent, this._getProperties(DebugManagerComponent.Properties), false);
  }
  start() {
    this._myGetDefaultResourcesComponent.active = true;
    this._myGetSceneObjectsComponent.active = true;
    if (this._myEnableDebugComponent != null) {
      this._myEnableDebugComponent.active = true;
    }
    if (this._myEnableToolComponent != null) {
      this._myEnableToolComponent.active = true;
    }
    if (this._myAddPPToWindowComponent != null) {
      this._myAddPPToWindowComponent.active = true;
    }
    if (this._myAddWLToWindowComponent != null) {
      this._myAddWLToWindowComponent.active = true;
    }
    this._myInitConsoleVRComponent.active = true;
    this._myInitEasyTuneVariablesComponent.active = true;
    this._myObjectPoolManagerComponent.active = true;
    this._myInputManagerComponent.active = true;
    this._myAudioManagerComponent.active = true;
    this._myVisualManagerComponent.active = true;
    this._myDebugManagerComponent.active = true;
  }
  _getProperties(propertiesToGet) {
    let properties = {};
    let propertyNames = Object.getOwnPropertyNames(propertiesToGet);
    for (let propertyName of propertyNames) {
      if (this[propertyName] != void 0) {
        properties[propertyName] = this[propertyName];
      }
    }
    return properties;
  }
};
__publicField(PPGatewayComponent, "TypeName", "pp-gateway");
__publicField(PPGatewayComponent, "Properties", {
  _myEnableDebug: Property.bool(true),
  _myEnableTool: Property.bool(true),
  _myAddPPToWindow: Property.bool(true),
  _myAddWLToWindow: Property.bool(true),
  ...InputManagerComponent.Properties,
  ...AudioManagerComponent.Properties,
  ...VisualManagerComponent.Properties,
  ...ObjectPoolManagerComponent.Properties,
  ...DebugManagerComponent.Properties,
  ...GetSceneObjectsComponent.Properties,
  ...GetDefaultResourcesComponent.Properties
});

// js/pp/audio/audio_utils.js
var import_howler5 = __toESM(require_howler(), 1);
function isPlaybackBlocked() {
  let blocked = false;
  if (import_howler5.Howler != null && import_howler5.Howler.state != "running") {
    blocked = true;
  }
  return blocked;
}
var AudioUtils = {
  isPlaybackBlocked
};

// js/pp/audio/howler/howler_audio_player.js
var HowlerAudioPlayer = class extends AudioPlayer {
  constructor(howl, audioSetup = null) {
    super(audioSetup, howl);
    if (audioSetup == null) {
      this._myAudioSetup.myAudioFilePath = this._myAudio._src;
      this._myAudioSetup.myLoop = this._myAudio._loop;
      this._myAudioSetup.myAutoPlay = this._myAudio._autoplay;
      this._myAudioSetup.myVolume = this._myAudio._volume;
      this._myAudioSetup.myRate = this._myAudio._rate;
      this._myAudioSetup.myPool = this._myAudio._pool;
      this._myAudioSetup.myPreload = this._myAudio._preload;
      this._myAudioSetup.myPosition = this._myAudio._pos != null ? this._myAudio._pos.vec3_clone() : null;
      this._myAudioSetup.mySpatial = this._myAudio._pos != null;
      this._myAudioSetup.myReferenceDistance = this._myAudio._pannerAttr.refDistance;
    } else {
      this._myAudioSetup.myAudioFilePath = this._myAudio._src;
      this._myAudio.loop(this._myAudioSetup.myLoop);
      this._myAudio._autoplay = this._myAudioSetup.myAutoPlay;
      this._myAudio.volume(this._myAudioSetup.myVolume);
      this._myAudio.rate(this._myAudioSetup.myRate);
      this._myAudio._pool = this._myAudioSetup.myPool;
      this._myAudio._preload = this._myAudioSetup.myPreload;
      this.updatePosition(this._myAudioSetup.myPosition);
      this._myAudio._pannerAttr.refDistance = this._myAudioSetup.myReferenceDistance;
      if (this._myAudioSetup.myAutoPlay) {
        this._myAudio.play();
      }
    }
    this._addListeners();
  }
};

// js/pp/audio/components/mute_everything_component.js
var import_howler6 = __toESM(require_howler(), 1);
var MuteEverythingComponent = class extends Component {
  start() {
    import_howler6.Howler.mute(true);
  }
};
__publicField(MuteEverythingComponent, "TypeName", "pp-mute-everything");
__publicField(MuteEverythingComponent, "Properties", {});

// js/pp/audio/components/spatial_audio_listener_component.js
var import_howler7 = __toESM(require_howler(), 1);
var SpatialAudioListenerComponent = class extends Component {
  init() {
    this._myOrigin = vec3_create();
    this._myForward = vec3_create();
    this._myUp = vec3_create();
  }
  start() {
    this._updateAudioListener();
  }
  update(dt) {
    this._updateAudioListener();
  }
  _updateAudioListener() {
    this.object.pp_getPosition(this._myOrigin);
    this.object.pp_getForward(this._myForward);
    this.object.pp_getUp(this._myUp);
    import_howler7.Howler.pos(this._myOrigin[0], this._myOrigin[1], this._myOrigin[2]);
    import_howler7.Howler.orientation(
      this._myForward[0],
      this._myForward[1],
      this._myForward[2],
      this._myUp[0],
      this._myUp[1],
      this._myUp[2]
    );
  }
};
__publicField(SpatialAudioListenerComponent, "TypeName", "pp-spatial-audio-listener");
__publicField(SpatialAudioListenerComponent, "Properties", {});

// js/pp/cauldron/physics/physics_collision_collector.js
var PhysicsCollisionCollector = class {
  constructor(physXComponent, trigger = false) {
    this._myPhysX = physXComponent;
    this._myTrigger = trigger;
    this._myCollisions = [];
    this._myCollisionsStart = [];
    this._myCollisionsEnd = [];
    this._myUpdateActive = false;
    this._myCollisionsStartToProcess = [];
    this._myCollisionsEndToProcess = [];
    this._myCollisionCallbackID = null;
    this._myActive = false;
    this.setActive(true);
    this._myLogEnabled = false;
    this._myTriggerDesyncFixDelay = new Timer(0.1);
    this._myCollisionEmitter = new Emitter();
    this._myCollisionStartEmitter = new Emitter();
    this._myCollisionEndEmitter = new Emitter();
    this._myDestroyed = false;
  }
  getPhysX() {
    return this._myPhysX;
  }
  getCollisions() {
    return this._myCollisions;
  }
  getCollisionsStart() {
    return this._myCollisionsStart;
  }
  getCollisionsEnd() {
    return this._myCollisionsEnd;
  }
  isActive() {
    return this._myActive;
  }
  setActive(active) {
    if (this._myActive != active) {
      this._myActive = active;
      this._myCollisions.pp_clear();
      this._myCollisionsStart.pp_clear();
      this._myCollisionsEnd.pp_clear();
      this._myUpdateActive = false;
      this._myCollisionsStartToProcess.pp_clear();
      this._myCollisionsEndToProcess.pp_clear();
      if (this._myActive) {
        this._myCollisionCallbackID = this._myPhysX.onCollision(this._onCollision.bind(this));
      } else if (this._myCollisionCallbackID != null) {
        this._myPhysX.removeCollisionCallback(this._myCollisionCallbackID);
        this._myCollisionCallbackID = null;
      }
    }
  }
  // Set to true only if u are going to actually update this object and don't want to lose any collision start/end events prior to updating the first time after activation
  setUpdateActive(active) {
    this._myUpdateActive = active;
  }
  // Update is not mandatory, use it only if u want to access collisions start and end
  update(dt) {
    if (!this._myActive) {
      return;
    }
    this._myUpdateActive = true;
    let prevCollisionsStartToProcess = this._myCollisionsStartToProcess;
    this._myCollisionsStartToProcess = this._myCollisionsStart;
    this._myCollisionsStartToProcess.pp_clear();
    this._myCollisionsStart = prevCollisionsStartToProcess;
    let prevCollisionsEndToProcess = this._myCollisionsEndToProcess;
    this._myCollisionsEndToProcess = this._myCollisionsEnd;
    this._myCollisionsEndToProcess.pp_clear();
    this._myCollisionsEnd = prevCollisionsEndToProcess;
    if (this._myTrigger) {
      this._triggerDesyncFix(dt);
    }
  }
  isLogEnabled() {
    return this._myLogEnabled;
  }
  setLogEnabled(enabled) {
    this._myLogEnabled = enabled;
  }
  registerCollisionEventListener(id, listener) {
    this._myCollisionEmitter.add(listener, { id });
  }
  unregisterCollisionEventListener(id) {
    this._myCollisionEmitter.remove(id);
  }
  registerCollisionStartEventListener(id, listener) {
    this._myCollisionStartEmitter.add(listener, { id });
  }
  unregisterCollisionStartEventListener(id) {
    this._myCollisionStartEmitter.remove(id);
  }
  registerCollisionEndEventListener(id, listener) {
    this._myCollisionEndEmitter.add(listener, { id });
  }
  unregisterCollisionEndEventListener(id) {
    this._myCollisionEndEmitter.remove(id);
  }
  _onCollision(type, physXComponent) {
    if (type == CollisionEventType.Touch || type == CollisionEventType.TriggerTouch) {
      this._onCollisionStart(type, physXComponent);
    } else if (type == CollisionEventType.TouchLost || type == CollisionEventType.TriggerTouchLost) {
      this._onCollisionEnd(type, physXComponent);
    }
    this._myCollisionEmitter.notify(this._myPhysX, physXComponent, type);
  }
  _onCollisionStart(type, physXComponent) {
    if (this._myLogEnabled) {
      let objectFound = false;
      for (let object of this._myCollisions) {
        if (object.pp_equals(physXComponent.object)) {
          objectFound = true;
          break;
        }
      }
      if (objectFound) {
        console.error("Collision Start on object already collected");
      }
    }
    this._myCollisions.push(physXComponent.object);
    if (this._myUpdateActive) {
      this._myCollisionsStartToProcess.push(physXComponent.object);
      this._myCollisionsEndToProcess.pp_removeAll(function(element) {
        return element.pp_equals(physXComponent.object);
      });
    }
    if (this._myLogEnabled) {
      console.log("Collision Start -", this._myCollisions.length);
    }
    this._myCollisionStartEmitter.notify(this._myPhysX, physXComponent, type);
  }
  _onCollisionEnd(type, physXComponent) {
    if (this._myLogEnabled) {
      let objectFound = false;
      for (let object of this._myCollisions) {
        if (object.pp_equals(physXComponent.object)) {
          objectFound = true;
          break;
        }
      }
      if (!objectFound) {
        console.error("Collision End on object not collected");
      }
    }
    this._myCollisions.pp_removeAll(function(element) {
      return element.pp_equals(physXComponent.object);
    });
    if (this._myUpdateActive) {
      this._myCollisionsEndToProcess.push(physXComponent.object);
      this._myCollisionsStartToProcess.pp_removeAll(function(element) {
        return element.pp_equals(physXComponent.object);
      });
    }
    if (this._myLogEnabled) {
      console.log("Collision End -", this._myCollisions.length);
    }
    this._myCollisionEndEmitter.notify(this._myPhysX, physXComponent, type);
  }
  _triggerDesyncFix(dt) {
  }
  destroy() {
    this._myDestroyed = true;
    if (this._myCollisionCallbackID != null) {
      this._myPhysX.removeCollisionCallback(this._myCollisionCallbackID);
      this._myCollisionCallbackID = null;
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
PhysicsCollisionCollector.prototype._triggerDesyncFix = function() {
  let findAllCallback = function(element) {
    let physX = element.pp_getComponentSelf(PhysXComponent);
    return physX == null || !physX.active;
  };
  return function _triggerDesyncFix(dt) {
    this._myTriggerDesyncFixDelay.update(dt);
    if (this._myTriggerDesyncFixDelay.isDone()) {
      this._myTriggerDesyncFixDelay.start();
      let collisionsToEnd = this._myCollisions.pp_findAll(findAllCallback);
      if (collisionsToEnd.length > 0) {
        for (let i = 0; i < collisionsToEnd.length; i++) {
          let collision = collisionsToEnd[i];
          let physX = collision.pp_getComponentSelf(PhysXComponent);
          if (physX) {
            this._onCollisionEnd(CollisionEventType.TriggerTouchLost, physX);
          } else {
            console.error("NO PHYSX, HOW?");
          }
        }
      }
    }
  };
}();

// js/pp/cauldron/benchmarks/benchmark_max_physx_component.js
var BenchmarkMaxPhysXComponent = class extends Component {
  start() {
    this._myValid = false;
    if (!Globals.isDebugEnabled(this.engine))
      return;
    this._myValid = true;
    this._myStarted = false;
    this._myPreStartTimer = new Timer(1);
  }
  _start() {
    this._myParentObject = this.object.pp_addObject();
    this._myRaycastParams = new RaycastParams(Globals.getPhysics(this.engine));
    this._myRaycastResults = new RaycastResults();
    this._myStaticPhysXObjects = [];
    this._myStaticPhysXComponents = [];
    this._myStaticPhysXCollectors = [];
    this._myDynamicPhysXObjects = [];
    this._myDynamicPhysXComponents = [];
    this._myDynamicPhysXCollectors = [];
    this._myKinematicPhysXObjects = [];
    this._myKinematicPhysXComponents = [];
    this._myKinematicPhysXCollectors = [];
    this._spawnDome(true, false);
    this._spawnDome(false, false);
    this._spawnDome(false, true);
    this._myStartTimer = new Timer(1);
    this._myTimer = new Timer(0);
    this._myDebugTimer = new Timer(this._myVisualizeRaycastDelay);
    this._myLogEnabledTimer = new Timer(1);
    this._myFPSHistory = [];
    for (let i = 0; i < 7; i++) {
      this._myFPSHistory.push(0);
    }
    this._myAddVelocityDelay = 10;
    this._myTranslateVec3 = vec3_create();
    this._myRotateVec3 = vec3_create();
    this._myStarted = true;
  }
  update(dt) {
    if (!this._myValid)
      return;
    if (!this._myStarted) {
      this._myPreStartTimer.update(dt);
      if (this._myPreStartTimer.isDone()) {
        this._start();
      }
    } else {
      this._myStartTimer.update(dt);
      if (this._myStartTimer.isDone()) {
        this._myTimer.update(dt);
        this._myDebugTimer.update(dt);
        this._myLogEnabledTimer.update(dt);
        if (this._myTimer.isDone()) {
          this._myTimer.start();
          let debugEnabled = false;
          if (this._myDebugTimer.isDone()) {
            this._myDebugTimer.start();
            debugEnabled = true;
          }
          debugEnabled = debugEnabled && this._myVisualizeRaycast;
          this._raycastTest(debugEnabled);
        }
        this._myFPSHistory.pop();
        this._myFPSHistory.unshift(Math.round(1 / dt));
        if (this._myLogEnabled) {
          if (this._myLogEnabledTimer.isDone()) {
            this._myLogEnabledTimer.start();
            if (this._myClearConsoleBeforeLog) {
              console.clear();
            }
            console.log("Static PhysX Dome Size:", this._myStaticPhysXObjects.length);
            console.log("Dynamic PhysX Dome Size:", this._myDynamicPhysXObjects.length);
            console.log("Kinematic PhysX Dome Size:", this._myKinematicPhysXObjects.length);
            let staticCollisions = 0;
            for (let collector of this._myStaticPhysXCollectors) {
              staticCollisions += collector.getCollisions().length;
            }
            let dynamicCollisions = 0;
            for (let collector of this._myDynamicPhysXCollectors) {
              dynamicCollisions += collector.getCollisions().length;
            }
            let kinematicCollisions = 0;
            for (let collector of this._myKinematicPhysXCollectors) {
              kinematicCollisions += collector.getCollisions().length;
            }
            let totalCollisions = (staticCollisions + dynamicCollisions + kinematicCollisions) / 2;
            console.log("Current Collisions Count:", totalCollisions);
            console.log("Raycast Count:", this._myRaycastCount);
            console.log("FPS History:");
            let fpsString = "";
            for (let fps of this._myFPSHistory) {
              fpsString = fpsString.concat(fps, "\n");
            }
            console.log(fpsString);
          }
        }
      }
      if (this._myAddVelocityDelay > 0) {
        this._myAddVelocityDelay--;
        if (this._myAddVelocityDelay == 0) {
          for (let physX of this._myDynamicPhysXComponents) {
            physX.kinematic = false;
            let strength = 50;
            physX.linearVelocity = [Math.pp_random(-strength, strength), Math.pp_random(-strength, strength), Math.pp_random(-strength, strength)];
            physX.angularVelocity = [Math.pp_random(-strength, strength), Math.pp_random(-strength, strength), Math.pp_random(-strength, strength)];
          }
        }
      }
      for (let physX of this._myKinematicPhysXObjects) {
        let strength = 5 * dt;
        this._myTranslateVec3.vec3_set(Math.pp_random(-strength, strength), Math.pp_random(-strength, strength), Math.pp_random(-strength, strength));
        physX.pp_translate(this._myTranslateVec3);
        let rotateStrength = 50 * dt;
        this._myRotateVec3.vec3_set(Math.pp_random(-rotateStrength, rotateStrength), Math.pp_random(-rotateStrength, rotateStrength), Math.pp_random(-rotateStrength, rotateStrength));
        physX.pp_rotate(this._myRotateVec3);
      }
    }
  }
  _raycastTest(debugEnabled) {
    let raycastCount = this._myRaycastCount;
    let distance5 = 1e4;
    for (let i = 0; i < raycastCount; i++) {
      let origin = [Math.pp_random(1, 2) * Math.pp_randomSign(), Math.pp_random(1, 2) * Math.pp_randomSign(), Math.pp_random(1, 2) * Math.pp_randomSign()];
      let direction2 = [Math.pp_random(-1, 1), Math.pp_random(-1, 1), Math.pp_random(-1, 1)];
      direction2.vec3_normalize(direction2);
      this._myRaycastParams.myOrigin.vec3_copy(origin);
      this._myRaycastParams.myDirection.vec3_copy(direction2);
      this._myRaycastParams.myDistance = distance5;
      this._myRaycastParams.myBlockLayerFlags.setAllFlagsActive();
      let raycastResults = PhysicsUtils.raycast(this._myRaycastParams, this._myRaycastResults);
      if (debugEnabled && Globals.isDebugEnabled(this.engine)) {
        Globals.getDebugVisualManager(this.engine).drawRaycast(this._myDebugTimer.getDuration(), raycastResults, true, 5, 0.015);
      }
    }
  }
  _spawnDome(staticDome, dynamicDome) {
    let maxCount = this._myStaticPhysXCount;
    let physXList = this._myStaticPhysXObjects;
    let cloves = Math.ceil(Math.sqrt(this._myStaticPhysXCount));
    if (!staticDome) {
      if (dynamicDome) {
        cloves = Math.ceil(Math.sqrt(this._myDynamicPhysXCount));
        maxCount = this._myDynamicPhysXCount;
        physXList = this._myDynamicPhysXObjects;
      } else {
        cloves = Math.ceil(Math.sqrt(this._myKinematicPhysXCount));
        maxCount = this._myKinematicPhysXCount;
        physXList = this._myKinematicPhysXObjects;
      }
    }
    let angleForClove = Math.PI * 2 / cloves;
    let minDistance = Math.max(0, this._myStaticDomeSize - 20);
    let maxDistance = this._myStaticDomeSize + 20;
    if (!staticDome) {
      if (dynamicDome) {
        minDistance = Math.max(0, this._myDynamicDomeSize - 20);
        maxDistance = this._myDynamicDomeSize + 20;
      } else {
        minDistance = Math.max(0, this._myKinematicDomeSize - 20);
        maxDistance = this._myKinematicDomeSize + 20;
      }
    }
    let minExtraRotation = 0;
    let maxExtraRotation = Math.pp_toRadians(10);
    let upDirection = vec3_create(0, 1, 0);
    let horizontalDirection = vec3_create(0, 0, -1);
    for (let i = 0; i < cloves / 2; i++) {
      let verticalDirection = vec3_create(0, 1, 0);
      let rotationAxis = vec3_create();
      horizontalDirection.vec3_cross(verticalDirection, rotationAxis);
      rotationAxis.vec3_normalize(rotationAxis);
      for (let j = 0; j < cloves; j++) {
        if (physXList.length < maxCount) {
          let distance5 = Math.random() * (maxDistance - minDistance) + minDistance;
          let extraAxisRotation = (Math.random() * 2 - 1) * (maxExtraRotation - minExtraRotation) + minExtraRotation;
          let extraUpRotation = (Math.random() * 2 - 1) * (maxExtraRotation - minExtraRotation) + minExtraRotation;
          let physXDirection = verticalDirection.pp_clone();
          physXDirection.vec3_rotateAxisRadians(extraAxisRotation, rotationAxis, physXDirection);
          physXDirection.vec3_rotateAxisRadians(extraUpRotation, upDirection, physXDirection);
          physXDirection.vec3_scale(distance5, physXDirection);
          this._addPhysX(physXDirection, staticDome, dynamicDome);
        }
        verticalDirection.vec3_rotateAxisRadians(angleForClove / 2, rotationAxis, verticalDirection);
        if (physXList.length < maxCount) {
          let distance5 = Math.random() * (maxDistance - minDistance) + minDistance;
          let extraAxisRotation = (Math.random() * 2 - 1) * (maxExtraRotation - minExtraRotation) + minExtraRotation;
          let extraUpRotation = (Math.random() * 2 - 1) * (maxExtraRotation - minExtraRotation) + minExtraRotation;
          let physXDirection = verticalDirection.pp_clone();
          physXDirection.vec3_rotateAxisRadians(extraAxisRotation, rotationAxis, physXDirection);
          physXDirection.vec3_rotateAxisRadians(extraUpRotation, upDirection, physXDirection);
          physXDirection.vec3_scale(distance5, physXDirection);
          this._addPhysX(physXDirection, staticDome, dynamicDome);
        }
        verticalDirection.vec3_rotateAxisRadians(angleForClove / 2, rotationAxis, verticalDirection);
      }
      horizontalDirection.vec3_rotateAxisRadians(angleForClove, upDirection, horizontalDirection);
    }
  }
  _addPhysX(physXDirection, staticDome, dynamicDome) {
    let position = physXDirection;
    let scale11 = Math.pp_random(1, 10);
    let shape = Math.pp_randomPick(Shape.Sphere, Shape.Box);
    if (this._myUseConvexMesh) {
      shape = Shape.ConvexMesh;
      scale11 *= this._myShapeScaleMultiplier;
    }
    let physX = this._myParentObject.pp_addObject();
    physX.pp_setPosition(position);
    let physXComponent = physX.pp_addComponent(PhysXComponent, {
      "shape": shape,
      "shapeData": { index: this._myShapeIndex },
      "extents": vec3_create(scale11, scale11, scale11),
      "static": staticDome,
      "kinematic": !dynamicDome,
      "mass": 1
    });
    if (staticDome) {
      this._myStaticPhysXObjects.push(physX);
      this._myStaticPhysXComponents.push(physXComponent);
      this._myStaticPhysXCollectors.push(new PhysicsCollisionCollector(physXComponent));
    } else if (dynamicDome) {
      this._myDynamicPhysXObjects.push(physX);
      this._myDynamicPhysXComponents.push(physXComponent);
      this._myDynamicPhysXCollectors.push(new PhysicsCollisionCollector(physXComponent));
    } else {
      this._myKinematicPhysXObjects.push(physX);
      this._myKinematicPhysXComponents.push(physXComponent);
      this._myKinematicPhysXCollectors.push(new PhysicsCollisionCollector(physXComponent));
    }
  }
  onDestroy() {
    for (let collector of this._myStaticPhysXCollectors) {
      collector.destroy();
    }
    for (let collector of this._myDynamicPhysXCollectors) {
      collector.destroy();
    }
    for (let collector of this._myKinematicPhysXCollectors) {
      collector.destroy();
    }
  }
};
__publicField(BenchmarkMaxPhysXComponent, "TypeName", "pp-benchmark-max-physx");
__publicField(BenchmarkMaxPhysXComponent, "Properties", {
  _myStaticDomeSize: Property.float(40),
  _myStaticPhysXCount: Property.int(1e3),
  _myDynamicDomeSize: Property.float(80),
  _myDynamicPhysXCount: Property.int(250),
  _myKinematicDomeSize: Property.float(120),
  _myKinematicPhysXCount: Property.int(250),
  _myRaycastCount: Property.int(100),
  _myVisualizeRaycast: Property.bool(false),
  _myVisualizeRaycastDelay: Property.float(0.5),
  // You can use this to test with convex mesh, 
  // but u first need to add a physx with a convex mesh to the scene and read the shapeData index on the component to set it as _myShapeIndex
  _myUseConvexMesh: Property.bool(false),
  _myShapeIndex: Property.int(0),
  _myShapeScaleMultiplier: Property.float(1),
  // Used to adjust the scale of the convex mesh if too big or small based on how u imported it
  _myLogEnabled: Property.bool(true),
  _myClearConsoleBeforeLog: Property.bool(true)
});

// js/pp/cauldron/benchmarks/benchmark_max_visible_triangles_component.js
var BenchmarkMaxVisibleTrianglesComponent = class extends Component {
  _start() {
    this._myBackgroundSize = 4;
    this._myBackgroundObject.pp_setActive(true);
    this._myBackgroundObject.pp_setScale(this._myBackgroundSize + 0.1);
    this._myBackgroundObject.pp_translateLocal(vec3_create(0, 0, -1e-3));
    this._myDoubleTimer = new Timer(this._mySecondsBeforeDoubling);
    this._myDone = false;
    this._myCurrentPlanes = this._myStartPlaneCount;
    this._myDTHistory = [];
    this._myUpperLimit = -1;
    this._myLowerLimit = 0;
    this._myPlanes = [];
    this._mySkipNextFrames = 0;
    this._myMaxWaitFrames = 0;
    this._myMaxPlanesReached = false;
    this._myFirstTime = true;
  }
  _update(dt) {
    {
      if (dt < 1e-5) {
        return;
      }
      if (dt > 0.5 && this._myMaxWaitFrames > 0) {
        this._myMaxWaitFrames--;
        return;
      }
      this._myMaxWaitFrames = 10;
      if (this._mySkipNextFrames > 0) {
        this._mySkipNextFrames--;
        return;
      }
    }
    if (!this._myDone) {
      this._myDoubleTimer.update(dt);
      this._myDTHistory.push(dt);
      if (this._myDoubleTimer.isDone()) {
        this._myDoubleTimer.start();
        let frameRate = this._computeAverageFrameRate(false);
        if (this._myFirstTime) {
          this._myFirstTime = false;
        } else {
          let lagging = false;
          if (frameRate < this._myStableFrameRate - this._myTargetFrameRateThreshold) {
            this._myUpperLimit = this._myCurrentPlanes;
            lagging = true;
            if (this._myUpperLimit == 1) {
              this._myLowerLimit = 1;
            }
          } else {
            this._myLowerLimit = this._myCurrentPlanes;
            if (this._myUpperLimit > 0) {
              this._myUpperLimit = Math.max(this._myUpperLimit, this._myLowerLimit);
            }
          }
          this._myTriangleTextComponent.text = "Triangles: " + this._myCurrentPlanes * this._myRealTrianglesAmount;
          this._myPlaneTextComponent.text = "Planes: " + this._myCurrentPlanes;
          this._myFPSTextComponent.text = "FPS: " + frameRate + " / " + this._myStableFrameRate;
          if (lagging) {
            this._myTriangleTextComponent.material.color = this._myLagColor;
            this._myPlaneTextComponent.material.color = this._myLagColor;
            this._myFPSTextComponent.material.color = this._myLagColor;
          } else {
            this._myTriangleTextComponent.material.color = this._myNormalColor;
            this._myPlaneTextComponent.material.color = this._myNormalColor;
            this._myFPSTextComponent.material.color = this._myNormalColor;
          }
          let reset12 = false;
          if (this._myUpperLimit > 0 && (!lagging && this._myUpperLimit - this._myLowerLimit <= Math.max(2, 1e3 / this._myRealTrianglesAmount)) || lagging && this._myUpperLimit - this._myLowerLimit <= 1 || !lagging && this._myMaxPlanesReached) {
            if (frameRate < this._myStableFrameRate - this._myTargetFrameRateThreshold) {
              this._myLowerLimit = Math.max(1, Math.floor(this._myUpperLimit / 2.5));
              this._myUpperLimit = 0;
              reset12 = true;
              if (this._myLogEnabled) {
                console.log("Rst - Triangles:", this._myCurrentPlanes * this._myRealTrianglesAmount, "- Planes:", this._myCurrentPlanes, "- Frame Rate:", frameRate);
              }
            } else {
              if (this._myMaxPlanesReached) {
                if (this._myLogEnabled) {
                  console.log("Aborted - Max Planes Reached");
                  this._myDoneTextComponent.text = "Aborted - Max Planes Reached";
                }
              } else {
                this._displayPlanes(this._myLowerLimit);
                if (this._myLogEnabled) {
                  console.log("\nEnd - Triangles:", this._myLowerLimit * this._myRealTrianglesAmount, "- Planes:", this._myLowerLimit, "- Frame Rate:", frameRate);
                  console.log("Plane Triangles (Adjusted):", this._myRealTrianglesAmount);
                  console.log("Target Frame Rate:", this._myStableFrameRate, "- Threshold: ", this._myStableFrameRate - this._myTargetFrameRateThreshold);
                }
                this._myTriangleTextComponent.text = "Triangles: " + this._myLowerLimit * this._myRealTrianglesAmount;
                this._myPlaneTextComponent.text = "Planes: " + this._myLowerLimit;
                this._myFPSTextComponent.text = "FPS: " + frameRate + " / " + this._myStableFrameRate;
                this._myDoneTextComponent.text = "End";
              }
              this._myDone = true;
            }
          }
          if (lagging && !reset12) {
            if (this._myLogEnabled) {
              console.log("Lag - Triangles:", this._myCurrentPlanes * this._myRealTrianglesAmount, "- Planes:", this._myCurrentPlanes, "- Frame Rate:", frameRate);
            }
          }
          if (!this._myDone) {
            if (this._myUpperLimit > 0) {
              this._myCurrentPlanes = Math.floor((this._myUpperLimit + this._myLowerLimit) / 2);
              this._myCurrentPlanes = Math.max(this._myCurrentPlanes, 1);
            } else if (!reset12) {
              this._myCurrentPlanes = this._myLowerLimit * 2;
            } else {
              this._myCurrentPlanes = this._myLowerLimit;
            }
            if (this._myCurrentPlanes > 5e4) {
              this._myCurrentPlanes = 5e4;
              this._myMaxPlanesReached = true;
            } else {
              this._myMaxPlanesReached = false;
            }
          }
        }
        if (!this._myDone) {
          this._displayPlanes(this._myCurrentPlanes);
          this._myElapsedTime = 0;
          this._myFrameCount = 0;
          this._mySkipNextFrames = 30;
        }
      }
    }
  }
  _displayPlanes(count) {
    while (this._myPlanes.length > count) {
      let plane = this._myPlanes.pop();
      Globals.getObjectPoolManager(this.engine).release(this._myPoolID, plane);
    }
    while (this._myPlanes.length < count) {
      let plane = Globals.getObjectPoolManager(this.engine).get(this._myPoolID);
      this._myPlanes.push(plane);
    }
    let gridSize = 1;
    while (gridSize * gridSize < count) {
      gridSize++;
    }
    let spaceBetween = 0.01;
    let totalSpaceBetween = spaceBetween * (gridSize - 1);
    let planeSize = (this._myBackgroundSize * 2 - totalSpaceBetween) / (gridSize * 2);
    let currentCount = count;
    for (let i = 0; i < gridSize && currentCount > 0; i++) {
      for (let j = 0; j < gridSize && currentCount > 0; j++) {
        let plane = this._myPlanes[currentCount - 1];
        plane.pp_setScale(planeSize);
        let position = [-this._myBackgroundSize + planeSize + j * planeSize * 2 + j * spaceBetween, this._myBackgroundSize - planeSize - i * planeSize * 2 - i * spaceBetween, 0];
        plane.pp_setPositionLocal(position);
        plane.pp_setActive(true);
        currentCount--;
      }
    }
  }
  start() {
    this._myValid = false;
    if (!Globals.isDebugEnabled(this.engine))
      return;
    this._myValid = true;
    if (this._myPlaneMaterial == null) {
      this._myPlaneMaterial = Globals.getDefaultMaterials(this.engine).myPhongOpaque.clone();
      this._myPlaneMaterial.diffuseColor = vec4_create(0.95, 0.95, 0.95, 1);
      this._myPlaneMaterial.ambientColor = vec4_create(0, 0, 0, 1);
      this._myPlaneMaterial.ambientFactor = 0.5;
    }
    if (this._myBackgroundMaterial == null) {
      this._myBackgroundMaterial = Globals.getDefaultMaterials(this.engine).myPhongOpaque.clone();
      this._myBackgroundMaterial.diffuseColor = vec4_create(0.25, 0.25, 0.25, 1);
      this._myBackgroundMaterial.ambientColor = vec4_create(0, 0, 0, 1);
      this._myBackgroundMaterial.ambientFactor = 0.5;
    }
    if (this._myTextMaterial == null) {
      this._myTextMaterial = Globals.getDefaultMaterials(this.engine).myText.clone();
    }
    this._myLagColor = vec4_create(0.6, 0, 0, 1);
    this._myNormalColor = vec4_create(0.25, 0.25, 0.25, 1);
    this._myRealTrianglesAmount = 0;
    let parent = this.object;
    if (this._myDisplayInFrontOfPlayer) {
      parent = Globals.getPlayerObjects(this.engine).myHead.pp_addObject();
      parent.pp_rotateAxis(180, vec3_create(0, 1, 0));
      parent.pp_translateLocal(vec3_create(0, 0, this._myDisplayInFrontOfPlayerDistance));
    }
    this._myTrianglesObject = parent.pp_addObject();
    this._myBackgroundObject = this._myTrianglesObject.pp_addObject();
    {
      let meshComponent = this._myBackgroundObject.pp_addComponent(MeshComponent);
      meshComponent.mesh = MeshUtils.createPlane(this.engine);
      meshComponent.material = this._myBackgroundMaterial.clone();
    }
    this._myPlaneObject = this._myTrianglesObject.pp_addObject();
    {
      let meshComponent = this._myPlaneObject.pp_addComponent(MeshComponent);
      meshComponent.mesh = this._createPlaneMesh(this._myPlaneTriangles);
      this._myRealTrianglesAmount = meshComponent.mesh.indexData.length / 3;
      meshComponent.material = this._myPlaneMaterial.clone();
    }
    let poolParams = new ObjectPoolParams();
    if (!this._myCloneMesh) {
      poolParams.myInitialPoolSize = 3e4;
    } else {
      if (this._myRealTrianglesAmount <= 4) {
        poolParams.myInitialPoolSize = 15e3;
      } else if (this._myRealTrianglesAmount <= 8) {
        poolParams.myInitialPoolSize = 1e4;
      } else if (this._myRealTrianglesAmount <= 64) {
        poolParams.myInitialPoolSize = 7500;
      } else {
        poolParams.myInitialPoolSize = 5e3;
      }
    }
    poolParams.myPercentageToAddWhenEmpty = 0;
    poolParams.myAmountToAddWhenEmpty = 1e4;
    poolParams.myCloneParams = new CloneParams();
    poolParams.myCloneParams.myComponentDeepCloneParams.setDeepCloneComponentVariable(MeshComponent.TypeName, "material", this._myCloneMaterial);
    poolParams.myCloneParams.myComponentDeepCloneParams.setDeepCloneComponentVariable(MeshComponent.TypeName, "mesh", this._myCloneMesh);
    this._myPoolID = this.type + "_" + Math.pp_randomUUID();
    Globals.getObjectPoolManager(this.engine).addPool(this._myPoolID, new ObjectPool(this._myPlaneObject, poolParams));
    this._myBackgroundObject.pp_setActive(false);
    this._myPlaneObject.pp_setActive(false);
    this._myStartTimer = new Timer(2);
    this._mySessionStarted = false;
    this._myTextsObject = this._myTrianglesObject.pp_addObject();
    this._myTriangleTextObject = this._myTextsObject.pp_addObject();
    this._myTriangleTextComponent = this._myTriangleTextObject.pp_addComponent(TextComponent);
    this._myTriangleTextComponent.alignment = Alignment.Left;
    this._myTriangleTextComponent.justification = Justification.Line;
    this._myTriangleTextComponent.material = this._myTextMaterial.clone();
    this._myTriangleTextComponent.material.color = this._myNormalColor;
    this._myTriangleTextComponent.text = " ";
    this._myPlaneTextObject = this._myTextsObject.pp_addObject();
    this._myPlaneTextComponent = this._myPlaneTextObject.pp_addComponent(TextComponent);
    this._myPlaneTextComponent.alignment = Alignment.Left;
    this._myPlaneTextComponent.justification = Justification.Line;
    this._myPlaneTextComponent.material = this._myTextMaterial.clone();
    this._myPlaneTextComponent.material.color = this._myNormalColor;
    this._myPlaneTextComponent.text = " ";
    this._myFPSTextObject = this._myTextsObject.pp_addObject();
    this._myFPSTextComponent = this._myFPSTextObject.pp_addComponent(TextComponent);
    this._myFPSTextComponent.alignment = Alignment.Left;
    this._myFPSTextComponent.justification = Justification.Line;
    this._myFPSTextComponent.material = this._myTextMaterial.clone();
    this._myFPSTextComponent.material.color = this._myNormalColor;
    this._myFPSTextComponent.text = " ";
    this._myDoneTextObject = this._myTrianglesObject.pp_addObject();
    this._myDoneTextComponent = this._myDoneTextObject.pp_addComponent(TextComponent);
    this._myDoneTextComponent.alignment = Alignment.Center;
    this._myDoneTextComponent.justification = Justification.Line;
    this._myDoneTextComponent.material = this._myTextMaterial.clone();
    this._myDoneTextComponent.material.color = this._myNormalColor;
    this._myDoneTextComponent.text = " ";
    this._myTextsObject.pp_setPositionLocal(vec3_create(0, 4.3, 0));
    this._myTextsObject.pp_setScale(2.75);
    this._myTriangleTextObject.pp_setPositionLocal(vec3_create(-1.4, 0, 0));
    this._myPlaneTextObject.pp_setPositionLocal(vec3_create(0.55, 0, 0));
    this._myFPSTextObject.pp_setPositionLocal(vec3_create(-0.315, 0, 0));
    this._myDoneTextObject.pp_setPositionLocal(vec3_create(0, -4.6, 0));
    this._myDoneTextObject.pp_setScale(4);
    this._myDTHistory = [];
    this._myFramesToSkip = 10;
  }
  update(dt) {
    if (!this._myValid)
      return;
    if (this._myFramesToSkip == 0) {
      if (this._mySessionStarted || !this._myStartOnXRStart) {
        if (this._myStartTimer.isRunning()) {
          this._myStartTimer.update(dt);
          this._myDTHistory.push(dt);
          if (this._myStartTimer.isDone()) {
            this._myStableFrameRate = this._computeAverageFrameRate(true);
            if (this._myTargetFrameRate > 0) {
              this._myStableFrameRate = this._myTargetFrameRate;
            }
            if (this._myLogEnabled) {
              console.log("\nPlane Triangles (Adjusted):", this._myRealTrianglesAmount);
              console.log("Target Frame Rate:", this._myStableFrameRate, "- Threshold: ", this._myStableFrameRate - this._myTargetFrameRateThreshold);
              console.log("");
            }
            this._start();
          }
        } else {
          this._update(dt);
        }
      } else {
        this._mySessionStarted = XRUtils.getSession(this.engine) != null;
      }
    } else {
      this._myFramesToSkip--;
    }
  }
  _computeAverageFrameRate(firstCompute) {
    let frameRate = 0;
    this._myDTHistory.sort();
    let elementsToRemove = Math.floor(this._myDTHistory.length * Math.min(0.9, this._myDTHistoryToIgnorePercentage * (firstCompute ? 2 : 1)));
    for (let i = 0; i < elementsToRemove && this._myDTHistory.length > 1; i++) {
      this._myDTHistory.pop();
    }
    let averageDT = 0;
    for (let dt of this._myDTHistory) {
      averageDT += dt;
    }
    averageDT /= this._myDTHistory.length;
    frameRate = Math.round(1 / averageDT);
    this._myDTHistory = [];
    return frameRate;
  }
  _createPlaneMesh(trianglesAmount) {
    let squaresAmount = Math.ceil(trianglesAmount / 2);
    let row = 1;
    let column = 1;
    let closestSqrt = 1;
    while (closestSqrt * closestSqrt < squaresAmount) {
      closestSqrt++;
    }
    row = closestSqrt;
    column = closestSqrt;
    while (row > 1 && column > 1 && row * column > squaresAmount && (row - 1) * column >= squaresAmount) {
      row--;
    }
    let meshCreationParams = new MeshCreationParams(this.engine);
    for (let i = 0; i < row + 1; i++) {
      for (let j = 0; j < column + 1; j++) {
        let x = 2 / column * j;
        let y = 2 / row * i;
        let vertexCreationParams = new MeshCreationVertexParams();
        vertexCreationParams.myPosition = vec3_create();
        vertexCreationParams.myPosition[0] = x - 1;
        vertexCreationParams.myPosition[1] = y - 1;
        vertexCreationParams.myPosition[2] = 0;
        vertexCreationParams.myTextureCoordinates = vec2_create();
        vertexCreationParams.myTextureCoordinates[0] = x / 2;
        vertexCreationParams.myTextureCoordinates[1] = y / 2;
        vertexCreationParams.myNormal = vec3_create();
        vertexCreationParams.myNormal[0] = 0;
        vertexCreationParams.myNormal[1] = 0;
        vertexCreationParams.myNormal[2] = 1;
        meshCreationParams.myVertexes.push(vertexCreationParams);
      }
    }
    for (let i = 0; i < row; i++) {
      for (let j = 0; j < column; j++) {
        let firstTriangle = new MeshCreationTriangleParams();
        firstTriangle.myIndexes[0] = i * (column + 1) + j;
        firstTriangle.myIndexes[1] = i * (column + 1) + j + 1;
        firstTriangle.myIndexes[2] = (i + 1) * (column + 1) + j;
        let secondTriangle = new MeshCreationTriangleParams();
        secondTriangle.myIndexes[0] = (i + 1) * (column + 1) + j;
        secondTriangle.myIndexes[1] = i * (column + 1) + j + 1;
        secondTriangle.myIndexes[2] = (i + 1) * (column + 1) + j + 1;
        meshCreationParams.myTriangles.push(firstTriangle);
        meshCreationParams.myTriangles.push(secondTriangle);
      }
    }
    let mesh = MeshUtils.create(meshCreationParams);
    return mesh;
  }
  onDestroy() {
    Globals.getObjectPoolManager(this.engine)?.destroyPool(this._myPoolID);
  }
};
__publicField(BenchmarkMaxVisibleTrianglesComponent, "TypeName", "pp-benchmark-max-visible-triangles");
__publicField(BenchmarkMaxVisibleTrianglesComponent, "Properties", {
  _myTargetFrameRate: Property.int(-1),
  // -1 means it will auto detect it at start
  _myTargetFrameRateThreshold: Property.int(3),
  _myStartPlaneCount: Property.int(1),
  _myPlaneTriangles: Property.int(100),
  _mySecondsBeforeDoubling: Property.float(0.5),
  // Higher gives a better frame rate evaluation
  _myDTHistoryToIgnorePercentage: Property.float(0.25),
  _myCloneMaterial: Property.bool(false),
  _myCloneMesh: Property.bool(false),
  _myLogEnabled: Property.bool(true),
  _myStartOnXRStart: Property.bool(false),
  _myDisplayInFrontOfPlayer: Property.bool(true),
  _myDisplayInFrontOfPlayerDistance: Property.float(10),
  _myPlaneMaterial: Property.material(),
  _myBackgroundMaterial: Property.material(),
  _myTextMaterial: Property.material(null)
});

// js/pp/cauldron/utils/save_utils.js
function save(id, value) {
  if (value != null) {
    localStorage.setItem(id, value);
  }
}
function has2(id) {
  return SaveUtils.loadString(id, null) != null;
}
function remove2(id) {
  return localStorage.removeItem(id);
}
function clear3() {
  return localStorage.clear();
}
function load(id, defaultValue = null) {
  return SaveUtils.loadString(id, defaultValue);
}
function loadString(id, defaultValue = null) {
  let item = localStorage.getItem(id);
  if (item == null) {
    item = defaultValue;
  }
  return item;
}
function loadNumber(id, defaultValue = null) {
  let item = SaveUtils.loadString(id);
  if (item != null) {
    return Number(item);
  }
  return defaultValue;
}
function loadBool(id, defaultValue = null) {
  let item = SaveUtils.loadString(id);
  if (item == "true") {
    return true;
  } else if (item == "false") {
    return false;
  }
  return defaultValue;
}
var SaveUtils = {
  save,
  has: has2,
  remove: remove2,
  clear: clear3,
  load,
  loadString,
  loadNumber,
  loadBool
};

// js/pp/cauldron/cauldron/save_manager.js
var SaveManager = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this._myEngine = engine2;
    this._mySaveCache = /* @__PURE__ */ new Map();
    this._myCacheEnabled = true;
    this._myCommitSavesDelayTimer = new Timer(0, false);
    this._myDelaySavesCommit = true;
    this._myIDsToCommit = [];
    this._myCacheDefaultValueOnFail = true;
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myEngine);
    this._myClearEmitter = new Emitter();
    this._myDeleteEmitter = new Emitter();
    this._myDeleteIDEmitters = /* @__PURE__ */ new Map();
    this._mySaveEmitter = new Emitter();
    this._mySaveValueChangedEmitter = new Emitter();
    this._mySaveIDEmitters = /* @__PURE__ */ new Map();
    this._mySaveValueChangedIDEmitters = /* @__PURE__ */ new Map();
    this._myCommitSaveEmitter = new Emitter();
    this._myCommitSaveIDEmitters = /* @__PURE__ */ new Map();
    this._myCommitSavesEmitter = new Emitter();
    this._myLoadEmitter = new Emitter();
    this._myLoadIDEmitters = /* @__PURE__ */ new Map();
    this._myVisibilityChangeEventListener = null;
    this._myDestroyed = false;
  }
  setCommitSavesDelay(delay) {
    this._myCommitSavesDelayTimer.start(delay);
  }
  setDelaySavesCommit(delayed) {
    this._myDelaySavesCommit = delayed;
  }
  setCacheDefaultValueOnFail(cache) {
    this._myCacheDefaultValueOnFail = cache;
  }
  setCacheEnabled(enabled) {
    this._myCacheEnabled = enabled;
  }
  update(dt) {
    if (this._myCommitSavesDelayTimer.isRunning()) {
      this._myCommitSavesDelayTimer.update(dt);
      if (this._myCommitSavesDelayTimer.isDone()) {
        this.commitSaves();
      }
    }
  }
  save(id, value, delaySavesCommitOverride = null, cacheEnabledOverride = null) {
    let sameValue = false;
    if (this._mySaveCache.has(id) && this._isCacheEnabled(cacheEnabledOverride)) {
      sameValue = this._mySaveCache.get(id) === value;
    }
    if (!sameValue) {
      this._mySaveCache.set(id, value);
      if (this._myDelaySavesCommit && delaySavesCommitOverride == null || delaySavesCommitOverride != null && delaySavesCommitOverride) {
        this._myIDsToCommit.pp_pushUnique(id);
        if (!this._myCommitSavesDelayTimer.isRunning()) {
          this._myCommitSavesDelayTimer.start();
        }
      } else {
        let failed = this._commitSave(id, false);
        let commitSaveDelayed = false;
        this._myCommitSavesEmitter.notify(commitSaveDelayed, failed);
      }
    }
    this._mySaveEmitter.notify(id, value);
    if (this._mySaveIDEmitters.size > 0) {
      let emitter = this._mySaveIDEmitters.get(id);
      if (emitter != null) {
        emitter.notify(id, value);
      }
    }
    if (!sameValue) {
      this._mySaveValueChangedEmitter.notify(id, value);
      if (this._mySaveValueChangedIDEmitters.size > 0) {
        let emitter = this._mySaveValueChangedIDEmitters.get(id);
        if (emitter != null) {
          emitter.notify(id, value);
        }
      }
    }
  }
  commitSaves() {
    if (this._myIDsToCommit.length > 0) {
      let failed = false;
      for (let id of this._myIDsToCommit) {
        if (this._mySaveCache.has(id)) {
          let result = this._commitSave(id, true);
          failed = failed || result;
        }
      }
      this._myIDsToCommit = [];
      let commitSavesDelayed = true;
      this._myCommitSavesEmitter.notify(commitSavesDelayed, failed);
    }
  }
  has(id, cacheEnabledOverride = null) {
    return this._mySaveCache.has(id) && this._isCacheEnabled(cacheEnabledOverride) || SaveUtils.has(id);
  }
  remove(id) {
    this._mySaveCache.delete(id);
    SaveUtils.remove(id);
    this._myDeleteEmitter.notify(id);
    if (this._myDeleteIDEmitters.size > 0) {
      let emitter = this._myDeleteIDEmitters.get(id);
      if (emitter != null) {
        emitter.notify(id);
      }
    }
  }
  clear() {
    this._mySaveCache.clear();
    SaveUtils.clear();
    this._myClearEmitter.notify();
  }
  load(id, defaultValue = null, cacheEnabledOverride = null) {
    return this._load(id, defaultValue, "load", cacheEnabledOverride);
  }
  loadString(id, defaultValue = null, cacheEnabledOverride = null) {
    return this._load(id, defaultValue, "loadString", cacheEnabledOverride);
  }
  loadNumber(id, defaultValue = null, cacheEnabledOverride = null) {
    return this._load(id, defaultValue, "loadNumber", cacheEnabledOverride);
  }
  loadBool(id, defaultValue = null, cacheEnabledOverride = null) {
    return this._load(id, defaultValue, "loadBool", cacheEnabledOverride);
  }
  getCommitSavesDelay() {
    return this._myCommitSavesDelayTimer.getDuration();
  }
  isDelaySavesCommit() {
    return this._myDelaySavesCommit;
  }
  isCacheDefaultValueOnFail() {
    return this._myCacheDefaultValueOnFail;
  }
  isCacheEnabled() {
    return this._myCacheEnabled;
  }
  _commitSave(id, commitSaveDelayed) {
    let value = this._mySaveCache.get(id);
    let failed = false;
    try {
      SaveUtils.save(id, value);
    } catch (error3) {
      failed = true;
    }
    this._myCommitSaveEmitter.notify(id, value, commitSaveDelayed, failed);
    if (this._myCommitSaveIDEmitters.size > 0) {
      let emitter = this._myCommitSaveIDEmitters.get(id);
      if (emitter != null) {
        emitter.notify(id, value, commitSaveDelayed, failed);
      }
    }
    return failed;
  }
  _load(id, defaultValue, functionName, cacheEnabledOverride = null) {
    let value = null;
    let failed = false;
    let loadFromCache = false;
    if (this._mySaveCache.has(id) && this._isCacheEnabled(cacheEnabledOverride)) {
      value = this._mySaveCache.get(id);
      if (value == null && defaultValue != null) {
        value = defaultValue;
        if (this._myCacheDefaultValueOnFail) {
          this._mySaveCache.set(id, value);
        }
      }
      loadFromCache = true;
    } else {
      let saveResult = null;
      try {
        saveResult = SaveUtils[functionName](id, null);
      } catch (error3) {
        saveResult = null;
        failed = true;
      }
      if (saveResult == null) {
        value = defaultValue;
      } else {
        value = saveResult;
      }
      if (saveResult != null || this._myCacheDefaultValueOnFail) {
        this._mySaveCache.set(id, value);
      } else {
        this._mySaveCache.set(id, null);
      }
    }
    this._myLoadEmitter.notify(id, value, loadFromCache, failed);
    if (this._myLoadIDEmitters.size > 0) {
      let emitter = this._myLoadIDEmitters.get(id);
      if (emitter != null) {
        emitter.notify(id, value, loadFromCache, failed);
      }
    }
    return value;
  }
  _onXRSessionStart(session) {
    this._myVisibilityChangeEventListener = function(event) {
      if (event.session.visibilityState != "visible") {
        this._onXRSessionInterrupt();
      }
    }.bind(this);
    session.addEventListener("visibilitychange", this._myVisibilityChangeEventListener);
  }
  _onXRSessionEnd() {
    this._myVisibilityChangeEventListener = null;
    this._onXRSessionInterrupt();
  }
  _onXRSessionInterrupt() {
    this.commitSaves();
  }
  registerClearEventListener(listenerID, listener) {
    this._myClearEmitter.add(listener, { id: listenerID });
  }
  unregisterClearEventListener(listenerID) {
    this._myClearEmitter.remove(listenerID);
  }
  registerDeleteEventListener(listenerID, listener) {
    this._myDeleteEmitter.add(listener, { id: listenerID });
  }
  unregisterDeleteEventListener(listenerID) {
    this._myDeleteEmitter.remove(listenerID);
  }
  registerDeleteIDEventListener(valueID, listenerID, listener) {
    let valueIDEmitter = this._myDeleteIDEmitters.get(valueID);
    if (valueIDEmitter == null) {
      this._myDeleteIDEmitters.set(valueID, /* @__PURE__ */ new Map());
      valueIDEmitter = this._myDeleteIDEmitters.get(valueID);
    }
    valueIDEmitter.add(listener, { id: listenerID });
  }
  unregisterDeleteIDEventListener(valueID, listenerID) {
    let valueIDEmitter = this._myDeleteIDEmitters.get(valueID);
    if (valueIDEmitter != null) {
      valueIDEmitter.remove(listenerID);
      if (valueIDEmitter.size <= 0) {
        this._myDeleteIDEmitters.delete(valueID);
      }
    }
  }
  registerSaveEventListener(listenerID, listener) {
    this._mySaveEmitter.add(listener, { id: listenerID });
  }
  unregisterSaveEventListener(listenerID) {
    this._mySaveEmitter.remove(listenerID);
  }
  registerSaveIDEventListener(valueID, listenerID, listener) {
    let valueIDEmitter = this._mySaveIDEmitters.get(valueID);
    if (valueIDEmitter == null) {
      this._mySaveIDEmitters.set(valueID, /* @__PURE__ */ new Map());
      valueIDEmitter = this._mySaveIDEmitters.get(valueID);
    }
    valueIDEmitter.add(listener, { id: listenerID });
  }
  unregisterSaveIDEventListener(valueID, listenerID) {
    let valueIDEmitter = this._mySaveIDEmitters.get(valueID);
    if (valueIDEmitter != null) {
      valueIDEmitter.remove(listenerID);
      if (valueIDEmitter.size <= 0) {
        this._mySaveIDEmitters.delete(valueID);
      }
    }
  }
  registerSaveValueChangedEventListener(listenerID, listener) {
    this._mySaveValueChangedEmitter.add(listener, { id: listenerID });
  }
  unregisterSaveValueChangedEventListener(listenerID) {
    this._mySaveValueChangedEmitter.remove(listenerID);
  }
  registerSaveValueChangedIDEventListener(valueID, listenerID, listener) {
    let valueIDEmitter = this._mySaveValueChangedIDEmitters.get(valueID);
    if (valueIDEmitter == null) {
      this._mySaveValueChangedIDEmitters.set(valueID, /* @__PURE__ */ new Map());
      valueIDEmitter = this._mySaveValueChangedIDEmitters.get(valueID);
    }
    valueIDEmitter.add(listener, { id: listenerID });
  }
  unregisterSaveValueChangedIDEventListener(valueID, listenerID) {
    let valueIDEmitter = this._mySaveValueChangedIDEmitters.get(valueID);
    if (valueIDEmitter != null) {
      valueIDEmitter.remove(listenerID);
      if (valueIDEmitter.size <= 0) {
        this._mySaveValueChangedIDEmitters.delete(valueID);
      }
    }
  }
  registerCommitSavesEventListener(listenerID, listener) {
    this._myCommitSavesEmitter.add(listener, { id: listenerID });
  }
  unregisterCommitSavesEventListener(listenerID) {
    this._myCommitSavesEmitter.remove(listenerID);
  }
  registerCommitSaveEventListener(listenerID, listener) {
    this._myCommitSaveEmitter.add(listener, { id: listenerID });
  }
  unregisterCommitSaveEventListener(listenerID) {
    this._myCommitSaveEmitter.remove(listenerID);
  }
  registerCommitSaveIDEventListener(valueID, listenerID, listener) {
    let valueIDEmitter = this._myCommitSaveIDEmitters.get(valueID);
    if (valueIDEmitter == null) {
      this._myCommitSaveIDEmitters.set(valueID, /* @__PURE__ */ new Map());
      valueIDEmitter = this._myCommitSaveIDEmitters.get(valueID);
    }
    valueIDEmitter.add(listener, { id: listenerID });
  }
  unregisterCommitSaveIDEventListener(valueID, listenerID) {
    let valueIDEmitter = this._myCommitSaveIDEmitters.get(valueID);
    if (valueIDEmitter != null) {
      valueIDEmitter.remove(listenerID);
      if (valueIDEmitter.size <= 0) {
        this._myCommitSaveIDEmitters.delete(valueID);
      }
    }
  }
  registerLoadEventListener(listenerID, listener) {
    this._myLoadEmitter.add(listener, { id: listenerID });
  }
  unregisterLoadEventListener(listenerID) {
    this._myLoadEmitter.remove(listenerID);
  }
  registerLoadIDEventListener(valueID, listenerID, listener) {
    let valueIDEmitter = this._myLoadIDEmitters.get(valueID);
    if (valueIDEmitter == null) {
      this._myLoadIDEmitters.set(valueID, /* @__PURE__ */ new Map());
      valueIDEmitter = this._myLoadIDEmitters.get(valueID);
    }
    valueIDEmitter.add(listener, { id: listenerID });
  }
  unregisterLoadIDEventListener(valueID, listenerID) {
    let valueIDEmitter = this._myLoadIDEmitters.get(valueID);
    if (valueIDEmitter != null) {
      valueIDEmitter.remove(listenerID);
      if (valueIDEmitter.size <= 0) {
        this._myLoadIDEmitters.delete(valueID);
      }
    }
  }
  _isCacheEnabled(cacheEnabledOverride = null) {
    return this._myCacheEnabled && cacheEnabledOverride == null || cacheEnabledOverride != null && cacheEnabledOverride;
  }
  destroy() {
    this._myDestroyed = true;
    XRUtils.getSession(this._myEngine)?.removeEventListener("visibilitychange", this._myVisibilityChangeEventListener);
    XRUtils.unregisterSessionStartEndEventListeners(this, this._myEngine);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/cauldron/components/clear_console_on_xr_session_start_component.js
var ClearConsoleOnXRSessionStartComponent = class extends Component {
  start() {
    this._myFirstTime = true;
    XRUtils.registerSessionStartEventListener(this, this._onXRSessionStart.bind(this), true, false, this.engine);
  }
  _onXRSessionStart() {
    if (!this._myFirstTimeOnly || this._myFirstTime) {
      this._myFirstTime = false;
      console.clear();
    }
  }
  onDestroy() {
    XRUtils.unregisterSessionStartEventListener(this, this.engine);
  }
};
__publicField(ClearConsoleOnXRSessionStartComponent, "TypeName", "pp-clear-console-on-xr-session-start");
__publicField(ClearConsoleOnXRSessionStartComponent, "Properties", {
  _myFirstTimeOnly: Property.bool(true)
});

// js/pp/cauldron/components/set_active_component.js
var SetActiveComponent = class extends Component {
  init() {
    if (this.active && this._mySetActiveWhen == 0) {
      this._setActive();
    }
  }
  start() {
    if (this._mySetActiveWhen == 1) {
      this._setActive();
    }
    this._myFirstUpdate = true;
    this._myFirstXRStart = true;
    this._myFirstXREnd = true;
    if (this._mySetActiveWhen == 3 || this._mySetActiveWhen == 5) {
      XRUtils.registerSessionStartEventListener(this, this._onXRSessionStart.bind(this), true, true, this.engine);
    }
    if (this._mySetActiveWhen == 4 || this._mySetActiveWhen == 6) {
      XRUtils.registerSessionEndEventListener(this, this._onXRSessionEnd.bind(this), this.engine);
    }
  }
  update(dt) {
    if (this._mySetActiveWhen == 2 && this._myFirstUpdate) {
      this._setActive();
    }
    this._myFirstUpdate = false;
  }
  _onXRSessionStart() {
    if (this._mySetActiveWhen == 3 || this._mySetActiveWhen == 5 && this._myFirstXRStart) {
      this._setActive();
    }
    this._myFirstXRStart = false;
  }
  _onXRSessionEnd() {
    if (this._mySetActiveWhen == 4 || this._mySetActiveWhen == 6 && this._myFirstXREnd) {
      this._setActive();
    }
    this._myFirstXREnd = false;
  }
  _setActive() {
    if (this._mySetActiveOn == 0) {
      this.object.pp_setActiveSelf(this._myActive);
    } else if (this._mySetActiveOn == 1) {
      this.object.pp_setActiveChildren(this._myActive);
    } else if (this._mySetActiveOn == 2) {
      this.object.pp_setActiveDescendants(this._myActive);
    } else {
      this.object.pp_setActive(this._myActive);
    }
  }
  onDestroy() {
    XRUtils.unregisterSessionStartEndEventListeners(this, this.engine);
  }
};
__publicField(SetActiveComponent, "TypeName", "pp-set-active");
__publicField(SetActiveComponent, "Properties", {
  _myActive: Property.bool(true),
  _mySetActiveOn: Property.enum(["Self", "Children", "Descendants", "Hierarchy"], "Hierarchy"),
  _mySetActiveWhen: Property.enum(["Init", "Start", "First Update", "Enter XR", "Exit XR", "First Enter XR", "First Exit XR"], "Init")
});

// js/pp/cauldron/components/adjust_hierarchy_physx_scale_component.js
var AdjustHierarchyPhysXScaleComponent = class extends Component {
  init() {
    if (this.active && this._myWhen == 0) {
      this._adjustScale();
    }
  }
  start() {
    if (this._myWhen == 1) {
      this._adjustScale();
    }
    this._myFirst = true;
  }
  update(dt) {
    if (this._myWhen == 2 && this._myFirst) {
      this._myFirst = false;
      this._adjustScale();
    }
  }
  _adjustScale() {
    let scale11 = this.object.pp_getScale();
    let physXComponents = this.object.pp_getComponents(PhysXComponent);
    for (let physX of physXComponents) {
      physX.extents[0] = physX.extents[0] * scale11[0];
      physX.extents[1] = physX.extents[1] * scale11[1];
      physX.extents[2] = physX.extents[2] * scale11[2];
      if (physX.active) {
        physX.active = false;
        physX.active = true;
      }
    }
  }
};
__publicField(AdjustHierarchyPhysXScaleComponent, "TypeName", "pp-adjust-hierarchy-physx-scale");
__publicField(AdjustHierarchyPhysXScaleComponent, "Properties", {
  _myWhen: Property.enum(["Init", "Start", "First Update"], "Start")
});

// js/pp/cauldron/components/show_fps_component.js
var ShowFPSComponent = class extends Component {
  start() {
    this._myColor = vec4_create(1, 1, 1, 1);
    if (this._myTextMaterial != null) {
      this._myColor.vec4_copy(this._myTextMaterial.color);
    }
    this._myScreenPosition = vec3_create(this._myScreenPositionX, this._myScreenPositionY, this._myScreenPositionZ);
    this._myCurrentFPS = 0;
    this._myTimer = new Timer(this._myRefreshSeconds);
    this._myTotalDT = 0;
    this._myFrames = 0;
  }
  update(dt) {
    if (Globals.isDebugEnabled(this.engine)) {
      this._myTotalDT += dt;
      this._myFrames++;
      this._myTimer.update(dt);
      if (this._myTimer.isDone()) {
        this._myTimer.start();
        this._myCurrentFPS = Math.round(this._myFrames / this._myTotalDT);
        this._myTotalDT = 0;
        this._myFrames = 0;
      }
      Globals.getDebugVisualManager(this.engine).drawUIText(0, this._myCurrentFPS.toFixed(0), this._myScreenPosition, this._myScale, this._myColor, Alignment.Right, Justification.Bottom);
    }
  }
};
__publicField(ShowFPSComponent, "TypeName", "pp-show-fps");
__publicField(ShowFPSComponent, "Properties", {
  _myRefreshSeconds: Property.float(0.25),
  _myScreenPositionX: Property.float(1),
  _myScreenPositionY: Property.float(-1),
  _myScreenPositionZ: Property.float(1),
  _myScale: Property.float(1.5),
  _myTextMaterial: Property.material()
});

// js/pp/cauldron/fsm/fsm.js
var StateData = class {
  constructor(stateID, stateObject) {
    this.myID = stateID;
    this.myObject = stateObject;
  }
};
var TransitionData = class {
  constructor(transitionID, fromStateData, toStateData, transitionObject, skipStateFunction) {
    this.myID = transitionID;
    this.myFromState = fromStateData;
    this.myToState = toStateData;
    this.myObject = transitionObject;
    this.mySkipStateFunction = skipStateFunction;
  }
};
var PerformMode = {
  IMMEDIATE: 0,
  DELAYED: 1
};
var PerformDelayedMode = {
  QUEUE: 0,
  KEEP_FIRST: 1,
  KEEP_LAST: 2
};
var SkipStateFunction = {
  NONE: 0,
  END: 1,
  START: 2,
  BOTH: 3
};
var FSM = class {
  constructor(performMode = PerformMode.IMMEDIATE, performDelayedMode = PerformDelayedMode.QUEUE) {
    this._myCurrentStateData = null;
    this._myStates = /* @__PURE__ */ new Map();
    this._myTransitions = /* @__PURE__ */ new Map();
    this._myLogEnabled = false;
    this._myLogShowDelayedInfo = false;
    this._myLogFSMName = "FSM";
    this._myPerformMode = performMode;
    this._myPerformDelayedMode = performDelayedMode;
    this._myPendingPerforms = [];
    this._myCurrentlyPerformedTransition = null;
    this._myInitEmitter = new Emitter();
    this._myInitIDEmitters = /* @__PURE__ */ new Map();
    this._myTransitionEmitter = new Emitter();
    this._myTransitionIDEmitters = [];
  }
  addState(stateID, state = null) {
    let stateObject = null;
    if (!state || typeof state == "function") {
      stateObject = {};
      if (typeof state == "function") {
        stateObject.update = function update() {
          return state(...arguments);
        };
      } else {
        stateObject.update = null;
      }
      stateObject.clone = function clone17() {
        let cloneObject = {};
        cloneObject.update = this.update;
        cloneObject.clone = this.clone;
        return cloneObject;
      };
    } else {
      stateObject = state;
    }
    let stateData = new StateData(stateID, stateObject);
    this._myStates.set(stateID, stateData);
    this._myTransitions.set(stateID, /* @__PURE__ */ new Map());
  }
  addTransition(fromStateID, toStateID, transitionID, transition = null, skipStateFunction = SkipStateFunction.NONE) {
    let transitionObject = null;
    if (!transition || typeof transition == "function") {
      transitionObject = {};
      if (typeof transition == "function") {
        transitionObject.perform = function perform() {
          return transition(...arguments);
        };
      } else {
        transitionObject.perform = null;
      }
      transitionObject.clone = function clone17() {
        let cloneObject = {};
        cloneObject.perform = this.perform;
        cloneObject.clone = this.clone;
        return cloneObject;
      };
    } else {
      transitionObject = transition;
    }
    if (this.hasState(fromStateID) && this.hasState(toStateID)) {
      let transitionsFromState = this._getTransitionsFromState(fromStateID);
      let transitionData = new TransitionData(transitionID, this.getState(fromStateID), this.getState(toStateID), transitionObject, skipStateFunction);
      transitionsFromState.set(transitionID, transitionData);
    } else {
      if (!this.hasState(fromStateID) && !this.hasState(toStateID)) {
        console.error("Can't add transition:", transitionID, "- from state not found:", fromStateID, "- to state not found:", toStateID);
      } else if (!this.hasState(fromStateID)) {
        console.error("Can't add transition:", transitionID, "- from state not found:", fromStateID);
      } else if (!this.hasState(toStateID)) {
        console.error("Can't add transition:", transitionID, "- to state not found:", toStateID);
      }
    }
  }
  init(initStateID, initTransition = null, ...args) {
    let initTransitionObject = initTransition;
    if (initTransition && typeof initTransition == "function") {
      initTransitionObject = {};
      initTransitionObject.performInit = initTransition;
    }
    if (this.hasState(initStateID)) {
      let initStateData = this._myStates.get(initStateID);
      if (this._myLogEnabled) {
        console.log(this._myLogFSMName, "- Init:", initStateID);
      }
      if (initTransitionObject && initTransitionObject.performInit) {
        initTransitionObject.performInit(this, initStateData, ...args);
      } else if (initStateData.myObject && initStateData.myObject.init) {
        initStateData.myObject.init(this, initStateData, ...args);
      }
      this._myCurrentStateData = initStateData;
      this._myInitEmitter.notify(this, initStateData, initTransitionObject, ...args);
      if (this._myInitIDEmitters.size > 0) {
        let emitter = this._myInitIDEmitters.get(initStateID);
        if (emitter != null) {
          emitter.notify(this, initStateData, initTransitionObject, ...args);
        }
      }
    } else if (this._myLogEnabled) {
      console.warn(this._myLogFSMName, "- Init state not found:", initStateID);
    }
  }
  update(dt, ...args) {
    if (this._myPendingPerforms.length > 0) {
      for (let i = 0; i < this._myPendingPerforms.length; i++) {
        this._perform(this._myPendingPerforms[i].myID, PerformMode.DELAYED, ...this._myPendingPerforms[i].myArgs);
      }
      this._myPendingPerforms = [];
    }
    if (this._myCurrentStateData && this._myCurrentStateData.myObject && this._myCurrentStateData.myObject.update) {
      this._myCurrentStateData.myObject.update(dt, this, ...args);
    }
  }
  perform(transitionID, ...args) {
    if (this._myPerformMode == PerformMode.DELAYED) {
      this.performDelayed(transitionID, ...args);
    } else {
      this.performImmediate(transitionID, ...args);
    }
  }
  performDelayed(transitionID, ...args) {
    let performDelayed = false;
    switch (this._myPerformDelayedMode) {
      case PerformDelayedMode.QUEUE:
        this._myPendingPerforms.push(new _PendingPerform(transitionID, ...args));
        performDelayed = true;
        break;
      case PerformDelayedMode.KEEP_FIRST:
        if (!this.hasPendingPerforms()) {
          this._myPendingPerforms.push(new _PendingPerform(transitionID, ...args));
          performDelayed = true;
        }
        break;
      case PerformDelayedMode.KEEP_LAST:
        this.resetPendingPerforms();
        this._myPendingPerforms.push(new _PendingPerform(transitionID, ...args));
        performDelayed = true;
        break;
    }
    return performDelayed;
  }
  performImmediate(transitionID, ...args) {
    return this._perform(transitionID, PerformMode.IMMEDIATE, ...args);
  }
  canPerform(transitionID) {
    return this.hasTransitionFromState(this._myCurrentStateData.myID, transitionID);
  }
  canGoTo(stateID, transitionID = null) {
    return this.hasTransitionFromStateToState(this._myCurrentStateData.myID, stateID, transitionID);
  }
  isInState(stateID) {
    return this._myCurrentStateData != null && this._myCurrentStateData.myID == stateID;
  }
  isPerformingTransition() {
    return this._myCurrentlyPerformedTransition != null;
  }
  getCurrentlyPerformedTransition() {
    return this._myCurrentlyPerformedTransition;
  }
  hasBeenInit() {
    return this._myCurrentStateData != null;
  }
  reset() {
    this.resetState();
    this.resetPendingPerforms();
  }
  resetState() {
    this._myCurrentStateData = null;
  }
  resetPendingPerforms() {
    this._myPendingPerforms = [];
  }
  getCurrentState() {
    return this._myCurrentStateData;
  }
  getCurrentTransitions() {
    return this.getTransitionsFromState(this._myCurrentStateData.myID);
  }
  getCurrentTransitionsToState(stateID) {
    return this.getTransitionsFromStateToState(this._myCurrentStateData.myID, stateID);
  }
  getState(stateID) {
    return this._myStates.get(stateID);
  }
  getStates() {
    return this._myStates.values();
  }
  getTransitions() {
    let transitions = [];
    for (let transitionsFromState of this._myTransitions.values()) {
      for (let transitionData of transitionsFromState.values()) {
        transitions.push(transitionData);
      }
    }
    return transitions;
  }
  getTransitionsFromState(fromStateID) {
    let transitionsFromState = this._getTransitionsFromState(fromStateID);
    return Array.from(transitionsFromState.values());
  }
  getTransitionsFromStateToState(fromStateID, toStateID) {
    let transitionsFromState = this._getTransitionsFromState(fromStateID);
    let transitionsToState = [];
    for (let transitionData of transitionsFromState.values()) {
      if (transitionData.myToState.myID == toStateID) {
        transitionsToState.push(transitionData);
      }
    }
    return transitionsToState;
  }
  removeState(stateID) {
    if (this.hasState(stateID)) {
      this._myStates.delete(stateID);
      this._myTransitions.delete(stateID);
      for (let transitionsFromState of this._myTransitions.values()) {
        let toDelete = [];
        for (let [transitionID, transitionData] of transitionsFromState.entries()) {
          if (transitionData.myToState.myID == stateID) {
            toDelete.push(transitionID);
          }
        }
        for (let transitionID of toDelete) {
          transitionsFromState.delete(transitionID);
        }
      }
      return true;
    }
    return false;
  }
  removeTransitionFromState(fromStateID, transitionID) {
    let fromTransitions = this._getTransitionsFromState(fromStateID);
    if (fromTransitions) {
      return fromTransitions.delete(transitionID);
    }
    return false;
  }
  hasState(stateID) {
    return this._myStates.has(stateID);
  }
  hasTransitionFromState(fromStateID, transitionID) {
    let transitions = this.getTransitionsFromState(fromStateID);
    let transitionIndex = transitions.findIndex(function(transition) {
      return transition.myID == transitionID;
    });
    return transitionIndex >= 0;
  }
  hasTransitionFromStateToState(fromStateID, toStateID, transitionID = null) {
    let transitions = this.getTransitionsFromStateToState(fromStateID, toStateID);
    let hasTransition = false;
    if (transitionID) {
      let transitionIndex = transitions.findIndex(function(transition) {
        return transition.myID == transitionID;
      });
      hasTransition = transitionIndex >= 0;
    } else {
      hasTransition = transitions.length > 0;
    }
    return hasTransition;
  }
  setPerformMode(performMode) {
    this._myPerformMode = performMode;
  }
  getPerformMode() {
    return this._myPerformMode;
  }
  setPerformDelayedMode(performDelayedMode) {
    this._myPerformDelayedMode = performDelayedMode;
  }
  getPerformDelayedMode() {
    return this._myPerformDelayedMode;
  }
  hasPendingPerforms() {
    return this._myPendingPerforms.length > 0;
  }
  getPendingPerforms() {
    return this._myPendingPerforms.pp_clone();
  }
  clone(deepClone = false) {
    if (!this.isCloneable(deepClone)) {
      return null;
    }
    let cloneFSM = new FSM();
    cloneFSM._myLogEnabled = this._myLogEnabled;
    cloneFSM._myLogShowDelayedInfo = this._myLogShowDelayedInfo;
    cloneFSM._myLogFSMName = this._myLogFSMName;
    cloneFSM._myPerformMode = this._myPerformMode;
    cloneFSM._myPerformDelayedMode = this._myPerformDelayedMode;
    cloneFSM._myPendingPerforms = this._myPendingPerforms.pp_clone();
    for (let entry of this._myStates.entries()) {
      let stateData = null;
      if (deepClone) {
        stateData = new StateData(entry[1].myID, entry[1].myObject.clone());
      } else {
        stateData = new StateData(entry[1].myID, entry[1].myObject);
      }
      cloneFSM._myStates.set(stateData.myID, stateData);
    }
    for (let entry of this._myTransitions.entries()) {
      let transitionsFromState = /* @__PURE__ */ new Map();
      cloneFSM._myTransitions.set(entry[0], transitionsFromState);
      for (let transitonEntry of entry[1].entries()) {
        let transitionData = null;
        let fromState = cloneFSM.getState(transitonEntry[1].myFromState.myID);
        let toState = cloneFSM.getState(transitonEntry[1].myToState.myID);
        if (deepClone) {
          transitionData = new TransitionData(transitonEntry[1].myID, fromState, toState, transitonEntry[1].myObject.clone(), transitonEntry[1].mySkipStateFunction);
        } else {
          transitionData = new TransitionData(transitonEntry[1].myID, fromState, toState, transitonEntry[1].myObject, transitonEntry[1].mySkipStateFunction);
        }
        transitionsFromState.set(transitionData.myID, transitionData);
      }
    }
    if (this._myCurrentStateData) {
      cloneFSM._myCurrentStateData = cloneFSM.getState(this._myCurrentStateData.myID);
    }
    return cloneFSM;
  }
  isCloneable(deepClone = false) {
    if (!deepClone) {
      return true;
    }
    let deepCloneable = true;
    for (let entry of this._myStates.entries()) {
      deepCloneable = deepCloneable && entry[1].myObject.clone != null;
    }
    for (let entry of this._myTransitions.entries()) {
      for (let transitonEntry of entry[1].entries()) {
        deepCloneable = deepCloneable && transitonEntry[1].myObject.clone != null;
      }
    }
    return deepCloneable;
  }
  setLogEnabled(active, fsmName = null, showDelayedInfo = false) {
    this._myLogEnabled = active;
    this._myLogShowDelayedInfo = showDelayedInfo;
    if (fsmName) {
      this._myLogFSMName = "FSM: ".concat(fsmName);
    }
  }
  registerInitEventListener(listenerID, listener) {
    this._myInitEmitter.add(listener, { id: listenerID });
  }
  unregisterInitEventListener(listenerID) {
    this._myInitEmitter.remove(listenerID);
  }
  registerInitIDEventListener(initStateID, listenerID, listener) {
    let initStateIDEmitter = this._myInitIDEmitters.get(initStateID);
    if (initStateIDEmitter == null) {
      this._myInitIDEmitters.set(initStateID, new Emitter());
      initStateIDEmitter = this._myInitIDEmitters.get(initStateID);
    }
    initStateIDEmitter.add(listener, { id: listenerID });
  }
  unregisterInitIDEventListener(initStateID, listenerID) {
    let initStateIDEmitter = this._myInitIDEmitters.get(initStateID);
    if (initStateIDEmitter != null) {
      initStateIDEmitter.remove(listenerID);
      if (initStateIDEmitter.isEmpty) {
        this._myInitIDEmitters.delete(initStateID);
      }
    }
  }
  registerTransitionEventListener(listenerID, listener) {
    this._myTransitionEmitter.add(listener, { id: listenerID });
  }
  unregisterTransitionEventListener(listenerID) {
    this._myTransitionEmitter.remove(listenerID);
  }
  // The fsm IDs can be null, that means that the listener is called whenever only the valid IDs match
  // This let you register to all the transitions with a specific ID and from of a specific state but to every state (toStateID == null)
  registerTransitionIDEventListener(fromStateID, toStateID, transitionID, listenerID, listener) {
    let internalTransitionIDEmitter = null;
    for (let value of this._myTransitionIDEmitters) {
      if (value[0] == fromStateID && value[1] == toStateID && value[2] == transitionID) {
        internalTransitionIDEmitter = value[3];
        break;
      }
    }
    if (internalTransitionIDEmitter == null) {
      let transitionIDEmitter = [];
      transitionIDEmitter[0] = fromStateID;
      transitionIDEmitter[1] = toStateID;
      transitionIDEmitter[2] = transitionID;
      transitionIDEmitter[3] = new Emitter();
      internalTransitionIDEmitter = transitionIDEmitter[3];
      this._myTransitionIDEmitters.push(transitionIDEmitter);
    }
    internalTransitionIDEmitter.add(listener, { id: listenerID });
  }
  unregisterTransitionIDEventListener(fromStateID, toStateID, transitionID, listenerID) {
    let internalTransitionIDEmitter = null;
    for (let value of this._myTransitionIDEmitters) {
      if (value[0] == fromStateID && value[1] == toStateID && value[2] == transitionID) {
        internalTransitionIDEmitter = value[3];
        break;
      }
    }
    if (internalTransitionIDEmitter != null) {
      internalTransitionIDEmitter.remove(listenerID);
      if (internalTransitionIDEmitter.isEmpty) {
        this._myTransitionIDEmitters.pp_remove((element) => element[0] == fromStateID && element[1] == toStateID && element[2] == transitionID);
      }
    }
  }
  _perform(transitionID, performMode, ...args) {
    if (this.isPerformingTransition()) {
      let currentlyPerformedTransition = this.getCurrentlyPerformedTransition();
      let consoleArguments = [this._myLogFSMName, "- Trying to perform:", transitionID];
      if (this._myLogShowDelayedInfo) {
        consoleArguments.push(performMode == PerformMode.DELAYED ? "- Delayed" : "- Immediate");
      }
      consoleArguments.push("- But another transition is currently being performed -", currentlyPerformedTransition.myID);
      console.warn(...consoleArguments);
      return false;
    }
    if (this._myCurrentStateData) {
      if (this.canPerform(transitionID)) {
        let transitions = this._myTransitions.get(this._myCurrentStateData.myID);
        let transitionToPerform = transitions.get(transitionID);
        this._myCurrentlyPerformedTransition = transitionToPerform;
        let fromState = this._myCurrentStateData;
        let toState = this._myStates.get(transitionToPerform.myToState.myID);
        if (this._myLogEnabled) {
          let consoleArguments = [this._myLogFSMName, "- From:", fromState.myID, "- To:", toState.myID, "- With:", transitionID];
          if (this._myLogShowDelayedInfo) {
            consoleArguments.push(performMode == PerformMode.DELAYED ? "- Delayed" : "- Immediate");
          }
          console.log(...consoleArguments);
        }
        if (transitionToPerform.mySkipStateFunction != SkipStateFunction.END && transitionToPerform.mySkipStateFunction != SkipStateFunction.BOTH && fromState.myObject && fromState.myObject.end) {
          fromState.myObject.end(this, transitionToPerform, ...args);
        }
        if (transitionToPerform.myObject && transitionToPerform.myObject.perform) {
          transitionToPerform.myObject.perform(this, transitionToPerform, ...args);
        }
        if (transitionToPerform.mySkipStateFunction != SkipStateFunction.START && transitionToPerform.mySkipStateFunction != SkipStateFunction.BOTH && toState.myObject && toState.myObject.start) {
          toState.myObject.start(this, transitionToPerform, ...args);
        }
        this._myCurrentStateData = transitionToPerform.myToState;
        this._myTransitionEmitter.notify(this, fromState, toState, transitionToPerform, performMode, ...args);
        if (this._myTransitionIDEmitters.length > 0) {
          let internalTransitionIDEmitters = [];
          for (let value of this._myTransitionIDEmitters) {
            if ((value[0] == null || value[0] == fromState.myID) && (value[1] == null || value[1] == toState.myID) && (value[2] == null || value[2] == transitionToPerform.myID)) {
              internalTransitionIDEmitters.push(value[3]);
            }
          }
          for (let emitter of internalTransitionIDEmitters) {
            emitter.notify(this, fromState, toState, transitionToPerform, performMode, ...args);
          }
        }
        this._myCurrentlyPerformedTransition = null;
        return true;
      } else if (this._myLogEnabled) {
        let consoleArguments = [this._myLogFSMName, "- No Transition:", transitionID, "- From:", this._myCurrentStateData.myID];
        if (this._myLogShowDelayedInfo) {
          consoleArguments.push(performMode == PerformMode.DELAYED ? "- Delayed" : "- Immediate");
        }
        console.warn(...consoleArguments);
      }
    } else if (this._myLogEnabled) {
      let consoleArguments = [this._myLogFSMName, "- FSM not initialized yet"];
      if (this._myLogShowDelayedInfo) {
        consoleArguments.push(performMode == PerformMode.DELAYED ? "- Delayed" : "- Immediate");
      }
      console.warn(...consoleArguments);
    }
    return false;
  }
  _getTransitionsFromState(fromStateID) {
    return this._myTransitions.get(fromStateID);
  }
};
var _PendingPerform = class {
  constructor(transitionID, ...args) {
    this.myID = transitionID;
    this.myArgs = args;
  }
};

// js/pp/cauldron/fsm/state.js
var State = class {
  // Called every frame if this is the current state
  // You can retrieve this state data by calling fsm.getCurrentState()
  update(dt, fsm, ...args) {
  }
  // Called when the fsm is started with this init state if no init transition object is specified or it does not have a performInit function
  // Since the state is set as the current one after the init, you can't use fsm.getCurrentState() to get it, so it is forwarded as a param if needed
  init(fsm, state, ...args) {
  }
  // Called when entering this state if no transition object is specified or it does not have a perform function
  // You can get this state data by accesing to the to state data inside the transition
  start(fsm, transition, ...args) {
  }
  // Called when exiting this state if no transition function is specified
  // You can get this state data by accesing to the from state data inside the transition
  end(fsm, transition, ...args) {
  }
};

// js/pp/cauldron/fsm/transition.js
var Transition = class {
  // Called if this is used as an init transition for the fsm
  performInit(fsm, initState, ...args) {
  }
  // Called when performing a transition
  // You can find the from and to states inside the transition params
  perform(fsm, transition, ...args) {
  }
};

// js/pp/cauldron/fsm/states/timer_state.js
var TimerState = class extends State {
  constructor(duration = 0, transitionToPerformOnEnd = null, ...transitionArgs) {
    super();
    this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
    this._myTransitionArgs = transitionArgs;
    this._myTimer = new Timer(duration, false);
  }
  setDuration(duration) {
    this._myTimer.setDuration(duration);
  }
  setTransitionToPerformOnEnd(transitionToPerformOnEnd, ...transitionArgs) {
    this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
    this._myTransitionArgs = transitionArgs;
  }
  onEnd(callback, id = null) {
    this._myTimer.onEnd(callback, id);
  }
  unregisterOnEnd(id = null) {
    this._myTimer.unregisterOnEnd(id);
  }
  update(dt, fsm) {
    this._myTimer.update(dt);
    if (this._myTimer.isDone()) {
      if (this._myTransitionToPerformOnEnd != null) {
        fsm.perform(this._myTransitionToPerformOnEnd, ...this._myTransitionArgs);
      }
    }
  }
  start(fsm, transition, duration = null, transitionToPerformOnEnd = null, ...transitionArgs) {
    this._myTimer.start(duration);
    if (transitionToPerformOnEnd != null) {
      this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
      this._myTransitionArgs = transitionArgs;
    }
  }
  init(fsm, state, duration = null, transitionToPerformOnEnd = null, ...transitionArgs) {
    this._myTimer.start(duration);
    if (transitionToPerformOnEnd != null) {
      this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
      this._myTransitionArgs = transitionArgs;
    }
  }
};

// js/pp/cauldron/utils/color_utils.js
function rgbToHSV(rgb) {
  let hsv = rgb.pp_clone();
  let r = rgb[0];
  let g = rgb[1];
  let b = rgb[2];
  let max4 = Math.max(r, g, b), min4 = Math.min(r, g, b), d = max4 - min4, h, s = max4 === 0 ? 0 : d / max4, v = max4;
  switch (max4) {
    case min4:
      h = 0;
      break;
    case r:
      h = g - b + d * (g < b ? 6 : 0);
      h /= 6 * d;
      break;
    case g:
      h = b - r + d * 2;
      h /= 6 * d;
      break;
    case b:
      h = r - g + d * 4;
      h /= 6 * d;
      break;
  }
  hsv[0] = h;
  hsv[1] = s;
  hsv[2] = v;
  return hsv;
}
function hsvToRGB(hsv) {
  let rgb = hsv.pp_clone();
  let h = hsv[0];
  let s = hsv[1];
  let v = hsv[2];
  let r, g, b, i, f, p, q, t;
  i = Math.floor(h * 6);
  f = h * 6 - i;
  p = v * (1 - s);
  q = v * (1 - f * s);
  t = v * (1 - (1 - f) * s);
  switch (i % 6) {
    case 0:
      r = v, g = t, b = p;
      break;
    case 1:
      r = q, g = v, b = p;
      break;
    case 2:
      r = p, g = v, b = t;
      break;
    case 3:
      r = p, g = q, b = v;
      break;
    case 4:
      r = t, g = p, b = v;
      break;
    case 5:
      r = v, g = p, b = q;
      break;
  }
  rgb[0] = r;
  rgb[1] = g;
  rgb[2] = b;
  return rgb;
}
function rgbCodeToHuman(rgb) {
  return ColorUtils.color1To255(rgb);
}
function rgbHumanToCode(rgb) {
  return ColorUtils.color255To1(rgb);
}
function hsvCodeToHuman(hsv) {
  return ColorUtils.color1To255(hsv);
}
function hsvHumanToCode(hsv) {
  return ColorUtils.color255To1(hsv);
}
function color255To1(color) {
  let result = color.pp_clone();
  for (let i = 0; i < result.length; i++) {
    result[i] /= 255;
    result[i] = Math.pp_clamp(result[i], 0, 1);
  }
  return result;
}
function color1To255(color) {
  let result = color.pp_clone();
  for (let i = 0; i < result.length; i++) {
    result[i] = Math.round(result[i] * 255);
    result[i] = Math.pp_clamp(result[i], 0, 255);
  }
  return result;
}
var ColorUtils = {
  rgbToHSV,
  hsvToRGB,
  rgbCodeToHuman,
  rgbHumanToCode,
  hsvCodeToHuman,
  hsvHumanToCode,
  color255To1,
  color1To255
};

// js/pp/cauldron/utils/material_utils.js
var setAlpha = function() {
  let color = vec4_create();
  return function setAlpha2(material, alpha) {
    if (material.color != null) {
      color.vec4_copy(material.color);
      color[3] = alpha;
      material.color = color;
    }
    if (material.diffuseColor != null) {
      color.vec4_copy(material.diffuseColor);
      color[3] = alpha;
      material.diffuseColor = color;
    }
    if (material.ambientColor != null) {
      color.vec4_copy(material.ambientColor);
      color[3] = alpha;
      material.ambientColor = color;
    }
  };
}();
function setObjectAlpha(object, alpha) {
  let meshComponents = object.pp_getComponents(MeshComponent);
  for (let meshComponent of meshComponents) {
    if (meshComponent.material != null) {
      MaterialUtils.setAlpha(meshComponent.material, alpha);
    }
  }
}
function setObjectMaterial(object, material, cloneMaterial = false) {
  let meshComponents = object.pp_getComponents(MeshComponent);
  for (let meshComponent of meshComponents) {
    if (cloneMaterial) {
      meshComponent.material = material.clone();
    } else {
      meshComponent.material = material;
    }
  }
}
function setObjectClonedMaterials(object) {
  let meshComponents = object.pp_getComponents(MeshComponent);
  for (let meshComponent of meshComponents) {
    meshComponent.material = meshComponent.material.clone();
  }
}
function setObjectSpecularColor(object, color) {
  let meshComponents = object.pp_getComponents(MeshComponent);
  for (let meshComponent of meshComponents) {
    if (meshComponent.material.specularColor != null) {
      meshComponent.material.specularColor = color;
    }
  }
}
function setObjectFogColor(object, color) {
  let meshComponents = object.pp_getComponents(MeshComponent);
  for (let meshComponent of meshComponents) {
    if (meshComponent.material.fogColor != null) {
      meshComponent.material.fogColor = color;
    }
  }
}
var MaterialUtils = {
  setAlpha,
  setObjectAlpha,
  setObjectMaterial,
  setObjectClonedMaterials,
  setObjectSpecularColor,
  setObjectFogColor
};

// js/pp/cauldron/utils/text_utils.js
function setClonedMaterials(object) {
  let textComponents = object.pp_getComponents(TextComponent);
  for (let textComponent of textComponents) {
    textComponent.material = textComponent.material.clone();
  }
}
var TextUtils = {
  setClonedMaterials
};

// js/pp/cauldron/utils/analytics_utils.js
var _myAnalyticsEnabled = false;
var _mySendAnalyticsCallback = null;
var _myDataLogEnabled = false;
var _myEventsLogEnabled = false;
var _myErrorsLogEnabled = false;
function setAnalyticsEnabled(enabled) {
  _myAnalyticsEnabled = enabled;
}
function isAnalyticsEnabled() {
  return _myAnalyticsEnabled;
}
function setSendAnalyticsCallback(callback) {
  _mySendAnalyticsCallback = callback;
}
function setDataLogEnabled(enabled) {
  _myDataLogEnabled = enabled;
}
function isDataLogEnabled() {
  return _myDataLogEnabled;
}
function setEventsLogEnabled(enabled) {
  _myEventsLogEnabled = enabled;
}
function isEventsLogEnabled() {
  return _myEventsLogEnabled;
}
function setErrorsLogEnabled(enabled) {
  _myErrorsLogEnabled = enabled;
}
function isErrorsLogEnabled() {
  return _myErrorsLogEnabled;
}
function sendData(...args) {
  try {
    if (_myAnalyticsEnabled) {
      if (_myDataLogEnabled) {
        console.log("Analytics data sent: " + args);
      }
      if (_mySendAnalyticsCallback != null) {
        _mySendAnalyticsCallback(...args);
      } else if (_myErrorsLogEnabled) {
        console.error("You need to set the send analytics callback");
      }
    }
  } catch (error3) {
    if (_myErrorsLogEnabled) {
      console.error(error3);
    }
  }
}
function sendEvent(eventName, value = 1) {
  try {
    if (_myAnalyticsEnabled) {
      if (_myEventsLogEnabled) {
        console.log("Analytics event sent: " + eventName + " - Value: " + value);
      }
      if (_mySendAnalyticsCallback != null) {
        _mySendAnalyticsCallback("event", eventName, { "value": value });
      } else if (_myErrorsLogEnabled) {
        console.error("You need to set the send analytics callback");
      }
    }
  } catch (error3) {
    if (_myErrorsLogEnabled) {
      console.error(error3);
    }
  }
}
var AnalyticsUtils = {
  setAnalyticsEnabled,
  isAnalyticsEnabled,
  setSendAnalyticsCallback,
  setDataLogEnabled,
  isDataLogEnabled,
  setEventsLogEnabled,
  isEventsLogEnabled,
  setErrorsLogEnabled,
  isErrorsLogEnabled,
  sendData,
  sendEvent
};

// js/pp/debug/components/debug_transform_component.js
var DebugTransformComponent = class extends Component {
  start() {
    this._myStarted = false;
    if (Globals.isDebugEnabled(this.engine)) {
      this._myDebugVisualTransform = null;
      this._myDebugTransformParams = new VisualTransformParams(this.engine);
      this._myDebugTransformParams.myLength = this._myLength;
      this._myDebugTransformParams.myThickness = this._myThickness;
      this._myDebugVisualTransform = new VisualTransform(this._myDebugTransformParams);
      this._myDebugVisualTransform.setVisible(Globals.isDebugEnabled(this.engine));
      this._myStarted = true;
    }
  }
  update(dt) {
    if (Globals.isDebugEnabled(this.engine)) {
      if (this._myStarted) {
        this.object.pp_getTransform(this._myDebugTransformParams.myTransform);
        this._myDebugVisualTransform.paramsUpdated();
        this._myDebugVisualTransform.setVisible(true);
      }
    }
  }
  onDestroy() {
    if (this._myStarted) {
      this._myDebugVisualTransform.destroy();
    }
  }
};
__publicField(DebugTransformComponent, "TypeName", "pp-debug-transform");
__publicField(DebugTransformComponent, "Properties", {
  _myLength: Property.float(0.1),
  _myThickness: Property.float(5e-3)
});

// js/pp/debug/debug_functions_overwriter/debug_functions_overwriter.js
var DebugFunctionsOverwriterParams = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this.myObjectsByReference = [];
    this.myObjectsByPath = [];
    this.myClassesByReference = [];
    this.myClassesByPath = [];
    this.myFunctionsByPath = [];
    this.myExcludeConstructors = false;
    this.myExcludeJSObjectFunctions = false;
    this.myFunctionNamesToInclude = [];
    this.myFunctionNamesToExclude = [];
    this.myFunctionPathsToInclude = [];
    this.myFunctionPathsToExclude = [];
    this.myObjectAddObjectDescendantsDepthLevel = 0;
    this.myObjectAddClassDescendantsDepthLevel = 0;
    this.myObjectNamesToInclude = [];
    this.myObjectNamesToExclude = [];
    this.myClassNamesToInclude = [];
    this.myClassNamesToExclude = [];
    this.myObjectPathsToInclude = [];
    this.myObjectPathsToExclude = [];
    this.myClassPathsToInclude = [];
    this.myClassPathsToExclude = [];
    this.myLogEnabled = false;
    this.myEngine = engine2;
  }
};
var DebugFunctionsOverwriter = class {
  constructor(params = new DebugFunctionsOverwriterParams()) {
    this._myParams = params;
    this._myPropertiesAlreadyOverwritten = /* @__PURE__ */ new Map();
  }
  overwriteFunctions() {
    let classesAndParents = this._getReferencesAndParents(this._myParams.myClassesByReference, this._myParams.myClassesByPath, true);
    let objectsAndParents = this._getReferencesAndParents(this._myParams.myObjectsByReference, this._myParams.myObjectsByPath, false);
    let functionsAndParents = this._getReferencesAndParents([], this._myParams.myFunctionsByPath, false);
    this._objectAddDescendants(objectsAndParents, classesAndParents);
    for (let referenceAndParent of classesAndParents) {
      let reference = referenceAndParent[0];
      let referenceParent = referenceAndParent[1];
      let referenceName = referenceAndParent[2];
      let referencePath = referenceAndParent[3];
      let referenceNameForFilter = referenceAndParent[4];
      this._overwriteReferenceFunctions(reference, referenceParent, referenceName, referencePath, referenceNameForFilter, true);
    }
    for (let referenceAndParent of objectsAndParents) {
      let reference = referenceAndParent[0];
      let referenceParent = referenceAndParent[1];
      let referenceName = referenceAndParent[2];
      let referencePath = referenceAndParent[3];
      let referenceNameForFilter = referenceAndParent[4];
      this._overwriteReferenceFunctions(reference, referenceParent, referenceName, referencePath, referenceNameForFilter, false);
    }
    for (let referenceAndParent of functionsAndParents) {
      let referenceParent = referenceAndParent[1];
      let referenceName = referenceAndParent[2];
      let referencePath = referenceAndParent[3];
      this._overwriteFunction(referenceParent, referenceName, null, null, referencePath, false, true);
    }
  }
  // Hooks
  _getOverwrittenFunction(reference, propertyName, referencePath, isClass2, isFunction2) {
    return JSUtils.getObjectProperty(reference, propertyName);
  }
  _getOverwrittenConstructor(reference, propertyName, referencePath, isClass2, isFunction2) {
    return JSUtils.getObjectProperty(reference, propertyName);
  }
  _onOverwriteSuccess(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2, isConstructor) {
  }
  _onOverwriteFailure(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2, isConstructor) {
  }
  // Hooks end
  _overwriteReferenceFunctions(reference, referenceParent, referenceName, referencePath, referenceNameForFilter, isClass2) {
    let includePathList = this._myParams.myObjectPathsToInclude;
    let excludePathList = this._myParams.myObjectPathsToExclude;
    let includeNameList = this._myParams.myObjectNamesToInclude;
    let excludeNameList = this._myParams.myObjectNamesToExclude;
    if (isClass2) {
      includePathList = this._myParams.myClassPathsToInclude;
      excludePathList = this._myParams.myClassPathsToExclude;
      includeNameList = this._myParams.myClassNamesToInclude;
      excludeNameList = this._myParams.myClassNamesToExclude;
    }
    let validReferencePath = this._filterName(referencePath, includePathList, excludePathList);
    let validReferenceName = this._filterName(referenceNameForFilter, includeNameList, excludeNameList);
    if (validReferencePath && validReferenceName) {
      let propertyNames = JSUtils.getObjectPropertyNames(reference);
      if (propertyNames.pp_hasEqual("constructor")) {
        propertyNames.unshift("constructor");
      }
      for (let propertyName of propertyNames) {
        let overwriteTargetReference = null;
        let referenceParentForConstructor = null;
        let referenceNameForConstructor = null;
        if (isClass2) {
          let fixedReference = reference;
          if (referenceParent != null) {
            let ownReferenceDescriptor = Object.getOwnPropertyDescriptor(referenceParent, referenceName);
            if (ownReferenceDescriptor != null && ownReferenceDescriptor.value != null) {
              fixedReference = ownReferenceDescriptor.value;
            }
          }
          overwriteTargetReference = fixedReference.prototype;
          if (overwriteTargetReference == null) {
            overwriteTargetReference = fixedReference;
          } else {
            try {
              let referenceProperty = JSUtils.getObjectProperty(overwriteTargetReference, propertyName);
              if (referenceProperty == null) {
                overwriteTargetReference = fixedReference;
              }
            } catch (error3) {
              overwriteTargetReference = fixedReference;
            }
          }
          referenceParentForConstructor = referenceParent;
          referenceNameForConstructor = referenceName;
        } else {
          overwriteTargetReference = reference;
        }
        this._overwriteFunction(overwriteTargetReference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, false);
      }
    }
  }
  _overwriteFunction(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2) {
    try {
      let propertyCountedAlready = this._myPropertiesAlreadyOverwritten.get(propertyName) != null && this._myPropertiesAlreadyOverwritten.get(propertyName).pp_hasEqual(reference);
      if (!propertyCountedAlready) {
        if (JSUtils.isFunctionByName(reference, propertyName) || propertyName == "constructor" && JSUtils.isClassByName(reference, propertyName)) {
          if (!this._myParams.myExcludeJSObjectFunctions || !this._isJSObjectFunction(propertyName)) {
            let validFunctionName = this._filterName(propertyName, this._myParams.myFunctionNamesToInclude, this._myParams.myFunctionNamesToExclude);
            let validFunctionPath = this._filterName((referencePath != null ? referencePath + "." : "") + propertyName, this._myParams.myFunctionPathsToInclude, this._myParams.myFunctionPathsToExclude);
            if (validFunctionName && validFunctionPath) {
              if (!this._myPropertiesAlreadyOverwritten.has(propertyName)) {
                this._myPropertiesAlreadyOverwritten.set(propertyName, []);
              }
              let overwriteSuccess = false;
              let isConstructor = false;
              if (propertyName != "constructor") {
                try {
                  let newFunction = this._getOverwrittenFunction(reference, propertyName, referencePath, isClass2, isFunction2);
                  if (newFunction != JSUtils.getObjectProperty(reference, propertyName)) {
                    overwriteSuccess = JSUtils.overwriteObjectProperty(newFunction, reference, propertyName, false, true, this._myParams.myLogEnabled);
                  } else {
                    overwriteSuccess = true;
                  }
                } catch (error3) {
                  overwriteSuccess = false;
                  if (this._myParams.myLogEnabled) {
                    console.error(error3);
                  }
                }
              } else if (!this._myParams.myExcludeConstructors && isClass2 && referenceParentForConstructor != null) {
                let referenceForConstructor = JSUtils.getObjectProperty(referenceParentForConstructor, referenceNameForConstructor);
                if (referenceForConstructor != null && referenceForConstructor.prototype != null) {
                  isConstructor = true;
                  try {
                    let newConstructor = this._getOverwrittenConstructor(referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2);
                    if (newConstructor != referenceForConstructor) {
                      overwriteSuccess = JSUtils.overwriteObjectProperty(newConstructor, referenceParentForConstructor, referenceNameForConstructor, false, true, this._myParams.myLogEnabled);
                      if (overwriteSuccess) {
                        overwriteSuccess = JSUtils.overwriteObjectProperty(newConstructor, referenceForConstructor.prototype, propertyName, false, true, this._myParams.myLogEnabled);
                      }
                    } else {
                      overwriteSuccess = true;
                    }
                  } catch (error3) {
                    overwriteSuccess = false;
                    if (this._myParams.myLogEnabled) {
                      console.error(error3);
                    }
                  }
                }
              }
              if (overwriteSuccess) {
                this._myPropertiesAlreadyOverwritten.get(propertyName).push(reference);
                this._onOverwriteSuccess(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2, isConstructor);
              } else {
                this._onOverwriteFailure(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2, isConstructor);
              }
            }
          }
        }
      }
    } catch (error3) {
      if (this._myParams.myLogEnabled) {
        console.error(error3);
      }
    }
  }
  _getReferencesAndParents(byReferenceList, byPathList, isClass2) {
    let referenceAndParents = [];
    let equalCallback = (first2, second) => first2[0] == second[0];
    for (let pathPair of byPathList) {
      let path = pathPair;
      let referenceName = "";
      let referencePath = pathPair;
      let referenceNameForFilter = "";
      if (pathPair != null && Array.isArray(pathPair) && pathPair.length != null && pathPair.length == 2 && typeof pathPair[1] == "string") {
        path = pathPair[0];
        referencePath = pathPair[1];
      }
      referenceName = JSUtils.getObjectNameFromPath(path);
      referenceNameForFilter = JSUtils.getObjectNameFromPath(referencePath);
      let reference = JSUtils.getObjectFromPath(path, Globals.getWindow(this._myParams.myEngine));
      let referenceParent = JSUtils.getObjectParentFromPath(path, Globals.getWindow(this._myParams.myEngine));
      if (reference != null) {
        referenceAndParents.pp_pushUnique([reference, referenceParent, referenceName, referencePath, referenceNameForFilter], equalCallback);
      }
    }
    for (let referencePair of byReferenceList) {
      let reference = referencePair;
      let referenceName = "";
      let referencePath = "";
      let referenceNameForFilter = "";
      if (referencePair != null && referencePair.length != null && referencePair.length == 2 && typeof referencePair[1] == "string") {
        reference = referencePair[0];
        referencePath = referencePair[1];
        referenceNameForFilter = JSUtils.getObjectNameFromPath(referencePath);
      } else {
        referencePath = isClass2 ? reference.name : null;
        referenceNameForFilter = isClass2 ? reference.name : null;
      }
      if (isClass2) {
        referenceName = reference.name;
      } else {
        referenceName = JSUtils.getObjectNameFromPath(referencePath);
      }
      if (reference != null) {
        referenceAndParents.pp_pushUnique([reference, null, referenceName, referencePath, referenceNameForFilter], equalCallback);
      }
    }
    return referenceAndParents;
  }
  _objectAddDescendants(objectsAndParents, classesAndParents) {
    let equalCallback = (first2, second) => first2[0] == second[0];
    let objectsToVisit = [];
    for (let objectAndParent of objectsAndParents) {
      objectsToVisit.pp_pushUnique([objectAndParent[0], 0, objectAndParent[3]], equalCallback);
    }
    while (objectsToVisit.length > 0) {
      let objectToVisit = objectsToVisit.shift();
      let object = objectToVisit[0];
      let objectLevel = objectToVisit[1];
      let objectPath = objectToVisit[2];
      if (objectLevel + 1 <= this._myParams.myObjectAddObjectDescendantsDepthLevel || this._myParams.myObjectAddObjectDescendantsDepthLevel == -1 || objectLevel + 1 <= this._myParams.myObjectAddClassDescendantsDepthLevel || this._myParams.myObjectAddClassDescendantsDepthLevel == -1) {
        let propertyNames = null;
        try {
          propertyNames = JSUtils.getObjectPropertyNames(object);
        } catch (error3) {
          continue;
        }
        for (let propertyName of propertyNames) {
          let objectProperty = null;
          try {
            objectProperty = JSUtils.getObjectProperty(object, propertyName);
            if (objectProperty == null) {
              continue;
            }
          } catch (error3) {
            continue;
          }
          let currentPath = "";
          let currentName = "";
          if (objectPath != null) {
            currentName = propertyName;
            currentPath = objectPath + "." + currentName;
          } else {
            currentName = propertyName;
            currentPath = currentName;
          }
          let isClass2 = JSUtils.isClassByName(object, propertyName);
          let isObject2 = JSUtils.isObjectByName(object, propertyName);
          let includePathList = this._myParams.myObjectPathsToInclude;
          let excludePathList = this._myParams.myObjectPathsToExclude;
          let includeNameList = this._myParams.myObjectNamesToInclude;
          let excludeNameList = this._myParams.myObjectNamesToExclude;
          if (isClass2) {
            includePathList = this._myParams.myClassPathsToInclude;
            excludePathList = this._myParams.myClassPathsToExclude;
            includeNameList = this._myParams.myClassNamesToInclude;
            excludeNameList = this._myParams.myClassNamesToExclude;
          }
          let validReferencePath = this._filterName(currentPath, includePathList, excludePathList);
          let validReferenceName = this._filterName(propertyName, includeNameList, excludeNameList);
          if (validReferencePath && validReferenceName) {
            if (isObject2 && (objectLevel + 1 <= this._myParams.myObjectAddObjectDescendantsDepthLevel || this._myParams.myObjectAddObjectDescendantsDepthLevel == -1)) {
              objectsAndParents.pp_pushUnique([objectProperty, object, propertyName, currentPath, currentName], equalCallback);
            }
            if (isClass2 && propertyName != "constructor" && (objectLevel + 1 <= this._myParams.myObjectAddClassDescendantsDepthLevel || this._myParams.myObjectAddClassDescendantsDepthLevel == -1)) {
              classesAndParents.pp_pushUnique([objectProperty, object, propertyName, currentPath, currentName], equalCallback);
            }
            if (isObject2) {
              objectsToVisit.pp_pushUnique([objectProperty, objectLevel + 1, currentPath], equalCallback);
            }
          }
        }
      }
    }
  }
  _filterName(name, includeList, excludeList) {
    let validName = includeList.length == 0;
    for (let includeName of includeList) {
      if (name.match(includeName) != null) {
        validName = true;
        break;
      }
    }
    if (validName) {
      for (let excludeName of excludeList) {
        if (name.match(excludeName) != null) {
          validName = false;
          break;
        }
      }
    }
    return validName;
  }
  _isJSObjectFunction(propertyName) {
  }
};
DebugFunctionsOverwriter.prototype._isJSObjectFunction = function() {
  let jsObjectFunctions = [
    "__defineGetter__",
    "__defineSetter__",
    "hasOwnProperty",
    "__lookupGetter__",
    "__lookupSetter__",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toString",
    "valueOf",
    "__proto__",
    "toLocaleString",
    "arguments",
    "caller",
    "apply",
    "bind",
    "call",
    "callee"
  ];
  return function _isJSObjectFunction(propertyName) {
    return jsObjectFunctions.pp_hasEqual(propertyName);
  };
}();

// js/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/debug_functions_performance_analyzer.js
var DebugFunctionsPerformanceAnalyzerParams = class extends DebugFunctionsOverwriterParams {
  constructor() {
    super();
    this.myExecutionTimeAnalysisEnabled = true;
    this.myAddPathPrefixToFunctionID = true;
    this.myFilterDebugFunctionsPerformanceAnalyzerClasses = true;
  }
};
var DebugFunctionPerformanceAnalysisResults = class {
  constructor() {
    this.myReference = null;
    this.myName = "";
    this.myPath = "";
    this.myID = "";
    this.myCallsCount = 0;
    this.myTotalExecutionTime = 0;
    this.myTotalExecutionTimePercentage = 0;
    this.myAverageExecutionTime = 0;
    this.myTimeElapsedSinceLastReset = 0;
    this._myTotalExecutionTimeInternal = 0;
  }
  reset() {
    this.myCallsCount = 0;
    this.myTotalExecutionTime = 0;
    this.myTotalExecutionTimePercentage = 0;
    this.myAverageExecutionTime = 0;
    this.myTimeElapsedSinceLastReset = 0;
    this._myTotalExecutionTimeInternal = 0;
  }
  max(other) {
    this.myCallsCount = Math.max(this.myCallsCount, other.myCallsCount);
    this.myTotalExecutionTime = Math.max(this.myTotalExecutionTime, other.myTotalExecutionTime);
    this.myTotalExecutionTimePercentage = Math.max(this.myTotalExecutionTimePercentage, other.myTotalExecutionTimePercentage);
    this.myAverageExecutionTime = Math.max(this.myAverageExecutionTime, other.myAverageExecutionTime);
  }
  copy(other) {
    this.myReference = other.myReference;
    this.myName = other.myName;
    this.myPath = other.myPath;
    this.myID = other.myID;
    this.myCallsCount = other.myCallsCount;
    this.myTotalExecutionTime = other.myTotalExecutionTime;
    this.myTotalExecutionTimePercentage = other.myTotalExecutionTimePercentage;
    this.myAverageExecutionTime = other.myAverageExecutionTime;
    this.myTimeElapsedSinceLastReset = other.myTimeElapsedSinceLastReset;
    this._myTotalExecutionTimeInternal = other._myTotalExecutionTimeInternal;
  }
};
var DebugFunctionsPerformanceAnalyzerSortOrder = {
  NONE: 0,
  CALLS_COUNT: 1,
  TOTAL_EXECUTION_TIME: 2,
  AVERAGE_EXECUTION_TIME: 3
};
var DebugFunctionsPerformanceAnalyzer = class extends DebugFunctionsOverwriter {
  constructor(params = new DebugFunctionsPerformanceAnalyzerParams()) {
    super(params);
    this._myFunctionPerformanceAnalysisResults = /* @__PURE__ */ new Map();
    this._myFunctionPerformanceAnalysisMaxResults = /* @__PURE__ */ new Map();
    this._myResultsAlreadyAdded = false;
    this._myExecutionTimes = {
      myOverheadExecutionTimeSinceLastReset: 0,
      myLastFunctionExecutionTime: 0,
      myOriginalFunctionOverheadExecutionTimes: []
    };
    this._myTimeOfLastReset = Globals.getWindow(this._myParams.myEngine).performance.now();
    this._myMaxTimeElapsedSinceLastReset = 0;
    let originalPush = Array.prototype["push"];
    let originalPop = Array.prototype["pop"];
    this._myExecutionTimes.myOriginalFunctionOverheadExecutionTimes.push = function() {
      return originalPush.bind(this)(...arguments);
    };
    this._myExecutionTimes.myOriginalFunctionOverheadExecutionTimes.pop = function() {
      return originalPop.bind(this)(...arguments);
    };
  }
  overwriteFunctions() {
    super.overwriteFunctions();
    this.resetResults();
    this.resetMaxResults();
  }
  getTimeElapsedSinceLastReset() {
    return Globals.getWindow(this._myParams.myEngine).performance.now() - this._myTimeOfLastReset - this._myExecutionTimes.myOverheadExecutionTimeSinceLastReset;
  }
  getMaxTimeElapsedSinceLastReset() {
    this._myMaxTimeElapsedSinceLastReset = Math.max(this._myMaxTimeElapsedSinceLastReset, this.getTimeElapsedSinceLastReset());
    return this._myMaxTimeElapsedSinceLastReset;
  }
  resetResults() {
    this._updateDerivatesResults();
    this._updateMaxResults();
    for (let property2 of this._myFunctionPerformanceAnalysisResults.keys()) {
      this._myFunctionPerformanceAnalysisResults.get(property2).reset();
    }
    this._myExecutionTimes.myOverheadExecutionTimeSinceLastReset = 0;
    this._myTimeOfLastReset = Globals.getWindow(this._myParams.myEngine).performance.now();
  }
  resetMaxResults() {
    this._myMaxTimeElapsedSinceLastReset = 0;
    for (let property2 of this._myFunctionPerformanceAnalysisMaxResults.keys()) {
      this._myFunctionPerformanceAnalysisMaxResults.get(property2).reset();
    }
  }
  getResults(sortOrder = DebugFunctionsPerformanceAnalyzerSortOrder.NONE) {
    this._updateDerivatesResults();
    this._updateMaxResults();
    let results = this._myFunctionPerformanceAnalysisResults;
    results = this._sortResults(results, sortOrder);
    return results;
  }
  getMaxResults(sortOrder = DebugFunctionsPerformanceAnalyzerSortOrder.NONE) {
    this._updateDerivatesResults();
    this._updateMaxResults();
    let results = this._myFunctionPerformanceAnalysisMaxResults;
    results = this._sortResults(results, sortOrder);
    return results;
  }
  _getOverwrittenFunction(reference, propertyName, referencePath, isClass2, isFunction2) {
    return this._getOverwrittenFunctionInternal(reference, propertyName, referencePath, isClass2, isFunction2, false);
  }
  _getOverwrittenConstructor(reference, propertyName, referencePath, isClass2, isFunction2) {
    return this._getOverwrittenFunctionInternal(reference, propertyName, referencePath, isClass2, isFunction2, true);
  }
  _onOverwriteSuccess(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2, isConstructor) {
    this._myResultsAlreadyAdded = false;
  }
  _onOverwriteFailure(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2, isConstructor) {
    if (this._myResultsAlreadyAdded) {
      let propertyID = this._getPropertyID(propertyName, referencePath, isFunction2, isConstructor);
      this._myFunctionPerformanceAnalysisResults.delete(propertyID);
    }
  }
  _sortResults(results, sortOrder) {
    let sortedResults = results;
    if (sortOrder != DebugFunctionsPerformanceAnalyzerSortOrder.NONE) {
      sortedResults = new Map([...results.entries()].sort(function(first2, second) {
        let sortResult = 0;
        if (sortOrder == DebugFunctionsPerformanceAnalyzerSortOrder.CALLS_COUNT) {
          sortResult = -(first2[1].myCallsCount - second[1].myCallsCount);
          if (sortResult == 0) {
            sortResult = -(first2[1].myTotalExecutionTime - second[1].myTotalExecutionTime);
            if (sortResult == 0) {
              sortResult = -(first2[1].myAverageExecutionTime - second[1].myAverageExecutionTime);
            }
          }
        } else if (sortOrder == DebugFunctionsPerformanceAnalyzerSortOrder.TOTAL_EXECUTION_TIME) {
          sortResult = -(first2[1].myTotalExecutionTime - second[1].myTotalExecutionTime);
          if (sortResult == 0) {
            sortResult = -(first2[1].myAverageExecutionTime - second[1].myAverageExecutionTime);
            if (sortResult == 0) {
              sortResult = -(first2[1].myCallsCount - second[1].myCallsCount);
            }
          }
        } else {
          sortResult = -(first2[1].myAverageExecutionTime - second[1].myAverageExecutionTime);
          if (sortResult == 0) {
            sortResult = -(first2[1].myTotalExecutionTime - second[1].myTotalExecutionTime);
            if (sortResult == 0) {
              sortResult = -(first2[1].myCallsCount - second[1].myCallsCount);
            }
          }
        }
        return sortResult;
      }));
    }
    return sortedResults;
  }
  _getPropertyID(propertyName, referencePath, isFunction2, isConstructor) {
    let id = isConstructor ? "constructor" : propertyName;
    if (referencePath != null && this._myParams.myAddPathPrefixToFunctionID) {
      if (!isFunction2) {
        id = referencePath + "." + id;
      } else {
        id = referencePath;
      }
    }
    return id;
  }
  _updateDerivatesResults() {
    let timeElapsedSinceLastReset = this.getTimeElapsedSinceLastReset();
    let beforeTime = Globals.getWindow(this._myParams.myEngine).performance.now();
    for (let property2 of this._myFunctionPerformanceAnalysisResults.keys()) {
      let results = this._myFunctionPerformanceAnalysisResults.get(property2);
      if (timeElapsedSinceLastReset != 0) {
        results.myTotalExecutionTimePercentage = results.myTotalExecutionTime / timeElapsedSinceLastReset;
      } else {
        if (results.myCallsCount != 0) {
          results.myTotalExecutionTimePercentage = 1;
        } else {
          results.myTotalExecutionTimePercentage = 0;
        }
      }
      if (results.myCallsCount != 0) {
        results.myAverageExecutionTime = results.myTotalExecutionTime / results.myCallsCount;
      } else {
        results.myAverageExecutionTime = 0;
      }
      results.myTimeElapsedSinceLastReset = timeElapsedSinceLastReset;
    }
    this._myExecutionTimes.myOverheadExecutionTimeSinceLastReset += Globals.getWindow(this._myParams.myEngine).performance.now() - beforeTime;
  }
  _updateMaxResults() {
    let beforeTime = Globals.getWindow(this._myParams.myEngine).performance.now();
    this._myMaxTimeElapsedSinceLastReset = Math.max(this._myMaxTimeElapsedSinceLastReset, this.getTimeElapsedSinceLastReset());
    for (let property2 of this._myFunctionPerformanceAnalysisResults.keys()) {
      if (this._myFunctionPerformanceAnalysisMaxResults.has(property2)) {
        this._myFunctionPerformanceAnalysisMaxResults.get(property2).max(this._myFunctionPerformanceAnalysisResults.get(property2));
      } else {
        let maxResults = new DebugFunctionPerformanceAnalysisResults();
        maxResults.copy(this._myFunctionPerformanceAnalysisResults.get(property2));
        this._myFunctionPerformanceAnalysisMaxResults.set(property2, maxResults);
      }
    }
    this._myExecutionTimes.myOverheadExecutionTimeSinceLastReset += Globals.getWindow(this._myParams.myEngine).performance.now() - beforeTime;
  }
  _getOverwrittenFunctionInternal(reference, propertyName, referencePath, isClass2, isFunction2, isConstructor) {
    let newFunction = JSUtils.getObjectProperty(reference, propertyName);
    if (!this._myParams.myFilterDebugFunctionsPerformanceAnalyzerClasses || !this._isPerformanceAnalyzer(reference, propertyName, isClass2)) {
      if (propertyName != "_myPerformanceAnalyzerOriginalFunction") {
        let propertyID = this._getPropertyID(propertyName, referencePath, isFunction2, isConstructor);
        this._myResultsAlreadyAdded = this._myFunctionPerformanceAnalysisResults.has(propertyID);
        let analysisResults = new DebugFunctionPerformanceAnalysisResults();
        analysisResults.myReference = reference;
        analysisResults.myName = propertyName;
        analysisResults.myPath = referencePath;
        analysisResults.myID = referencePath;
        this._myFunctionPerformanceAnalysisResults.set(propertyID, analysisResults);
        try {
          let window2 = Globals.getWindow(this._myParams.myEngine);
          let functionPerformanceAnalysisResults = this._myFunctionPerformanceAnalysisResults.get(propertyID);
          let executionTimes = this._myExecutionTimes;
          let originalFunction = reference[propertyName];
          let functionCallOverhead = 175e-6;
          let overheadError = 35e-5;
          let executionTimeAnalysisEnabled = this._myParams.myExecutionTimeAnalysisEnabled;
          if (!isConstructor) {
            newFunction = function() {
              let startTime = window2.performance.now();
              let errorToThrow = null;
              let returnValue = void 0;
              let boundOriginalFunction = null;
              let startOriginalFunctionTime = 0;
              let endOriginalFunctionTime = 0;
              let originalFunctionOverheadExecutionTime = 0;
              let executionTimeToAdjust = 0;
              let executionTime = 0;
              let beforeOverhead = 0;
              let inBetweenOverhead = 0;
              if (executionTimeAnalysisEnabled) {
                executionTimes.myOriginalFunctionOverheadExecutionTimes.push(0);
                startOriginalFunctionTime = window2.performance.now();
                endOriginalFunctionTime = window2.performance.now();
                try {
                  boundOriginalFunction = originalFunction.bind(this);
                  startOriginalFunctionTime = window2.performance.now();
                  returnValue = boundOriginalFunction(...arguments);
                  endOriginalFunctionTime = window2.performance.now();
                } catch (error3) {
                  endOriginalFunctionTime = window2.performance.now();
                  errorToThrow = error3;
                }
              } else {
                try {
                  boundOriginalFunction = originalFunction.bind(this);
                  returnValue = boundOriginalFunction(...arguments);
                } catch (error3) {
                  errorToThrow = error3;
                }
              }
              functionPerformanceAnalysisResults.myCallsCount += 1;
              if (executionTimeAnalysisEnabled) {
                originalFunctionOverheadExecutionTime = executionTimes.myOriginalFunctionOverheadExecutionTimes.pop();
                executionTimeToAdjust = endOriginalFunctionTime - startOriginalFunctionTime - originalFunctionOverheadExecutionTime;
                executionTime = executionTimeToAdjust - functionCallOverhead;
                if (originalFunction._myPerformanceAnalyzerHasBeenOverwritten) {
                  executionTime = executionTimes.myLastFunctionExecutionTime;
                }
                functionPerformanceAnalysisResults._myTotalExecutionTimeInternal += executionTime;
                functionPerformanceAnalysisResults.myTotalExecutionTime = Math.max(0, functionPerformanceAnalysisResults._myTotalExecutionTimeInternal);
                executionTimes.myLastFunctionExecutionTime = executionTime;
                beforeOverhead = startOriginalFunctionTime - startTime;
                inBetweenOverhead = beforeOverhead - endOriginalFunctionTime - overheadError;
                if (executionTimes.myOriginalFunctionOverheadExecutionTimes.length > 0) {
                  executionTimes.myOriginalFunctionOverheadExecutionTimes[executionTimes.myOriginalFunctionOverheadExecutionTimes.length - 1] += inBetweenOverhead + originalFunctionOverheadExecutionTime + overheadError * 2.75;
                  executionTimes.myOriginalFunctionOverheadExecutionTimes[executionTimes.myOriginalFunctionOverheadExecutionTimes.length - 1] += window2.performance.now();
                }
                executionTimes.myOverheadExecutionTimeSinceLastReset += inBetweenOverhead;
                executionTimes.myOverheadExecutionTimeSinceLastReset += window2.performance.now();
              }
              if (errorToThrow != null) {
                throw errorToThrow;
              }
              return returnValue;
            };
          } else {
            newFunction = function() {
              let startTime = window2.performance.now();
              let errorToThrow = null;
              let returnValue = void 0;
              let startOriginalFunctionTime = 0;
              let endOriginalFunctionTime = 0;
              let originalFunctionOverheadExecutionTime = 0;
              let executionTimeToAdjust = 0;
              let executionTime = 0;
              let beforeOverhead = 0;
              let inBetweenOverhead = 0;
              if (executionTimeAnalysisEnabled) {
                executionTimes.myOriginalFunctionOverheadExecutionTimes.push(0);
                startOriginalFunctionTime = window2.performance.now();
                endOriginalFunctionTime = window2.performance.now();
                try {
                  startOriginalFunctionTime = window2.performance.now();
                  returnValue = new originalFunction(...arguments);
                  endOriginalFunctionTime = window2.performance.now();
                } catch (error3) {
                  endOriginalFunctionTime = window2.performance.now();
                  errorToThrow = error3;
                }
              } else {
                try {
                  returnValue = new originalFunction(...arguments);
                } catch (error3) {
                  errorToThrow = error3;
                }
              }
              functionPerformanceAnalysisResults.myCallsCount += 1;
              if (executionTimeAnalysisEnabled) {
                originalFunctionOverheadExecutionTime = executionTimes.myOriginalFunctionOverheadExecutionTimes.pop();
                executionTimeToAdjust = endOriginalFunctionTime - startOriginalFunctionTime - originalFunctionOverheadExecutionTime;
                executionTime = executionTimeToAdjust - functionCallOverhead;
                if (originalFunction._myPerformanceAnalyzerHasBeenOverwritten) {
                  executionTime = executionTimes.myLastFunctionExecutionTime;
                }
                functionPerformanceAnalysisResults._myTotalExecutionTimeInternal += executionTime;
                functionPerformanceAnalysisResults.myTotalExecutionTime = Math.max(0, functionPerformanceAnalysisResults._myTotalExecutionTimeInternal);
                executionTimes.myLastFunctionExecutionTime = executionTime;
                beforeOverhead = startOriginalFunctionTime - startTime;
                inBetweenOverhead = beforeOverhead - endOriginalFunctionTime - overheadError;
                if (executionTimes.myOriginalFunctionOverheadExecutionTimes.length > 0) {
                  executionTimes.myOriginalFunctionOverheadExecutionTimes[executionTimes.myOriginalFunctionOverheadExecutionTimes.length - 1] += inBetweenOverhead + originalFunctionOverheadExecutionTime + overheadError * 2.75;
                  executionTimes.myOriginalFunctionOverheadExecutionTimes[executionTimes.myOriginalFunctionOverheadExecutionTimes.length - 1] += window2.performance.now();
                }
                executionTimes.myOverheadExecutionTimeSinceLastReset += inBetweenOverhead;
                executionTimes.myOverheadExecutionTimeSinceLastReset += window2.performance.now();
              }
              if (errorToThrow != null) {
                throw errorToThrow;
              }
              return returnValue;
            };
          }
          if (newFunction != null) {
            Object.defineProperty(newFunction, "_myPerformanceAnalyzerHasBeenOverwritten", {
              value: true,
              enumerable: false,
              configurable: false,
              writable: false
            });
            Object.defineProperty(newFunction, "_myPerformanceAnalyzerOriginalFunction", {
              value: originalFunction,
              enumerable: false,
              configurable: false,
              writable: false
            });
          }
        } catch (error3) {
          if (this._myParams.myLogEnabled) {
            console.error("Function:", propertyName, "of:", reference, "can't be overwritten.\nError:", error3);
          }
        }
      }
    }
    return newFunction;
  }
  _isPerformanceAnalyzer(reference, propertyName, isClass2) {
    let isPerformanceAnalyzer = false;
    if (isClass2) {
      if (reference == DebugFunctionsPerformanceAnalyzer.prototype || reference == DebugFunctionPerformanceAnalysisResults.prototype) {
        isPerformanceAnalyzer = true;
      }
    }
    return isPerformanceAnalyzer;
  }
};

// js/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/debug_functions_performance_analysis_results_logger.js
var DebugFunctionsPerformanceAnalysisResultsLoggerParams = class {
  constructor() {
    this.myPerformanceAnalyzer = null;
    this.myLogTitle = "Functions Performance Analysis Results";
    this.mySecondsBetweenLogs = 1;
    this.myLogFunction = "log";
    this.myFormatLog = true;
    this.myFormatLogIndentationCharacter = "-";
    this.myLogMaxResults = false;
    this.myLogSortOrder = DebugFunctionsPerformanceAnalyzerSortOrder.NONE;
    this.myLogMaxAmountOfFunctions = null;
    this.myLogFunctionsWithCallsCountAbove = null;
    this.myLogFunctionsWithTotalExecutionTimePercentageAbove = null;
    this.myLogCallsCountResults = false;
    this.myLogTotalExecutionTimeResults = false;
    this.myLogTotalExecutionTimePercentageResults = false;
    this.myLogAverageExecutionTimeResults = false;
    this.myClearConsoleBeforeLog = false;
  }
};
var DebugFunctionsPerformanceAnalysisResultsLogger = class {
  constructor(params) {
    this._myParams = params;
    this._myLogTimer = new Timer(this._myParams.mySecondsBetweenLogs);
    this._myMaxNameLength = 0;
    this._myMaxCallsCountLength = 0;
    this._myMaxTotalExecutionTimeLength = 0;
    this._myMaxTotalExecutionTimePercentageLength = 0;
    this._myMaxAverageExecutionTimeLength = 0;
  }
  update(dt) {
    if (this._myParams.myPerformanceAnalyzer == null) {
      return;
    }
    this._myLogTimer.update(dt);
    if (this._myLogTimer.isDone()) {
      this._myLogTimer.start();
      let timeSinceLastReset = this._myParams.myPerformanceAnalyzer.getTimeElapsedSinceLastReset();
      if (this._myParams.myLogMaxResults) {
        timeSinceLastReset = this._myParams.myPerformanceAnalyzer.getMaxTimeElapsedSinceLastReset();
      }
      let analysisResults = null;
      if (!this._myParams.myLogMaxResults) {
        analysisResults = this._myParams.myPerformanceAnalyzer.getResults(this._myParams.myLogSortOrder);
      } else {
        analysisResults = this._myParams.myPerformanceAnalyzer.getMaxResults(this._myParams.myLogSortOrder);
      }
      if (this._myParams.myLogFunctionsWithCallsCountAbove != null) {
        let analysisResultsClone = new Map(analysisResults);
        analysisResults = /* @__PURE__ */ new Map();
        let keys = [...analysisResultsClone.keys()];
        for (let i = 0; i < keys.length; i++) {
          let results = analysisResultsClone.get(keys[i]);
          if (results.myCallsCount > this._myParams.myLogFunctionsWithCallsCountAbove) {
            analysisResults.set(keys[i], results);
          }
        }
      }
      if (this._myParams.myLogFunctionsWithTotalExecutionTimePercentageAbove != null) {
        let analysisResultsClone = new Map(analysisResults);
        analysisResults = /* @__PURE__ */ new Map();
        let keys = [...analysisResultsClone.keys()];
        for (let i = 0; i < keys.length; i++) {
          let results = analysisResultsClone.get(keys[i]);
          if (results.myTotalExecutionTimePercentage * 100 > this._myParams.myLogFunctionsWithTotalExecutionTimePercentageAbove) {
            analysisResults.set(keys[i], results);
          }
        }
      }
      if (this._myParams.myLogMaxAmountOfFunctions != null) {
        let analysisResultsClone = new Map(analysisResults);
        analysisResults = /* @__PURE__ */ new Map();
        let keys = [...analysisResultsClone.keys()];
        for (let i = 0; i < this._myParams.myLogMaxAmountOfFunctions && i < keys.length; i++) {
          let counter = analysisResultsClone.get(keys[i]);
          analysisResults.set(keys[i], counter);
        }
      }
      if (this._myParams.myClearConsoleBeforeLog) {
        console.clear();
      }
      let analysisResultsToLog = /* @__PURE__ */ new Map();
      for (let key of analysisResults.keys()) {
        let currentResults = analysisResults.get(key);
        let resultsToLog = {};
        if (this._myParams.myLogCallsCountResults) {
          resultsToLog.myCallsCount = currentResults.myCallsCount;
        }
        if (this._myParams.myLogTotalExecutionTimeResults) {
          resultsToLog.myTotalExecutionTime = currentResults.myTotalExecutionTime;
        }
        if (this._myParams.myLogTotalExecutionTimePercentageResults) {
          resultsToLog.myTotalExecutionTimePercentage = currentResults.myTotalExecutionTimePercentage;
        }
        if (this._myParams.myLogAverageExecutionTimeResults) {
          resultsToLog.myAverageExecutionTime = currentResults.myAverageExecutionTime;
        }
        analysisResultsToLog.set(key, resultsToLog);
      }
      let resultsText = "";
      for (let entry of analysisResults.entries()) {
        let name = entry[0];
        let results = entry[1];
        this._myMaxNameLength = Math.max(this._myMaxNameLength, name.length);
        this._myMaxCallsCountLength = Math.max(this._myMaxCallsCountLength, results.myCallsCount.toFixed(0).length);
        this._myMaxTotalExecutionTimeLength = Math.max(this._myMaxTotalExecutionTimeLength, results.myTotalExecutionTime.toFixed(5).length);
        this._myMaxTotalExecutionTimePercentageLength = Math.max(this._myMaxTotalExecutionTimePercentageLength, (results.myTotalExecutionTimePercentage * 100).toFixed(2).length);
        this._myMaxAverageExecutionTimeLength = Math.max(this._myMaxAverageExecutionTimeLength, results.myAverageExecutionTime.toFixed(5).length);
      }
      for (let entry of analysisResults.entries()) {
        let name = entry[0];
        let results = entry[1];
        let parametersToLog = 0;
        if (this._myParams.myLogCallsCountResults) {
          parametersToLog++;
        }
        if (this._myParams.myLogTotalExecutionTimeResults) {
          parametersToLog++;
        }
        if (this._myParams.myLogTotalExecutionTimePercentageResults) {
          parametersToLog++;
        }
        if (this._myParams.myLogAverageExecutionTimeResults) {
          parametersToLog++;
        }
        let textOrdered = [];
        let callsCountText = parametersToLog > 1 ? "Calls Count: " : "";
        if (this._myParams.myFormatLog) {
          for (let i = 0; i < this._myMaxCallsCountLength - results.myCallsCount.toFixed(0).length; i++) {
            callsCountText += " ";
          }
        }
        callsCountText += results.myCallsCount.toFixed(0);
        let totalExecutionTimeText = parametersToLog > 1 ? "Total Time: " : "";
        if (this._myParams.myFormatLog) {
          for (let i = 0; i < this._myMaxTotalExecutionTimeLength - results.myTotalExecutionTime.toFixed(5).length; i++) {
            totalExecutionTimeText += " ";
          }
        }
        totalExecutionTimeText += results.myTotalExecutionTime.toFixed(5) + "ms";
        let totalExecutionTimePercentageText = parametersToLog > 1 ? "Total Time: " : "";
        if (this._myParams.myFormatLog) {
          for (let i = 0; i < this._myMaxTotalExecutionTimePercentageLength - (results.myTotalExecutionTimePercentage * 100).toFixed(2).length; i++) {
            totalExecutionTimePercentageText += " ";
          }
        }
        totalExecutionTimePercentageText += (results.myTotalExecutionTimePercentage * 100).toFixed(2) + "%";
        let averageExecutionTimeText = parametersToLog > 1 ? "Average Time: " : "";
        if (this._myParams.myFormatLog) {
          for (let i = 0; i < this._myMaxAverageExecutionTimeLength - results.myAverageExecutionTime.toFixed(5).length; i++) {
            averageExecutionTimeText += " ";
          }
        }
        averageExecutionTimeText += results.myAverageExecutionTime.toFixed(5) + "ms";
        if (!this._myParams.myLogCallsCountResults) {
          callsCountText = null;
        }
        if (!this._myParams.myLogTotalExecutionTimeResults) {
          totalExecutionTimeText = null;
        }
        if (!this._myParams.myLogTotalExecutionTimePercentageResults) {
          totalExecutionTimePercentageText = null;
        }
        if (!this._myParams.myLogAverageExecutionTimeResults) {
          averageExecutionTimeText = null;
        }
        switch (this._myParams.myLogSortOrder) {
          case DebugFunctionsPerformanceAnalyzerSortOrder.CALLS_COUNT:
            textOrdered.push(callsCountText);
            textOrdered.push(totalExecutionTimeText);
            textOrdered.push(totalExecutionTimePercentageText);
            textOrdered.push(averageExecutionTimeText);
            break;
          case DebugFunctionsPerformanceAnalyzerSortOrder.TOTAL_EXECUTION_TIME:
            textOrdered.push(totalExecutionTimeText);
            textOrdered.push(totalExecutionTimePercentageText);
            textOrdered.push(averageExecutionTimeText);
            textOrdered.push(callsCountText);
            break;
          case DebugFunctionsPerformanceAnalyzerSortOrder.AVERAGE_EXECUTION_TIME:
            textOrdered.push(averageExecutionTimeText);
            textOrdered.push(totalExecutionTimeText);
            textOrdered.push(totalExecutionTimePercentageText);
            textOrdered.push(callsCountText);
            break;
          default:
            textOrdered.push(callsCountText);
            textOrdered.push(totalExecutionTimeText);
            textOrdered.push(totalExecutionTimePercentageText);
            textOrdered.push(averageExecutionTimeText);
        }
        resultsText += "\n";
        if (this._myParams.myFormatLog) {
          let nameIndented = name + " ";
          while (nameIndented.length < this._myMaxNameLength + 1) {
            nameIndented += this._myParams.myFormatLogIndentationCharacter;
          }
          nameIndented += this._myParams.myFormatLogIndentationCharacter + " ";
          resultsText += nameIndented;
        } else {
          resultsText += name + " - ";
        }
        let avoidFirst = true;
        for (let text of textOrdered) {
          if (text != null) {
            if (avoidFirst) {
              avoidFirst = false;
            } else {
              resultsText += " - ";
            }
            resultsText += text;
          }
        }
      }
      if (this._myParams.myLogTotalExecutionTimeResults || this._myParams.myLogTotalExecutionTimePercentageResults || this._myParams.myLogAverageExecutionTimeResults) {
        console[this._myParams.myLogFunction]("\n" + this._myParams.myLogTitle, "\n\nTotal Time:", timeSinceLastReset.toFixed(5), "ms\n", resultsText);
      } else {
        console[this._myParams.myLogFunction]("\n" + this._myParams.myLogTitle, "\n", resultsText);
      }
    }
  }
};

// js/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_functions_performance_analyzer_component.js
var DebugFunctionsPerformanceAnalyzerComponent = class extends Component {
  init() {
    this._myActive = false;
    if (Globals.isDebugEnabled(this.engine)) {
      this._myActive = true;
      this._myFunctionsPerformanceAnalyzer = null;
      this._myFunctionsPerformanceAnalysisResultsLogger = null;
      this._mySkipFirstUpdate = true;
      this._myStartTimer = new Timer(this._myDelayStart);
      if (this._myDelayStart == 0) {
        this._myStartTimer.end();
        this._mySkipFirstUpdate = false;
        this._start();
      }
    }
  }
  update(dt) {
    if (this._myActive) {
      if (this._mySkipFirstUpdate) {
        this._mySkipFirstUpdate = false;
        return;
      }
      if (this._myStartTimer.isRunning()) {
        this._myStartTimer.update(dt);
        if (this._myStartTimer.isDone()) {
          this._start();
        }
      } else {
        this._myFunctionsPerformanceAnalysisResultsLogger.update(dt);
        this._myFunctionsPerformanceAnalyzer.resetResults();
      }
      if (this._myResetMaxResultsShortcutEnabled) {
        if (Globals.getLeftGamepad(this.engine).getButtonInfo(GamepadButtonID.SELECT).isPressEnd(3)) {
          this._myFunctionsPerformanceAnalyzer.resetMaxResults();
        }
      }
    }
  }
  _start() {
    let functionsPerformanceAnalyzerParams = new DebugFunctionsPerformanceAnalyzerParams(this.engine);
    if (this._myObjectsByPath.length > 0) {
      let toIncludeList = [...this._myObjectsByPath.split(",")];
      for (let i = 0; i < toIncludeList.length; i++) {
        toIncludeList[i] = toIncludeList[i].trim();
      }
      functionsPerformanceAnalyzerParams.myObjectsByPath.push(...toIncludeList);
    }
    if (this._myClassesByPath.length > 0) {
      let toIncludeList = [...this._myClassesByPath.split(",")];
      for (let i = 0; i < toIncludeList.length; i++) {
        toIncludeList[i] = toIncludeList[i].trim();
      }
      functionsPerformanceAnalyzerParams.myClassesByPath.push(...toIncludeList);
    }
    if (this._myFunctionsByPath.length > 0) {
      let toIncludeList = [...this._myFunctionsByPath.split(",")];
      for (let i = 0; i < toIncludeList.length; i++) {
        toIncludeList[i] = toIncludeList[i].trim();
      }
      functionsPerformanceAnalyzerParams.myFunctionsByPath.push(...toIncludeList);
    }
    functionsPerformanceAnalyzerParams.myExcludeConstructors = this._myExcludeConstructors;
    functionsPerformanceAnalyzerParams.myExcludeJSObjectFunctions = this._myExcludeJSObjectFunctions;
    functionsPerformanceAnalyzerParams.myAddPathPrefixToFunctionID = this._myAddPathPrefixToFunctionID;
    if (this._myFunctionPathsToInclude.length > 0) {
      let toIncludeList = [...this._myFunctionPathsToInclude.split(",")];
      for (let i = 0; i < toIncludeList.length; i++) {
        toIncludeList[i] = toIncludeList[i].trim();
      }
      functionsPerformanceAnalyzerParams.myFunctionPathsToInclude.push(...toIncludeList);
    }
    if (this._myFunctionPathsToExclude.length > 0) {
      let toExcludeList = [...this._myFunctionPathsToExclude.split(",")];
      for (let i = 0; i < toExcludeList.length; i++) {
        toExcludeList[i] = toExcludeList[i].trim();
      }
      functionsPerformanceAnalyzerParams.myFunctionPathsToExclude.push(...toExcludeList);
    }
    functionsPerformanceAnalyzerParams.myObjectAddObjectDescendantsDepthLevel = this._myObjectAddObjectDescendantsDepthLevel;
    functionsPerformanceAnalyzerParams.myObjectAddClassDescendantsDepthLevel = this._myObjectAddClassDescendantsDepthLevel;
    functionsPerformanceAnalyzerParams.myExecutionTimeAnalysisEnabled = this._myLogTotalExecutionTimeResults || this._myLogTotalExecutionTimePercentageResults || this._myLogAverageExecutionTimeResults;
    functionsPerformanceAnalyzerParams.myClassesByReference = this._myClassesByReference != 0 ? this._myClassesByReference : [];
    functionsPerformanceAnalyzerParams.myObjectsByReference = this._myObjectsByReference != 0 ? this._myObjectsByReference : [];
    this._myFunctionsPerformanceAnalyzer = new DebugFunctionsPerformanceAnalyzer(functionsPerformanceAnalyzerParams);
    this._myFunctionsPerformanceAnalyzer.overwriteFunctions();
    let functionsPerformanceAnalysisResultsLoggerParams = new DebugFunctionsPerformanceAnalysisResultsLoggerParams();
    functionsPerformanceAnalysisResultsLoggerParams.myPerformanceAnalyzer = this._myFunctionsPerformanceAnalyzer;
    functionsPerformanceAnalysisResultsLoggerParams.myLogTitle = this._myLogTitle;
    functionsPerformanceAnalysisResultsLoggerParams.mySecondsBetweenLogs = this._mySecondsBetweenLogs;
    functionsPerformanceAnalysisResultsLoggerParams.myLogFunction = ["log", "error", "warn", "debug"][this._myLogFunction];
    functionsPerformanceAnalysisResultsLoggerParams.myLogMaxAmountOfFunctions = this._myLogMaxAmountOfFunctions >= 0 ? this._myLogMaxAmountOfFunctions : null;
    functionsPerformanceAnalysisResultsLoggerParams.myLogFunctionsWithCallsCountAbove = this._myLogFunctionsWithCallsCountAbove >= 0 ? this._myLogFunctionsWithCallsCountAbove : null;
    functionsPerformanceAnalysisResultsLoggerParams.myLogFunctionsWithTotalExecutionTimePercentageAbove = this._myLogFunctionsWithTotalExecutionTimePercentageAbove >= 0 ? this._myLogFunctionsWithTotalExecutionTimePercentageAbove : null;
    functionsPerformanceAnalysisResultsLoggerParams.myLogMaxResults = this._myLogMaxResults;
    functionsPerformanceAnalysisResultsLoggerParams.myClearConsoleBeforeLog = this._myClearConsoleBeforeLog;
    functionsPerformanceAnalysisResultsLoggerParams.myLogSortOrder = this._myLogSortOrder;
    functionsPerformanceAnalysisResultsLoggerParams.myLogCallsCountResults = this._myLogCallsCountResults;
    functionsPerformanceAnalysisResultsLoggerParams.myLogTotalExecutionTimeResults = this._myLogTotalExecutionTimeResults;
    functionsPerformanceAnalysisResultsLoggerParams.myLogTotalExecutionTimePercentageResults = this._myLogTotalExecutionTimePercentageResults;
    functionsPerformanceAnalysisResultsLoggerParams.myLogAverageExecutionTimeResults = this._myLogAverageExecutionTimeResults;
    this._myFunctionsPerformanceAnalysisResultsLogger = new DebugFunctionsPerformanceAnalysisResultsLogger(functionsPerformanceAnalysisResultsLoggerParams);
  }
};
__publicField(DebugFunctionsPerformanceAnalyzerComponent, "TypeName", "pp-debug-functions-performance-analyzer");
__publicField(DebugFunctionsPerformanceAnalyzerComponent, "Properties", {
  _myObjectsByPath: Property.string(""),
  _myClassesByPath: Property.string(""),
  _myFunctionsByPath: Property.string(""),
  _myDelayStart: Property.float(0),
  _myLogTitle: Property.string("Functions Performance Analysis Results"),
  _myLogFunction: Property.enum(["Log", "Error", "Warn", "Debug"], "Log"),
  _mySecondsBetweenLogs: Property.float(1),
  _myLogMaxResults: Property.bool(false),
  _myLogSortOrder: Property.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "None"),
  _myLogCallsCountResults: Property.bool(true),
  _myLogTotalExecutionTimeResults: Property.bool(true),
  _myLogTotalExecutionTimePercentageResults: Property.bool(true),
  _myLogAverageExecutionTimeResults: Property.bool(true),
  _myLogMaxAmountOfFunctions: Property.int(-1),
  _myLogFunctionsWithCallsCountAbove: Property.int(-1),
  _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property.float(-1),
  _myFunctionPathsToInclude: Property.string(""),
  _myFunctionPathsToExclude: Property.string(""),
  _myExcludeConstructors: Property.bool(false),
  _myExcludeJSObjectFunctions: Property.bool(true),
  _myAddPathPrefixToFunctionID: Property.bool(true),
  _myObjectAddObjectDescendantsDepthLevel: Property.int(0),
  _myObjectAddClassDescendantsDepthLevel: Property.int(0),
  _myClearConsoleBeforeLog: Property.bool(false),
  _myResetMaxResultsShortcutEnabled: Property.bool(false),
  _myClassesByReference: Property.enum(["Code Driven"], "Code Driven"),
  _myObjectsByReference: Property.enum(["Code Driven"], "Code Driven")
});

// js/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_pp_functions_performance_analyzer_component.js
var DebugPPFunctionsPerformanceAnalyzerComponent = class extends Component {
  init() {
    this.object.pp_addComponent(DebugFunctionsPerformanceAnalyzerComponent, {
      _myObjectsByPath: "PP",
      _myDelayStart: this._myDelayStart,
      _myLogTitle: "PP Functions Performance Analysis Results",
      _myLogFunction: this._myLogFunction,
      _mySecondsBetweenLogs: this._mySecondsBetweenLogs,
      _myLogMaxResults: this._myLogMaxResults,
      _myLogSortOrder: this._myLogSortOrder,
      _myLogMaxAmountOfFunctions: this._myLogMaxAmountOfFunctions,
      _myLogFunctionsWithCallsCountAbove: this._myLogFunctionsWithCallsCountAbove,
      _myLogFunctionsWithTotalExecutionTimePercentageAbove: this._myLogFunctionsWithTotalExecutionTimePercentageAbove,
      _myLogCallsCountResults: this._myLogCallsCountResults,
      _myLogTotalExecutionTimeResults: this._myLogTotalExecutionTimeResults,
      _myLogTotalExecutionTimePercentageResults: this._myLogTotalExecutionTimePercentageResults,
      _myLogAverageExecutionTimeResults: this._myLogAverageExecutionTimeResults,
      _myFunctionPathsToInclude: this._myFunctionPathsToInclude,
      _myFunctionPathsToExclude: this._myFunctionPathsToExclude,
      _myExcludeConstructors: this._myExcludeConstructors,
      _myExcludeJSObjectFunctions: true,
      _myAddPathPrefixToFunctionID: true,
      _myObjectAddObjectDescendantsDepthLevel: 1,
      _myObjectAddClassDescendantsDepthLevel: 1,
      _myClearConsoleBeforeLog: this._myClearConsoleBeforeLog,
      _myResetMaxResultsShortcutEnabled: this._myResetMaxResultsShortcutEnabled
    });
  }
};
__publicField(DebugPPFunctionsPerformanceAnalyzerComponent, "TypeName", "pp-debug-pp-functions-performance-analyzer");
__publicField(DebugPPFunctionsPerformanceAnalyzerComponent, "Properties", {
  _myDelayStart: Property.float(0),
  _myLogFunction: Property.enum(["Log", "Error", "Warn", "Debug"], "Log"),
  _mySecondsBetweenLogs: Property.float(1),
  _myLogMaxResults: Property.bool(false),
  _myLogSortOrder: Property.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "None"),
  _myLogCallsCountResults: Property.bool(true),
  _myLogTotalExecutionTimeResults: Property.bool(true),
  _myLogTotalExecutionTimePercentageResults: Property.bool(true),
  _myLogAverageExecutionTimeResults: Property.bool(true),
  _myLogMaxAmountOfFunctions: Property.int(-1),
  _myLogFunctionsWithCallsCountAbove: Property.int(-1),
  _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property.float(-1),
  _myFunctionPathsToInclude: Property.string(""),
  _myFunctionPathsToExclude: Property.string(""),
  _myExcludeConstructors: Property.bool(false),
  _myClearConsoleBeforeLog: Property.bool(false),
  _myResetMaxResultsShortcutEnabled: Property.bool(false)
});

// js/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_array_functions_performance_analyzer_component.js
var DebugArrayFunctionsPerformanceAnalyzerComponent = class extends Component {
  init() {
    let classesByPath = "Array, Uint8ClampedArray, Uint8Array, Uint16Array, Uint32Array, Int8Array, Int16Array, Int32Array, Float32Array, Float64Array";
    if (this._myIncludeOnlyMainArrayTypes) {
      classesByPath = "Array, Uint8Array, Uint16Array, Float32Array";
    }
    this.object.pp_addComponent(DebugFunctionsPerformanceAnalyzerComponent, {
      _myClassesByPath: classesByPath,
      _myDelayStart: this._myDelayStart,
      _myLogTitle: "Array Functions Performance Analysis Results",
      _myLogFunction: this._myLogFunction,
      _mySecondsBetweenLogs: this._mySecondsBetweenLogs,
      _myLogMaxResults: this._myLogMaxResults,
      _myLogSortOrder: this._myLogSortOrder,
      _myLogMaxAmountOfFunctions: this._myLogMaxAmountOfFunctions,
      _myLogFunctionsWithCallsCountAbove: this._myLogFunctionsWithCallsCountAbove,
      _myLogFunctionsWithTotalExecutionTimePercentageAbove: this._myLogFunctionsWithTotalExecutionTimePercentageAbove,
      _myLogCallsCountResults: this._myLogCallsCountResults,
      _myLogTotalExecutionTimeResults: this._myLogTotalExecutionTimeResults,
      _myLogTotalExecutionTimePercentageResults: this._myLogTotalExecutionTimePercentageResults,
      _myLogAverageExecutionTimeResults: this._myLogAverageExecutionTimeResults,
      _myFunctionPathsToInclude: this._myFunctionPathsToInclude + (this._myFunctionPathsToInclude.length > 0 && this._myIncludeOnlyArrayExtensionFunctions ? ", " : "") + (this._myIncludeOnlyArrayExtensionFunctions ? "pp_, vec_, vec2_, vec3_, vec4_, quat_, quat2_, mat3_, mat4_, _pp_, _vec_, _quat_" : ""),
      _myFunctionPathsToExclude: this._myFunctionPathsToExclude,
      _myExcludeConstructors: this._myExcludeConstructors,
      _myExcludeJSObjectFunctions: true,
      _myAddPathPrefixToFunctionID: true,
      _myClearConsoleBeforeLog: this._myClearConsoleBeforeLog,
      _myResetMaxResultsShortcutEnabled: this._myResetMaxResultsShortcutEnabled
    });
  }
};
__publicField(DebugArrayFunctionsPerformanceAnalyzerComponent, "TypeName", "pp-debug-array-functions-performance-analyzer");
__publicField(DebugArrayFunctionsPerformanceAnalyzerComponent, "Properties", {
  _myIncludeOnlyMainArrayTypes: Property.bool(true),
  _myIncludeOnlyArrayExtensionFunctions: Property.bool(false),
  _myDelayStart: Property.float(0),
  _myLogFunction: Property.enum(["Log", "Error", "Warn", "Debug"], "Log"),
  _mySecondsBetweenLogs: Property.float(1),
  _myLogMaxResults: Property.bool(false),
  _myLogSortOrder: Property.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "None"),
  _myLogCallsCountResults: Property.bool(true),
  _myLogTotalExecutionTimeResults: Property.bool(true),
  _myLogTotalExecutionTimePercentageResults: Property.bool(true),
  _myLogAverageExecutionTimeResults: Property.bool(true),
  _myLogMaxAmountOfFunctions: Property.int(-1),
  _myLogFunctionsWithCallsCountAbove: Property.int(-1),
  _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property.float(-1),
  _myFunctionPathsToInclude: Property.string(""),
  _myFunctionPathsToExclude: Property.string(""),
  _myExcludeConstructors: Property.bool(false),
  _myClearConsoleBeforeLog: Property.bool(false),
  _myResetMaxResultsShortcutEnabled: Property.bool(false)
});

// js/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_pp_array_creation_performance_analyzer_component.js
var DebugPPArrayCreationPerformanceAnalyzerComponent = class extends Component {
  init() {
    this.object.pp_addComponent(DebugFunctionsPerformanceAnalyzerComponent, {
      _myObjectsByReference: [
        [Vec2Utils, "Vec2Utils"],
        [Vec3Utils, "Vec3Utils"],
        [Vec4Utils, "Vec4Utils"],
        [QuatUtils, "QuatUtils"],
        [Quat2Utils, "Quat2Utils"],
        [Mat3Utils, "Mat3Utils"],
        [Mat4Utils, "Mat4Utils"]
      ],
      _myDelayStart: this._myDelayStart,
      _myLogTitle: "PP Array Creation Performance Analysis Results",
      _myLogFunction: this._myLogFunction,
      _mySecondsBetweenLogs: this._mySecondsBetweenLogs,
      _myLogMaxResults: this._myLogMaxResults,
      _myLogSortOrder: this._myLogSortOrder,
      _myLogMaxAmountOfFunctions: this._myLogMaxAmountOfFunctions,
      _myLogFunctionsWithCallsCountAbove: this._myLogFunctionsWithCallsCountAbove,
      _myLogFunctionsWithTotalExecutionTimePercentageAbove: this._myLogFunctionsWithTotalExecutionTimePercentageAbove,
      _myLogCallsCountResults: this._myLogCallsCountResults,
      _myLogTotalExecutionTimeResults: this._myLogTotalExecutionTimeResults,
      _myLogTotalExecutionTimePercentageResults: this._myLogTotalExecutionTimePercentageResults,
      _myLogAverageExecutionTimeResults: this._myLogAverageExecutionTimeResults,
      _myFunctionPathsToInclude: "create",
      _myExcludeConstructors: true,
      _myExcludeJSObjectFunctions: true,
      _myAddPathPrefixToFunctionID: true,
      _myClearConsoleBeforeLog: this._myClearConsoleBeforeLog,
      _myResetMaxResultsShortcutEnabled: this._myResetMaxResultsShortcutEnabled
    });
  }
};
__publicField(DebugPPArrayCreationPerformanceAnalyzerComponent, "TypeName", "pp-debug-pp-array-creation-performance-analyzer");
__publicField(DebugPPArrayCreationPerformanceAnalyzerComponent, "Properties", {
  _myDelayStart: Property.float(0),
  _myLogFunction: Property.enum(["Log", "Error", "Warn", "Debug"], "Log"),
  _mySecondsBetweenLogs: Property.float(1),
  _myLogMaxResults: Property.bool(false),
  _myLogSortOrder: Property.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "None"),
  _myLogCallsCountResults: Property.bool(true),
  _myLogTotalExecutionTimeResults: Property.bool(true),
  _myLogTotalExecutionTimePercentageResults: Property.bool(true),
  _myLogAverageExecutionTimeResults: Property.bool(true),
  _myLogMaxAmountOfFunctions: Property.int(-1),
  _myLogFunctionsWithCallsCountAbove: Property.int(-1),
  _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property.float(-1),
  _myClearConsoleBeforeLog: Property.bool(false),
  _myResetMaxResultsShortcutEnabled: Property.bool(false)
});

// js/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_wl_function_performance_analyzer_component.js
var DebugWLFunctionsPerformanceAnalyzerComponent = class extends Component {
  init() {
    this.object.pp_addComponent(DebugFunctionsPerformanceAnalyzerComponent, {
      _myObjectsByPath: "WL",
      _myDelayStart: this._myDelayStart,
      _myLogTitle: "WL Functions Performance Analysis Results",
      _myLogFunction: this._myLogFunction,
      _mySecondsBetweenLogs: this._mySecondsBetweenLogs,
      _myLogMaxResults: this._myLogMaxResults,
      _myLogSortOrder: this._myLogSortOrder,
      _myLogMaxAmountOfFunctions: this._myLogMaxAmountOfFunctions,
      _myLogFunctionsWithCallsCountAbove: this._myLogFunctionsWithCallsCountAbove,
      _myLogFunctionsWithTotalExecutionTimePercentageAbove: this._myLogFunctionsWithTotalExecutionTimePercentageAbove,
      _myLogCallsCountResults: this._myLogCallsCountResults,
      _myLogTotalExecutionTimeResults: this._myLogTotalExecutionTimeResults,
      _myLogTotalExecutionTimePercentageResults: this._myLogTotalExecutionTimePercentageResults,
      _myLogAverageExecutionTimeResults: this._myLogAverageExecutionTimeResults,
      _myFunctionPathsToInclude: this._myFunctionPathsToInclude,
      _myFunctionPathsToExclude: this._myFunctionPathsToExclude,
      _myExcludeConstructors: this._myExcludeConstructors,
      _myExcludeJSObjectFunctions: true,
      _myAddPathPrefixToFunctionID: true,
      _myObjectAddObjectDescendantsDepthLevel: 1,
      _myObjectAddClassDescendantsDepthLevel: 1,
      _myClearConsoleBeforeLog: this._myClearConsoleBeforeLog,
      _myResetMaxResultsShortcutEnabled: this._myResetMaxResultsShortcutEnabled
    });
  }
};
__publicField(DebugWLFunctionsPerformanceAnalyzerComponent, "TypeName", "pp-debug-wl-functions-performance-analyzer");
__publicField(DebugWLFunctionsPerformanceAnalyzerComponent, "Properties", {
  _myDelayStart: Property.float(0),
  _myLogFunction: Property.enum(["Log", "Error", "Warn", "Debug"], "Log"),
  _mySecondsBetweenLogs: Property.float(1),
  _myLogMaxResults: Property.bool(false),
  _myLogSortOrder: Property.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "None"),
  _myLogCallsCountResults: Property.bool(true),
  _myLogTotalExecutionTimeResults: Property.bool(true),
  _myLogTotalExecutionTimePercentageResults: Property.bool(true),
  _myLogAverageExecutionTimeResults: Property.bool(true),
  _myLogMaxAmountOfFunctions: Property.int(-1),
  _myLogFunctionsWithCallsCountAbove: Property.int(-1),
  _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property.float(-1),
  _myFunctionPathsToInclude: Property.string(""),
  _myFunctionPathsToExclude: Property.string(""),
  _myExcludeConstructors: Property.bool(false),
  _myClearConsoleBeforeLog: Property.bool(false),
  _myResetMaxResultsShortcutEnabled: Property.bool(false)
});

// js/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_wl_components_function_performance_analyzer_component.js
var DebugWLComponentsFunctionsPerformanceAnalyzerComponent = class extends Component {
  init() {
    this._myStartTimer = new Timer(this._myDelayStart);
    if (this._myDelayStart == 0) {
      this._myStartTimer.end();
      this._start();
    }
  }
  update(dt) {
    if (this._myStartTimer.isRunning()) {
      this._myStartTimer.update(dt);
      if (this._myStartTimer.isDone()) {
        this._start();
      }
    }
  }
  _start() {
    let objectsByReference = [];
    let classesByReference = [];
    if (this._myAnalyzeComponentInstances) {
      this._addComponentInstanceReferences(objectsByReference);
    }
    if (this._myAnalyzeComponentTypes) {
      this._addComponentTypeReferences(classesByReference);
    }
    this._myAnalyzerComponent = this.object.pp_addComponent(DebugFunctionsPerformanceAnalyzerComponent, {
      _myObjectsByReference: objectsByReference,
      _myClassesByReference: classesByReference,
      _myDelayStart: 0,
      _myLogTitle: "WL Components Performance Analysis Results",
      _myLogFunction: this._myLogFunction,
      _mySecondsBetweenLogs: this._mySecondsBetweenLogs,
      _myLogMaxResults: this._myLogMaxResults,
      _myLogSortOrder: this._myLogSortOrder,
      _myLogMaxAmountOfFunctions: this._myLogMaxAmountOfFunctions,
      _myLogFunctionsWithCallsCountAbove: this._myLogFunctionsWithCallsCountAbove,
      _myLogFunctionsWithTotalExecutionTimePercentageAbove: this._myLogFunctionsWithTotalExecutionTimePercentageAbove,
      _myLogCallsCountResults: this._myLogCallsCountResults,
      _myLogTotalExecutionTimeResults: this._myLogTotalExecutionTimeResults,
      _myLogTotalExecutionTimePercentageResults: this._myLogTotalExecutionTimePercentageResults,
      _myLogAverageExecutionTimeResults: this._myLogAverageExecutionTimeResults,
      _myFunctionPathsToInclude: this._myFunctionPathsToInclude,
      _myFunctionPathsToExclude: this._myFunctionPathsToExclude,
      _myExcludeConstructors: this._myExcludeConstructors,
      _myExcludeJSObjectFunctions: true,
      _myAddPathPrefixToFunctionID: true,
      _myObjectAddClassDescendantsDepthLevel: 0,
      _myClearConsoleBeforeLog: this._myClearConsoleBeforeLog,
      _myResetMaxResultsShortcutEnabled: this._myResetMaxResultsShortcutEnabled
    });
  }
  _addComponentTypeReferences(classesByReference) {
    let nativeComponentClasses = [
      AnimationComponent,
      CollisionComponent,
      InputComponent,
      LightComponent,
      MeshComponent,
      PhysXComponent,
      TextComponent,
      ViewComponent
    ];
    for (let nativeComponentClass of nativeComponentClasses) {
      classesByReference.push([nativeComponentClass.prototype, '{"' + nativeComponentClass.TypeName + '"}']);
    }
    for (let componentClass of ComponentUtils.getJavascriptComponentClassesByIndex(this.engine)) {
      classesByReference.push([componentClass.prototype, '{"' + componentClass.TypeName + '"}']);
    }
  }
  _addComponentInstanceReferences(objectsByReference) {
    for (let componentInstance of ComponentUtils.getJavascriptComponentInstances(this.engine)) {
      let id = "";
      switch (this._myComponentInstanceID) {
        case 0:
          id = componentInstance.object.pp_getID();
          break;
        case 1:
          id = componentInstance.object.pp_getName();
          break;
        case 2:
          id = componentInstance.object.pp_getID();
          if (componentInstance.object.pp_getName().length > 0) {
            id = id + " - " + componentInstance.object.pp_getName();
          }
          break;
      }
      objectsByReference.push([
        componentInstance,
        '{"' + componentInstance.type + '"}[' + id + "]"
      ]);
    }
  }
};
__publicField(DebugWLComponentsFunctionsPerformanceAnalyzerComponent, "TypeName", "pp-debug-wl-components-functions-performance-analyzer");
__publicField(DebugWLComponentsFunctionsPerformanceAnalyzerComponent, "Properties", {
  _myAnalyzeComponentTypes: Property.bool(true),
  _myAnalyzeComponentInstances: Property.bool(false),
  _myComponentInstanceID: Property.enum(["Object ID", "Object Name", "Object ID - Object Name"], "Object ID - Object Name"),
  _myDelayStart: Property.float(0),
  _myLogFunction: Property.enum(["Log", "Error", "Warn", "Debug"], "Log"),
  _mySecondsBetweenLogs: Property.float(1),
  _myLogMaxResults: Property.bool(false),
  _myLogSortOrder: Property.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "None"),
  _myLogCallsCountResults: Property.bool(true),
  _myLogTotalExecutionTimeResults: Property.bool(true),
  _myLogTotalExecutionTimePercentageResults: Property.bool(true),
  _myLogAverageExecutionTimeResults: Property.bool(true),
  _myLogMaxAmountOfFunctions: Property.int(-1),
  _myLogFunctionsWithCallsCountAbove: Property.int(-1),
  _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property.float(-1),
  _myFunctionPathsToInclude: Property.string(""),
  _myFunctionPathsToExclude: Property.string(""),
  _myExcludeConstructors: Property.bool(false),
  _myClearConsoleBeforeLog: Property.bool(false),
  _myResetMaxResultsShortcutEnabled: Property.bool(false)
});

// js/pp/gameplay/cauldron/cauldron/direction_2D_to_3D_converter.js
var Direction2DTo3DConverterParams = class {
  constructor() {
    this.myStartFlyingForward = false;
    this.myStartFlyingRight = false;
    this.myAutoUpdateFlyForward = false;
    this.myAutoUpdateFlyRight = false;
    this.myResetFlyForwardWhenZero = false;
    this.myResetFlyRightWhenZero = false;
    this.myMinAngleToFlyForwardUp = 90;
    this.myMinAngleToFlyForwardDown = 90;
    this.myMinAngleToFlyRightUp = 90;
    this.myMinAngleToFlyRightDown = 90;
    this.myAdjustForwardWhenCloseToUp = true;
    this.myAdjustRightWhenCloseToUp = true;
    this.myAdjustForwardWhenCloseToUpAngleThreshold = 10;
    this.myAdjustRightWhenCloseToUpAngleThreshold = 10;
    this.myInvertForwardWhenUpsideDown = false;
    this.myInvertRightWhenUpsideDown = false;
    this.myAdjustLastValidFlatForwardOverConversionReferenceRotation = true;
    this.myAdjustLastValidFlatRightOverConversionReferenceRotation = true;
  }
};
var Direction2DTo3DConverter = class {
  constructor(params = new Direction2DTo3DConverterParams()) {
    this._myParams = params;
    this._myFlyingForward = this._myParams.myStartFlyingForward;
    this._myFlyingRight = this._myParams.myStartFlyingRight;
    this._myLastConvertRotationQuat = quat_create();
    this._myLastConvertRotationQuatValid = false;
    this._myLastValidFlatForward = vec3_create();
    this._myLastValidFlatRight = vec3_create();
  }
  // @direction3DUp can be used to flat the direction if the @conversionTransform is not aligned with it
  // It's also needed to specify the fly axis, if different from the @conversionTransform up
  // If @direction3DUp is null, @conversionTransform up is used
  convert(direction2D, conversionTransform, direction3DUp = null, outDirection3D = vec3_create()) {
    return this.convertTransform(direction2D, conversionTransform, direction3DUp, outDirection3D);
  }
  isFlying() {
    return this._myFlyingForward || this._myFlyingRight;
  }
  isFlyingForward() {
    return this._myFlyingForward;
  }
  isFlyingRight() {
    return this._myFlyingRight;
  }
  startFlying() {
    this._myFlyingForward = true;
    this._myFlyingRight = true;
  }
  startFlyingForward() {
    this._myFlyingForward = true;
  }
  startFlyingRight() {
    this._myFlyingRight = true;
  }
  stopFlying() {
    this._myFlyingForward = false;
    this._myFlyingRight = false;
  }
  stopFlyingForward() {
    this._myFlyingForward = false;
  }
  stopFlyingRight() {
    this._myFlyingRight = false;
  }
  resetFly() {
    this.resetFlyForward();
    this.resetFlyRight();
  }
  resetFlyForward() {
    if (this._myParams.myStartFlyingForward) {
      this.startFlyingForward();
    } else {
      this.stopFlyingForward();
    }
  }
  resetFlyRight() {
    if (this._myParams.myStartFlyingRight) {
      this.startFlyingRight();
    } else {
      this.stopFlyingRight();
    }
  }
  resetLastValidFlatDirections() {
    this._myLastValidFlatForward.vec3_zero();
    this._myLastValidFlatRight.vec3_zero();
  }
  resetLastValidFlatForward() {
    this._myLastValidFlatForward.vec3_zero();
  }
  resetLastValidFlatRight() {
    this._myLastValidFlatRight.vec3_zero();
  }
  resetLastConvertTransform() {
    this._myLastConvertRotationQuatValid = false;
    this._myLastConvertRotationQuat.quat_identity();
  }
  // Convert Alternatives
  // If @direction3DUp is null, vec3_create(0, 1, 0) is used
  // Does not work properly if @conversionForward is aligned with @direction3DUp
  convertForward(direction2D, conversionForward, direction3DUp = null, outDirection3D = vec3_create()) {
  }
  // @direction3DUp can be used to flat the direction if the @conversionTransform is not aligned with it
  // It's also needed to specify the fly axis, if different from the @conversionTransform up
  // If @direction3DUp is null, conversionTransform up is used
  convertTransform(direction2D, conversionTransform, direction3DUp = null, outDirection3D = vec3_create()) {
    return this.convertTransformMatrix(direction2D, conversionTransform, direction3DUp, outDirection3D);
  }
  convertTransformMatrix(direction2D, conversionTransformMatrix, direction3DUp = null, outDirection3D = vec3_create()) {
  }
  convertTransformQuat(direction2D, conversionTransformQuat, direction3DUp = null, outDirection3D = vec3_create()) {
  }
  convertRotationQuat(direction2D, conversionRotationQuat, direction3DUp = null, outDirection3D = vec3_create()) {
  }
};
Direction2DTo3DConverter.prototype.convertForward = function() {
  let rotationQuat = quat_create();
  return function convertForward(direction2D, conversionForward, direction3DUp = null, outDirection3D = vec3_create()) {
    rotationQuat.quat_identity();
    rotationQuat.quat_setForward(conversionForward, direction3DUp);
    return this.convertRotationQuat(direction2D, rotationQuat, direction3DUp, outDirection3D);
  };
}();
Direction2DTo3DConverter.prototype.convertTransformMatrix = function() {
  let rotationQuat = quat_create();
  return function convertTransformMatrix(direction2D, conversionTransformMatrix, direction3DUp = null, outDirection3D = vec3_create()) {
    rotationQuat = conversionTransformMatrix.mat4_getRotationQuat(rotationQuat);
    return this.convertRotationQuat(direction2D, rotationQuat, direction3DUp, outDirection3D);
  };
}();
Direction2DTo3DConverter.prototype.convertTransformQuat = function() {
  let rotationQuat = quat_create();
  return function convertTransformQuat(direction2D, conversionTransformQuat, direction3DUp = null, outDirection3D = vec3_create()) {
    rotationQuat = conversionTransformQuat.quat2_getRotationQuat(rotationQuat);
    return this.convertRotationQuat(direction2D, rotationQuat, direction3DUp, outDirection3D);
  };
}();
Direction2DTo3DConverter.prototype.convertRotationQuat = function() {
  let forward = vec3_create();
  let right = vec3_create();
  let up = vec3_create();
  let direction3DUpNegate = vec3_create();
  let forwardScaled = vec3_create();
  let rightScaled = vec3_create();
  let rotationToNewConvertPivoted = quat_create();
  return function convertRotationQuat(direction2D, conversionRotationQuat, direction3DUp = null, outDirection3D = vec3_create()) {
    outDirection3D.vec3_zero();
    if (this._myParams.myAdjustLastValidFlatForwardOverConversionReferenceRotation || this._myParams.myAdjustLastValidFlatRightOverConversionReferenceRotation) {
      if (direction3DUp != null) {
        if (this._myLastConvertRotationQuatValid) {
          rotationToNewConvertPivoted = this._myLastConvertRotationQuat.quat_rotationToQuat(conversionRotationQuat, rotationToNewConvertPivoted).quat_rotationAroundAxisQuat(direction3DUp, rotationToNewConvertPivoted);
          if (Math.pp_angleClamp(rotationToNewConvertPivoted.quat_getAngle(), true) > Math.PP_EPSILON_DEGREES) {
            if (this._myParams.myAdjustLastValidFlatForwardOverConversionReferenceRotation) {
              this._myLastValidFlatForward.vec3_rotateQuat(rotationToNewConvertPivoted, this._myLastValidFlatForward);
            }
            if (this._myParams.myAdjustLastValidFlatRightOverConversionReferenceRotation) {
              this._myLastValidFlatRight.vec3_rotateQuat(rotationToNewConvertPivoted, this._myLastValidFlatRight);
            }
          }
        }
      }
    }
    if (direction2D.vec2_isZero()) {
      let resetFlyForward = this._myParams.myAutoUpdateFlyForward && this._myParams.myResetFlyForwardWhenZero;
      if (resetFlyForward) {
        this.resetFlyForward();
      }
      let resetFlyRight = this._myParams.myAutoUpdateFlyRight && this._myParams.myResetFlyRightWhenZero;
      if (resetFlyRight) {
        this.resetFlyRight();
      }
    } else {
      forward = conversionRotationQuat.quat_getForward(forward);
      right = conversionRotationQuat.quat_getRight(right);
      up = conversionRotationQuat.quat_getUp(up);
      if (direction3DUp != null) {
        let upsideDown = !direction3DUp.vec3_isConcordant(up);
        direction3DUpNegate = direction3DUp.vec3_negate(direction3DUpNegate);
        if (this._myParams.myAutoUpdateFlyForward) {
          let angleForwardWithDirectionUp = forward.vec3_angle(direction3DUp);
          this._myFlyingForward = this._myFlyingForward || (angleForwardWithDirectionUp < 90 - this._myParams.myMinAngleToFlyForwardUp || angleForwardWithDirectionUp > 90 + this._myParams.myMinAngleToFlyForwardDown);
        }
        if (this._myParams.myAutoUpdateFlyRight) {
          let angleRightWithDirectionUp = right.vec3_angle(direction3DUp);
          this._myFlyingRight = this._myFlyingRight || (angleRightWithDirectionUp < 90 - this._myParams.myMinAngleToFlyRightUp || angleRightWithDirectionUp > 90 + this._myParams.myMinAngleToFlyRightDown);
        }
        if (!this._myFlyingForward) {
          if (this._myParams.myAdjustForwardWhenCloseToUp && !this._myLastValidFlatForward.vec3_isZero(Math.PP_EPSILON) && (forward.vec3_angle(direction3DUp) < this._myParams.myAdjustForwardWhenCloseToUpAngleThreshold || forward.vec3_angle(direction3DUpNegate) < this._myParams.myAdjustForwardWhenCloseToUpAngleThreshold)) {
            forward.pp_copy(this._myLastValidFlatForward);
          } else if (upsideDown && this._myParams.myInvertForwardWhenUpsideDown) {
            forward.vec3_negate(forward);
          }
          forward = forward.vec3_removeComponentAlongAxis(direction3DUp, forward);
          forward.vec3_normalize(forward);
          if (forward.vec3_isZero(Math.PP_EPSILON)) {
            if (!this._myLastValidFlatForward.vec3_isZero(Math.PP_EPSILON)) {
              forward.pp_copy(this._myLastValidFlatForward);
            } else {
              forward.vec3_set(0, 0, 1);
            }
          }
        }
        if (!this._myFlyingRight) {
          if (this._myParams.myAdjustRightWhenCloseToUp && !this._myLastValidFlatRight.vec3_isZero(Math.PP_EPSILON) && (right.vec3_angle(direction3DUp) < this._myParams.myAdjustRightWhenCloseToUpAngleThreshold || right.vec3_angle(direction3DUpNegate) < this._myParams.myAdjustRightWhenCloseToUpAngleThreshold)) {
            right.pp_copy(this._myLastValidFlatRight);
          } else if (upsideDown && this._myParams.myInvertRightWhenUpsideDown) {
            right.vec3_negate(right);
          }
          right = right.vec3_removeComponentAlongAxis(direction3DUp, right);
          right.vec3_normalize(right);
          if (right.vec3_isZero(Math.PP_EPSILON)) {
            if (!this._myLastValidFlatRight.vec3_isZero(Math.PP_EPSILON)) {
              right.pp_copy(this._myLastValidFlatRight);
            } else {
              right.vec3_set(-1, 0, 0);
            }
          }
        }
        if (forward.vec3_angle(direction3DUp) >= this._myParams.myAdjustForwardWhenCloseToUpAngleThreshold && forward.vec3_angle(direction3DUpNegate) >= this._myParams.myAdjustForwardWhenCloseToUpAngleThreshold || direction2D[1] != 0 && this._myLastValidFlatForward.vec3_isZero(Math.PP_EPSILON)) {
          this._myLastValidFlatForward = forward.vec3_removeComponentAlongAxis(direction3DUp, this._myLastValidFlatForward);
          this._myLastValidFlatForward.vec3_normalize(this._myLastValidFlatForward);
        }
        if (right.vec3_angle(direction3DUp) >= this._myParams.myAdjustRightWhenCloseToUpAngleThreshold && right.vec3_angle(direction3DUpNegate) >= this._myParams.myAdjustRightWhenCloseToUpAngleThreshold || direction2D[0] != 0 && this._myLastValidFlatRight.vec3_isZero(Math.PP_EPSILON)) {
          this._myLastValidFlatRight = right.vec3_removeComponentAlongAxis(direction3DUp, this._myLastValidFlatRight);
          this._myLastValidFlatRight.vec3_normalize(this._myLastValidFlatRight);
        }
      }
      outDirection3D = right.vec3_scale(direction2D[0], rightScaled).vec3_add(forward.vec3_scale(direction2D[1], forwardScaled), outDirection3D);
      if (direction3DUp != null && !this._myFlyingForward && !this._myFlyingRight) {
        outDirection3D = outDirection3D.vec3_removeComponentAlongAxis(direction3DUp, outDirection3D);
      }
      outDirection3D.vec3_normalize(outDirection3D);
    }
    this._myLastConvertRotationQuat.quat_copy(conversionRotationQuat);
    this._myLastConvertRotationQuatValid = true;
    return outDirection3D;
  };
}();

// js/pp/gameplay/cauldron/cauldron/number_over_factor.js
var NumberOverFactor = class {
  constructor(fromNumberOverFactor, toNumberOverFactor = null, fromFactor = 0, toFactor = 0, easingFunction = EasingFunction.linear, roundingFunction = null) {
    if (toNumberOverFactor == null) {
      toNumberOverFactor = fromNumberOverFactor;
    }
    this._myFromNumber = fromNumberOverFactor;
    this._myToNumber = toNumberOverFactor;
    this._myFromFactor = fromFactor;
    this._myToFactor = toFactor;
    this._myEasingFunction = easingFunction;
    this._myRoundingFunction = roundingFunction;
  }
  get(factor) {
    let interpolationFactor = this._myEasingFunction(Math.pp_mapToRange(factor, this._myFromFactor, this._myToFactor, 0, 1));
    let numberOverFactor = Math.pp_lerp(this._myFromNumber, this._myToNumber, interpolationFactor);
    if (this._myRoundingFunction) {
      numberOverFactor = this._myRoundingFunction(numberOverFactor, this._myFromNumber, this._myToNumber);
    }
    return numberOverFactor;
  }
  getAverage(factor) {
    return this.get(factor);
  }
  getRange(factor) {
    let numberOverFactor = this.get(factor);
    return [numberOverFactor, numberOverFactor];
  }
  getMax(factor) {
    return this.get(factor);
  }
  getMin(factor) {
    return this.get(factor);
  }
  isInside(number, factor) {
    let numberOverFactor = this.get(factor);
    return numberOverFactor == number;
  }
  isInsideAngleRange(number, factor) {
    return this.isInsideAngleRangeDegrees(number, factor);
  }
  isInsideAngleRangeDegrees(number, factor) {
    let numberOverFactor = this.get(factor);
    let clampedNumber = Math.pp_angleClampDegrees(number);
    let clampedNumberOverFactor = Math.pp_angleClampDegrees(numberOverFactor);
    return clampedNumber == clampedNumberOverFactor;
  }
  isInsideAngleRangeRadians(number, factor) {
    let numberOverFactor = this.get(factor);
    let clampedNumber = Math.pp_angleClampRadians(number);
    let clampedNumberOverFactor = Math.pp_angleClampRadians(numberOverFactor);
    return clampedNumber == clampedNumberOverFactor;
  }
};
var IntOverFactor = class extends NumberOverFactor {
  constructor(fromNumberOverFactor, toNumberOverFactor, fromFactor, toFactor, easingFunction = EasingFunction.linear, roundingFunction = null) {
    if (roundingFunction == null) {
      roundingFunction = function(numberToRound, fromNumberOverFactor2, toNumberOverFactor2) {
        let roundedNumber = null;
        let useFloor = fromNumberOverFactor2 <= toNumberOverFactor2;
        if (useFloor) {
          roundedNumber = Math.floor(numberToRound);
        } else {
          roundedNumber = Math.ceil(numberToRound);
        }
        return roundedNumber;
      };
    }
    super(fromNumberOverFactor, toNumberOverFactor, fromFactor, toFactor, easingFunction, roundingFunction);
  }
};
var NumberRangeOverFactor = class {
  constructor(fromRange, toRange = null, fromFactor = 0, toFactor = 0, easingFunction = EasingFunction.linear, roundingFunction = null) {
    if (toRange == null) {
      toRange = fromRange;
    }
    this._myFromNumberOverFactor = new NumberOverFactor(fromRange[0], toRange[0], fromFactor, toFactor, easingFunction, roundingFunction);
    this._myToNumberOverFactor = new NumberOverFactor(fromRange[1], toRange[1], fromFactor, toFactor, easingFunction, roundingFunction);
    this._myRoundingFunction = roundingFunction;
  }
  get(factor) {
    let fromNumberOverFactor = this._myFromNumberOverFactor.get(factor);
    let toNumberOverFactor = this._myToNumberOverFactor.get(factor);
    let randomNumberOverFactor = null;
    if (this._myRoundingFunction) {
      randomNumberOverFactor = Math.pp_randomInt(fromNumberOverFactor, toNumberOverFactor);
    } else {
      randomNumberOverFactor = Math.pp_random(fromNumberOverFactor, toNumberOverFactor);
    }
    return randomNumberOverFactor;
  }
  getAverage(factor) {
    let fromNumberOverFactor = this._myFromNumberOverFactor.get(factor);
    let toNumberOverFactor = this._myToNumberOverFactor.get(factor);
    let averageNumberOverFactor = (fromNumberOverFactor + toNumberOverFactor) / 2;
    if (this._myRoundingFunction) {
      averageNumberOverFactor = this._myRoundingFunction(averageNumberOverFactor, fromNumberOverFactor, toNumberOverFactor);
    }
    return averageNumberOverFactor;
  }
  getRange(factor) {
    let fromNumberOverFactor = this._myFromNumberOverFactor.get(factor);
    let toNumberOverFactor = this._myToNumberOverFactor.get(factor);
    return [fromNumberOverFactor, toNumberOverFactor];
  }
  getMax(factor) {
    let fromNumberOverFactor = this._myFromNumberOverFactor.get(factor);
    let toNumberOverFactor = this._myToNumberOverFactor.get(factor);
    return Math.max(fromNumberOverFactor, toNumberOverFactor);
  }
  getMin(factor) {
    let fromNumberOverFactor = this._myFromNumberOverFactor.get(factor);
    let toNumberOverFactor = this._myToNumberOverFactor.get(factor);
    return Math.min(fromNumberOverFactor, toNumberOverFactor);
  }
  isInside(number, factor) {
    let fromNumberOverFactor = this._myFromNumberOverFactor.get(factor);
    let toNumberOverFactor = this._myToNumberOverFactor.get(factor);
    let min4 = Math.min(fromNumberOverFactor, toNumberOverFactor);
    let max4 = Math.max(fromNumberOverFactor, toNumberOverFactor);
    return number >= min4 && number <= max4;
  }
  isInsideAngleRange(number, factor) {
    return this.isInsideAngleRangeDegrees(number, factor);
  }
  isInsideAngleRangeDegrees(number, factor) {
    let fromNumberOverFactor = this._myFromNumberOverFactor.get(factor);
    let toNumberOverFactor = this._myToNumberOverFactor.get(factor);
    return Math.pp_isInsideAngleRangeDegrees(number, fromNumberOverFactor, toNumberOverFactor);
  }
  isInsideAngleRangeRadians(number, factor) {
    let fromNumberOverFactor = this._myFromNumberOverFactor.get(factor);
    let toNumberOverFactor = this._myToNumberOverFactor.get(factor);
    return Math.pp_isInsideAngleRangeRadians(number, fromNumberOverFactor, toNumberOverFactor);
  }
};
var IntRangeOverFactor = class extends NumberRangeOverFactor {
  constructor(fromRange, toRange, fromFactor, toFactor, easingFunction = EasingFunction.linear, roundingFunction = null) {
    if (roundingFunction == null) {
      roundingFunction = function(numberToRound, fromNumberOverFactor, toNumberOverFactor) {
        let roundedNumber = null;
        let useFloor = fromNumberOverFactor <= toNumberOverFactor;
        if (useFloor) {
          roundedNumber = Math.floor(numberToRound);
        } else {
          roundedNumber = Math.ceil(numberToRound);
        }
        return roundedNumber;
      };
    }
    super(fromRange, toRange, fromFactor, toFactor, easingFunction, roundingFunction);
  }
};

// js/pp/gameplay/grab_throw/grabbable_component.js
var GrabbableComponent = class extends Component {
  init() {
    this._myGrabbed = false;
    this._myGrabber = null;
    this._myOldParent = null;
    this._myPhysX = null;
    this._myOldKinematicValue = null;
    this._myGrabEmitter = new Emitter();
    this._myThrowEmitter = new Emitter();
    this._myReleaseEmitter = new Emitter();
  }
  start() {
    this._myOldParent = this.object.pp_getParent();
    this._myPhysX = this.object.pp_getComponent(PhysXComponent);
  }
  onDeactivate() {
    this.release();
  }
  grab(grabber) {
    if (!this.isGrabbed()) {
      this._myOldKinematicValue = this._myPhysX.kinematic;
    }
    this.release();
    this._myPhysX.kinematic = true;
    this._myOldParent = this.object.pp_getParent();
    this.object.pp_setParent(grabber);
    this._myGrabbed = true;
    this._myGrabEmitter.notify(grabber, this);
  }
  throw(linearVelocity, angularVelocity) {
    if (this._myGrabbed) {
      let grabber = this._myGrabber;
      this._release();
      this._myPhysX.linearVelocity = linearVelocity.vec3_scale(this._myThrowLinearVelocityMultiplier);
      this._myPhysX.angularVelocity = angularVelocity.vec3_scale(this._myThrowAngularVelocityMultiplier);
      this._myThrowEmitter.notify(grabber, this);
      this._myReleaseEmitter.notify(grabber, this, true);
    }
  }
  release() {
    if (this._myGrabbed) {
      let grabber = this._myGrabber;
      this._release();
      this._myReleaseEmitter.notify(grabber, this, false);
    }
  }
  getLinearVelocity() {
    let linearVelocity = vec3_create();
    this._myPhysX.linearVelocity.vec3_clone(linearVelocity);
    return linearVelocity;
  }
  getAngularVelocity() {
    return this.getAngularVelocityDegrees();
  }
  getAngularVelocityDegrees() {
    let angularVelocityDegrees = vec3_create();
    this._myPhysX.angularVelocity.vec3_toDegrees(angularVelocityDegrees);
    return angularVelocityDegrees;
  }
  getAngularVelocityRadians() {
    let angularVelocityRadians = vec3_create();
    this._myPhysX.angularVelocity.vec3_clone(angularVelocityRadians);
    return angularVelocityRadians;
  }
  isGrabbed() {
    return this._myGrabbed;
  }
  getGrabber() {
    return this._myGrabber;
  }
  registerGrabEventListener(id, listener) {
    this._myGrabEmitter.add(listener, { id });
  }
  unregisterGrabEventListener(id) {
    this._myGrabEmitter.remove(id);
  }
  registerThrowEventListener(id, listener) {
    this._myThrowEmitter.add(listener, { id });
  }
  unregisterThrowEventListener(id) {
    this._myThrowEmitter.remove(id);
  }
  registerReleaseEventListener(id, listener) {
    this._myReleaseEmitter.add(listener, { id });
  }
  unregisterReleaseEventListener(id) {
    this._myReleaseEmitter.remove(id);
  }
  _release() {
    if (this._myParentOnRelease == 0) {
      this.object.pp_setParent(Globals.getSceneObjects(this.engine).myDynamics);
    } else {
      this.object.pp_setParent(this._myOldParent);
    }
    this._myGrabbed = false;
    this._myGrabber = null;
    if (this._myKinematicValueOnRelease == 0) {
      this._myPhysX.kinematic = true;
    } else if (this._myKinematicValueOnRelease == 1) {
      this._myPhysX.kinematic = false;
    } else if (this._myOldKinematicValue != null) {
      this._myPhysX.kinematic = this._myOldKinematicValue;
    }
    if (this._myPhysX.kinematic) {
      this._myPhysX.linearVelocity = vec3_create();
      this._myPhysX.angularVelocity = vec3_create();
    }
  }
  pp_clone(targetObject) {
    let clonedComponent = ComponentUtils.cloneDefault(this, targetObject);
    return clonedComponent;
  }
  pp_clonePostProcess(clonedComponent) {
    clonedComponent.start();
  }
};
__publicField(GrabbableComponent, "TypeName", "pp-grabbable");
__publicField(GrabbableComponent, "Properties", {
  _myThrowLinearVelocityMultiplier: Property.float(1),
  _myThrowAngularVelocityMultiplier: Property.float(1),
  _myKinematicValueOnRelease: Property.enum(["True", "False", "Own"], "False"),
  _myParentOnRelease: Property.enum(["Scene", "Own"], "Own")
});

// js/pp/gameplay/grab_throw/grabber_hand_component.js
var GrabberHandComponent = class extends Component {
  init() {
    this._myGrabbables = [];
    this._myGamepad = null;
    this._myActiveGrabButton = null;
    this._myLinearVelocityHistorySize = 5;
    this._myLinearVelocityHistorySpeedAverageSamplesFromStart = 1;
    this._myLinearVelocityHistoryDirectionAverageSamplesFromStart = 3;
    this._myLinearVelocityHistoryDirectionAverageSkipFromStart = 0;
    this._myHandLinearVelocityHistory = new Array(this._myLinearVelocityHistorySize);
    this._myHandLinearVelocityHistory.fill(vec3_create());
    this._myAngularVelocityHistorySize = 1;
    this._myHandAngularVelocityHistory = new Array(this._myAngularVelocityHistorySize);
    this._myHandAngularVelocityHistory.fill(vec3_create());
    this._myThrowMaxAngularSpeedRadians = Math.pp_toRadians(this._myThrowMaxAngularSpeed);
    this._myGrabEmitter = new Emitter();
    this._myThrowEmitter = new Emitter();
    this._myDebugEnabled = false;
  }
  start() {
    if (this._myHandedness == HandednessIndex.LEFT) {
      this._myGamepad = Globals.getLeftGamepad(this.engine);
    } else {
      this._myGamepad = Globals.getRightGamepad(this.engine);
    }
    this._myPhysX = this.object.pp_getComponent(PhysXComponent);
    this._myCollisionsCollector = new PhysicsCollisionCollector(this._myPhysX, true);
  }
  update(dt) {
    this._myCollisionsCollector.update(dt);
    if (this._myGrabbables.length > 0) {
      this._updateLinearVelocityHistory();
      this._updateAngularVelocityHistory();
    }
  }
  grab(grabButton = null) {
    this._grab(grabButton);
  }
  throw(throwButton = null) {
    this._throw(throwButton);
  }
  getGamepad() {
    return this._myGamepad;
  }
  getHandedness() {
    return InputUtils.getHandednessByIndex(this._myHandedness);
  }
  registerGrabEventListener(id, listener) {
    this._myGrabEmitter.add(listener, { id });
  }
  unregisterGrabEventListener(id) {
    this._myGrabEmitter.remove(id);
  }
  registerThrowEventListener(id, listener) {
    this._myThrowEmitter.add(listener, { id });
  }
  unregisterThrowEventListener(id) {
    this._myThrowEmitter.remove(id);
  }
  onActivate() {
    if (this._myGamepad != null) {
      if (this._myGrabButton == 0) {
        this._myGamepad.registerButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_START, this, this._grab.bind(this, GamepadButtonID.SELECT));
        this._myGamepad.registerButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_END, this, this._throw.bind(this, GamepadButtonID.SELECT));
      } else if (this._myGrabButton == 1) {
        this._myGamepad.registerButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_START, this, this._grab.bind(this, GamepadButtonID.SQUEEZE));
        this._myGamepad.registerButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_END, this, this._throw.bind(this, GamepadButtonID.SQUEEZE));
      } else {
        this._myGamepad.registerButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_START, this, this._grab.bind(this, GamepadButtonID.SQUEEZE));
        this._myGamepad.registerButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_END, this, this._throw.bind(this, GamepadButtonID.SQUEEZE));
        this._myGamepad.registerButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_START, this, this._grab.bind(this, GamepadButtonID.SELECT));
        this._myGamepad.registerButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_END, this, this._throw.bind(this, GamepadButtonID.SELECT));
      }
    }
  }
  onDeactivate() {
    this.throw();
    if (this._myGamepad != null) {
      if (this._myGrabButton == 0) {
        this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_START, this);
        this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_END, this);
      } else if (this._myGrabButton == 1) {
        this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_START, this);
        this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_END, this);
      } else {
        this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_START, this);
        this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.PRESS_END, this);
        this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_START, this);
        this._myGamepad.unregisterButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.PRESS_END, this);
      }
    }
  }
  _grab(grabButton) {
    if (this._myGrabbables.length >= this._myMaxNumberOfObjects) {
      return;
    }
    if (this._myGrabButton == 2 || this._myActiveGrabButton == null || this._myActiveGrabButton == grabButton || grabButton == null) {
      let grabbablesToGrab = [];
      let collisions = this._myCollisionsCollector.getCollisions();
      for (let i = 0; i < collisions.length; i++) {
        let grabbable = collisions[i].pp_getComponent(GrabbableComponent);
        if (grabbable && grabbable.active) {
          grabbablesToGrab.push(grabbable);
        }
      }
      let grabberPosition = this.object.pp_getPosition();
      grabbablesToGrab.sort(function(first2, second) {
        let firstPosition = first2.object.pp_getPosition();
        let secondPosition = second.object.pp_getPosition();
        let firstDistance = firstPosition.vec3_distance(grabberPosition);
        let secondDistance = secondPosition.vec3_distance(grabberPosition);
        return Math.pp_sign(firstDistance - secondDistance, 0);
      });
      for (let grabbableToGrab of grabbablesToGrab) {
        if (!this._isAlreadyGrabbed(grabbableToGrab)) {
          let grabbableData = new _GrabberHandComponentGrabbableData(grabbableToGrab, this._myThrowVelocitySource == 1, this._myLinearVelocityHistorySize, this._myAngularVelocityHistorySize);
          this._myGrabbables.push(grabbableData);
          grabbableToGrab.grab(this.object);
          grabbableToGrab.registerReleaseEventListener(this, this._onRelease.bind(this));
          if (this._mySnapOnPivot) {
            grabbableToGrab.object.pp_resetPositionLocal();
          }
          this._myGrabEmitter.notify(this, grabbableToGrab);
        }
        if (this._myGrabbables.length >= this._myMaxNumberOfObjects) {
          break;
        }
      }
      if (this._myGrabbables.length > 0) {
        if (this._myActiveGrabButton == null) {
          this._myActiveGrabButton = grabButton;
        }
      }
    }
  }
  _throw(throwButton) {
    if (this._myGrabButton == 2 || this._myActiveGrabButton == null || this._myActiveGrabButton == throwButton || throwButton == null) {
      if (this._myGrabbables.length > 0) {
        let linearVelocity = null;
        let angularVelocity = null;
        if (this._myThrowVelocitySource == 0) {
          linearVelocity = this._computeReleaseLinearVelocity(this._myHandLinearVelocityHistory);
          angularVelocity = this._computeReleaseAngularVelocity(this._myHandAngularVelocityHistory);
        }
        for (let grabbableData of this._myGrabbables) {
          let grabbable = grabbableData.getGrabbable();
          grabbable.unregisterReleaseEventListener(this);
          if (this._myThrowVelocitySource == 1) {
            linearVelocity = this._computeReleaseLinearVelocity(grabbableData.getLinearVelocityHistory());
            angularVelocity = this._computeReleaseAngularVelocity(grabbableData.getAngularVelocityHistory());
          }
          grabbable.throw(linearVelocity, angularVelocity);
          this._myThrowEmitter.notify(this, grabbable);
        }
        this._myGrabbables = [];
      }
      this._myActiveGrabButton = null;
    }
  }
  _onRelease(grabber, grabbable) {
    grabbable.unregisterReleaseEventListener(this);
    this._myGrabbables.pp_remove((element) => element.getGrabbable() == grabbable);
    if (this._myGrabbables.length <= 0) {
      this._myActiveGrabButton = null;
    }
  }
  _updateLinearVelocityHistory() {
    let handPose = this._myGamepad.getHandPose();
    this._myHandLinearVelocityHistory.unshift(handPose.getLinearVelocity());
    this._myHandLinearVelocityHistory.pop();
    for (let grabbable of this._myGrabbables) {
      grabbable.updateLinearVelocityHistory();
    }
  }
  _updateAngularVelocityHistory() {
    let handPose = this._myGamepad.getHandPose();
    this._myHandAngularVelocityHistory.unshift(handPose.getAngularVelocityRadians());
    this._myHandAngularVelocityHistory.pop();
    for (let grabbable of this._myGrabbables) {
      grabbable.updateAngularVelocityHistory();
    }
  }
  _computeReleaseLinearVelocity(linearVelocityHistory) {
    let speed = linearVelocityHistory[0].vec3_length();
    for (let i = 1; i < this._myLinearVelocityHistorySpeedAverageSamplesFromStart; i++) {
      speed += linearVelocityHistory[i].vec3_length();
    }
    speed /= this._myLinearVelocityHistorySpeedAverageSamplesFromStart;
    let speedEaseMultiplier = Math.pp_mapToRange(speed, this._myThrowLinearVelocityBoostMinSpeedThreshold, this._myThrowLinearVelocityBoostMaxSpeedThreshold, 0, 1);
    speedEaseMultiplier = EasingFunction.easeIn(speedEaseMultiplier);
    let extraSpeed = speed * (speedEaseMultiplier * this._myThrowLinearVelocityBoost);
    speed += extraSpeed;
    speed *= this._myThrowLinearVelocityMultiplier;
    speed = Math.pp_clamp(speed, 0, this._myThrowMaxLinearSpeed);
    if (this._myDebugEnabled && Globals.isDebugEnabled(this.engine)) {
      this._debugDirectionLines(linearVelocityHistory);
    }
    let directionCurrentWeight = this._myLinearVelocityHistoryDirectionAverageSamplesFromStart;
    let lastDirectionIndex = this._myLinearVelocityHistoryDirectionAverageSkipFromStart + this._myLinearVelocityHistoryDirectionAverageSamplesFromStart;
    let direction2 = vec3_create();
    for (let i = this._myLinearVelocityHistoryDirectionAverageSkipFromStart; i < lastDirectionIndex; i++) {
      let currentDirection = linearVelocityHistory[i];
      currentDirection.vec3_scale(directionCurrentWeight, currentDirection);
      direction2.vec3_add(currentDirection, direction2);
      directionCurrentWeight--;
    }
    direction2.vec3_normalize(direction2);
    direction2.vec3_scale(speed, direction2);
    return direction2;
  }
  _computeReleaseAngularVelocity(angularVelocityHistory) {
    let angularVelocity = angularVelocityHistory[0];
    let speed = angularVelocity.vec3_length();
    speed = Math.pp_clamp(speed * this._myThrowAngularVelocityMultiplier, 0, this._myThrowMaxAngularSpeedRadians);
    let direction2 = angularVelocity;
    direction2.vec3_normalize(direction2);
    direction2.vec3_scale(speed, direction2);
    return direction2;
  }
  _debugDirectionLines(linearVelocityHistory) {
    for (let j = this._myLinearVelocityHistoryDirectionAverageSkipFromStart + this._myLinearVelocityHistoryDirectionAverageSamplesFromStart; j > this._myLinearVelocityHistoryDirectionAverageSkipFromStart; j--) {
      let directionCurrentWeight = j - this._myLinearVelocityHistoryDirectionAverageSkipFromStart;
      let lastDirectionIndex = j - this._myLinearVelocityHistoryDirectionAverageSkipFromStart;
      let direction2 = vec3_create();
      for (let i = this._myLinearVelocityHistoryDirectionAverageSkipFromStart; i < lastDirectionIndex; i++) {
        let currentDirection = linearVelocityHistory[i].pp_clone();
        currentDirection.vec3_scale(directionCurrentWeight, currentDirection);
        direction2.vec3_add(currentDirection, direction2);
        directionCurrentWeight--;
      }
      direction2.vec3_normalize(direction2);
      let color = 1 / j;
      Globals.getDebugVisualManager(this.engine).drawLine(5, this.object.pp_getPosition(), direction2, 0.2, vec4_create(color, color, color, 1));
    }
  }
  _isAlreadyGrabbed(grabbable) {
    let found = this._myGrabbables.pp_find((element) => element.getGrabbable() == grabbable);
    return found != null;
  }
};
__publicField(GrabberHandComponent, "TypeName", "pp-grabber-hand");
__publicField(GrabberHandComponent, "Properties", {
  _myHandedness: Property.enum(["Left", "Right"], "Left"),
  _myGrabButton: Property.enum(["Select", "Squeeze", "Both", "Both Exclusive"], "Squeeze"),
  // @"Both Exclusive" means u can use both buttons but you have to use the same button you grabbed with to throw
  _mySnapOnPivot: Property.bool(false),
  _myMaxNumberOfObjects: Property.int(1),
  // How many objects you can grab at the same time
  // ADVANCED SETTINGS
  _myThrowVelocitySource: Property.enum(["Hand", "Grabbable"], "Hand"),
  _myThrowLinearVelocityMultiplier: Property.float(1),
  // Multiply the overall throw speed, so slow throws will be multiplied too
  _myThrowMaxLinearSpeed: Property.float(15),
  _myThrowAngularVelocityMultiplier: Property.float(0.5),
  _myThrowMaxAngularSpeed: Property.float(1080),
  // @Degrees
  _myThrowLinearVelocityBoost: Property.float(1.75),
  // This boost is applied from 0% to 100% based on how fast you throw, so slow throws are not affected
  _myThrowLinearVelocityBoostMinSpeedThreshold: Property.float(0.6),
  // 0% boost is applied if plain throw speed is under this value
  _myThrowLinearVelocityBoostMaxSpeedThreshold: Property.float(2.5)
  // 100% boost is applied if plain throw speed is over this value
});
var _GrabberHandComponentGrabbableData = class {
  constructor(grabbable, useGrabbableAsVelocitySource, linearVelocityHistorySize, angularVelocityHistorySize) {
    this._myGrabbable = grabbable;
    this._myUseGrabbableAsVelocitySource = useGrabbableAsVelocitySource;
    if (this._myUseGrabbableAsVelocitySource) {
      this._myLinearVelocityHistory = new Array(linearVelocityHistorySize);
      this._myLinearVelocityHistory.fill(vec3_create());
      this._myAngularVelocityHistory = new Array(angularVelocityHistorySize);
      this._myAngularVelocityHistory.fill(vec3_create());
    }
  }
  getGrabbable() {
    return this._myGrabbable;
  }
  getLinearVelocityHistory() {
    return this._myLinearVelocityHistory;
  }
  getAngularVelocityHistory() {
    return this._myAngularVelocityHistory;
  }
  updateLinearVelocityHistory() {
    if (this._myUseGrabbableAsVelocitySource) {
      this._myLinearVelocityHistory.unshift(this._myGrabbable.getLinearVelocity());
      this._myLinearVelocityHistory.pop();
    }
  }
  updateAngularVelocityHistory() {
    if (this._myUseGrabbableAsVelocitySource) {
      this._myAngularVelocityHistory.unshift(this._myGrabbable.getAngularVelocityRadians());
      this._myAngularVelocityHistory.pop();
    }
  }
  onDestroy() {
    this._myCollisionsCollector.destroy();
  }
};

// js/pp/gameplay/integrations/construct_arcade/ca_utils.js
var _myDummyServer = null;
var _myUseDummyServerOnSDKMissing = false;
var _myUseDummyServerOnError = false;
var CAError = {
  DUMMY_NOT_INITIALIZED: 0,
  CA_SDK_MISSING: 1,
  SUBMIT_SCORE_FAILED: 2,
  GET_LEADERBOARD_FAILED: 3,
  GET_USER_FAILED: 4,
  USER_HAS_NO_SCORE: 5
};
function setUseDummyServerOnSDKMissing(useDummyServer) {
  _myUseDummyServerOnSDKMissing = useDummyServer;
}
function setUseDummyServerOnError(useDummyServer) {
  _myUseDummyServerOnError = useDummyServer;
}
function setDummyServer(dummyServer) {
  _myDummyServer = dummyServer;
}
function isUseDummyServerOnSDKMissing() {
  return _myUseDummyServerOnSDKMissing;
}
function isUseDummyServerOnError() {
  return _myUseDummyServerOnError;
}
function getDummyServer() {
  return _myDummyServer;
}
function isSDKAvailable() {
  return window.casdk != null;
}
function getSDK() {
  return window.casdk;
}
function getLeaderboard(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback = null, onErrorCallback = null, useDummyServerOverride = null) {
  if (CAUtils.isSDKAvailable()) {
    let casdk = CAUtils.getSDK();
    if (!aroundPlayer) {
      try {
        casdk.getLeaderboard(leaderboardID, ascending, aroundPlayer, scoresAmount).then(function(result) {
          if (result.leaderboard) {
            if (onDoneCallback != null) {
              onDoneCallback(result.leaderboard);
            }
          } else {
            if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
              CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback);
            } else if (onErrorCallback != null) {
              let error3 = {};
              error3.reason = "Get leaderboard failed";
              error3.type = CAError.GET_LEADERBOARD_FAILED;
              onErrorCallback(error3, result);
            }
          }
        }).catch(function(result) {
          if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
            CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback);
          } else if (onErrorCallback != null) {
            let error3 = {};
            error3.reason = "Get leaderboard failed";
            error3.type = CAError.GET_LEADERBOARD_FAILED;
            onErrorCallback(error3, result);
          }
        });
      } catch (error3) {
        if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
          CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback);
        } else if (onErrorCallback != null) {
          let error4 = {};
          error4.reason = "Get leaderboard failed";
          error4.type = CAError.GET_LEADERBOARD_FAILED;
          onErrorCallback(error4, null);
        }
      }
    } else {
      CAUtils.getUser(
        function(user) {
          let userName = user.displayName;
          try {
            casdk.getLeaderboard(leaderboardID, ascending, aroundPlayer, scoresAmount).then(function(result) {
              if (result.leaderboard) {
                let userValid = false;
                for (let value of result.leaderboard) {
                  if (value.displayName == userName && value.score != 0) {
                    userValid = true;
                    break;
                  }
                }
                if (userValid) {
                  if (onDoneCallback != null) {
                    onDoneCallback(result.leaderboard);
                  }
                } else {
                  if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
                    CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback);
                  } else if (onErrorCallback != null) {
                    let error3 = {};
                    error3.reason = "Searching for around player but the user has not submitted a score yet";
                    error3.type = CAError.USER_HAS_NO_SCORE;
                    onErrorCallback(error3, result);
                  }
                }
              } else {
                if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
                  CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback);
                } else if (onErrorCallback != null) {
                  let error3 = {};
                  error3.reason = "Get leaderboard failed";
                  error3.type = CAError.GET_LEADERBOARD_FAILED;
                  onErrorCallback(error3, result);
                }
              }
            }).catch(function(result) {
              if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
                CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback);
              } else if (onErrorCallback != null) {
                let error3 = {};
                error3.reason = "Get leaderboard failed";
                error3.type = CAError.GET_LEADERBOARD_FAILED;
                onErrorCallback(error3, result);
              }
            });
          } catch (error3) {
            if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
              CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback);
            } else if (onErrorCallback != null) {
              let error4 = {};
              error4.reason = "Get leaderboard failed";
              error4.type = CAError.GET_LEADERBOARD_FAILED;
              onErrorCallback(error4, null);
            }
          }
        },
        function() {
          if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
            CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback);
          } else if (onErrorCallback != null) {
            let error3 = {};
            error3.reason = "Searching for around player but the user can't be retrieved";
            error3.type = CAError.GET_USER_FAILED;
            onErrorCallback(error3, null);
          }
        },
        false
      );
    }
  } else {
    if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnSDKMissing && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
      CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback);
    } else if (onErrorCallback != null) {
      let error3 = {};
      error3.reason = "Construct Arcade SDK missing";
      error3.type = CAError.CA_SDK_MISSING;
      onErrorCallback(error3, null);
    }
  }
}
function getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback = null, onErrorCallback = null) {
  if (_myDummyServer) {
    _myDummyServer.getLeaderboard(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback);
  } else {
    if (onErrorCallback != null) {
      let error3 = {};
      error3.reason = "Dummy server not initialized";
      error3.type = CAError.DUMMY_NOT_INITIALIZED;
      onErrorCallback(error3, null);
    }
  }
}
function submitScore(leaderboardID, scoreToSubmit, onDoneCallback = null, onErrorCallback = null, useDummyServerOverride = null) {
  if (CAUtils.isSDKAvailable()) {
    let casdk = CAUtils.getSDK();
    try {
      casdk.submitScore(leaderboardID, scoreToSubmit).then(function(result) {
        if (result.error) {
          if (_myDummyServer != null && _myDummyServer.submitScore != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
            CAUtils.submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback);
          } else if (onErrorCallback != null) {
            let error3 = {};
            error3.reason = "Submit score failed";
            error3.type = CAError.SUBMIT_SCORE_FAILED;
            onErrorCallback(error3, result);
          }
        } else {
          onDoneCallback();
        }
      }).catch(function(result) {
        if (_myDummyServer != null && _myDummyServer.submitScore != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
          CAUtils.submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback);
        } else if (onErrorCallback != null) {
          let error3 = {};
          error3.reason = "Submit score failed";
          error3.type = CAError.SUBMIT_SCORE_FAILED;
          onErrorCallback(error3, result);
        }
      });
    } catch (error3) {
      if (_myDummyServer != null && _myDummyServer.submitScore != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
        CAUtils.submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback);
      } else if (onErrorCallback != null) {
        let error4 = {};
        error4.reason = "Submit score failed";
        error4.type = CAError.SUBMIT_SCORE_FAILED;
        onErrorCallback(error4, null);
      }
    }
  } else {
    if (_myDummyServer != null && _myDummyServer.submitScore != null && (_myUseDummyServerOnSDKMissing && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
      CAUtils.submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback);
    } else if (onErrorCallback != null) {
      let error3 = {};
      error3.reason = "Construct Arcade SDK missing";
      error3.type = CAError.CA_SDK_MISSING;
      onErrorCallback(error3, null);
    }
  }
}
function submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback = null, onErrorCallback = null) {
  if (_myDummyServer) {
    _myDummyServer.submitScore(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback);
  } else {
    if (onErrorCallback != null) {
      let error3 = {};
      error3.reason = "Dummy server not initialized";
      error3.type = CAError.DUMMY_NOT_INITIALIZED;
      onErrorCallback(error3, null);
    }
  }
}
function getUser(onDoneCallback = null, onErrorCallback = null, useDummyServerOverride = null) {
  if (CAUtils.isSDKAvailable()) {
    let casdk = CAUtils.getSDK();
    try {
      casdk.getUser().then(function(result) {
        if (result.user) {
          if (onDoneCallback != null) {
            onDoneCallback(result.user);
          }
        } else {
          if (_myDummyServer != null && _myDummyServer.getUser != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
            CAUtils.getUserDummy(onDoneCallback, onErrorCallback);
          } else if (onErrorCallback != null) {
            let error3 = {};
            error3.reason = "Get user failed";
            error3.type = CAError.GET_USER_FAILED;
            onErrorCallback(error3, result);
          }
        }
      }).catch(function(result) {
        if (_myDummyServer != null && _myDummyServer.getUser != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
          CAUtils.getUserDummy(onDoneCallback, onErrorCallback);
        } else if (onErrorCallback != null) {
          let error3 = {};
          error3.reason = "Get user failed";
          error3.type = CAError.GET_USER_FAILED;
          onErrorCallback(error3, result);
        }
      });
    } catch (error3) {
      if (_myDummyServer != null && _myDummyServer.getUser != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
        CAUtils.getUserDummy(onDoneCallback, onErrorCallback);
      } else if (onErrorCallback != null) {
        let error4 = {};
        error4.reason = "Get user failed";
        error4.type = CAError.GET_USER_FAILED;
        onErrorCallback(error4, null);
      }
    }
  } else {
    if (_myDummyServer != null && _myDummyServer.getUser != null && (_myUseDummyServerOnSDKMissing && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
      CAUtils.getUserDummy(onDoneCallback, onErrorCallback);
    } else if (onErrorCallback != null) {
      let error3 = {};
      error3.reason = "Construct Arcade SDK missing";
      error3.type = CAError.CA_SDK_MISSING;
      onErrorCallback(error3, null);
    }
  }
}
function getUserDummy(onDoneCallback = null, onErrorCallback = null) {
  if (_myDummyServer) {
    _myDummyServer.getUser(onDoneCallback, onErrorCallback);
  } else {
    if (onErrorCallback != null) {
      let error3 = {};
      error3.reason = "Dummy server not initialized";
      error3.type = CAError.DUMMY_NOT_INITIALIZED;
      onErrorCallback(error3, null);
    }
  }
}
var CAUtils = {
  setUseDummyServerOnSDKMissing,
  setUseDummyServerOnError,
  setDummyServer,
  isUseDummyServerOnSDKMissing,
  isUseDummyServerOnError,
  getDummyServer,
  isSDKAvailable,
  getSDK,
  getLeaderboard,
  getLeaderboardDummy,
  submitScore,
  submitScoreDummy,
  getUser,
  getUserDummy
};

// js/pp/gameplay/integrations/construct_arcade/ca_dummy_server.js
var CADummyServer = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this._myEngine = engine2;
  }
  getLeaderboard(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback = null, onErrorCallback = null) {
    let leaderboard = null;
    if (CAUtils.isSDKAvailable()) {
      leaderboard = [
        { rank: 0, displayName: "An", score: 0 },
        { rank: 1, displayName: "Error", score: 0 },
        { rank: 2, displayName: "Has", score: 0 },
        { rank: 3, displayName: "Occurred", score: 0 },
        { rank: 4, displayName: "While", score: 0 },
        { rank: 5, displayName: "Trying", score: 0 },
        { rank: 6, displayName: "To", score: 0 },
        { rank: 7, displayName: "Retrieve", score: 0 },
        { rank: 8, displayName: "The", score: 0 },
        { rank: 9, displayName: "Leaderboard", score: 0 }
      ];
    } else {
      if (aroundPlayer) {
        leaderboard = [
          { rank: 0, displayName: "Sign In", score: 0 },
          { rank: 1, displayName: "And", score: 0 },
          { rank: 2, displayName: "Play", score: 0 },
          { rank: 3, displayName: "On", score: 0 },
          { rank: 4, displayName: "HeyVR", score: 0 },
          { rank: 5, displayName: "To", score: 0 },
          { rank: 6, displayName: "Submit", score: 0 },
          { rank: 7, displayName: "Your", score: 0 },
          { rank: 8, displayName: "Own", score: 0 },
          { rank: 9, displayName: "Score", score: 0 }
        ];
      } else {
        leaderboard = [
          { rank: 0, displayName: "The", score: 0 },
          { rank: 1, displayName: "Top 10", score: 0 },
          { rank: 2, displayName: "Leaderboard", score: 0 },
          { rank: 3, displayName: "Is", score: 0 },
          { rank: 4, displayName: "Available", score: 0 },
          { rank: 5, displayName: "Only", score: 0 },
          { rank: 5, displayName: "When", score: 0 },
          { rank: 7, displayName: "Playing", score: 0 },
          { rank: 8, displayName: "On", score: 0 },
          { rank: 9, displayName: "HeyVR", score: 0 }
        ];
      }
    }
    while (leaderboard.length > scoresAmount) {
      leaderboard.pop();
    }
    if (onDoneCallback != null) {
      onDoneCallback(leaderboard);
    }
  }
  submitScore(leaderboardID, scoreToSubmit, onDoneCallback = null, onErrorCallback = null) {
    if (onDoneCallback != null) {
      onDoneCallback();
    }
  }
  getUser(onDoneCallback = null, onErrorCallback = null) {
    let user = {};
    user.displayName = "Florian";
    if (onDoneCallback != null) {
      onDoneCallback(user);
    }
  }
};

// js/pp/gameplay/integrations/construct_arcade/ca_display_leaderboard_component.js
var CADisplayLeaderboardComponent = class extends Component {
  init() {
    this._myUsernamesTextComponent = null;
    this._myScoresTextComponent = null;
    this._myStarted = false;
    this._myDestroyed = false;
  }
  start() {
    if (this._myAddDefaultCADummyServer) {
      CAUtils.setDummyServer(new CADummyServer());
      CAUtils.setUseDummyServerOnSDKMissing(true);
      CAUtils.setUseDummyServerOnError(true);
    }
  }
  update(dt) {
    if (!this._myStarted) {
      this._myStarted = true;
      if (this._myUsernamesTextObject != null) {
        this._myUsernamesTextComponent = this._myUsernamesTextObject.pp_getComponent(TextComponent);
      }
      if (this._myScoresTextObject != null) {
        this._myScoresTextComponent = this._myScoresTextObject.pp_getComponent(TextComponent);
      }
      this.updateLeaderboard();
    }
  }
  updateLeaderboard() {
    CAUtils.getLeaderboard(this._myLeaderboardID, this._myAscending, this._myLocal, this._myScoresAmount, this._onLeaderboardRetrieved.bind(this));
  }
  _onLeaderboardRetrieved(leaderboard) {
    if (this._myDestroyed)
      return;
    let namesText = "";
    let scoresText = "";
    let maxRankDigit = 0;
    for (let value of leaderboard) {
      let rank = value.rank + 1;
      if (rank.toFixed(0).length > maxRankDigit) {
        maxRankDigit = rank.toFixed(0).length;
      }
    }
    for (let value of leaderboard) {
      let rank = value.rank + 1;
      let fixedRank = rank.toFixed(0);
      while (fixedRank.length < maxRankDigit) {
        fixedRank = "0".concat(fixedRank);
      }
      let newlines = "\n";
      for (let i = 0; i < this._myNumberOfLinesBetweenScores; i++) {
        newlines = newlines + "\n";
      }
      namesText = namesText.concat(fixedRank, this._myPositionAndUsernameSeparator, value.displayName, newlines);
      let convertedScore = this._formatScore(value.score);
      scoresText = scoresText.concat(convertedScore, newlines);
    }
    if (this._myUsernamesTextComponent != null) {
      this._myUsernamesTextComponent.text = namesText;
    }
    if (this._myScoresTextComponent != null) {
      this._myScoresTextComponent.text = scoresText;
    }
  }
  _formatScore(score) {
    let convertedScore = score.toString();
    if (this._myScoreFormat == 1) {
      convertedScore = this._formatTime(score, true, true, true);
    } else if (this._myScoreFormat == 2) {
      convertedScore = this._formatTime(score, false, true, true);
    } else if (this._myScoreFormat == 3) {
      convertedScore = this._formatTime(score, false, false, true);
    } else if (this._myScoreFormat == 4) {
      convertedScore = this._formatTime(score, true, true, false);
    } else if (this._myScoreFormat == 5) {
      convertedScore = this._formatTime(score, false, true, false);
    }
    return convertedScore;
  }
  _formatTime(score, displayHours, displayMinutes, displaySeconds) {
    let time = Math.floor(score / 1e3);
    let hours = 0;
    if (displayHours) {
      hours = Math.floor(time / 3600);
      time -= hours * 3600;
    }
    let minutes = 0;
    if (displayMinutes) {
      minutes = Math.floor(time / 60);
      time -= minutes * 60;
    }
    let seconds = 0;
    if (displaySeconds) {
      seconds = Math.floor(time);
    }
    let convertedTime = "";
    if (displaySeconds) {
      convertedTime = seconds.toFixed(0).length < 2 && (displayMinutes || displayHours) ? "0".concat(seconds.toFixed(0)) : seconds.toFixed(0);
    }
    if (displayMinutes) {
      convertedTime = (minutes.toFixed(0).length < 2 && (displaySeconds || displayHours) ? "0".concat(minutes.toFixed(0)) : minutes.toFixed(0)) + (displaySeconds ? ":" + convertedTime : "");
    }
    if (displayHours) {
      convertedTime = (hours.toFixed(0).length < 2 && (displaySeconds || displayMinutes) ? "0".concat(hours.toFixed(0)) : hours.toFixed(0)) + (displayMinutes ? ":" + convertedTime : "");
    }
    return convertedTime;
  }
  pp_clone(targetObject) {
    let clonedComponent = ComponentUtils.cloneDefault(this, targetObject);
    return clonedComponent;
  }
  onDestroy() {
    this._myDestroyed = true;
  }
};
__publicField(CADisplayLeaderboardComponent, "TypeName", "pp-ca-display-leaderboard");
__publicField(CADisplayLeaderboardComponent, "Properties", {
  _myUsernamesTextObject: Property.object(),
  _myScoresTextObject: Property.object(),
  _myLeaderboardID: Property.string(""),
  _myLocal: Property.bool(false),
  _myAscending: Property.bool(false),
  _myScoresAmount: Property.int(10),
  _myScoreFormat: Property.enum(["Value", "Hours:Minutes:Seconds", "Minutes:Seconds", "Seconds", "Hours:Minutes", "Minutes"], "Value"),
  _myPositionAndUsernameSeparator: Property.string(" - "),
  _myNumberOfLinesBetweenScores: Property.int(1),
  _myAddDefaultCADummyServer: Property.bool(false)
});

// js/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_params.js
var CollisionCheckParams = class {
  constructor() {
    this.mySplitMovementEnabled = false;
    this.mySplitMovementMaxLength = 0;
    this.mySplitMovementMaxStepsEnabled = false;
    this.mySplitMovementMaxSteps = 0;
    this.mySplitMovementStepEqualLength = false;
    this.mySplitMovementStepEqualLengthMinLength = 0;
    this.mySplitMovementStopWhenHorizontalMovementCanceled = false;
    this.mySplitMovementStopWhenVerticalMovementCanceled = false;
    this.mySplitMovementStopCallback = null;
    this.mySplitMovementStopReturnPrevious = false;
    this.myRadius = 0;
    this.myDistanceFromFeetToIgnore = 0;
    this.myDistanceFromHeadToIgnore = 0;
    this.myPositionOffsetLocal = vec3_create();
    this.myRotationOffsetLocalQuat = quat_create();
    this.myHorizontalMovementCheckEnabled = false;
    this.myHorizontalMovementStepEnabled = false;
    this.myHorizontalMovementStepMaxLength = 0;
    this.myHorizontalMovementRadialStepAmount = 0;
    this.myHorizontalMovementCheckDiagonalOutward = false;
    this.myHorizontalMovementCheckDiagonalInward = false;
    this.myHorizontalMovementCheckStraight = false;
    this.myHorizontalMovementCheckHorizontalBorder = false;
    this.myHorizontalMovementCheckVerticalStraight = false;
    this.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = false;
    this.myHorizontalMovementCheckVerticalDiagonalUpwardInward = false;
    this.myHorizontalMovementCheckVerticalDiagonalDownwardOutward = false;
    this.myHorizontalMovementCheckVerticalDiagonalDownwardInward = false;
    this.myHorizontalMovementCheckVerticalStraightDiagonalUpward = false;
    this.myHorizontalMovementCheckVerticalStraightDiagonalDownward = false;
    this.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward = false;
    this.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward = false;
    this.myHorizontalMovementHorizontalStraightCentralCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightCentralCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = false;
    this.myHorizontalPositionCheckEnabled = false;
    this.myHalfConeAngle = 0;
    this.myHalfConeSliceAmount = 0;
    this.myCheckConeBorder = false;
    this.myCheckConeRay = false;
    this.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = true;
    this.myHorizontalPositionCheckVerticalDirectionType = 0;
    this.myCheckHorizontalFixedForwardEnabled = false;
    this.myCheckHorizontalFixedForward = vec3_create();
    this.myVerticalMovementCheckEnabled = false;
    this.myVerticalPositionCheckEnabled = false;
    this.myFeetRadius = 0;
    this.myAdjustVerticalMovementWithGroundAngleDownhill = false;
    this.myAdjustVerticalMovementWithGroundAngleUphill = false;
    this.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle = null;
    this.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle = null;
    this.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle = null;
    this.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle = null;
    this.myAdjustHorizontalMovementWithGroundAngleDownhill = false;
    this.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle = null;
    this.myAdjustVerticalMovementWithCeilingAngleDownhill = false;
    this.myAdjustVerticalMovementWithCeilingAngleUphill = false;
    this.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = null;
    this.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = null;
    this.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = null;
    this.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = null;
    this.myAdjustHorizontalMovementWithCeilingAngleDownhill = false;
    this.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle = null;
    this.myCheckVerticalFixedForwardEnabled = false;
    this.myCheckVerticalFixedForward = vec3_create();
    this.myCheckVerticalBothDirection = false;
    this.mySnapOnGroundEnabled = false;
    this.mySnapOnGroundExtraDistance = 0;
    this.mySnapOnCeilingEnabled = false;
    this.mySnapOnCeilingExtraDistance = 0;
    this.myGroundPopOutEnabled = false;
    this.myGroundPopOutExtraDistance = 0;
    this.myCeilingPopOutEnabled = false;
    this.myCeilingPopOutExtraDistance = 0;
    this.myVerticalMovementReduceEnabled = false;
    this.myGroundCircumferenceAddCenter = false;
    this.myGroundCircumferenceSliceAmount = 0;
    this.myGroundCircumferenceStepAmount = 0;
    this.myGroundCircumferenceRotationPerStep = 0;
    this.myVerticalAllowHitInsideCollisionIfOneOk = false;
    this.myCheckHeight = false;
    this.myCheckHeightVerticalMovement = false;
    this.myCheckHeightVerticalPosition = false;
    this.myCheckHeightTopMovement = false;
    this.myCheckHeightTopPosition = false;
    this.myCheckHeightConeOnCollision = false;
    this.myCheckHeightConeOnCollisionKeepHit = false;
    this.myHeightCheckStepAmountMovement = 0;
    this.myHeightCheckStepAmountPosition = 0;
    this.myCheckVerticalStraight = false;
    this.myCheckVerticalDiagonalRayOutward = false;
    this.myCheckVerticalDiagonalRayInward = false;
    this.myCheckVerticalDiagonalBorderOutward = false;
    this.myCheckVerticalDiagonalBorderInward = false;
    this.myCheckVerticalDiagonalBorderRayOutward = false;
    this.myCheckVerticalDiagonalBorderRayInward = false;
    this.myCheckVerticalSearchFartherVerticalHit = false;
    this.myGroundAngleToIgnore = 0;
    this.myGroundAngleToIgnoreWithPerceivedAngle = null;
    this.myCeilingAngleToIgnore = 0;
    this.myCeilingAngleToIgnoreWithPerceivedAngle = null;
    this.myHorizontalMovementGroundAngleIgnoreHeight = null;
    this.myHorizontalMovementCeilingAngleIgnoreHeight = null;
    this.myHorizontalPositionGroundAngleIgnoreHeight = null;
    this.myHorizontalPositionCeilingAngleIgnoreHeight = null;
    this.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = null;
    this.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft = null;
    this.myHeight = 0;
    this.myComputeGroundInfoEnabled = false;
    this.myComputeCeilingInfoEnabled = false;
    this.myDistanceToBeOnGround = 0;
    this.myDistanceToComputeGroundInfo = 0;
    this.myDistanceToBeOnCeiling = 0;
    this.myDistanceToComputeCeilingInfo = 0;
    this.myVerticalFixToBeOnGround = 0;
    this.myVerticalFixToComputeGroundInfo = 0;
    this.myVerticalFixToBeOnCeiling = 0;
    this.myVerticalFixToComputeCeilingInfo = 0;
    this.myGroundIsBaseInsideCollisionCheckEnabled = false;
    this.myCeilingIsBaseInsideCollisionCheckEnabled = false;
    this.myIsOnGroundIfInsideHit = false;
    this.myIsOnCeilingIfInsideHit = false;
    this.myIsOnGroundMaxSurfaceAngle = null;
    this.myIsOnCeilingMaxSurfaceAngle = null;
    this.myFindGroundDistanceMaxOutsideDistance = 0;
    this.myFindGroundDistanceMaxInsideDistance = 0;
    this.myFindCeilingDistanceMaxOutsideDistance = 0;
    this.myFindCeilingDistanceMaxInsideDistance = 0;
    this.myAllowGroundSteepFix = false;
    this.myAllowCeilingSteepFix = false;
    this.myMustStayOnGround = false;
    this.myMustStayOnCeiling = false;
    this.myMustStayOnValidGroundAngleDownhill = false;
    this.myMustStayOnValidCeilingAngleDownhill = false;
    this.myRegatherGroundInfoOnSurfaceCheckFail = false;
    this.myRegatherCeilingInfoOnSurfaceCheckFail = false;
    this.myMustStayBelowIgnorableGroundAngleDownhill = false;
    this.myMustStayBelowIgnorableCeilingAngleDownhill = false;
    this.myMustStayBelowGroundAngleDownhill = null;
    this.myMustStayBelowCeilingAngleDownhill = null;
    this.myMovementMustStayOnGroundHitAngle = null;
    this.myMovementMustStayOnCeilingHitAngle = null;
    this.myTeleportMustBeOnIgnorableGroundAngle = false;
    this.myCheckTransformMustBeOnIgnorableGroundAngle = false;
    this.myTeleportMustBeOnIgnorableCeilingAngle = false;
    this.myCheckTransformMustBeOnIgnorableCeilingAngle = false;
    this.myTeleportMustBeOnGroundAngle = null;
    this.myCheckTransformMustBeOnGroundAngle = null;
    this.myTeleportMustBeOnCeilingAngle = null;
    this.myCheckTransformMustBeOnCeilingAngle = null;
    this.myTeleportMustBeOnGround = false;
    this.myCheckTransformMustBeOnGround = false;
    this.myTeleportMustBeOnCeiling = false;
    this.myCheckTransformMustBeOnCeiling = false;
    this.mySlidingEnabled = false;
    this.mySlidingHorizontalMovementCheckBetterNormal = false;
    this.mySlidingMaxAttempts = 0;
    this.mySlidingCheckBothDirections = false;
    this.mySlidingFlickeringPreventionType = 0;
    this.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding = false;
    this.mySlidingFlickerPreventionCheckAnywayCounter = 0;
    this.mySlidingAdjustSign90Degrees = false;
    this.myHorizontalBlockLayerFlags = new PhysicsLayerFlags();
    this.myHorizontalObjectsToIgnore = [];
    this.myVerticalBlockLayerFlags = new PhysicsLayerFlags();
    this.myVerticalObjectsToIgnore = [];
    this.myExtraMovementCheckCallback = null;
    this.myExtraTeleportCheckCallback = null;
    this.myExtraCheckTransformCheckCallback = null;
    this.myDebugEnabled = false;
    this.myDebugHorizontalMovementEnabled = false;
    this.myDebugHorizontalPositionEnabled = false;
    this.myDebugVerticalMovementEnabled = false;
    this.myDebugVerticalPositionEnabled = false;
    this.myDebugSlidingEnabled = false;
    this.myDebugGroundInfoEnabled = false;
    this.myDebugCeilingInfoEnabled = false;
    this.myDebugRuntimeParamsEnabled = false;
    this.myDebugMovementEnabled = false;
  }
  copy(other) {
    this.mySplitMovementEnabled = other.mySplitMovementEnabled;
    this.mySplitMovementMaxLength = other.mySplitMovementMaxLength;
    this.mySplitMovementMaxStepsEnabled = other.mySplitMovementMaxStepsEnabled;
    this.mySplitMovementMaxSteps = other.mySplitMovementMaxSteps;
    this.mySplitMovementStepEqualLength = other.mySplitMovementStepEqualLength;
    this.mySplitMovementStepEqualLengthMinLength = other.mySplitMovementStepEqualLengthMinLength;
    this.mySplitMovementStopWhenHorizontalMovementCanceled = other.mySplitMovementStopWhenHorizontalMovementCanceled;
    this.mySplitMovementStopWhenVerticalMovementCanceled = other.mySplitMovementStopWhenVerticalMovementCanceled;
    this.mySplitMovementStopCallback = other.mySplitMovementStopCallback;
    this.mySplitMovementStopReturnPrevious = other.mySplitMovementStopReturnPrevious;
    this.myRadius = other.myRadius;
    this.myDistanceFromFeetToIgnore = other.myDistanceFromFeetToIgnore;
    this.myDistanceFromHeadToIgnore = other.myDistanceFromHeadToIgnore;
    this.myPositionOffsetLocal.vec3_copy(other.myPositionOffsetLocal);
    this.myRotationOffsetLocalQuat.quat_copy(other.myRotationOffsetLocalQuat);
    this.myHorizontalMovementCheckEnabled = other.myHorizontalMovementCheckEnabled;
    this.myHorizontalMovementStepEnabled = other.myHorizontalMovementStepEnabled;
    this.myHorizontalMovementStepMaxLength = other.myHorizontalMovementStepMaxLength;
    this.myHorizontalMovementRadialStepAmount = other.myHorizontalMovementRadialStepAmount;
    this.myHorizontalMovementCheckDiagonalOutward = other.myHorizontalMovementCheckDiagonalOutward;
    this.myHorizontalMovementCheckDiagonalInward = other.myHorizontalMovementCheckDiagonalInward;
    this.myHorizontalMovementCheckStraight = other.myHorizontalMovementCheckStraight;
    this.myHorizontalMovementCheckHorizontalBorder = other.myHorizontalMovementCheckHorizontalBorder;
    this.myHorizontalMovementCheckVerticalStraight = other.myHorizontalMovementCheckVerticalStraight;
    this.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = other.myHorizontalMovementCheckVerticalDiagonalUpwardOutward;
    this.myHorizontalMovementCheckVerticalDiagonalUpwardInward = other.myHorizontalMovementCheckVerticalDiagonalUpwardInward;
    this.myHorizontalMovementCheckVerticalDiagonalDownwardOutward = other.myHorizontalMovementCheckVerticalDiagonalDownwardOutward;
    this.myHorizontalMovementCheckVerticalDiagonalDownwardInward = other.myHorizontalMovementCheckVerticalDiagonalDownwardInward;
    this.myHorizontalMovementCheckVerticalStraightDiagonalUpward = other.myHorizontalMovementCheckVerticalStraightDiagonalUpward;
    this.myHorizontalMovementCheckVerticalStraightDiagonalDownward = other.myHorizontalMovementCheckVerticalStraightDiagonalDownward;
    this.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward = other.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward;
    this.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward = other.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward;
    this.myHorizontalMovementHorizontalStraightCentralCheckEnabled = other.myHorizontalMovementHorizontalStraightCentralCheckEnabled;
    this.myHorizontalMovementVerticalStraightCentralCheckEnabled = other.myHorizontalMovementVerticalStraightCentralCheckEnabled;
    this.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled;
    this.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled;
    this.myHorizontalPositionCheckEnabled = other.myHorizontalPositionCheckEnabled;
    this.myHalfConeAngle = other.myHalfConeAngle;
    this.myHalfConeSliceAmount = other.myHalfConeSliceAmount;
    this.myCheckConeBorder = other.myCheckConeBorder;
    this.myCheckConeRay = other.myCheckConeRay;
    this.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = other.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision;
    this.myHorizontalPositionCheckVerticalDirectionType = other.myHorizontalPositionCheckVerticalDirectionType;
    this.myVerticalMovementCheckEnabled = other.myVerticalMovementCheckEnabled;
    this.myVerticalPositionCheckEnabled = other.myVerticalPositionCheckEnabled;
    this.myFeetRadius = other.myFeetRadius;
    this.myAdjustVerticalMovementWithGroundAngleDownhill = other.myAdjustVerticalMovementWithGroundAngleDownhill;
    this.myAdjustVerticalMovementWithGroundAngleUphill = other.myAdjustVerticalMovementWithGroundAngleUphill;
    this.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle = other.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle;
    this.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle = other.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle;
    this.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle = other.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle;
    this.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle = other.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle;
    this.myAdjustHorizontalMovementWithGroundAngleDownhill = other.myAdjustHorizontalMovementWithGroundAngleDownhill;
    this.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle = other.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle;
    this.myAdjustVerticalMovementWithCeilingAngleDownhill = other.myAdjustVerticalMovementWithCeilingAngleDownhill;
    this.myAdjustVerticalMovementWithCeilingAngleUphill = other.myAdjustVerticalMovementWithCeilingAngleUphill;
    this.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = other.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle;
    this.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = other.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle;
    this.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = other.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle;
    this.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = other.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle;
    this.myAdjustHorizontalMovementWithCeilingAngleDownhill = other.myAdjustHorizontalMovementWithCeilingAngleDownhill;
    this.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle = other.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle;
    this.myCheckVerticalFixedForwardEnabled = other.myCheckVerticalFixedForwardEnabled;
    this.myCheckVerticalFixedForward.vec3_copy(other.myCheckVerticalFixedForward);
    this.myCheckVerticalBothDirection = other.myCheckVerticalBothDirection;
    this.mySnapOnGroundEnabled = other.mySnapOnGroundEnabled;
    this.mySnapOnGroundExtraDistance = other.mySnapOnGroundExtraDistance;
    this.mySnapOnCeilingEnabled = other.mySnapOnCeilingEnabled;
    this.mySnapOnCeilingExtraDistance = other.mySnapOnCeilingExtraDistance;
    this.myGroundPopOutEnabled = other.myGroundPopOutEnabled;
    this.myGroundPopOutExtraDistance = other.myGroundPopOutExtraDistance;
    this.myCeilingPopOutEnabled = other.myCeilingPopOutEnabled;
    this.myCeilingPopOutExtraDistance = other.myCeilingPopOutExtraDistance;
    this.myVerticalMovementReduceEnabled = other.myVerticalMovementReduceEnabled;
    this.myGroundCircumferenceAddCenter = other.myGroundCircumferenceAddCenter;
    this.myGroundCircumferenceSliceAmount = other.myGroundCircumferenceSliceAmount;
    this.myGroundCircumferenceStepAmount = other.myGroundCircumferenceStepAmount;
    this.myGroundCircumferenceRotationPerStep = other.myGroundCircumferenceRotationPerStep;
    this.myVerticalAllowHitInsideCollisionIfOneOk = other.myVerticalAllowHitInsideCollisionIfOneOk;
    this.myCheckHeight = other.myCheckHeight;
    this.myCheckHeightVerticalMovement = other.myCheckHeightVerticalMovement;
    this.myCheckHeightVerticalPosition = other.myCheckHeightVerticalPosition;
    this.myCheckHeightTopMovement = other.myCheckHeightTopMovement;
    this.myCheckHeightTopPosition = other.myCheckHeightTopPosition;
    this.myCheckHeightConeOnCollision = other.myCheckHeightConeOnCollision;
    this.myCheckHeightConeOnCollisionKeepHit = other.myCheckHeightConeOnCollisionKeepHit;
    this.myHeightCheckStepAmountMovement = other.myHeightCheckStepAmountMovement;
    this.myHeightCheckStepAmountPosition = other.myHeightCheckStepAmountPosition;
    this.myCheckVerticalStraight = other.myCheckVerticalStraight;
    this.myCheckVerticalDiagonalRayOutward = other.myCheckVerticalDiagonalRayOutward;
    this.myCheckVerticalDiagonalRayInward = other.myCheckVerticalDiagonalRayInward;
    this.myCheckVerticalDiagonalBorderOutward = other.myCheckVerticalDiagonalBorderOutward;
    this.myCheckVerticalDiagonalBorderInward = other.myCheckVerticalDiagonalBorderInward;
    this.myCheckVerticalDiagonalBorderRayOutward = other.myCheckVerticalDiagonalBorderRayOutward;
    this.myCheckVerticalDiagonalBorderRayInward = other.myCheckVerticalDiagonalBorderRayInward;
    this.myCheckVerticalSearchFartherVerticalHit = other.myCheckVerticalSearchFartherVerticalHit;
    this.myGroundAngleToIgnore = other.myGroundAngleToIgnore;
    this.myGroundAngleToIgnoreWithPerceivedAngle = other.myGroundAngleToIgnoreWithPerceivedAngle;
    this.myCeilingAngleToIgnore = other.myCeilingAngleToIgnore;
    this.myCeilingAngleToIgnoreWithPerceivedAngle = other.myCeilingAngleToIgnoreWithPerceivedAngle;
    this.myHorizontalMovementGroundAngleIgnoreHeight = other.myHorizontalMovementGroundAngleIgnoreHeight;
    this.myHorizontalMovementCeilingAngleIgnoreHeight = other.myHorizontalMovementCeilingAngleIgnoreHeight;
    this.myHorizontalPositionGroundAngleIgnoreHeight = other.myHorizontalPositionGroundAngleIgnoreHeight;
    this.myHorizontalPositionCeilingAngleIgnoreHeight = other.myHorizontalPositionCeilingAngleIgnoreHeight;
    this.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = other.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft;
    this.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft = other.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft;
    this.myHeight = other.myHeight;
    this.myComputeGroundInfoEnabled = other.myComputeGroundInfoEnabled;
    this.myComputeCeilingInfoEnabled = other.myComputeCeilingInfoEnabled;
    this.myDistanceToBeOnGround = other.myDistanceToBeOnGround;
    this.myDistanceToComputeGroundInfo = other.myDistanceToComputeGroundInfo;
    this.myDistanceToBeOnCeiling = other.myDistanceToBeOnCeiling;
    this.myDistanceToComputeCeilingInfo = other.myDistanceToComputeCeilingInfo;
    this.myVerticalFixToBeOnGround = other.myVerticalFixToBeOnGround;
    this.myVerticalFixToComputeGroundInfo = other.myVerticalFixToComputeGroundInfo;
    this.myVerticalFixToBeOnCeiling = other.myVerticalFixToBeOnCeiling;
    this.myVerticalFixToComputeCeilingInfo = other.myVerticalFixToComputeCeilingInfo;
    this.myGroundIsBaseInsideCollisionCheckEnabled = other.myGroundIsBaseInsideCollisionCheckEnabled;
    this.myCeilingIsBaseInsideCollisionCheckEnabled = other.myCeilingIsBaseInsideCollisionCheckEnabled;
    this.myIsOnGroundIfInsideHit = other.myIsOnGroundIfInsideHit;
    this.myIsOnCeilingIfInsideHit = other.myIsOnCeilingIfInsideHit;
    this.myIsOnGroundMaxSurfaceAngle = other.myIsOnGroundMaxSurfaceAngle;
    this.myIsOnCeilingMaxSurfaceAngle = other.myIsOnCeilingMaxSurfaceAngle;
    this.myFindGroundDistanceMaxOutsideDistance = other.myFindGroundDistanceMaxOutsideDistance;
    this.myFindGroundDistanceMaxInsideDistance = other.myFindGroundDistanceMaxInsideDistance;
    this.myFindCeilingDistanceMaxOutsideDistance = other.myFindCeilingDistanceMaxOutsideDistance;
    this.myFindCeilingDistanceMaxInsideDistance = other.myFindCeilingDistanceMaxInsideDistance;
    this.myAllowGroundSteepFix = other.myAllowGroundSteepFix;
    this.myAllowCeilingSteepFix = other.myAllowCeilingSteepFix;
    this.myMustStayOnGround = other.myMustStayOnGround;
    this.myMustStayOnCeiling = other.myMustStayOnCeiling;
    this.myMustStayOnValidGroundAngleDownhill = other.myMustStayOnValidGroundAngleDownhill;
    this.myMustStayOnValidCeilingAngleDownhill = other.myMustStayOnValidCeilingAngleDownhill;
    this.myRegatherGroundInfoOnSurfaceCheckFail = other.myRegatherGroundInfoOnSurfaceCheckFail;
    this.myRegatherCeilingInfoOnSurfaceCheckFail = other.myRegatherCeilingInfoOnSurfaceCheckFail;
    this.myMustStayBelowGroundAngleDownhill = other.myMustStayBelowGroundAngleDownhill;
    this.myMustStayBelowCeilingAngleDownhill = other.myMustStayBelowCeilingAngleDownhill;
    this.myMustStayBelowIgnorableGroundAngleDownhill = other.myMustStayBelowIgnorableGroundAngleDownhill;
    this.myMustStayBelowIgnorableCeilingAngleDownhill = other.myMustStayBelowIgnorableCeilingAngleDownhill;
    this.myMovementMustStayOnGroundHitAngle = other.myMovementMustStayOnGroundHitAngle;
    this.myMovementMustStayOnCeilingHitAngle = other.myMovementMustStayOnCeilingHitAngle;
    this.myTeleportMustBeOnIgnorableGroundAngle = other.myTeleportMustBeOnIgnorableGroundAngle;
    this.myCheckTransformMustBeOnIgnorableGroundAngle = other.myCheckTransformMustBeOnIgnorableGroundAngle;
    this.myTeleportMustBeOnIgnorableCeilingAngle = other.myTeleportMustBeOnIgnorableCeilingAngle;
    this.myCheckTransformMustBeOnIgnorableCeilingAngle = other.myCheckTransformMustBeOnIgnorableCeilingAngle;
    this.myTeleportMustBeOnGroundAngle = other.myTeleportMustBeOnGroundAngle;
    this.myCheckTransformMustBeOnGroundAngle = other.myCheckTransformMustBeOnGroundAngle;
    this.myTeleportMustBeOnCeilingAngle = other.myTeleportMustBeOnCeilingAngle;
    this.myCheckTransformMustBeOnCeilingAngle = other.myCheckTransformMustBeOnCeilingAngle;
    this.myTeleportMustBeOnGround = other.myTeleportMustBeOnGround;
    this.myCheckTransformMustBeOnGround = other.myCheckTransformMustBeOnGround;
    this.myTeleportMustBeOnCeiling = other.myTeleportMustBeOnCeiling;
    this.myCheckTransformMustBeOnCeiling = other.myCheckTransformMustBeOnCeiling;
    this.mySlidingEnabled = other.mySlidingEnabled;
    this.mySlidingHorizontalMovementCheckBetterNormal = other.mySlidingHorizontalMovementCheckBetterNormal;
    this.mySlidingMaxAttempts = other.mySlidingMaxAttempts;
    this.mySlidingCheckBothDirections = other.mySlidingCheckBothDirections;
    this.mySlidingFlickeringPreventionType = other.mySlidingFlickeringPreventionType;
    this.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding = other.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding;
    this.mySlidingFlickerPreventionCheckAnywayCounter = other.mySlidingFlickerPreventionCheckAnywayCounter;
    this.mySlidingAdjustSign90Degrees = other.mySlidingAdjustSign90Degrees;
    this.myHorizontalBlockLayerFlags.copy(other.myHorizontalBlockLayerFlags);
    this.myHorizontalObjectsToIgnore.pp_copy(other.myHorizontalObjectsToIgnore);
    this.myVerticalBlockLayerFlags.copy(other.myVerticalBlockLayerFlags);
    this.myVerticalObjectsToIgnore.pp_copy(other.myVerticalObjectsToIgnore);
    this.myExtraMovementCheckCallback = other.myExtraMovementCheckCallback;
    this.myExtraTeleportCheckCallback = other.myExtraTeleportCheckCallback;
    this.myExtraCheckTransformCheckCallback = other.myExtraCheckTransformCheckCallback;
    this.myDebugEnabled = other.myDebugEnabled;
    this.myDebugHorizontalMovementEnabled = other.myDebugHorizontalMovementEnabled;
    this.myDebugHorizontalPositionEnabled = other.myDebugHorizontalPositionEnabled;
    this.myDebugVerticalMovementEnabled = other.myDebugVerticalMovementEnabled;
    this.myDebugVerticalPositionEnabled = other.myDebugVerticalPositionEnabled;
    this.myDebugSlidingEnabled = other.myDebugSlidingEnabled;
    this.myDebugGroundInfoEnabled = other.myDebugGroundInfoEnabled;
    this.myDebugCeilingInfoEnabled = other.myDebugCeilingInfoEnabled;
    this.myDebugRuntimeParamsEnabled = other.myDebugRuntimeParamsEnabled;
    this.myDebugMovementEnabled = other.myDebugMovementEnabled;
  }
};
var CollisionRuntimeParams = class {
  constructor() {
    this.myOriginalPosition = vec3_create();
    this.myNewPosition = vec3_create();
    this.myOriginalHeight = 0;
    this.myOriginalForward = vec3_create();
    this.myOriginalUp = vec3_create();
    this.myOffsetUp = vec3_create();
    this.myOriginalMovement = vec3_create();
    this.myFixedMovement = vec3_create();
    this.myLastValidOriginalHorizontalMovement = vec3_create();
    this.myLastValidOriginalVerticalMovement = vec3_create();
    this.myLastValidSurfaceAdjustedHorizontalMovement = vec3_create();
    this.myLastValidSurfaceAdjustedVerticalMovement = vec3_create();
    this.myLastValidEndHorizontalMovement = vec3_create();
    this.myLastValidEndVerticalMovement = vec3_create();
    this.myIsOnGround = false;
    this.myGroundAngle = 0;
    this.myGroundPerceivedAngle = 0;
    this.myGroundNormal = vec3_create();
    this.myGroundHitMaxAngle = 0;
    this.myGroundHitMaxNormal = vec3_create();
    this.myGroundDistance = null;
    this.myGroundIsBaseInsideCollision = false;
    this.myIsOnCeiling = false;
    this.myCeilingAngle = 0;
    this.myCeilingPerceivedAngle = 0;
    this.myCeilingNormal = vec3_create();
    this.myCeilingHitMaxAngle = 0;
    this.myCeilingHitMaxNormal = vec3_create();
    this.myCeilingDistance = null;
    this.myCeilingIsBaseInsideCollision = false;
    this.myHorizontalMovementCanceled = false;
    this.myIsCollidingHorizontally = false;
    this.myHorizontalCollisionHit = new RaycastHit();
    this.myVerticalMovementCanceled = false;
    this.myIsCollidingVertically = false;
    this.myVerticalCollisionHit = new RaycastHit();
    this.myHasSnappedOnGround = false;
    this.myHasSnappedOnCeiling = false;
    this.myHasPoppedOutGround = false;
    this.myHasPoppedOutCeiling = false;
    this.myHasReducedVerticalMovement = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill = false;
    this.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill = false;
    this.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill = false;
    this.myIsSliding = false;
    this.myIsSlidingIntoOppositeDirection = false;
    this.myIsSlidingFlickerPrevented = false;
    this.mySlidingFlickerPreventionCheckAnywayCounter = 0;
    this.mySlidingMovementAngle = 0;
    this.mySlidingCollisionAngle = 0;
    this.mySlidingCollisionHit = new RaycastHit();
    this.mySlidingWallNormal = new vec3_create();
    this.mySliding90DegreesSign = 0;
    this.mySlidingRecompute90DegreesSign = true;
    this.myLastValidIsSliding = false;
    this.mySlidingPreviousHorizontalMovement = vec3_create();
    this.myOriginalTeleportPosition = vec3_create();
    this.myFixedTeleportPosition = vec3_create();
    this.myOriginalPositionCheckPosition = vec3_create();
    this.myFixedPositionCheckPosition = vec3_create();
    this.myTeleportCanceled = false;
    this.myIsPositionOk = false;
    this.myIsTeleport = false;
    this.myIsMove = false;
    this.myIsPositionCheck = false;
    this.myIsPositionCheckAllowAdjustments = false;
    this.mySplitMovementSteps = 0;
    this.mySplitMovementStepsPerformed = 0;
    this.mySplitMovementStop = false;
    this.mySplitMovementMovementChecked = vec3_create();
    this.myRealIsOnGround = false;
    this.myRealIsOnCeiling = false;
  }
  reset() {
    this.myOriginalPosition.vec3_zero();
    this.myNewPosition.vec3_zero();
    this.myOriginalHeight = 0;
    this.myOriginalForward.vec3_zero();
    this.myOriginalUp.vec3_zero();
    this.myOffsetUp.vec3_zero();
    this.myOriginalMovement.vec3_zero();
    this.myFixedMovement.vec3_zero();
    this.myLastValidOriginalHorizontalMovement.vec3_zero();
    this.myLastValidOriginalVerticalMovement.vec3_zero();
    this.myLastValidSurfaceAdjustedHorizontalMovement.vec3_zero();
    this.myLastValidSurfaceAdjustedVerticalMovement.vec3_zero();
    this.myLastValidEndHorizontalMovement.vec3_zero();
    this.myLastValidEndVerticalMovement.vec3_zero();
    this.myIsOnGround = false;
    this.myGroundAngle = 0;
    this.myGroundPerceivedAngle = 0;
    this.myGroundNormal.vec3_zero();
    this.myGroundHitMaxAngle = 0;
    this.myGroundHitMaxNormal.vec3_zero();
    this.myGroundDistance = null;
    this.myGroundIsBaseInsideCollision = false;
    this.myIsOnCeiling = false;
    this.myCeilingAngle = 0;
    this.myCeilingPerceivedAngle = 0;
    this.myCeilingNormal.vec3_zero();
    this.myCeilingHitMaxAngle = 0;
    this.myCeilingHitMaxNormal.vec3_zero();
    this.myCeilingDistance = null;
    this.myCeilingIsBaseInsideCollision = false;
    this.myHorizontalMovementCanceled = false;
    this.myIsCollidingHorizontally = false;
    this.myHorizontalCollisionHit.reset();
    this.myVerticalMovementCanceled = false;
    this.myIsCollidingVertically = false;
    this.myVerticalCollisionHit.reset();
    this.myHasSnappedOnGround = false;
    this.myHasSnappedOnCeiling = false;
    this.myHasPoppedOutGround = false;
    this.myHasPoppedOutCeiling = false;
    this.myHasReducedVerticalMovement = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill = false;
    this.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill = false;
    this.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill = false;
    this.myIsSliding = false;
    this.myIsSlidingIntoOppositeDirection = false;
    this.myIsSlidingFlickerPrevented = false;
    this.mySlidingFlickerPreventionCheckAnywayCounter = 0;
    this.mySlidingMovementAngle = 0;
    this.mySlidingCollisionAngle = 0;
    this.mySlidingCollisionHit.reset();
    this.mySliding90DegreesSign = 0;
    this.mySlidingRecompute90DegreesSign = true;
    this.myLastValidIsSliding = false;
    this.mySlidingPreviousHorizontalMovement.vec3_zero();
    this.mySlidingWallNormal.vec3_zero();
    this.myOriginalTeleportPosition.vec3_zero();
    this.myFixedTeleportPosition.vec3_zero();
    this.myOriginalPositionCheckPosition.vec3_zero();
    this.myFixedPositionCheckPosition.vec3_zero();
    this.myTeleportCanceled = false;
    this.myIsPositionOk = false;
    this.myIsTeleport = false;
    this.myIsMove = false;
    this.myIsPositionCheck = false;
    this.myIsPositionCheckAllowAdjustments = false;
    this.mySplitMovementSteps = 0;
    this.mySplitMovementStepsPerformed = 0;
    this.mySplitMovementStop = false;
    this.mySplitMovementMovementChecked.vec3_zero();
    this.myRealIsOnGround = false;
    this.myRealIsOnCeiling = false;
  }
  copy(other) {
    this.myOriginalPosition.vec3_copy(other.myOriginalPosition);
    this.myNewPosition.vec3_copy(other.myNewPosition);
    this.myOriginalHeight = other.myOriginalHeight;
    this.myOriginalForward.vec3_copy(other.myOriginalForward);
    this.myOriginalUp.vec3_copy(other.myOriginalUp);
    this.myOffsetUp.vec3_copy(other.myOffsetUp);
    this.myOriginalMovement.vec3_copy(other.myOriginalMovement);
    this.myFixedMovement.vec3_copy(other.myFixedMovement);
    this.myLastValidOriginalHorizontalMovement.vec3_copy(other.myLastValidOriginalHorizontalMovement);
    this.myLastValidOriginalVerticalMovement.vec3_copy(other.myLastValidOriginalVerticalMovement);
    this.myLastValidSurfaceAdjustedHorizontalMovement.vec3_copy(other.myLastValidSurfaceAdjustedHorizontalMovement);
    this.myLastValidSurfaceAdjustedVerticalMovement.vec3_copy(other.myLastValidSurfaceAdjustedVerticalMovement);
    this.myLastValidEndHorizontalMovement.vec3_copy(other.myLastValidEndHorizontalMovement);
    this.myLastValidEndVerticalMovement.vec3_copy(other.myLastValidEndVerticalMovement);
    this.myIsOnGround = other.myIsOnGround;
    this.myGroundAngle = other.myGroundAngle;
    this.myGroundPerceivedAngle = other.myGroundPerceivedAngle;
    this.myGroundNormal.vec3_copy(other.myGroundNormal);
    this.myGroundHitMaxAngle = other.myGroundHitMaxAngle;
    this.myGroundHitMaxNormal.vec3_copy(other.myGroundHitMaxNormal);
    this.myGroundDistance = other.myGroundDistance;
    this.myGroundIsBaseInsideCollision = other.myGroundIsBaseInsideCollision;
    this.myIsOnCeiling = other.myIsOnCeiling;
    this.myCeilingAngle = other.myCeilingAngle;
    this.myCeilingPerceivedAngle = other.myCeilingPerceivedAngle;
    this.myCeilingNormal.vec3_copy(other.myCeilingNormal);
    this.myCeilingHitMaxAngle = other.myCeilingHitMaxAngle;
    this.myCeilingHitMaxNormal.vec3_copy(other.myCeilingHitMaxNormal);
    this.myCeilingDistance = other.myCeilingDistance;
    this.myCeilingIsBaseInsideCollision = other.myCeilingIsBaseInsideCollision;
    this.myHorizontalMovementCanceled = other.myHorizontalMovementCanceled;
    this.myIsCollidingHorizontally = other.myIsCollidingHorizontally;
    this.myHorizontalCollisionHit.copy(other.myHorizontalCollisionHit);
    this.myVerticalMovementCanceled = other.myVerticalMovementCanceled;
    this.myIsCollidingVertically = other.myIsCollidingVertically;
    this.myVerticalCollisionHit.copy(other.myVerticalCollisionHit);
    this.myHasSnappedOnGround = other.myHasSnappedOnGround;
    this.myHasSnappedOnCeiling = other.myHasSnappedOnCeiling;
    this.myHasPoppedOutGround = other.myHasPoppedOutGround;
    this.myHasPoppedOutCeiling = other.myHasPoppedOutCeiling;
    this.myHasReducedVerticalMovement = other.myHasReducedVerticalMovement;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill = other.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill = other.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill;
    this.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill = other.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill = other.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill = other.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill;
    this.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill = other.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill;
    this.myIsSliding = other.myIsSliding;
    this.myIsSlidingIntoOppositeDirection = other.myIsSlidingIntoOppositeDirection;
    this.myIsSlidingFlickerPrevented = other.myIsSlidingFlickerPrevented;
    this.mySlidingFlickerPreventionCheckAnywayCounter = other.mySlidingFlickerPreventionCheckAnywayCounter;
    this.mySlidingMovementAngle = other.mySlidingMovementAngle;
    this.mySlidingCollisionAngle = other.mySlidingCollisionAngle;
    this.mySlidingCollisionHit.copy(other.mySlidingCollisionHit);
    this.mySliding90DegreesSign = other.mySliding90DegreesSign;
    this.mySlidingRecompute90DegreesSign = other.mySlidingRecompute90DegreesSign;
    this.myLastValidIsSliding = other.myLastValidIsSliding;
    this.mySlidingPreviousHorizontalMovement.vec3_copy(other.mySlidingPreviousHorizontalMovement);
    this.mySlidingWallNormal.vec3_copy(other.mySlidingWallNormal);
    this.myOriginalTeleportPosition.vec3_copy(other.myOriginalTeleportPosition);
    this.myFixedTeleportPosition.vec3_copy(other.myFixedTeleportPosition);
    this.myTeleportCanceled = other.myTeleportCanceled;
    this.myIsPositionOk = other.myIsPositionOk;
    this.myOriginalPositionCheckPosition.vec3_copy(other.myOriginalPositionCheckPosition);
    this.myFixedPositionCheckPosition.vec3_copy(other.myFixedPositionCheckPosition);
    this.myIsTeleport = other.myIsTeleport;
    this.myIsMove = other.myIsMove;
    this.myIsPositionCheck = other.myIsPositionCheck;
    this.myIsPositionCheckAllowAdjustments = other.myIsPositionCheckAllowAdjustments;
    this.mySplitMovementSteps = other.mySplitMovementSteps;
    this.mySplitMovementStepsPerformed = other.mySplitMovementStepsPerformed;
    this.mySplitMovementStop = other.mySplitMovementStop;
    this.mySplitMovementMovementChecked.vec3_copy(other.mySplitMovementMovementChecked);
    this.myRealIsOnGround = other.myRealIsOnGround;
    this.myRealIsOnCeiling = other.myRealIsOnCeiling;
  }
};

// js/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check.js
function generate360TeleportParamsFromMovementParams(movementParams, outTeleportParams = new CollisionCheckParams()) {
  outTeleportParams.copy(movementParams);
  outTeleportParams.myHalfConeAngle = 180;
  outTeleportParams.myHalfConeSliceAmount = Math.round(outTeleportParams.myHalfConeAngle / movementParams.myHalfConeAngle * movementParams.myHalfConeSliceAmount);
  outTeleportParams.myCheckHorizontalFixedForwardEnabled = true;
  outTeleportParams.myCheckHorizontalFixedForward = vec3_create(0, 0, 1);
  return outTeleportParams;
}
var CollisionCheckUtils = {
  generate360TeleportParamsFromMovementParams
};
var CollisionCheck = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this._myEngine = engine2;
    this._myRaycastParams = new RaycastParams(Globals.getPhysics(this._myEngine));
    this._myRaycastResult = new RaycastResults();
    this._myFixRaycastResult = new RaycastResults();
    this._myBackupRaycastHit = new RaycastHit();
    this._myPrevCollisionRuntimeParams = new CollisionRuntimeParams();
    this._mySlidingCollisionRuntimeParams = new CollisionRuntimeParams();
    this._myCheckBetterSlidingNormalCollisionRuntimeParams = new CollisionRuntimeParams();
    this._myInternalSlidingCollisionRuntimeParams = new CollisionRuntimeParams();
    this._mySlidingFlickeringFixCollisionRuntimeParams = new CollisionRuntimeParams();
    this._mySlidingFlickeringFixSlidingCollisionRuntimeParams = new CollisionRuntimeParams();
    this._mySlidingOppositeDirectionCollisionRuntimeParams = new CollisionRuntimeParams();
    this._mySlidingOnVerticalCheckCollisionRuntimeParams = new CollisionRuntimeParams();
    this._myDebugEnabled = false;
    this._myTotalRaycasts = 0;
    this._myTotalRaycastsMax = 0;
  }
  move(movement, transformQuat4, collisionCheckParams, collisionRuntimeParams) {
    this._move(movement, transformQuat4, collisionCheckParams, collisionRuntimeParams);
  }
  // #TODO Add teleport position/transform and return originalteleportransform
  // instead of position old transform / new transform
  teleport(position, transformQuat4, collisionCheckParams, collisionRuntimeParams) {
    this._teleport(position, transformQuat4, collisionCheckParams, collisionRuntimeParams);
  }
  positionCheck(allowFix, transformQuat4, collisionCheckParams, collisionRuntimeParams) {
    this._positionCheck(allowFix, transformQuat4, collisionCheckParams, collisionRuntimeParams);
  }
  updateSurfaceInfo(transformQuat4, collisionCheckParams, collisionRuntimeParams) {
    this._updateSurfaceInfo(transformQuat4, collisionCheckParams, collisionRuntimeParams);
  }
  _debugMovement(movement, fixedMovement, feetPosition, up, collisionCheckParams) {
    let originalHorizontalMovement = movement.vec3_removeComponentAlongAxis(up);
    let horizontalMovement = fixedMovement.vec3_removeComponentAlongAxis(up);
    let verticalMovement = fixedMovement.vec3_componentAlongAxis(up);
    let feetPositionPlusOffset = feetPosition.vec3_add(up.vec3_scale(collisionCheckParams.myDistanceFromFeetToIgnore + 1e-3));
    if (!originalHorizontalMovement.vec3_isZero()) {
      originalHorizontalMovement.vec3_normalize(originalHorizontalMovement);
      Globals.getDebugVisualManager(this._myEngine).drawArrow(0, feetPositionPlusOffset, originalHorizontalMovement, 0.2, vec4_create(0.5, 0.5, 1, 1));
    }
    if (!horizontalMovement.vec3_isZero()) {
      horizontalMovement.vec3_normalize(horizontalMovement);
      Globals.getDebugVisualManager(this._myEngine).drawArrow(0, feetPositionPlusOffset, horizontalMovement, 0.2, vec4_create(0, 0, 1, 1));
    }
    if (!verticalMovement.vec3_isZero()) {
      verticalMovement.vec3_normalize(verticalMovement);
      Globals.getDebugVisualManager(this._myEngine).drawArrow(0, feetPosition, verticalMovement, 0.2, vec4_create(0, 0, 1, 1));
    }
  }
  _debugRuntimeParams(collisionRuntimeParams) {
    if (collisionRuntimeParams.myHorizontalCollisionHit.isValid()) {
      Globals.getDebugVisualManager(this._myEngine).drawArrow(
        0,
        collisionRuntimeParams.myHorizontalCollisionHit.myPosition,
        collisionRuntimeParams.myHorizontalCollisionHit.myNormal,
        0.2,
        vec4_create(1, 0, 0, 1)
      );
    }
    if (collisionRuntimeParams.mySlidingCollisionHit.isValid()) {
      Globals.getDebugVisualManager(this._myEngine).drawArrow(
        0,
        collisionRuntimeParams.mySlidingCollisionHit.myPosition,
        collisionRuntimeParams.mySlidingCollisionHit.myNormal,
        0.2,
        vec4_create(1, 0, 0, 1)
      );
    }
    if (collisionRuntimeParams.myVerticalCollisionHit.isValid()) {
      Globals.getDebugVisualManager(this._myEngine).drawArrow(
        0,
        collisionRuntimeParams.myVerticalCollisionHit.myPosition,
        collisionRuntimeParams.myVerticalCollisionHit.myNormal,
        0.2,
        vec4_create(1, 0, 0, 1)
      );
    }
  }
  _raycastAndDebug(origin, direction2, distance5, ignoreHitsInsideCollision, isHorizontal, collisionCheckParams, collisionRuntimeParams) {
  }
};
CollisionCheck.prototype._raycastAndDebug = function() {
  let tempRaycastResult = new RaycastResults();
  return function _raycastAndDebug(origin, direction2, distance5, ignoreHitsInsideCollision, isHorizontal, collisionCheckParams, collisionRuntimeParams) {
    this._myRaycastParams.myOrigin.vec3_copy(origin);
    this._myRaycastParams.myDirection.vec3_copy(direction2);
    this._myRaycastParams.myDistance = distance5;
    if (isHorizontal) {
      this._myRaycastParams.myBlockLayerFlags.copy(collisionCheckParams.myHorizontalBlockLayerFlags);
      this._myRaycastParams.myObjectsToIgnore = collisionCheckParams.myHorizontalObjectsToIgnore;
    } else {
      this._myRaycastParams.myBlockLayerFlags.copy(collisionCheckParams.myVerticalBlockLayerFlags);
      this._myRaycastParams.myObjectsToIgnore = collisionCheckParams.myVerticalObjectsToIgnore;
    }
    this._myRaycastParams.myIgnoreHitsInsideCollision = ignoreHitsInsideCollision;
    let raycastResult = null;
    let raycastPerformanceDebugEnabled = false;
    if (raycastPerformanceDebugEnabled && Globals.isDebugEnabled(this._myEngine)) {
      let raycastAlways = false;
      if (raycastAlways || !this._myRaycastResult.isColliding()) {
        raycastResult = PhysicsUtils.raycast(this._myRaycastParams, tempRaycastResult);
      }
      if (!this._myRaycastResult.isColliding() && tempRaycastResult.isColliding()) {
        this._myRaycastResult.copy(tempRaycastResult);
      }
      raycastResult = this._myRaycastResult;
    } else {
      raycastResult = PhysicsUtils.raycast(this._myRaycastParams, this._myRaycastResult);
    }
    this._myTotalRaycasts++;
    if (this._myDebugEnabled && Globals.isDebugEnabled(this._myEngine)) {
      Globals.getDebugVisualManager(this._myEngine).drawRaycast(0, raycastResult);
    }
    return raycastResult;
  };
}();

// js/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_movement_check.js
CollisionCheck.prototype._move = function() {
  let transformUp = vec3_create();
  let transformForward = vec3_create();
  let feetPosition = vec3_create();
  let transformOffsetLocalQuat = quat2_create();
  let offsetTransformQuat = quat2_create();
  let horizontalMovement = vec3_create();
  let verticalMovement = vec3_create();
  let movementStep = vec3_create();
  let currentMovementStep = vec3_create();
  let movementChecked = vec3_create();
  let fixedMovement = vec3_create();
  let newFeetPosition = vec3_create();
  let fixedMovementStep = vec3_create();
  let previousCollisionRuntimeParams = new CollisionRuntimeParams();
  let previousFixedMovement = vec3_create();
  let previousMovementChecked = vec3_create();
  return function _move(movement, transformQuat4, collisionCheckParams, collisionRuntimeParams) {
    transformOffsetLocalQuat.quat2_setPositionRotationQuat(collisionCheckParams.myPositionOffsetLocal, collisionCheckParams.myRotationOffsetLocalQuat);
    offsetTransformQuat = transformOffsetLocalQuat.quat2_toWorld(transformQuat4, offsetTransformQuat);
    if (transformQuat4.vec_equals(offsetTransformQuat, 1e-5)) {
      offsetTransformQuat.quat2_copy(transformQuat4);
    }
    transformUp = offsetTransformQuat.quat2_getUp(transformUp);
    transformForward = offsetTransformQuat.quat2_getForward(transformForward);
    feetPosition = offsetTransformQuat.quat2_getPosition(feetPosition);
    let height = collisionCheckParams.myHeight;
    height = height - 1e-5;
    if (height < 1e-5) {
      height = 0;
    }
    horizontalMovement = movement.vec3_removeComponentAlongAxis(transformUp, horizontalMovement);
    verticalMovement = movement.vec3_componentAlongAxis(transformUp, verticalMovement);
    let movementStepAmount = 1;
    movementStep.vec3_copy(movement);
    if (!movement.vec3_isZero(1e-5) && collisionCheckParams.mySplitMovementEnabled) {
      let equalStepLength = movement.vec3_length() / collisionCheckParams.mySplitMovementMaxSteps;
      if (!collisionCheckParams.mySplitMovementStepEqualLength || equalStepLength < collisionCheckParams.mySplitMovementStepEqualLengthMinLength) {
        let maxLength = collisionCheckParams.mySplitMovementStepEqualLength ? collisionCheckParams.mySplitMovementStepEqualLengthMinLength : collisionCheckParams.mySplitMovementMaxLength;
        movementStepAmount = Math.ceil(movement.vec3_length() / maxLength);
        if (movementStepAmount > 1) {
          movementStep = movementStep.vec3_normalize(movementStep).vec3_scale(maxLength, movementStep);
          movementStepAmount = collisionCheckParams.mySplitMovementMaxStepsEnabled ? Math.min(movementStepAmount, collisionCheckParams.mySplitMovementMaxSteps) : movementStepAmount;
        }
        movementStepAmount = Math.max(1, movementStepAmount);
        if (movementStepAmount == 1) {
          movementStep.vec3_copy(movement);
        }
      } else {
        movementStepAmount = collisionCheckParams.mySplitMovementMaxSteps;
        if (movementStepAmount > 1) {
          movementStep = movementStep.vec3_normalize(movementStep).vec3_scale(equalStepLength, movementStep);
        }
      }
    }
    fixedMovement.vec3_zero();
    movementChecked.vec3_zero();
    previousCollisionRuntimeParams.copy(collisionRuntimeParams);
    previousFixedMovement.vec3_copy(fixedMovement);
    previousMovementChecked.vec3_copy(movementChecked);
    let stepsPerformed = 0;
    let splitMovementStop = false;
    for (let i = 0; i < movementStepAmount; i++) {
      if (movementStepAmount == 1 || i != movementStepAmount - 1) {
        currentMovementStep.vec3_copy(movementStep);
      } else {
        currentMovementStep = movement.vec3_sub(movementChecked, currentMovementStep);
      }
      newFeetPosition = feetPosition.vec3_add(fixedMovement, newFeetPosition);
      fixedMovementStep.vec3_zero();
      fixedMovementStep = this._moveStep(currentMovementStep, newFeetPosition, transformUp, transformForward, height, true, collisionCheckParams, collisionRuntimeParams, fixedMovementStep);
      fixedMovement.vec3_add(fixedMovementStep, fixedMovement);
      movementChecked = movementChecked.vec3_add(movementStep, movementChecked);
      stepsPerformed = i + 1;
      if (collisionRuntimeParams.myHorizontalMovementCanceled && collisionRuntimeParams.myVerticalMovementCanceled || collisionRuntimeParams.myHorizontalMovementCanceled && collisionCheckParams.mySplitMovementStopWhenHorizontalMovementCanceled || collisionRuntimeParams.myVerticalMovementCanceled && collisionCheckParams.mySplitMovementStopWhenVerticalMovementCanceled || collisionCheckParams.mySplitMovementStopCallback != null && collisionCheckParams.mySplitMovementStopCallback(collisionRuntimeParams)) {
        if (collisionCheckParams.mySplitMovementStopReturnPrevious) {
          collisionRuntimeParams.copy(previousCollisionRuntimeParams);
          fixedMovement.vec3_copy(previousFixedMovement);
          movementChecked.vec3_copy(previousMovementChecked);
          stepsPerformed -= 1;
        }
        splitMovementStop = true;
        break;
      }
      previousCollisionRuntimeParams.copy(collisionRuntimeParams);
      previousFixedMovement.vec3_copy(fixedMovement);
      previousMovementChecked.vec3_copy(movementChecked);
    }
    collisionRuntimeParams.mySplitMovementSteps = movementStepAmount;
    collisionRuntimeParams.mySplitMovementStepsPerformed = stepsPerformed;
    collisionRuntimeParams.mySplitMovementStop = splitMovementStop;
    collisionRuntimeParams.mySplitMovementMovementChecked.vec3_copy(movementChecked);
    collisionRuntimeParams.myOriginalUp = transformQuat4.quat2_getUp(collisionRuntimeParams.myOriginalUp);
    collisionRuntimeParams.myOriginalForward = transformQuat4.quat2_getForward(collisionRuntimeParams.myOriginalForward);
    collisionRuntimeParams.myOriginalPosition = transformQuat4.quat2_getPosition(collisionRuntimeParams.myOriginalPosition);
    collisionRuntimeParams.myOffsetUp.vec3_copy(transformUp);
    collisionRuntimeParams.myOriginalHeight = collisionCheckParams.myHeight;
    collisionRuntimeParams.myOriginalMovement.vec3_copy(movement);
    collisionRuntimeParams.myFixedMovement.vec3_copy(fixedMovement);
    collisionRuntimeParams.myNewPosition = collisionRuntimeParams.myOriginalPosition.vec3_add(collisionRuntimeParams.myFixedMovement, collisionRuntimeParams.myNewPosition);
    collisionRuntimeParams.myIsMove = true;
  };
}();
CollisionCheck.prototype._moveStep = function() {
  let horizontalMovement = vec3_create();
  let verticalMovement = vec3_create();
  let fixedHorizontalMovement = vec3_create();
  let fixedVerticalMovement = vec3_create();
  let horizontalDirection = vec3_create();
  let forwardForHorizontal = vec3_create();
  let forwardForVertical = vec3_create();
  let forwardForPerceivedAngle = vec3_create();
  let newFeetPosition = vec3_create();
  let surfaceAdjustedVerticalMovement = vec3_create();
  let surfaceAdjustedHorizontalMovement = vec3_create();
  let fixedMovement = vec3_create();
  let zAxis = vec3_create(0, 0, 1);
  let xAxis = vec3_create(1, 0, 0);
  return function _moveStep(movement, feetPosition, transformUp, transformForward, height, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, outFixedMovement) {
    horizontalMovement = movement.vec3_removeComponentAlongAxis(transformUp, horizontalMovement);
    if (horizontalMovement.vec3_isZero(1e-6)) {
      horizontalMovement.vec3_zero();
    }
    verticalMovement = movement.vec3_componentAlongAxis(transformUp, verticalMovement);
    if (verticalMovement.vec3_isZero(1e-6)) {
      verticalMovement.vec3_zero();
    }
    if (horizontalMovement.vec3_isZero()) {
    }
    this._myPrevCollisionRuntimeParams.copy(collisionRuntimeParams);
    collisionRuntimeParams.reset();
    surfaceAdjustedHorizontalMovement = this._adjustHorizontalMovementWithSurface(horizontalMovement, verticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, surfaceAdjustedHorizontalMovement);
    if (surfaceAdjustedHorizontalMovement.vec3_isZero(1e-5)) {
      surfaceAdjustedHorizontalMovement.vec3_zero();
    }
    this._syncCollisionRuntimeParamsWithPrevious(surfaceAdjustedHorizontalMovement, verticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams);
    {
      forwardForHorizontal.vec3_copy(collisionCheckParams.myCheckHorizontalFixedForward);
      if (!collisionCheckParams.myCheckHorizontalFixedForwardEnabled) {
        if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
          forwardForHorizontal = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForHorizontal);
        } else if (!horizontalMovement.vec3_isZero()) {
          forwardForHorizontal = horizontalMovement.vec3_normalize(forwardForHorizontal);
        } else {
          forwardForHorizontal.vec3_copy(transformForward);
        }
      } else {
        if (collisionCheckParams.myCheckHorizontalFixedForward.vec3_isOnAxis(transformUp)) {
          if (zAxis.vec3_isOnAxis(transformUp)) {
            forwardForHorizontal.vec3_copy(xAxis);
          } else {
            forwardForHorizontal.vec3_copy(zAxis);
          }
        }
        forwardForHorizontal = forwardForHorizontal.vec3_removeComponentAlongAxis(transformUp, forwardForHorizontal);
        forwardForHorizontal = forwardForHorizontal.vec3_normalize(forwardForHorizontal);
        if (forwardForHorizontal.vec_equals(collisionCheckParams.myCheckHorizontalFixedForward, 1e-5)) {
          forwardForHorizontal.vec3_copy(collisionCheckParams.myCheckHorizontalFixedForward);
        }
      }
      fixedHorizontalMovement.vec3_zero();
      if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
        fixedHorizontalMovement = this._horizontalCheck(surfaceAdjustedHorizontalMovement, feetPosition, height, transformUp, forwardForHorizontal, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, false, fixedHorizontalMovement);
        if (collisionCheckParams.mySlidingEnabled && collisionRuntimeParams.myIsCollidingHorizontally && this._isSlidingNormalValid(surfaceAdjustedHorizontalMovement, transformUp, collisionRuntimeParams)) {
          fixedHorizontalMovement = this._horizontalSlide(surfaceAdjustedHorizontalMovement, feetPosition, height, transformUp, forwardForHorizontal, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, fixedHorizontalMovement);
        } else {
        }
      }
      if (fixedHorizontalMovement.vec3_isZero(1e-6)) {
        fixedHorizontalMovement.vec3_zero();
      }
      if (!surfaceAdjustedHorizontalMovement.vec3_isZero() && fixedHorizontalMovement.vec3_isZero()) {
        collisionRuntimeParams.myHorizontalMovementCanceled = true;
      }
    }
    {
      forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
      if (!collisionCheckParams.myCheckVerticalFixedForwardEnabled) {
        if (fixedHorizontalMovement.vec3_isZero()) {
          if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
            forwardForVertical = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForVertical);
          } else if (!horizontalMovement.vec3_isZero()) {
            forwardForVertical = horizontalMovement.vec3_normalize(forwardForVertical);
          } else {
            forwardForVertical.vec3_copy(transformForward);
          }
        } else {
          forwardForVertical = fixedHorizontalMovement.vec3_normalize(forwardForVertical);
        }
      } else {
        if (collisionCheckParams.myCheckVerticalFixedForward.vec3_isOnAxis(transformUp)) {
          if (zAxis.vec3_isOnAxis(transformUp)) {
            forwardForVertical.vec3_copy(xAxis);
          } else {
            forwardForVertical.vec3_copy(zAxis);
          }
        }
        forwardForVertical = forwardForVertical.vec3_removeComponentAlongAxis(transformUp, forwardForVertical);
        forwardForVertical = forwardForVertical.vec3_normalize(forwardForVertical);
        if (forwardForVertical.vec_equals(collisionCheckParams.myCheckVerticalFixedForward, 1e-5)) {
          forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
        }
      }
      surfaceAdjustedVerticalMovement = this._adjustVerticalMovementWithSurface(fixedHorizontalMovement, verticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, surfaceAdjustedVerticalMovement);
      newFeetPosition = feetPosition.vec3_add(fixedHorizontalMovement, newFeetPosition);
      let originalMovementSign = Math.pp_sign(verticalMovement.vec3_lengthSigned(transformUp), 0);
      fixedVerticalMovement.vec3_zero();
      fixedVerticalMovement = this._verticalCheck(surfaceAdjustedVerticalMovement, originalMovementSign, newFeetPosition, height, transformUp, forwardForVertical, collisionCheckParams, collisionRuntimeParams, fixedVerticalMovement);
      if (fixedVerticalMovement.vec3_isZero(1e-6)) {
        fixedVerticalMovement.vec3_zero();
      }
    }
    outFixedMovement.vec3_zero();
    if (!collisionRuntimeParams.myIsCollidingVertically) {
      outFixedMovement = fixedHorizontalMovement.vec3_add(fixedVerticalMovement, outFixedMovement);
    } else {
      collisionRuntimeParams.myHorizontalMovementCanceled = true;
      collisionRuntimeParams.myVerticalMovementCanceled = true;
      fixedHorizontalMovement.vec3_zero();
      fixedVerticalMovement.vec3_zero();
      if (!collisionCheckParams.myCheckVerticalFixedForwardEnabled) {
        if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
          forwardForVertical = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForVertical);
        } else if (!horizontalMovement.vec3_isZero()) {
          forwardForVertical = horizontalMovement.vec3_normalize(forwardForVertical);
        } else {
          forwardForVertical.vec3_copy(transformForward);
        }
      }
    }
    newFeetPosition = feetPosition.vec3_add(outFixedMovement, newFeetPosition);
    forwardForPerceivedAngle.vec3_copy(transformForward);
    if (!fixedHorizontalMovement.vec3_isZero()) {
      forwardForPerceivedAngle = fixedHorizontalMovement.vec3_normalize(forwardForPerceivedAngle);
    } else if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
      forwardForPerceivedAngle = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForPerceivedAngle);
    } else if (!horizontalMovement.vec3_isZero()) {
      forwardForPerceivedAngle = horizontalMovement.vec3_normalize(forwardForPerceivedAngle);
    }
    if (collisionCheckParams.myComputeGroundInfoEnabled) {
      this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
    }
    if (collisionCheckParams.myComputeCeilingInfoEnabled) {
      this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
    }
    if (!surfaceAdjustedHorizontalMovement.vec3_isZero() && !collisionRuntimeParams.myHorizontalMovementCanceled) {
      let surfaceCheckOk = this._postSurfaceCheck(fixedHorizontalMovement, fixedVerticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams);
      if (!surfaceCheckOk) {
        collisionRuntimeParams.myHorizontalMovementCanceled = true;
        collisionRuntimeParams.myVerticalMovementCanceled = true;
        fixedHorizontalMovement.vec3_zero();
        fixedVerticalMovement.vec3_zero();
        outFixedMovement.vec3_zero();
        newFeetPosition = feetPosition.vec3_add(outFixedMovement, newFeetPosition);
        if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
          forwardForPerceivedAngle = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForPerceivedAngle);
        } else if (!horizontalMovement.vec3_isZero()) {
          forwardForPerceivedAngle = horizontalMovement.vec3_normalize(forwardForPerceivedAngle);
        } else {
          forwardForPerceivedAngle.vec3_copy(transformForward);
        }
        if (collisionCheckParams.myComputeGroundInfoEnabled && collisionCheckParams.myRegatherGroundInfoOnSurfaceCheckFail) {
          this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
        } else {
          collisionRuntimeParams.myIsOnGround = this._myPrevCollisionRuntimeParams.myIsOnGround;
          collisionRuntimeParams.myGroundAngle = this._myPrevCollisionRuntimeParams.myGroundAngle;
          collisionRuntimeParams.myGroundPerceivedAngle = this._myPrevCollisionRuntimeParams.myGroundPerceivedAngle;
          collisionRuntimeParams.myGroundNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myGroundNormal);
        }
        if (collisionCheckParams.myComputeCeilingInfoEnabled && collisionCheckParams.myRegatherCeilingInfoOnSurfaceCheckFail) {
          this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
        } else {
          collisionRuntimeParams.myIsOnCeiling = this._myPrevCollisionRuntimeParams.myIsOnCeiling;
          collisionRuntimeParams.myCeilingAngle = this._myPrevCollisionRuntimeParams.myCeilingAngle;
          collisionRuntimeParams.myCeilingPerceivedAngle = this._myPrevCollisionRuntimeParams.myCeilingPerceivedAngle;
          collisionRuntimeParams.myCeilingNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myCeilingNormal);
        }
      }
    }
    if (collisionCheckParams.myExtraMovementCheckCallback != null) {
      fixedMovement.vec3_copy(outFixedMovement);
      outFixedMovement = collisionCheckParams.myExtraMovementCheckCallback(
        movement,
        fixedMovement,
        feetPosition,
        transformUp,
        transformForward,
        height,
        collisionCheckParams,
        this._myPrevCollisionRuntimeParams,
        collisionRuntimeParams,
        outFixedMovement
      );
      fixedHorizontalMovement = outFixedMovement.vec3_removeComponentAlongAxis(transformUp, fixedHorizontalMovement);
      fixedVerticalMovement = outFixedMovement.vec3_componentAlongAxis(transformUp, fixedVerticalMovement);
    }
    {
      if (collisionCheckParams.mySlidingAdjustSign90Degrees) {
        if (!collisionRuntimeParams.myHorizontalMovementCanceled && !collisionRuntimeParams.myIsSliding && !fixedHorizontalMovement.vec3_isZero()) {
          collisionRuntimeParams.mySlidingRecompute90DegreesSign = true;
        }
      }
      if (!horizontalMovement.vec3_isZero()) {
        collisionRuntimeParams.myLastValidOriginalHorizontalMovement.vec3_copy(horizontalMovement);
      }
      if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
        collisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement.vec3_copy(surfaceAdjustedHorizontalMovement);
      }
      if (!verticalMovement.vec3_isZero()) {
        collisionRuntimeParams.myLastValidOriginalVerticalMovement.vec3_copy(verticalMovement);
      }
      if (!surfaceAdjustedVerticalMovement.vec3_isZero()) {
        collisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement.vec3_copy(surfaceAdjustedVerticalMovement);
      }
      if (!fixedHorizontalMovement.vec3_isZero(1e-6)) {
        collisionRuntimeParams.myLastValidIsSliding = collisionRuntimeParams.myIsSliding;
        collisionRuntimeParams.myIsSlidingFlickerPrevented = false;
        collisionRuntimeParams.myLastValidEndHorizontalMovement.vec3_copy(fixedHorizontalMovement);
        if (!collisionRuntimeParams.myIsSliding) {
        } else {
        }
      } else {
      }
      if (!fixedVerticalMovement.vec3_isZero(1e-6)) {
        collisionRuntimeParams.myLastValidEndVerticalMovement.vec3_copy(fixedVerticalMovement);
      }
    }
    let moveStepFixed = false;
    if (!collisionRuntimeParams.myHorizontalMovementCanceled && !fixedHorizontalMovement.vec3_isZero(1e-6)) {
      horizontalDirection = fixedHorizontalMovement.vec3_normalize(horizontalDirection);
      let surfaceTooSteepResults = this._surfaceTooSteep(transformUp, horizontalDirection, collisionCheckParams, this._myPrevCollisionRuntimeParams);
      if (surfaceTooSteepResults[0] || surfaceTooSteepResults[1]) {
        horizontalDirection = fixedHorizontalMovement.vec3_normalize(horizontalDirection);
        let newSurfaceTooSteepResults = this._surfaceTooSteep(transformUp, horizontalDirection, collisionCheckParams, collisionRuntimeParams);
        if (surfaceTooSteepResults[0] && newSurfaceTooSteepResults[0] || surfaceTooSteepResults[1] && newSurfaceTooSteepResults[1] || !allowSurfaceSteepFix || surfaceTooSteepResults[0] && !collisionCheckParams.myAllowGroundSteepFix || surfaceTooSteepResults[1] && !collisionCheckParams.myAllowCeilingSteepFix) {
          outFixedMovement.vec3_zero();
          collisionRuntimeParams.copy(this._myPrevCollisionRuntimeParams);
          this._moveStep(movement, feetPosition, transformUp, transformForward, height, false, collisionCheckParams, collisionRuntimeParams, outFixedMovement);
          moveStepFixed = true;
        }
      }
    }
    if (!moveStepFixed) {
      if (collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugMovementEnabled && Globals.isDebugEnabled(this._myEngine)) {
        this._debugMovement(movement, outFixedMovement, newFeetPosition, transformUp, collisionCheckParams);
      }
      if (collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugRuntimeParamsEnabled && Globals.isDebugEnabled(this._myEngine)) {
        this._debugRuntimeParams(collisionRuntimeParams);
      }
    }
    return outFixedMovement;
  };
}();
CollisionCheck.prototype._syncCollisionRuntimeParamsWithPrevious = function() {
  let previousFixedHorizontalMovement = vec3_create();
  return function _syncCollisionRuntimeParamsWithPrevious(surfaceAdjustedHorizontalMovement, verticalMovement, up, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams) {
    collisionRuntimeParams.myIsSlidingFlickerPrevented = previousCollisionRuntimeParams.myIsSlidingFlickerPrevented;
    collisionRuntimeParams.myLastValidOriginalHorizontalMovement.vec3_copy(previousCollisionRuntimeParams.myLastValidOriginalHorizontalMovement);
    collisionRuntimeParams.myLastValidOriginalVerticalMovement.vec3_copy(previousCollisionRuntimeParams.myLastValidOriginalVerticalMovement);
    collisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement.vec3_copy(previousCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement);
    collisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement.vec3_copy(previousCollisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement);
    collisionRuntimeParams.myLastValidIsSliding = previousCollisionRuntimeParams.myLastValidIsSliding;
    collisionRuntimeParams.mySliding90DegreesSign = previousCollisionRuntimeParams.mySliding90DegreesSign;
    collisionRuntimeParams.mySlidingRecompute90DegreesSign = previousCollisionRuntimeParams.mySlidingRecompute90DegreesSign;
    if (collisionCheckParams.mySlidingAdjustSign90Degrees) {
      let angleWithPreviousThreshold = 0.5;
      if (!previousCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement.vec3_isZero() && !surfaceAdjustedHorizontalMovement.vec3_isZero() && surfaceAdjustedHorizontalMovement.vec3_angle(previousCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement) > angleWithPreviousThreshold) {
        if (!previousCollisionRuntimeParams.myLastValidIsSliding) {
          let angleSigned2 = surfaceAdjustedHorizontalMovement.vec3_angleSigned(previousCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement, up);
          let angleSignedThreshold = 10;
          if (Math.abs(angleSigned2) < 180 - angleSignedThreshold) {
            collisionRuntimeParams.mySliding90DegreesSign = Math.pp_sign(angleSigned2);
          }
        }
        collisionRuntimeParams.mySlidingRecompute90DegreesSign = true;
      }
    }
    previousFixedHorizontalMovement = previousCollisionRuntimeParams.myFixedMovement.vec3_removeComponentAlongAxis(up, previousFixedHorizontalMovement);
    if (previousFixedHorizontalMovement.vec3_isZero(1e-6)) {
      collisionRuntimeParams.mySlidingPreviousHorizontalMovement.vec3_copy(previousCollisionRuntimeParams.mySlidingPreviousHorizontalMovement);
    } else {
      collisionRuntimeParams.mySlidingPreviousHorizontalMovement.vec3_copy(previousFixedHorizontalMovement);
    }
  };
}();
Object.defineProperty(CollisionCheck.prototype, "_move", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_moveStep", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_syncCollisionRuntimeParamsWithPrevious", { enumerable: false });

// js/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_teleport_check.js
CollisionCheck.prototype._teleport = function() {
  let transformUp = vec3_create();
  let transformForward = vec3_create();
  let feetPosition = vec3_create();
  let originalFeetPosition = vec3_create();
  let transformOffsetLocalQuat = quat2_create();
  let offsetTransformQuat = quat2_create();
  let feetPositionOffsetToOriginal = vec3_create();
  let offsetTeleportPosition = vec3_create();
  let zero7 = vec3_create();
  let forwardForHorizontal = vec3_create();
  let forwardForVertical = vec3_create();
  let forwardForPerceivedAngle = vec3_create();
  let fixedHorizontalMovement = vec3_create();
  let fixedVerticalMovement = vec3_create();
  let newFeetPosition = vec3_create();
  let endPosition = vec3_create();
  let zAxis = vec3_create(0, 0, 1);
  let xAxis = vec3_create(1, 0, 0);
  return function _teleport(teleportPosition, transformQuat4, collisionCheckParams, collisionRuntimeParams, isPositionCheck = false) {
    transformOffsetLocalQuat.quat2_setPositionRotationQuat(collisionCheckParams.myPositionOffsetLocal, collisionCheckParams.myRotationOffsetLocalQuat);
    offsetTransformQuat = transformOffsetLocalQuat.quat2_toWorld(transformQuat4, offsetTransformQuat);
    if (transformQuat4.vec_equals(offsetTransformQuat, 1e-5)) {
      offsetTransformQuat.quat2_copy(transformQuat4);
    }
    transformUp = offsetTransformQuat.quat2_getUp(transformUp);
    transformForward = offsetTransformQuat.quat2_getForward(transformForward);
    feetPosition = offsetTransformQuat.quat2_getPosition(feetPosition);
    offsetTeleportPosition.vec3_copy(teleportPosition);
    originalFeetPosition = transformQuat4.quat2_getPosition(originalFeetPosition);
    feetPositionOffsetToOriginal = originalFeetPosition.vec3_sub(feetPosition, feetPositionOffsetToOriginal);
    if (feetPositionOffsetToOriginal.vec3_isZero(1e-5)) {
      feetPositionOffsetToOriginal.vec3_zero();
    } else {
      offsetTeleportPosition = offsetTeleportPosition.vec3_sub(feetPositionOffsetToOriginal, offsetTeleportPosition);
    }
    let height = collisionCheckParams.myHeight;
    height = height - 1e-5;
    if (height < 1e-5) {
      height = 0;
    }
    this._myPrevCollisionRuntimeParams.copy(collisionRuntimeParams);
    collisionRuntimeParams.reset();
    forwardForHorizontal.vec3_copy(collisionCheckParams.myCheckHorizontalFixedForward);
    if (!collisionCheckParams.myCheckHorizontalFixedForwardEnabled) {
      forwardForHorizontal.vec3_copy(transformForward);
    } else {
      if (collisionCheckParams.myCheckHorizontalFixedForward.vec3_isOnAxis(transformUp)) {
        if (zAxis.vec3_isOnAxis(transformUp)) {
          forwardForHorizontal.vec3_copy(xAxis);
        } else {
          forwardForHorizontal.vec3_copy(zAxis);
        }
      }
      forwardForHorizontal = forwardForHorizontal.vec3_removeComponentAlongAxis(transformUp, forwardForHorizontal);
      forwardForHorizontal = forwardForHorizontal.vec3_normalize(forwardForHorizontal);
      if (forwardForHorizontal.vec_equals(collisionCheckParams.myCheckHorizontalFixedForward, 1e-5)) {
        forwardForHorizontal.vec3_copy(collisionCheckParams.myCheckHorizontalFixedForward);
      }
    }
    fixedHorizontalMovement = this._horizontalCheck(zero7, offsetTeleportPosition, height, transformUp, forwardForHorizontal, false, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, false, fixedHorizontalMovement);
    if (!collisionRuntimeParams.myIsCollidingHorizontally) {
      newFeetPosition = offsetTeleportPosition.vec3_add(fixedHorizontalMovement, newFeetPosition);
      forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
      if (!collisionCheckParams.myCheckVerticalFixedForwardEnabled) {
        forwardForVertical.vec3_copy(transformForward);
      } else {
        if (collisionCheckParams.myCheckVerticalFixedForward.vec3_isOnAxis(transformUp)) {
          if (zAxis.vec3_isOnAxis(transformUp)) {
            forwardForVertical.vec3_copy(xAxis);
          } else {
            forwardForVertical.vec3_copy(zAxis);
          }
        }
        forwardForVertical = forwardForVertical.vec3_removeComponentAlongAxis(transformUp, forwardForVertical);
        forwardForVertical = forwardForVertical.vec3_normalize(forwardForVertical);
        if (forwardForVertical.vec_equals(collisionCheckParams.myCheckVerticalFixedForward, 1e-5)) {
          forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
        }
      }
      let downward = -1;
      fixedVerticalMovement = this._verticalCheck(zero7, downward, newFeetPosition, height, transformUp, forwardForVertical, collisionCheckParams, collisionRuntimeParams, fixedVerticalMovement);
      if (!collisionRuntimeParams.myIsCollidingVertically) {
        newFeetPosition = newFeetPosition.vec3_add(fixedVerticalMovement, newFeetPosition);
        forwardForPerceivedAngle.vec3_copy(transformForward);
        if (collisionCheckParams.myComputeGroundInfoEnabled) {
          this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
        }
        if (collisionCheckParams.myComputeCeilingInfoEnabled) {
          this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
        }
        if (!collisionRuntimeParams.myIsOnGround) {
          if (collisionCheckParams.myTeleportMustBeOnGround && !isPositionCheck || collisionCheckParams.myCheckTransformMustBeOnGround && isPositionCheck) {
            collisionRuntimeParams.myTeleportCanceled = true;
          }
        }
        if (!collisionRuntimeParams.myIsOnCeiling) {
          if (collisionCheckParams.myTeleportMustBeOnCeiling && !isPositionCheck || collisionCheckParams.myCheckTransformMustBeOnCeiling && isPositionCheck) {
            collisionRuntimeParams.myTeleportCanceled = true;
          }
        }
        if (collisionRuntimeParams.myIsOnGround) {
          let minAngle = null;
          if (!isPositionCheck) {
            if (collisionCheckParams.myTeleportMustBeOnIgnorableGroundAngle) {
              minAngle = collisionCheckParams.myGroundAngleToIgnore;
            }
            if (collisionCheckParams.myTeleportMustBeOnGroundAngle != null) {
              minAngle = Math.min(minAngle, collisionCheckParams.myTeleportMustBeOnGroundAngle);
            }
          } else {
            if (collisionCheckParams.myCheckTransformMustBeOnIgnorableGroundAngle) {
              minAngle = collisionCheckParams.myGroundAngleToIgnore;
            }
            if (collisionCheckParams.myCheckTransformMustBeOnGroundAngle != null) {
              minAngle = Math.min(minAngle, collisionCheckParams.myCheckTransformMustBeOnGroundAngle);
            }
          }
          if (minAngle != null && collisionRuntimeParams.myGroundAngle > minAngle + 1e-4) {
            collisionRuntimeParams.myTeleportCanceled = true;
          }
        }
        if (collisionRuntimeParams.myIsOnCeiling) {
          let minAngle = null;
          if (!isPositionCheck) {
            if (collisionCheckParams.myTeleportMustBeOnIgnorableCeilingAngle) {
              minAngle = collisionCheckParams.myCeilingAngleToIgnore;
            }
            if (collisionCheckParams.myTeleportMustBeOnCeilingAngle != null) {
              minAngle = Math.min(minAngle, collisionCheckParams.myTeleportMustBeOnCeilingAngle);
            }
          } else {
            if (collisionCheckParams.myCheckTransformMustBeOnIgnorableCeilingAngle) {
              minAngle = collisionCheckParams.myCeilingAngleToIgnore;
            }
            if (collisionCheckParams.myCheckTransformMustBeOnCeilingAngle != null) {
              minAngle = Math.min(minAngle, collisionCheckParams.myCheckTransformMustBeOnCeilingAngle);
            }
          }
          if (minAngle != null && collisionRuntimeParams.myCeilingAngle > minAngle + 1e-4) {
            collisionRuntimeParams.myTeleportCanceled = true;
          }
        }
        if (collisionRuntimeParams.myTeleportCanceled) {
          if (collisionCheckParams.myComputeGroundInfoEnabled && collisionCheckParams.myRegatherGroundInfoOnSurfaceCheckFail) {
            this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
          } else {
            collisionRuntimeParams.myIsOnGround = this._myPrevCollisionRuntimeParams.myIsOnGround;
            collisionRuntimeParams.myGroundAngle = this._myPrevCollisionRuntimeParams.myGroundAngle;
            collisionRuntimeParams.myGroundPerceivedAngle = this._myPrevCollisionRuntimeParams.myGroundPerceivedAngle;
            collisionRuntimeParams.myGroundNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myGroundNormal);
          }
          if (collisionCheckParams.myComputeCeilingInfoEnabled && collisionCheckParams.myRegatherCeilingInfoOnSurfaceCheckFail) {
            this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
          } else {
            collisionRuntimeParams.myIsOnCeiling = this._myPrevCollisionRuntimeParams.myIsOnCeiling;
            collisionRuntimeParams.myCeilingAngle = this._myPrevCollisionRuntimeParams.myCeilingAngle;
            collisionRuntimeParams.myCeilingPerceivedAngle = this._myPrevCollisionRuntimeParams.myCeilingPerceivedAngle;
            collisionRuntimeParams.myCeilingNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myCeilingNormal);
          }
        }
      } else {
        collisionRuntimeParams.myTeleportCanceled = true;
      }
    } else {
      collisionRuntimeParams.myTeleportCanceled = true;
    }
    if (!isPositionCheck) {
      if (collisionCheckParams.myExtraTeleportCheckCallback != null) {
        endPosition.vec3_copy(newFeetPosition);
        newFeetPosition = collisionCheckParams.myExtraTeleportCheckCallback(
          offsetTeleportPosition,
          endPosition,
          feetPosition,
          transformUp,
          transformForward,
          height,
          collisionCheckParams,
          this._myPrevCollisionRuntimeParams,
          collisionRuntimeParams,
          newFeetPosition
        );
      }
    } else {
      if (collisionCheckParams.myExtraCheckTransformCheckCallback != null) {
        endPosition.vec3_copy(newFeetPosition);
        newFeetPosition = collisionCheckParams.myExtraCheckTransformCheckCallback(
          endPosition,
          feetPosition,
          transformUp,
          transformForward,
          height,
          collisionCheckParams,
          this._myPrevCollisionRuntimeParams,
          collisionRuntimeParams,
          newFeetPosition
        );
      }
    }
    collisionRuntimeParams.myOriginalUp = transformQuat4.quat2_getUp(collisionRuntimeParams.myOriginalUp);
    collisionRuntimeParams.myOriginalForward = transformQuat4.quat2_getForward(collisionRuntimeParams.myOriginalForward);
    collisionRuntimeParams.myOriginalPosition = transformQuat4.quat2_getPosition(collisionRuntimeParams.myOriginalPosition);
    collisionRuntimeParams.myOriginalHeight = collisionCheckParams.myHeight;
    collisionRuntimeParams.myOriginalTeleportPosition.vec3_copy(teleportPosition);
    if (!collisionRuntimeParams.myTeleportCanceled) {
      collisionRuntimeParams.myFixedTeleportPosition.vec3_copy(newFeetPosition);
      if (!feetPositionOffsetToOriginal.vec3_isZero(1e-5)) {
        collisionRuntimeParams.myFixedTeleportPosition = collisionRuntimeParams.myFixedTeleportPosition.vec3_add(feetPositionOffsetToOriginal, collisionRuntimeParams.myFixedTeleportPosition);
      }
      collisionRuntimeParams.myNewPosition.vec3_copy(collisionRuntimeParams.myFixedTeleportPosition);
    } else {
      collisionRuntimeParams.myNewPosition.vec3_copy(collisionRuntimeParams.myOriginalPosition);
    }
    collisionRuntimeParams.myIsTeleport = true;
    if (collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugRuntimeParamsEnabled && Globals.isDebugEnabled(this._myEngine)) {
      this._debugRuntimeParams(collisionRuntimeParams);
    }
  };
}();
Object.defineProperty(CollisionCheck.prototype, "_teleport", { enumerable: false });

// js/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_position_check.js
CollisionCheck.prototype._positionCheck = function() {
  let feetPosition = vec3_create();
  return function _positionCheck(allowAdjustments, transformQuat4, collisionCheckParams, collisionRuntimeParams) {
    feetPosition = transformQuat4.quat2_getPosition(feetPosition);
    this._teleport(feetPosition, transformQuat4, collisionCheckParams, collisionRuntimeParams, true);
    collisionRuntimeParams.myIsPositionOk = !collisionRuntimeParams.myTeleportCanceled;
    collisionRuntimeParams.myIsPositionCheck = true;
    collisionRuntimeParams.myOriginalPositionCheckPosition.vec3_copy(collisionRuntimeParams.myOriginalTeleportPosition);
    collisionRuntimeParams.myFixedPositionCheckPosition.vec3_copy(collisionRuntimeParams.myFixedTeleportPosition);
    collisionRuntimeParams.myIsPositionCheckAllowAdjustments = allowAdjustments;
    if (!allowAdjustments) {
      collisionRuntimeParams.myIsPositionOk = collisionRuntimeParams.myIsPositionOk && collisionRuntimeParams.myOriginalPositionCheckPosition.vec_equals(collisionRuntimeParams.myFixedPositionCheckPosition, 1e-5);
    }
    collisionRuntimeParams.myOriginalTeleportPosition.vec3_zero();
    collisionRuntimeParams.myFixedTeleportPosition.vec3_zero();
    collisionRuntimeParams.myTeleportCanceled = false;
    collisionRuntimeParams.myIsTeleport = false;
  };
}();
Object.defineProperty(CollisionCheck.prototype, "_positionCheck", { enumerable: false });

// js/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/horizontal_collision_check.js
CollisionCheck.prototype._horizontalCheck = function() {
  let fixedFeetPosition = vec3_create();
  let newFixedFeetPosition = vec3_create();
  let newFeetPosition = vec3_create();
  let horizontalDirection = vec3_create();
  return function _horizontalCheck(movement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, avoidSlidingExtraCheck, outFixedMovement) {
    collisionRuntimeParams.myIsCollidingHorizontally = false;
    collisionRuntimeParams.myHorizontalCollisionHit.reset();
    outFixedMovement.vec3_zero();
    horizontalDirection = movement.vec3_normalize(horizontalDirection);
    let surfaceTooSteepResults = this._surfaceTooSteep(up, horizontalDirection, collisionCheckParams, previousCollisionRuntimeParams);
    if (movement.vec3_isZero(1e-6) || (!surfaceTooSteepResults[0] || allowSurfaceSteepFix && collisionCheckParams.myAllowGroundSteepFix) && (!surfaceTooSteepResults[1] || allowSurfaceSteepFix && collisionCheckParams.myAllowCeilingSteepFix)) {
      fixedFeetPosition = feetPosition.vec3_add(up.vec3_scale(collisionCheckParams.myDistanceFromFeetToIgnore + 1e-4, fixedFeetPosition), fixedFeetPosition);
      let fixedHeight = Math.max(0, height - collisionCheckParams.myDistanceFromFeetToIgnore - collisionCheckParams.myDistanceFromHeadToIgnore - 1e-4 * 2);
      let canMove = true;
      if (collisionCheckParams.myHorizontalMovementCheckEnabled && !movement.vec3_isZero(1e-6)) {
        canMove = this._horizontalMovementCheck(movement, feetPosition, height, fixedFeetPosition, fixedHeight, up, collisionCheckParams, collisionRuntimeParams);
      }
      if (canMove) {
        if (collisionCheckParams.myHorizontalPositionCheckEnabled) {
          newFixedFeetPosition = fixedFeetPosition.vec3_add(movement, newFixedFeetPosition);
          newFeetPosition = feetPosition.vec3_add(movement, newFeetPosition);
          let canStay = this._horizontalPositionCheck(newFeetPosition, height, newFixedFeetPosition, fixedHeight, up, forward, collisionCheckParams, collisionRuntimeParams);
          if (canStay) {
            outFixedMovement.vec3_copy(movement);
          }
          if (outFixedMovement.vec3_isZero(1e-6)) {
            outFixedMovement.vec3_zero();
          }
        } else {
          outFixedMovement.vec3_copy(movement);
        }
      } else if (!avoidSlidingExtraCheck && collisionCheckParams.mySlidingEnabled && collisionCheckParams.mySlidingHorizontalMovementCheckBetterNormal) {
        this._horizontalCheckBetterSlideNormal(movement, feetPosition, height, fixedFeetPosition, fixedHeight, up, forward, collisionCheckParams, collisionRuntimeParams);
      }
    }
    return outFixedMovement;
  };
}();
CollisionCheck.prototype._horizontalCheckRaycast = function() {
  let direction2 = vec3_create();
  let fixedFeetPosition = vec3_create();
  let fixedHitPosition = vec3_create();
  return function _horizontalCheckRaycast(startPosition, endPosition, movementDirection, up, ignoreHitsInsideCollision, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, fixHitOnCollision, collisionCheckParams, collisionRuntimeParams, checkAllHits = false, ignoreHitsInsideCollisionIfObjectToIgnore = false) {
    let origin = startPosition;
    direction2 = endPosition.vec3_sub(origin, direction2);
    if (movementDirection != null && !direction2.vec3_isConcordant(movementDirection)) {
      direction2.vec3_negate(direction2);
      origin = endPosition;
    }
    let distance5 = direction2.vec3_length();
    direction2.vec3_normalize(direction2);
    let raycastResult = this._raycastAndDebug(origin, direction2, distance5, ignoreHitsInsideCollision, true, collisionCheckParams, collisionRuntimeParams);
    let isOk = true;
    if (raycastResult.isColliding()) {
      let hitsToControl = checkAllHits ? raycastResult.myHits.length : 1;
      let validHitIndex = 0;
      for (let i = 0; i < hitsToControl; i++) {
        let hit = raycastResult.myHits[i];
        if ((ignoreGroundAngleCallback == null || !ignoreGroundAngleCallback(hit, ignoreHitsInsideCollisionIfObjectToIgnore)) && (ignoreCeilingAngleCallback == null || !ignoreCeilingAngleCallback(hit, ignoreHitsInsideCollisionIfObjectToIgnore))) {
          isOk = false;
          validHitIndex = i;
          break;
        }
      }
      if (!isOk && validHitIndex > 0) {
        for (let i = 0; i < validHitIndex; i++) {
          raycastResult.removeHit(0);
        }
      }
    }
    if (!isOk && fixHitOnCollision) {
      let hitPosition = raycastResult.myHits[0].myPosition;
      fixedFeetPosition = feetPosition.vec3_copyComponentAlongAxis(hitPosition, up, fixedFeetPosition);
      fixedHitPosition.vec3_copy(hitPosition);
      let directionOffsetEpsilonValue = 1e-4;
      direction2 = direction2.vec3_componentAlongAxis(up, direction2);
      if (!direction2.vec3_isZero(1e-6)) {
        direction2.vec3_normalize(direction2);
        direction2.vec3_scale(directionOffsetEpsilonValue, direction2);
        fixedFeetPosition.vec3_add(direction2, fixedFeetPosition);
        fixedHitPosition.vec3_add(direction2, fixedHitPosition);
      }
      direction2 = fixedHitPosition.vec3_sub(fixedFeetPosition, direction2);
      direction2.vec3_normalize(direction2);
      direction2.vec3_scale(directionOffsetEpsilonValue, direction2);
      fixedHitPosition = fixedHitPosition.vec3_add(direction2, fixedHitPosition);
      let swapRaycastResult = this._myRaycastResult;
      this._myRaycastResult = this._myFixRaycastResult;
      isOk = this._horizontalCheckRaycast(
        fixedFeetPosition,
        fixedHitPosition,
        null,
        up,
        false,
        ignoreGroundAngleCallback,
        ignoreCeilingAngleCallback,
        feetPosition,
        false,
        collisionCheckParams,
        collisionRuntimeParams
      );
      if (this._myRaycastResult.isColliding()) {
        this._myFixRaycastResult = swapRaycastResult;
      } else {
        isOk = false;
        this._myRaycastResult = swapRaycastResult;
      }
    }
    return isOk;
  };
}();
CollisionCheck.prototype._ignoreSurfaceAngle = function() {
  let objectsEqualCallback = (first2, second) => first2.pp_equals(second);
  let movementDirection = vec3_create();
  let hitDirection = vec3_create();
  let hitMovement = vec3_create();
  let projectAlongAxis = vec3_create();
  return function _ignoreSurfaceAngle(feetPosition, height, movementOrForward, objectsToIgnore, outIgnoredObjects, isGround, isMovementCheck, up, collisionCheckParams, hit, ignoreHitsInsideCollisionIfObjectToIgnore) {
    let isIgnorable = false;
    let surfaceIgnoreHeight = null;
    let groundIgnoreHeight = isMovementCheck ? collisionCheckParams.myHorizontalMovementGroundAngleIgnoreHeight : collisionCheckParams.myHorizontalPositionGroundAngleIgnoreHeight;
    let ceilingIgnoreHeight = isMovementCheck ? collisionCheckParams.myHorizontalMovementCeilingAngleIgnoreHeight : collisionCheckParams.myHorizontalPositionCeilingAngleIgnoreHeight;
    if (isGround && groundIgnoreHeight != null) {
      surfaceIgnoreHeight = Math.pp_clamp(groundIgnoreHeight + 2e-4, 0, height);
    } else if (!isGround && ceilingIgnoreHeight != null) {
      surfaceIgnoreHeight = Math.pp_clamp(height - ceilingIgnoreHeight - 2e-4, 0, height);
    }
    let surfaceIgnoreMaxMovementLeft = null;
    if (isMovementCheck) {
      if (isGround && collisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft != null) {
        surfaceIgnoreMaxMovementLeft = collisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft;
      } else if (!isGround && collisionCheckParams.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft != null) {
        surfaceIgnoreMaxMovementLeft = collisionCheckParams.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft;
      }
    }
    if (!hit.myInsideCollision) {
      movementDirection = movementOrForward.vec3_normalize(movementDirection);
      let surfaceAngle = hit.myNormal.vec3_angle(up);
      if (!isGround) {
        surfaceAngle = 180 - surfaceAngle;
      }
      if (isGround && collisionCheckParams.myGroundAngleToIgnore > 0 && surfaceAngle > collisionCheckParams.myGroundAngleToIgnore + 1e-4) {
        if (collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle != null && surfaceAngle <= collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle + 1e-4) {
          let perceivedAngle = this.computeSurfacePerceivedAngle(
            hit.myNormal,
            movementDirection,
            up,
            true
          );
          surfaceAngle = Math.abs(perceivedAngle);
        }
      } else if (!isGround && collisionCheckParams.myCeilingAngleToIgnore > 0 && surfaceAngle > collisionCheckParams.myCeilingAngleToIgnore + 1e-4) {
        if (collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle != null && surfaceAngle <= collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle + 1e-4) {
          let perceivedAngle = this.computeSurfacePerceivedAngle(
            hit.myNormal,
            movementDirection,
            up,
            false
          );
          surfaceAngle = Math.abs(perceivedAngle);
        }
      }
      if (isGround && (collisionCheckParams.myGroundAngleToIgnore > 0 && surfaceAngle <= collisionCheckParams.myGroundAngleToIgnore + 1e-4) || !isGround && (collisionCheckParams.myCeilingAngleToIgnore > 0 && surfaceAngle <= collisionCheckParams.myCeilingAngleToIgnore + 1e-4)) {
        if (objectsToIgnore == null || objectsToIgnore.pp_hasEqual(hit.myObject, objectsEqualCallback)) {
          let surfaceHeightCheckOk = true;
          let maxMovementLeftCheckOk = true;
          if (surfaceIgnoreHeight != null) {
            surfaceHeightCheckOk = false;
            let feetPositionUp = feetPosition.vec3_valueAlongAxis(up);
            let hitUp = hit.myPosition.vec3_valueAlongAxis(up);
            let hitHeight = hitUp - feetPositionUp;
            if (isGround && hitHeight <= surfaceIgnoreHeight || !isGround && hitHeight >= surfaceIgnoreHeight) {
              surfaceHeightCheckOk = true;
            } else {
            }
          }
          if (surfaceHeightCheckOk && isMovementCheck) {
            if (surfaceIgnoreMaxMovementLeft != null) {
              let movementLength = movementOrForward.vec3_length();
              if (movementLength > surfaceIgnoreMaxMovementLeft) {
                maxMovementLeftCheckOk = false;
                let hitPosition = hit.myPosition;
                let halfConeAngle = Math.min(collisionCheckParams.myHalfConeAngle, 90);
                hitDirection = hitPosition.vec3_sub(feetPosition, hitDirection);
                if (hitDirection.vec3_isToTheRight(movementDirection, up)) {
                  projectAlongAxis = movementDirection.vec3_rotateAxis(-halfConeAngle, up, projectAlongAxis);
                } else {
                  projectAlongAxis = movementDirection.vec3_rotateAxis(halfConeAngle, up, projectAlongAxis);
                }
                hitMovement = hitDirection.vec3_projectOnAxisAlongAxis(movementDirection, projectAlongAxis, hitMovement);
                let hitMovementLength = hitMovement.vec3_length();
                let movementLeft = movementLength - hitMovementLength;
                if (movementLeft <= surfaceIgnoreMaxMovementLeft) {
                  maxMovementLeftCheckOk = true;
                } else {
                }
              }
            }
          }
          if (surfaceHeightCheckOk && maxMovementLeftCheckOk) {
            isIgnorable = true;
          }
        }
      }
    } else if (ignoreHitsInsideCollisionIfObjectToIgnore) {
      if (objectsToIgnore == null || objectsToIgnore.pp_hasEqual(hit.myObject, objectsEqualCallback)) {
        isIgnorable = true;
      }
    }
    if (isIgnorable) {
      if (outIgnoredObjects != null) {
        outIgnoredObjects.pp_pushUnique(hit.myObject, objectsEqualCallback);
      }
    }
    return isIgnorable;
  };
}();
Object.defineProperty(CollisionCheck.prototype, "_horizontalCheck", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_horizontalCheckRaycast", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_ignoreSurfaceAngle", { enumerable: false });

// js/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/horizontal_collision_sliding.js
CollisionCheck.prototype._horizontalSlide = function() {
  let previousHorizontalMovement = vec3_create();
  return function _horizontalSlide(movement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, outSlideMovement) {
    if (movement.vec3_isZero(1e-5)) {
      return outSlideMovement.vec3_zero();
    }
    this._mySlidingCollisionRuntimeParams.copy(collisionRuntimeParams);
    previousHorizontalMovement.vec3_copy(collisionRuntimeParams.mySlidingPreviousHorizontalMovement);
    outSlideMovement = this._internalHorizontalSlide(movement, feetPosition, height, up, forward, previousHorizontalMovement, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingCollisionRuntimeParams, previousCollisionRuntimeParams, false, outSlideMovement);
    if (collisionCheckParams.mySlidingCheckBothDirections) {
      this._horizontalSlideCheckOpposite(movement, feetPosition, height, up, forward, previousHorizontalMovement, this._myPrevCollisionRuntimeParams.myIsSliding, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, this._mySlidingCollisionRuntimeParams, previousCollisionRuntimeParams, outSlideMovement);
    }
    if (this._mySlidingCollisionRuntimeParams.myIsSliding && collisionCheckParams.mySlidingFlickeringPreventionType > 0) {
      let isFlickering = this._horizontalSlideFlickerCheck(movement, outSlideMovement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingCollisionRuntimeParams, previousCollisionRuntimeParams);
      this._mySlidingCollisionRuntimeParams.myIsSliding = !isFlickering;
    }
    if (this._mySlidingCollisionRuntimeParams.myIsSliding) {
      let backupFlickerPrevented = collisionRuntimeParams.myIsSlidingFlickerPrevented;
      collisionRuntimeParams.copy(this._mySlidingCollisionRuntimeParams);
      collisionRuntimeParams.myIsSlidingFlickerPrevented = backupFlickerPrevented || this._mySlidingCollisionRuntimeParams.myIsSlidingFlickerPrevented;
    } else {
      collisionRuntimeParams.myIsSlidingFlickerPrevented = collisionRuntimeParams.myIsSlidingFlickerPrevented || this._mySlidingCollisionRuntimeParams.myIsSlidingFlickerPrevented;
      outSlideMovement.vec3_zero();
    }
    return outSlideMovement;
  };
}();
CollisionCheck.prototype._horizontalSlideCheckOpposite = function() {
  let horizontalCollisionNormal = vec3_create();
  let oppositeSlideMovement = vec3_create();
  return function _horizontalSlideCheckOpposite(movement, feetPosition, height, up, forward, previousHorizontalMovement, previousIsSliding, allowSurfaceSteepFix, collisionCheckParams, preSlideCollisionRuntimeParams, postSlideCollisionRuntimeParams, previousCollisionRuntimeParams, outSlideMovement) {
    horizontalCollisionNormal = preSlideCollisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_removeComponentAlongAxis(up, horizontalCollisionNormal);
    horizontalCollisionNormal.vec3_normalize(horizontalCollisionNormal);
    let angleNormalWithMovementThreshold = 20;
    if (horizontalCollisionNormal.vec3_angle(movement) > 180 - angleNormalWithMovementThreshold) {
      return;
    } else if (previousIsSliding && postSlideCollisionRuntimeParams.myIsSliding && outSlideMovement.vec3_isConcordant(previousHorizontalMovement)) {
      return;
    } else {
    }
    this._mySlidingOppositeDirectionCollisionRuntimeParams.copy(preSlideCollisionRuntimeParams);
    oppositeSlideMovement = this._internalHorizontalSlide(movement, feetPosition, height, up, forward, previousHorizontalMovement, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingOppositeDirectionCollisionRuntimeParams, previousCollisionRuntimeParams, true, oppositeSlideMovement);
    if (this._mySlidingOppositeDirectionCollisionRuntimeParams.myIsSliding) {
      let isOppositeBetter = false;
      if (postSlideCollisionRuntimeParams.myIsSliding) {
        if (movement.vec3_angle(oppositeSlideMovement) < movement.vec3_angle(outSlideMovement) - 1e-4) {
          isOppositeBetter = true;
        } else {
          if (Math.abs(movement.vec3_angle(oppositeSlideMovement) - movement.vec3_angle(outSlideMovement)) <= 1e-4) {
            if (previousHorizontalMovement.vec3_angle(oppositeSlideMovement) < previousHorizontalMovement.vec3_angle(outSlideMovement) - 1e-4) {
              let angleNormalWithMovementThreshold2 = 5;
              if (horizontalCollisionNormal.vec3_angle(movement) < 90 + angleNormalWithMovementThreshold2) {
                isOppositeBetter = true;
              }
            }
          }
        }
      } else {
        let angleEpsilon = 1e-3;
        if (movement.vec3_isConcordant(oppositeSlideMovement) && movement.vec3_angle(oppositeSlideMovement) < 90 - angleEpsilon) {
          isOppositeBetter = true;
        } else {
        }
      }
      if (isOppositeBetter) {
        outSlideMovement.vec3_copy(oppositeSlideMovement);
        postSlideCollisionRuntimeParams.copy(this._mySlidingOppositeDirectionCollisionRuntimeParams);
      } else {
      }
    } else {
    }
  };
}();
CollisionCheck.prototype._horizontalSlideFlickerCheck = function() {
  let previousHorizontalMovement = vec3_create();
  let newFeetPosition = vec3_create();
  let fixedMovement = vec3_create();
  let flickerFixSlideMovement = vec3_create();
  return function _horizontalSlideFlickerCheck(movement, slideMovement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams) {
    let isFlickering = false;
    previousHorizontalMovement.vec3_copy(collisionRuntimeParams.mySlidingPreviousHorizontalMovement);
    let shouldCheckFlicker = this._myPrevCollisionRuntimeParams.myIsSlidingFlickerPrevented || previousHorizontalMovement.vec3_isZero(1e-5);
    if (!shouldCheckFlicker) {
      if (this._myPrevCollisionRuntimeParams.myIsSliding || !collisionCheckParams.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding) {
        let flickerCollisionAngle = 90;
        let flickerMovementAngle = 85;
        switch (collisionCheckParams.mySlidingFlickeringPreventionType) {
          case 1:
            shouldCheckFlicker = previousHorizontalMovement.vec3_signTo(movement, up, 0) != slideMovement.vec3_signTo(movement, up, 0);
            break;
          case 2:
            shouldCheckFlicker = collisionCheckParams.mySlidingCheckBothDirections && collisionRuntimeParams.myIsSlidingIntoOppositeDirection;
            shouldCheckFlicker = shouldCheckFlicker || Math.abs(collisionRuntimeParams.mySlidingCollisionAngle) > flickerCollisionAngle + 1e-5;
            break;
          case 3:
            shouldCheckFlicker = collisionCheckParams.mySlidingCheckBothDirections && collisionRuntimeParams.myIsSlidingIntoOppositeDirection;
            shouldCheckFlicker = shouldCheckFlicker || Math.abs(collisionRuntimeParams.mySlidingCollisionAngle) > flickerCollisionAngle + 1e-5;
            shouldCheckFlicker = shouldCheckFlicker || Math.abs(Math.abs(collisionRuntimeParams.mySlidingCollisionAngle) - flickerCollisionAngle) < 1e-5 && Math.abs(collisionRuntimeParams.mySlidingMovementAngle) > flickerMovementAngle + 1e-5;
            break;
          case 4:
            shouldCheckFlicker = true;
            break;
        }
      }
    }
    if (shouldCheckFlicker || this._myPrevCollisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter > 0) {
      if (shouldCheckFlicker) {
        collisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter = collisionCheckParams.mySlidingFlickerPreventionCheckAnywayCounter;
      } else {
        collisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter = Math.max(0, this._myPrevCollisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter - 1);
      }
      if ((collisionCheckParams.mySlidingFlickeringPreventionType != 1 || collisionRuntimeParams.myIsSlidingFlickerPrevented || this._myPrevCollisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter > 0) && (this._myPrevCollisionRuntimeParams.myIsSliding && previousHorizontalMovement.vec3_signTo(movement, up, 0) != slideMovement.vec3_signTo(movement, up, 0))) {
        isFlickering = true;
        collisionRuntimeParams.myIsSlidingFlickerPrevented = true;
      } else {
        this._mySlidingFlickeringFixCollisionRuntimeParams.reset();
        this._mySlidingFlickeringFixCollisionRuntimeParams.mySliding90DegreesSign = collisionRuntimeParams.mySliding90DegreesSign;
        this._mySlidingFlickeringFixCollisionRuntimeParams.mySlidingRecompute90DegreesSign = false;
        newFeetPosition = feetPosition.vec3_add(slideMovement, newFeetPosition);
        let backupDebugEnabled = collisionCheckParams.myDebugEnabled;
        collisionCheckParams.myDebugEnabled = collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugSlidingEnabled;
        fixedMovement.vec3_zero();
        fixedMovement = this._horizontalCheck(movement, newFeetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingFlickeringFixCollisionRuntimeParams, previousCollisionRuntimeParams, false, fixedMovement);
        collisionCheckParams.myDebugEnabled = backupDebugEnabled;
        if (fixedMovement.vec3_isZero(1e-5)) {
          this._mySlidingFlickeringFixSlidingCollisionRuntimeParams.copy(this._mySlidingFlickeringFixCollisionRuntimeParams);
          flickerFixSlideMovement = this._internalHorizontalSlide(movement, newFeetPosition, height, up, forward, slideMovement, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingFlickeringFixSlidingCollisionRuntimeParams, previousCollisionRuntimeParams, false, flickerFixSlideMovement);
          if (collisionCheckParams.mySlidingCheckBothDirections) {
            this._horizontalSlideCheckOpposite(movement, newFeetPosition, height, up, forward, slideMovement, true, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingFlickeringFixCollisionRuntimeParams, this._mySlidingFlickeringFixSlidingCollisionRuntimeParams, previousCollisionRuntimeParams, flickerFixSlideMovement);
          }
          if (this._mySlidingFlickeringFixSlidingCollisionRuntimeParams.myIsSliding) {
            if (slideMovement.vec3_signTo(movement, up, 0) != flickerFixSlideMovement.vec3_signTo(movement, up, 0)) {
              isFlickering = true;
              collisionRuntimeParams.myIsSlidingFlickerPrevented = true;
            }
          }
        }
      }
    } else {
    }
    if (isFlickering) {
    } else {
    }
    return isFlickering;
  };
}();
CollisionCheck.prototype._internalHorizontalSlide = function() {
  let invertedNormal = vec3_create();
  let slidingMovement = vec3_create();
  let movement90 = vec3_create();
  let currentMovement = vec3_create();
  let slideMovementForward = vec3_create();
  let fixedMovement = vec3_create();
  return function _internalHorizontalSlide(movement, feetPosition, height, up, forward, previousHorizontalMovement, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, checkOppositeDirection, outSlideMovement) {
    if (movement.vec3_isZero(1e-5)) {
      return outSlideMovement.vec3_zero();
    }
    invertedNormal = collisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_negate(invertedNormal);
    invertedNormal.vec3_removeComponentAlongAxis(up, invertedNormal);
    invertedNormal[0] = Math.abs(invertedNormal[0]) < 0.01 ? 0 : invertedNormal[0];
    invertedNormal[2] = Math.abs(invertedNormal[2]) < 0.01 ? 0 : invertedNormal[2];
    invertedNormal.vec3_normalize(invertedNormal);
    collisionRuntimeParams.mySlidingCollisionHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
    collisionRuntimeParams.mySlidingWallNormal.vec3_copy(collisionRuntimeParams.myHorizontalCollisionHit.myNormal);
    outSlideMovement.vec3_zero();
    slidingMovement.vec3_copy(invertedNormal);
    if (checkOppositeDirection) {
      slidingMovement.vec3_copy(movement);
      slidingMovement.vec3_normalize(slidingMovement);
    }
    if (!slidingMovement.vec3_isZero(1e-5)) {
      slidingMovement.vec3_scale(movement.vec3_length(), slidingMovement);
      let slidingSign = invertedNormal.vec3_signTo(movement, up);
      if (collisionCheckParams.mySlidingAdjustSign90Degrees) {
        let angleThreshold = 0.1;
        if (invertedNormal.vec3_angle(movement) < angleThreshold && collisionRuntimeParams.mySliding90DegreesSign != 0) {
          slidingSign = collisionRuntimeParams.mySliding90DegreesSign;
        } else if (collisionRuntimeParams.mySliding90DegreesSign == 0 || collisionRuntimeParams.mySlidingRecompute90DegreesSign) {
          collisionRuntimeParams.mySliding90DegreesSign = slidingSign;
        } else {
        }
        collisionRuntimeParams.mySlidingRecompute90DegreesSign = false;
      }
      if (checkOppositeDirection) {
        slidingSign *= -1;
      }
      let currentAngle = 90 * slidingSign;
      let maxAngle = Math.pp_angleClamp(slidingMovement.vec3_angleSigned(movement.vec3_rotateAxis(90 * slidingSign, up, movement90), up) * slidingSign, true) * slidingSign;
      let minAngle = Math.pp_angleClamp(slidingMovement.vec3_angleSigned(movement, up) * slidingSign, true) * slidingSign;
      if (checkOppositeDirection) {
        maxAngle = currentAngle;
        minAngle = 0;
      } else {
        if (Math.abs(maxAngle) < Math.abs(minAngle)) {
          minAngle = 0;
        }
        if (Math.abs(Math.abs(maxAngle) - Math.abs(minAngle)) < 1e-4) {
          minAngle = maxAngle;
        }
        if (Math.abs(maxAngle) < Math.abs(currentAngle) || Math.abs(Math.abs(maxAngle) - Math.abs(currentAngle)) < 1e-4) {
          currentAngle = maxAngle;
        }
        if (Math.abs(currentAngle) < Math.abs(minAngle) || Math.abs(Math.abs(minAngle) - Math.abs(currentAngle)) < 1e-4) {
          currentAngle = minAngle;
        }
      }
      if (checkOppositeDirection && !previousHorizontalMovement.vec3_isZero(1e-6)) {
        let angleWithPrevious = movement.vec3_angleSigned(previousHorizontalMovement, up);
        if (Math.pp_sign(angleWithPrevious) == Math.pp_sign(maxAngle) && Math.abs(maxAngle) > Math.abs(angleWithPrevious)) {
          currentAngle = angleWithPrevious;
        }
      }
      currentMovement.vec3_zero();
      let backupDebugEnabled = collisionCheckParams.myDebugEnabled;
      collisionCheckParams.myDebugEnabled = collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugSlidingEnabled;
      for (let i = 0; i < collisionCheckParams.mySlidingMaxAttempts; i++) {
        this._myInternalSlidingCollisionRuntimeParams.copy(collisionRuntimeParams);
        currentMovement = slidingMovement.vec3_rotateAxis(currentAngle, up, currentMovement);
        slideMovementForward.vec3_copy(forward);
        if (!collisionCheckParams.myCheckHorizontalFixedForwardEnabled) {
          if (!currentMovement.vec3_isZero()) {
            slideMovementForward = currentMovement.vec3_normalize(slideMovementForward);
          }
        }
        fixedMovement.vec3_zero();
        fixedMovement = this._horizontalCheck(currentMovement, feetPosition, height, up, slideMovementForward, allowSurfaceSteepFix, collisionCheckParams, this._myInternalSlidingCollisionRuntimeParams, previousCollisionRuntimeParams, true, fixedMovement);
        if (!fixedMovement.vec3_isZero(1e-5)) {
          outSlideMovement.vec3_copy(currentMovement);
          collisionRuntimeParams.copy(this._myInternalSlidingCollisionRuntimeParams);
          collisionRuntimeParams.myIsSliding = true;
          collisionRuntimeParams.myIsSlidingIntoOppositeDirection = checkOppositeDirection;
          collisionRuntimeParams.mySlidingMovementAngle = movement.vec3_angleSigned(currentMovement, up);
          collisionRuntimeParams.mySlidingCollisionAngle = invertedNormal.vec3_angleSigned(currentMovement, up);
          maxAngle = currentAngle;
          currentAngle = (maxAngle + minAngle) / 2;
        } else {
          if (currentAngle != maxAngle) {
            minAngle = currentAngle;
          }
          if (i == 0 && currentAngle != maxAngle) {
            currentAngle = maxAngle;
          } else {
            currentAngle = (minAngle + maxAngle) / 2;
          }
        }
        if (Math.abs(Math.abs(maxAngle) - Math.abs(minAngle)) < 1e-4) {
          break;
        }
      }
      collisionCheckParams.myDebugEnabled = backupDebugEnabled;
    }
    if (!collisionRuntimeParams.myIsSliding) {
      collisionRuntimeParams.mySlidingCollisionHit.reset();
    } else {
    }
    return outSlideMovement;
  };
}();
CollisionCheck.prototype._horizontalCheckBetterSlideNormal = function() {
  let movementDirection = vec3_create();
  let hitDirection = vec3_create();
  let projectAlongAxis = vec3_create();
  let fixedMovement = vec3_create();
  let newFixedFeetPosition = vec3_create();
  let newFeetPosition = vec3_create();
  return function _horizontalCheckBetterSlideNormal(movement, originalFeetPosition, originalHeight, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams) {
    movementDirection = movement.vec3_normalize(movementDirection);
    let hitPosition = collisionRuntimeParams.myHorizontalCollisionHit.myPosition;
    let halfConeAngle = Math.min(collisionCheckParams.myHalfConeAngle, 90);
    hitDirection = hitPosition.vec3_sub(feetPosition, hitDirection);
    if (hitDirection.vec3_isToTheRight(movementDirection, up)) {
      projectAlongAxis = movementDirection.vec3_rotateAxis(-halfConeAngle, up, projectAlongAxis);
    } else {
      projectAlongAxis = movementDirection.vec3_rotateAxis(halfConeAngle, up, projectAlongAxis);
    }
    fixedMovement = hitDirection.vec3_projectOnAxisAlongAxis(movementDirection, projectAlongAxis, fixedMovement);
    if (fixedMovement.vec3_isConcordant(movementDirection)) {
      fixedMovement = movementDirection.vec3_scale(Math.min(fixedMovement.vec3_length(), movement.vec3_length()), fixedMovement);
    } else {
      fixedMovement.vec3_zero();
    }
    if (collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugHorizontalMovementEnabled && Globals.isDebugEnabled(this._myEngine)) {
      Globals.getDebugVisualManager(this._myEngine).drawArrow(0, feetPosition, movementDirection, fixedMovement.vec3_length(), vec4_create(1, 0, 1, 1));
    }
    this._myCheckBetterSlidingNormalCollisionRuntimeParams.copy(collisionRuntimeParams);
    this._myCheckBetterSlidingNormalCollisionRuntimeParams.myIsCollidingHorizontally = false;
    this._myCheckBetterSlidingNormalCollisionRuntimeParams.myHorizontalCollisionHit.reset();
    newFixedFeetPosition = feetPosition.vec3_add(fixedMovement, newFixedFeetPosition);
    newFeetPosition = feetPosition.vec3_add(fixedMovement, newFeetPosition);
    let backupDebugEnabled = collisionCheckParams.myDebugEnabled;
    collisionCheckParams.myDebugEnabled = collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugSlidingEnabled;
    if (collisionCheckParams.myHorizontalPositionCheckEnabled) {
      this._horizontalPositionCheck(originalFeetPosition, originalHeight, newFixedFeetPosition, height, up, forward, collisionCheckParams, this._myCheckBetterSlidingNormalCollisionRuntimeParams);
    }
    collisionCheckParams.myDebugEnabled = backupDebugEnabled;
    if (this._myCheckBetterSlidingNormalCollisionRuntimeParams.myIsCollidingHorizontally && !this._myCheckBetterSlidingNormalCollisionRuntimeParams.myHorizontalCollisionHit.myInsideCollision) {
      collisionRuntimeParams.copy(this._myCheckBetterSlidingNormalCollisionRuntimeParams);
    }
  };
}();
CollisionCheck.prototype._isSlidingNormalValid = function() {
  let flatNormal = vec3_create();
  return function _isSlidingNormalValid(movement, up, collisionRuntimeParams) {
    let isValid = false;
    flatNormal = collisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_removeComponentAlongAxis(up, flatNormal);
    flatNormal.vec3_normalize(flatNormal);
    if (!flatNormal.vec3_isZero(1e-6)) {
      isValid = true;
    }
    return isValid;
  };
}();
Object.defineProperty(CollisionCheck.prototype, "_horizontalSlide", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_horizontalSlideCheckOpposite", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_horizontalSlideFlickerCheck", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_internalHorizontalSlide", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_horizontalCheckBetterSlideNormal", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_isSlidingNormalValid", { enumerable: false });

// js/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/horizontal_collision_movement_check.js
CollisionCheck.prototype._horizontalMovementCheck = function() {
  let checkPositions = [];
  let cachedCheckPositions = [];
  let currentCachedCheckPositionIndex = 0;
  let _localGetCachedCheckPosition = function() {
    let item = null;
    while (cachedCheckPositions.length <= currentCachedCheckPositionIndex) {
      cachedCheckPositions.push(vec3_create());
    }
    item = cachedCheckPositions[currentCachedCheckPositionIndex];
    currentCachedCheckPositionIndex++;
    return item;
  };
  let _localGroundObjectsToIgnore = [];
  let _localCeilingObjectsToIgnore = [];
  let _localGroundCeilingObjectsToIgnore = [];
  let objectsEqualCallback = (first2, second) => first2.pp_equals(second);
  let movementDirection = vec3_create();
  let heightOffset = vec3_create();
  let heightStep = vec3_create();
  let currentHeightOffset = vec3_create();
  let leftRadialDirection = vec3_create();
  let rightRadialDirection = vec3_create();
  return function _horizontalMovementCheck(movement, originalFeetPosition, originalHeight, feetPosition, height, up, collisionCheckParams, collisionRuntimeParams) {
    this._myDebugEnabled = collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugHorizontalMovementEnabled;
    let halfConeAngle = Math.min(collisionCheckParams.myHalfConeAngle, 90);
    movementDirection = movement.vec3_normalize(movementDirection);
    checkPositions.length = 0;
    currentCachedCheckPositionIndex = 0;
    let steplength = collisionCheckParams.myRadius / collisionCheckParams.myHorizontalMovementRadialStepAmount;
    {
      let tempCheckPosition = _localGetCachedCheckPosition();
      tempCheckPosition.vec3_copy(feetPosition);
      checkPositions.push(tempCheckPosition);
    }
    {
      leftRadialDirection = movementDirection.vec3_rotateAxis(halfConeAngle, up, leftRadialDirection);
      rightRadialDirection = movementDirection.vec3_rotateAxis(-halfConeAngle, up, rightRadialDirection);
      for (let i = 1; i <= collisionCheckParams.myHorizontalMovementRadialStepAmount; i++) {
        {
          let currentStep = i * steplength;
          let tempCheckPosition = _localGetCachedCheckPosition();
          let currentRadialPosition = leftRadialDirection.vec3_scale(currentStep, tempCheckPosition);
          let currentCheckPosition = currentRadialPosition.vec3_add(feetPosition, currentRadialPosition);
          checkPositions.push(currentCheckPosition);
        }
        {
          let currentStep = i * steplength;
          let tempCheckPosition = _localGetCachedCheckPosition();
          let currentRadialPosition = rightRadialDirection.vec3_scale(currentStep, tempCheckPosition);
          let currentCheckPosition = currentRadialPosition.vec3_add(feetPosition, currentRadialPosition);
          checkPositions.push(currentCheckPosition);
        }
      }
    }
    let groundObjectsToIgnore = null;
    let ceilingObjectsToIgnore = null;
    let groundCeilingObjectsToIgnore = null;
    if (collisionCheckParams.myGroundAngleToIgnore > 0) {
      groundObjectsToIgnore = _localGroundObjectsToIgnore;
      groundObjectsToIgnore.length = 0;
      groundCeilingObjectsToIgnore = _localGroundCeilingObjectsToIgnore;
      groundCeilingObjectsToIgnore.length = 0;
      let ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, null, groundObjectsToIgnore, true, true, up, collisionCheckParams);
      let ignoreCeilingAngleCallback = null;
      if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
        ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, null, groundCeilingObjectsToIgnore, false, true, up, collisionCheckParams);
      }
      heightOffset.vec3_zero();
      this._horizontalMovementHorizontalCheck(movement, feetPosition, checkPositions, heightOffset, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
    }
    if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
      if (!collisionRuntimeParams.myIsCollidingHorizontally && collisionCheckParams.myCheckHeight) {
        ceilingObjectsToIgnore = _localCeilingObjectsToIgnore;
        ceilingObjectsToIgnore.length = 0;
        let ignoreGroundAngleCallback = null;
        if (collisionCheckParams.myGroundAngleToIgnore > 0) {
          ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, groundObjectsToIgnore, null, true, true, up, collisionCheckParams);
        }
        let ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, null, ceilingObjectsToIgnore, false, true, up, collisionCheckParams);
        heightOffset = up.vec3_scale(height, heightOffset);
        this._horizontalMovementHorizontalCheck(movement, feetPosition, checkPositions, heightOffset, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
      }
    }
    if (!collisionRuntimeParams.myIsCollidingHorizontally) {
      let groundCeilingCheckIsFine = true;
      if (groundCeilingObjectsToIgnore != null) {
        for (let object of groundCeilingObjectsToIgnore) {
          if (!ceilingObjectsToIgnore.pp_hasEqual(object, objectsEqualCallback)) {
            groundCeilingCheckIsFine = false;
            break;
          }
        }
      }
      let ignoreGroundAngleCallback = null;
      let ignoreCeilingAngleCallback = null;
      if (collisionCheckParams.myGroundAngleToIgnore > 0) {
        ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, groundObjectsToIgnore, null, true, true, up, collisionCheckParams);
      }
      if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
        ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, ceilingObjectsToIgnore, null, false, true, up, collisionCheckParams);
      }
      let heightStepAmount = 0;
      if (collisionCheckParams.myCheckHeight && collisionCheckParams.myHeightCheckStepAmountMovement > 0 && height > 1e-6) {
        heightStepAmount = collisionCheckParams.myHeightCheckStepAmountMovement;
        heightStep = up.vec3_scale(height / heightStepAmount, heightStep);
      }
      for (let i = 0; i <= heightStepAmount; i++) {
        currentHeightOffset = heightStep.vec3_scale(i, currentHeightOffset);
        if (collisionCheckParams.myCheckHeightTopMovement || i == 0) {
          if (i != 0 && i != heightStepAmount || i == 0 && !groundCeilingCheckIsFine || i == 0 && collisionCheckParams.myGroundAngleToIgnore == 0 || i == heightStepAmount && collisionCheckParams.myCeilingAngleToIgnore == 0) {
            this._horizontalMovementHorizontalCheck(movement, feetPosition, checkPositions, currentHeightOffset, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
            if (collisionRuntimeParams.myIsCollidingHorizontally) {
              break;
            }
          }
        }
        if (i > 0) {
          if (collisionCheckParams.myCheckHeightVerticalMovement) {
            this._horizontalMovementVerticalCheck(movement, feetPosition, checkPositions, currentHeightOffset, heightStep, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
          }
          if (collisionRuntimeParams.myIsCollidingHorizontally) {
            break;
          }
        }
      }
    }
    return !collisionRuntimeParams.myIsCollidingHorizontally;
  };
}();
CollisionCheck.prototype._horizontalMovementVerticalCheck = function() {
  let movementStep = vec3_create();
  let movementDirection = vec3_create();
  let firstPosition = vec3_create();
  let secondPosition = vec3_create();
  let firstMovementPosition = vec3_create();
  let secondMovementPosition = vec3_create();
  let firstHeightPosition = vec3_create();
  let secondHeightPosition = vec3_create();
  let firstHeightMovementPosition = vec3_create();
  let secondHeightMovementPosition = vec3_create();
  return function _horizontalMovementVerticalCheck(movement, feetPosition, checkPositions, heightOffset, heightStep, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
    let isHorizontalCheckOk = true;
    let movementStepAmount = 1;
    movementStep.vec3_copy(movement);
    if (collisionCheckParams.myHorizontalMovementStepEnabled) {
      movementStepAmount = Math.max(1, Math.ceil(movement.vec3_length() / collisionCheckParams.myHorizontalMovementStepMaxLength));
      movement.vec3_scale(1 / movementStepAmount, movementStep);
    }
    movementDirection = movement.vec3_normalize(movementDirection);
    for (let m = 0; m < movementStepAmount; m++) {
      for (let j = 0; j < checkPositions.length; j++) {
        firstPosition = checkPositions[j].vec3_add(movementStep.vec3_scale(m, firstPosition), firstPosition).vec3_add(heightOffset, firstPosition);
        if (j > 0) {
          let secondIndex = Math.max(0, j - 2);
          secondPosition = checkPositions[secondIndex].vec3_add(movementStep.vec3_scale(m, secondPosition), secondPosition).vec3_add(heightOffset, secondPosition);
          if (collisionCheckParams.myHorizontalMovementCheckVerticalDiagonalUpwardOutward) {
            firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
            secondHeightPosition = secondPosition.vec3_sub(heightStep, secondHeightPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              secondHeightPosition,
              firstMovementPosition,
              movementDirection,
              up,
              true,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              true,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckVerticalDiagonalUpwardInward) {
            secondMovementPosition = secondPosition.vec3_add(movementStep, secondMovementPosition);
            firstHeightPosition = firstPosition.vec3_sub(heightStep, firstHeightPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              firstHeightPosition,
              secondMovementPosition,
              movementDirection,
              up,
              true,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              true,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckVerticalDiagonalDownwardOutward) {
            firstHeightMovementPosition = firstPosition.vec3_add(movementStep, firstHeightMovementPosition);
            firstHeightMovementPosition = firstHeightMovementPosition.vec3_sub(heightStep, firstHeightMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              secondPosition,
              firstHeightMovementPosition,
              movementDirection,
              up,
              true,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              true,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckVerticalDiagonalDownwardInward) {
            secondHeightMovementPosition = secondPosition.vec3_add(movementStep, secondHeightMovementPosition);
            secondHeightMovementPosition = secondHeightMovementPosition.vec3_sub(heightStep, secondHeightMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              firstPosition,
              secondHeightMovementPosition,
              movementDirection,
              up,
              true,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              true,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
          if (m == 0) {
            if (collisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward) {
              secondHeightPosition = secondPosition.vec3_sub(heightStep, secondHeightPosition);
              isHorizontalCheckOk = this._horizontalCheckRaycast(
                secondHeightPosition,
                firstPosition,
                movementDirection,
                up,
                true,
                ignoreGroundAngleCallback,
                ignoreCeilingAngleCallback,
                feetPosition,
                true,
                collisionCheckParams,
                collisionRuntimeParams
              );
              if (!isHorizontalCheckOk)
                break;
            }
            if (collisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward) {
              let firstHeightPosition2 = firstPosition.vec3_sub(heightStep);
              isHorizontalCheckOk = this._horizontalCheckRaycast(
                firstHeightPosition2,
                secondPosition,
                movementDirection,
                up,
                true,
                ignoreGroundAngleCallback,
                ignoreCeilingAngleCallback,
                feetPosition,
                true,
                collisionCheckParams,
                collisionRuntimeParams
              );
              if (!isHorizontalCheckOk)
                break;
            }
          }
          if (collisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward) {
            firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
            secondHeightMovementPosition = secondPosition.vec3_sub(heightStep, secondHeightMovementPosition).vec3_add(movementStep, secondHeightMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              secondHeightMovementPosition,
              firstMovementPosition,
              movementDirection,
              up,
              true,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              true,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward) {
            secondMovementPosition = secondPosition.vec3_add(movementStep, secondMovementPosition);
            firstHeightMovementPosition = firstPosition.vec3_sub(heightStep, firstHeightMovementPosition).vec3_add(movementStep, firstHeightMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              firstHeightMovementPosition,
              secondMovementPosition,
              movementDirection,
              up,
              true,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              true,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
        }
        if (collisionCheckParams.myHorizontalMovementCheckVerticalStraight || collisionCheckParams.myHorizontalMovementHorizontalStraightCentralCheckEnabled && j == 0) {
          if (m == 0) {
            firstHeightPosition = firstPosition.vec3_sub(heightStep, firstHeightPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              firstHeightPosition,
              firstPosition,
              movementDirection,
              up,
              true,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              true,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
          {
            firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
            firstHeightMovementPosition = firstMovementPosition.vec3_sub(heightStep, firstHeightMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              firstHeightMovementPosition,
              firstMovementPosition,
              movementDirection,
              up,
              true,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              true,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
        }
        if (collisionCheckParams.myHorizontalMovementCheckVerticalStraightDiagonalUpward || collisionCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled && j == 0) {
          firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
          firstHeightPosition = firstPosition.vec3_sub(heightStep, firstHeightPosition);
          isHorizontalCheckOk = this._horizontalCheckRaycast(
            firstHeightPosition,
            firstMovementPosition,
            movementDirection,
            up,
            true,
            ignoreGroundAngleCallback,
            ignoreCeilingAngleCallback,
            feetPosition,
            true,
            collisionCheckParams,
            collisionRuntimeParams
          );
          if (!isHorizontalCheckOk)
            break;
        }
        if (collisionCheckParams.myHorizontalMovementCheckVerticalStraightDiagonalDownward || collisionCheckParams.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled && j == 0) {
          firstHeightMovementPosition = firstPosition.vec3_sub(heightStep, firstHeightMovementPosition).vec3_add(movementStep, firstHeightMovementPosition);
          isHorizontalCheckOk = this._horizontalCheckRaycast(
            firstPosition,
            firstHeightMovementPosition,
            movementDirection,
            up,
            true,
            ignoreGroundAngleCallback,
            ignoreCeilingAngleCallback,
            feetPosition,
            true,
            collisionCheckParams,
            collisionRuntimeParams
          );
          if (!isHorizontalCheckOk)
            break;
        }
        if (!isHorizontalCheckOk) {
          collisionRuntimeParams.myIsCollidingHorizontally = true;
          collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
          break;
        }
      }
    }
    return isHorizontalCheckOk;
  };
}();
CollisionCheck.prototype._horizontalMovementHorizontalCheck = function() {
  let movementStep = vec3_create();
  let movementDirection = vec3_create();
  let firstPosition = vec3_create();
  let secondPosition = vec3_create();
  let firstMovementPosition = vec3_create();
  let secondMovementPosition = vec3_create();
  return function _horizontalMovementHorizontalCheck(movement, feetPosition, checkPositions, heightOffset, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
    let isHorizontalCheckOk = true;
    let movementStepAmount = 1;
    movementStep.vec3_copy(movement);
    if (collisionCheckParams.myHorizontalMovementStepEnabled) {
      movementStepAmount = Math.max(1, Math.ceil(movement.vec3_length() / collisionCheckParams.myHorizontalMovementStepMaxLength));
      movement.vec3_scale(1 / movementStepAmount, movementStep);
    }
    movementDirection = movement.vec3_normalize(movementDirection);
    for (let m = 0; m < movementStepAmount; m++) {
      for (let j = 0; j < checkPositions.length; j++) {
        firstPosition = checkPositions[j].vec3_add(movementStep.vec3_scale(m, firstPosition), firstPosition).vec3_add(heightOffset, firstPosition);
        if (j > 0) {
          let secondIndex = Math.max(0, j - 2);
          secondPosition = checkPositions[secondIndex].vec3_add(movementStep.vec3_scale(m, secondPosition), secondPosition).vec3_add(heightOffset, secondPosition);
          if (collisionCheckParams.myHorizontalMovementCheckDiagonalOutward) {
            firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              secondPosition,
              firstMovementPosition,
              movementDirection,
              up,
              true,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              true,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckDiagonalInward) {
            secondMovementPosition = secondPosition.vec3_add(movementStep, secondMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              firstPosition,
              secondMovementPosition,
              movementDirection,
              up,
              true,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              true,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckHorizontalBorder) {
            if (m == 0) {
              isHorizontalCheckOk = this._horizontalCheckRaycast(
                secondPosition,
                firstPosition,
                movementDirection,
                up,
                true,
                ignoreGroundAngleCallback,
                ignoreCeilingAngleCallback,
                feetPosition,
                true,
                collisionCheckParams,
                collisionRuntimeParams
              );
              if (!isHorizontalCheckOk)
                break;
            }
            {
              firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
              secondMovementPosition = secondPosition.vec3_add(movementStep, secondMovementPosition);
              isHorizontalCheckOk = this._horizontalCheckRaycast(
                secondMovementPosition,
                firstMovementPosition,
                movementDirection,
                up,
                true,
                ignoreGroundAngleCallback,
                ignoreCeilingAngleCallback,
                feetPosition,
                true,
                collisionCheckParams,
                collisionRuntimeParams
              );
              if (!isHorizontalCheckOk)
                break;
            }
          }
        }
        if (collisionCheckParams.myHorizontalMovementCheckStraight || collisionCheckParams.myHorizontalMovementVerticalStraightCentralCheckEnabled && j == 0) {
          firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
          isHorizontalCheckOk = this._horizontalCheckRaycast(
            firstPosition,
            firstMovementPosition,
            null,
            up,
            true,
            ignoreGroundAngleCallback,
            ignoreCeilingAngleCallback,
            feetPosition,
            true,
            collisionCheckParams,
            collisionRuntimeParams
          );
          if (!isHorizontalCheckOk)
            break;
        }
      }
      if (!isHorizontalCheckOk) {
        collisionRuntimeParams.myIsCollidingHorizontally = true;
        collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
        break;
      }
    }
    return isHorizontalCheckOk;
  };
}();
Object.defineProperty(CollisionCheck.prototype, "_horizontalMovementCheck", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_horizontalMovementVerticalCheck", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_horizontalMovementHorizontalCheck", { enumerable: false });

// js/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/horizontal_collision_position_check.js
CollisionCheck.prototype._horizontalPositionCheck = function() {
  let checkPositions = [];
  let cachedCheckPositions = [];
  let currentCachedCheckPositionIndex = 0;
  let _localGetCachedCheckPosition = function() {
    let item = null;
    while (cachedCheckPositions.length <= currentCachedCheckPositionIndex) {
      cachedCheckPositions.push(vec3_create());
    }
    item = cachedCheckPositions[currentCachedCheckPositionIndex];
    currentCachedCheckPositionIndex++;
    return item;
  };
  let _localGroundObjectsToIgnore = [];
  let _localCeilingObjectsToIgnore = [];
  let _localGroundCeilingObjectsToIgnore = [];
  let objectsEqualCallback = (first2, second) => first2.pp_equals(second);
  let heightOffset = vec3_create();
  let heightStep = vec3_create();
  let currentHeightOffset = vec3_create();
  let hitHeightOffset = vec3_create();
  let hitHeightOffsetEpsilon = vec3_create();
  let downwardHeightOffset = vec3_create();
  let downwardHeightStep = vec3_create();
  let verticalDirection = vec3_create();
  let vertilCheckHit = new RaycastHit();
  return function _horizontalPositionCheck(originalFeetPosition, originalHeight, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams) {
    this._myDebugEnabled = collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugHorizontalPositionEnabled;
    checkPositions.length = 0;
    currentCachedCheckPositionIndex = 0;
    let halfConeAngle = Math.min(collisionCheckParams.myHalfConeAngle, 180);
    let sliceAngle = halfConeAngle / collisionCheckParams.myHalfConeSliceAmount;
    let tempCheckPosition = _localGetCachedCheckPosition();
    checkPositions.push(feetPosition.vec3_add(forward.vec3_scale(collisionCheckParams.myRadius, tempCheckPosition), tempCheckPosition));
    for (let i = 1; i <= collisionCheckParams.myHalfConeSliceAmount; i++) {
      let currentAngle = i * sliceAngle;
      tempCheckPosition = _localGetCachedCheckPosition();
      let radialDirection = forward.vec3_rotateAxis(-currentAngle, up, tempCheckPosition);
      checkPositions.push(feetPosition.vec3_add(radialDirection.vec3_scale(collisionCheckParams.myRadius, radialDirection), radialDirection));
      tempCheckPosition = _localGetCachedCheckPosition();
      radialDirection = forward.vec3_rotateAxis(currentAngle, up, tempCheckPosition);
      checkPositions.push(feetPosition.vec3_add(radialDirection.vec3_scale(collisionCheckParams.myRadius, radialDirection), radialDirection));
    }
    let groundObjectsToIgnore = null;
    let ceilingObjectsToIgnore = null;
    let groundCeilingObjectsToIgnore = null;
    if (collisionCheckParams.myGroundAngleToIgnore > 0) {
      groundObjectsToIgnore = _localGroundObjectsToIgnore;
      groundObjectsToIgnore.length = 0;
      groundCeilingObjectsToIgnore = _localGroundCeilingObjectsToIgnore;
      groundCeilingObjectsToIgnore.length = 0;
      let ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, null, groundObjectsToIgnore, true, false, up, collisionCheckParams);
      let ignoreCeilingAngleCallback = null;
      if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
        ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, null, groundCeilingObjectsToIgnore, false, false, up, collisionCheckParams);
      }
      heightOffset.vec3_zero();
      this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, heightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
    }
    if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
      if (!collisionRuntimeParams.myIsCollidingHorizontally && collisionCheckParams.myCheckHeight) {
        ceilingObjectsToIgnore = _localCeilingObjectsToIgnore;
        ceilingObjectsToIgnore.length = 0;
        let ignoreGroundAngleCallback = null;
        if (collisionCheckParams.myGroundAngleToIgnore > 0) {
          ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, groundObjectsToIgnore, null, true, false, up, collisionCheckParams);
        }
        let ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, null, ceilingObjectsToIgnore, false, false, up, collisionCheckParams);
        heightOffset = up.vec3_scale(height, heightOffset);
        this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, heightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
      }
    }
    if (!collisionRuntimeParams.myIsCollidingHorizontally) {
      let groundCeilingCheckIsFine = true;
      if (groundCeilingObjectsToIgnore != null) {
        for (let object of groundCeilingObjectsToIgnore) {
          if (!ceilingObjectsToIgnore.pp_hasEqual(object, objectsEqualCallback)) {
            groundCeilingCheckIsFine = false;
            break;
          }
        }
      }
      let ignoreGroundAngleCallback = null;
      let ignoreCeilingAngleCallback = null;
      if (collisionCheckParams.myGroundAngleToIgnore > 0) {
        ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, groundObjectsToIgnore, null, true, false, up, collisionCheckParams);
      }
      if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
        ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, ceilingObjectsToIgnore, null, false, false, up, collisionCheckParams);
      }
      let heightStepAmount = 0;
      if (collisionCheckParams.myCheckHeight && collisionCheckParams.myHeightCheckStepAmountPosition > 0 && height > 0) {
        heightStepAmount = collisionCheckParams.myHeightCheckStepAmountPosition;
        up.vec3_scale(height / heightStepAmount, heightStep);
      }
      for (let i = 0; i <= heightStepAmount; i++) {
        currentHeightOffset = heightStep.vec3_scale(i, currentHeightOffset);
        if (collisionCheckParams.myCheckHeightTopPosition || i == 0) {
          if (i != 0 && i != heightStepAmount || i == 0 && !groundCeilingCheckIsFine || i == 0 && collisionCheckParams.myGroundAngleToIgnore == 0 || i != 0 && i == heightStepAmount && collisionCheckParams.myCeilingAngleToIgnore == 0) {
            this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, currentHeightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
            if (collisionRuntimeParams.myIsCollidingHorizontally) {
              break;
            }
          }
        }
        if (i > 0) {
          if (collisionCheckParams.myCheckHeightVerticalPosition) {
            let hitHeightOffsetEpsilonValue = 1e-4;
            if (collisionCheckParams.myHorizontalPositionCheckVerticalDirectionType == 0 || collisionCheckParams.myHorizontalPositionCheckVerticalDirectionType == 2) {
              verticalDirection.vec3_copy(up);
              this._horizontalPositionVerticalCheck(feetPosition, checkPositions, currentHeightOffset, heightStep, verticalDirection, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
              if (collisionRuntimeParams.myIsCollidingHorizontally && collisionCheckParams.myCheckHeightConeOnCollision) {
                hitHeightOffset = collisionRuntimeParams.myHorizontalCollisionHit.myPosition.vec3_sub(feetPosition, hitHeightOffset).vec3_componentAlongAxis(up, hitHeightOffset);
                hitHeightOffset.vec3_add(verticalDirection.vec3_scale(hitHeightOffsetEpsilonValue, hitHeightOffsetEpsilon), hitHeightOffset);
                collisionRuntimeParams.myIsCollidingHorizontally = false;
                if (collisionCheckParams.myCheckHeightConeOnCollisionKeepHit) {
                  vertilCheckHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
                }
                collisionRuntimeParams.myHorizontalCollisionHit.reset();
                this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, hitHeightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
                if (collisionRuntimeParams.myIsCollidingHorizontally) {
                  break;
                } else if (collisionCheckParams.myCheckHeightConeOnCollisionKeepHit) {
                  collisionRuntimeParams.myIsCollidingHorizontally = true;
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(vertilCheckHit);
                  break;
                }
              }
            }
            if (!collisionRuntimeParams.myIsCollidingHorizontally) {
              if (collisionCheckParams.myHorizontalPositionCheckVerticalDirectionType == 1 || collisionCheckParams.myHorizontalPositionCheckVerticalDirectionType == 2) {
                verticalDirection = up.vec3_negate(verticalDirection);
                downwardHeightOffset = currentHeightOffset.vec3_sub(heightStep, downwardHeightOffset);
                downwardHeightStep = heightStep.vec3_negate(downwardHeightStep);
                this._horizontalPositionVerticalCheck(feetPosition, checkPositions, downwardHeightOffset, downwardHeightStep, verticalDirection, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
              }
              if (collisionRuntimeParams.myIsCollidingHorizontally && collisionCheckParams.myCheckHeightConeOnCollision) {
                hitHeightOffset = collisionRuntimeParams.myHorizontalCollisionHit.myPosition.vec3_sub(feetPosition, hitHeightOffset).vec3_componentAlongAxis(up, hitHeightOffset);
                hitHeightOffset.vec3_add(verticalDirection.vec3_scale(hitHeightOffsetEpsilonValue, hitHeightOffsetEpsilon), hitHeightOffset);
                collisionRuntimeParams.myIsCollidingHorizontally = false;
                if (collisionCheckParams.myCheckHeightConeOnCollisionKeepHit) {
                  vertilCheckHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
                }
                collisionRuntimeParams.myHorizontalCollisionHit.reset();
                this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, hitHeightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
                if (collisionRuntimeParams.myIsCollidingHorizontally) {
                  break;
                } else if (collisionCheckParams.myCheckHeightConeOnCollisionKeepHit) {
                  collisionRuntimeParams.myIsCollidingHorizontally = true;
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(vertilCheckHit);
                  break;
                }
              }
            }
          }
        }
      }
    }
    return !collisionRuntimeParams.myIsCollidingHorizontally;
  };
}();
CollisionCheck.prototype._horizontalPositionHorizontalCheck = function() {
  let basePosition = vec3_create();
  let forwardNegate = vec3_create();
  let currentRadialPosition = vec3_create();
  let previousRadialPosition = vec3_create();
  return function _horizontalPositionHorizontalCheck(feetPosition, checkPositions, heightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
    let isHorizontalCheckOk = true;
    basePosition = feetPosition.vec3_add(heightOffset, basePosition);
    let halfRadialPositions = Math.floor(checkPositions.length / 2) + 1;
    for (let j = 0; j < halfRadialPositions; j++) {
      if (j > 0) {
        let leftIndex = Math.max(0, j * 2);
        let rightIndex = Math.max(0, j * 2 - 1);
        let leftAndRightEqual = checkPositions[leftIndex].vec_equals(checkPositions[rightIndex], 1e-6);
        if (collisionCheckParams.myCheckConeBorder) {
          for (let r = 0; r < 2; r++) {
            let currentIndex = r == 0 ? leftIndex : rightIndex;
            currentRadialPosition = checkPositions[currentIndex].vec3_add(heightOffset, currentRadialPosition);
            let previousIndex = Math.max(0, currentIndex - 2);
            previousRadialPosition = checkPositions[previousIndex].vec3_add(heightOffset, previousRadialPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              previousRadialPosition,
              currentRadialPosition,
              forward.vec3_negate(forwardNegate),
              up,
              true,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              true,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
        }
        if (collisionCheckParams.myCheckConeRay && isHorizontalCheckOk) {
          for (let r = 0; r < 2; r++) {
            if (r == 1 && leftAndRightEqual) {
              break;
            }
            let currentIndex = r == 0 ? leftIndex : rightIndex;
            currentRadialPosition = checkPositions[currentIndex].vec3_add(heightOffset, currentRadialPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(
              basePosition,
              currentRadialPosition,
              null,
              up,
              false,
              ignoreGroundAngleCallback,
              ignoreCeilingAngleCallback,
              feetPosition,
              false,
              collisionCheckParams,
              collisionRuntimeParams
            );
            if (!isHorizontalCheckOk)
              break;
          }
        }
      } else {
        if (collisionCheckParams.myCheckConeRay) {
          currentRadialPosition = checkPositions[j].vec3_add(heightOffset, currentRadialPosition);
          isHorizontalCheckOk = this._horizontalCheckRaycast(
            basePosition,
            currentRadialPosition,
            null,
            up,
            false,
            ignoreGroundAngleCallback,
            ignoreCeilingAngleCallback,
            feetPosition,
            false,
            collisionCheckParams,
            collisionRuntimeParams
          );
          if (!isHorizontalCheckOk)
            break;
        }
      }
      if (!isHorizontalCheckOk) {
        break;
      }
    }
    if (!isHorizontalCheckOk) {
      collisionRuntimeParams.myIsCollidingHorizontally = true;
      collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
    }
    return isHorizontalCheckOk;
  };
}();
CollisionCheck.prototype._horizontalPositionVerticalCheck = function() {
  let basePosition = vec3_create();
  let previousBasePosition = vec3_create();
  let currentRadialPosition = vec3_create();
  let previousRadialPosition = vec3_create();
  let previousCurrentRadialPosition = vec3_create();
  let previousPreviousRadialPosition = vec3_create();
  return function _horizontalPositionVerticalCheck(feetPosition, checkPositions, heightOffset, heightStep, verticalDirection, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
    let isHorizontalCheckOk = true;
    basePosition = feetPosition.vec3_add(heightOffset, basePosition);
    previousBasePosition = basePosition.vec3_sub(heightStep, previousBasePosition);
    for (let j = 0; j <= checkPositions.length; j++) {
      let previousCheckPositionIsEqual = false;
      if (j == checkPositions.length) {
        currentRadialPosition.vec3_copy(basePosition);
        previousRadialPosition.vec3_copy(previousBasePosition);
      } else {
        currentRadialPosition = checkPositions[j].vec3_add(heightOffset, currentRadialPosition);
        previousRadialPosition = currentRadialPosition.vec3_sub(heightStep, previousRadialPosition);
        if (j > 0) {
          previousCheckPositionIsEqual = checkPositions[j].vec_equals(checkPositions[j - 1], 1e-6);
        }
      }
      if (collisionCheckParams.myCheckVerticalStraight && !previousCheckPositionIsEqual) {
        isHorizontalCheckOk = this._horizontalCheckRaycast(
          previousRadialPosition,
          currentRadialPosition,
          null,
          up,
          collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision,
          ignoreGroundAngleCallback,
          ignoreCeilingAngleCallback,
          feetPosition,
          true,
          collisionCheckParams,
          collisionRuntimeParams,
          true,
          true
        );
        if (!isHorizontalCheckOk) {
          if (!collisionRuntimeParams.myIsCollidingHorizontally) {
            collisionRuntimeParams.myIsCollidingHorizontally = true;
            collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
          } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
            collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
          }
          if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
            break;
          }
        }
      }
      if (j < checkPositions.length) {
        if ((collisionCheckParams.myCheckVerticalDiagonalRayOutward || collisionCheckParams.myCheckVerticalDiagonalBorderRayOutward && (j == checkPositions.length - 2 || j == checkPositions.length - 1)) && !previousCheckPositionIsEqual) {
          isHorizontalCheckOk = this._horizontalCheckRaycast(
            previousBasePosition,
            currentRadialPosition,
            null,
            up,
            collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision,
            ignoreGroundAngleCallback,
            ignoreCeilingAngleCallback,
            feetPosition,
            true,
            collisionCheckParams,
            collisionRuntimeParams,
            true,
            true
          );
          if (!isHorizontalCheckOk) {
            if (!collisionRuntimeParams.myIsCollidingHorizontally) {
              collisionRuntimeParams.myIsCollidingHorizontally = true;
              collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
            } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
              collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
            }
            if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
              break;
            }
          }
        }
        if ((collisionCheckParams.myCheckVerticalDiagonalRayInward || collisionCheckParams.myCheckVerticalDiagonalBorderRayInward && (j == checkPositions.length - 2 || j == checkPositions.length - 1)) && !previousCheckPositionIsEqual) {
          isHorizontalCheckOk = this._horizontalCheckRaycast(
            previousRadialPosition,
            basePosition,
            null,
            up,
            collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision,
            ignoreGroundAngleCallback,
            ignoreCeilingAngleCallback,
            feetPosition,
            true,
            collisionCheckParams,
            collisionRuntimeParams,
            true,
            true
          );
          if (!isHorizontalCheckOk) {
            if (!collisionRuntimeParams.myIsCollidingHorizontally) {
              collisionRuntimeParams.myIsCollidingHorizontally = true;
              collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
            } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
              collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
            }
            if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
              break;
            }
          }
        }
        if (j > 0) {
          if (collisionCheckParams.myCheckVerticalDiagonalBorderOutward || collisionCheckParams.myCheckVerticalDiagonalBorderInward) {
            let previousIndex = Math.max(0, j - 2);
            previousCurrentRadialPosition = checkPositions[previousIndex].vec3_add(heightOffset, previousCurrentRadialPosition);
            previousPreviousRadialPosition = previousCurrentRadialPosition.vec3_sub(heightStep, previousPreviousRadialPosition);
            if (collisionCheckParams.myCheckVerticalDiagonalBorderOutward) {
              isHorizontalCheckOk = this._horizontalCheckRaycast(
                previousPreviousRadialPosition,
                currentRadialPosition,
                null,
                up,
                collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision,
                ignoreGroundAngleCallback,
                ignoreCeilingAngleCallback,
                feetPosition,
                true,
                collisionCheckParams,
                collisionRuntimeParams,
                true,
                true
              );
              if (!isHorizontalCheckOk) {
                if (!collisionRuntimeParams.myIsCollidingHorizontally) {
                  collisionRuntimeParams.myIsCollidingHorizontally = true;
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                }
                if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
                  break;
                }
              }
            }
            if (collisionCheckParams.myCheckVerticalDiagonalBorderInward) {
              isHorizontalCheckOk = this._horizontalCheckRaycast(
                previousRadialPosition,
                previousCurrentRadialPosition,
                null,
                up,
                collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision,
                ignoreGroundAngleCallback,
                ignoreCeilingAngleCallback,
                feetPosition,
                true,
                collisionCheckParams,
                collisionRuntimeParams,
                true,
                true
              );
              if (!isHorizontalCheckOk) {
                if (!collisionRuntimeParams.myIsCollidingHorizontally) {
                  collisionRuntimeParams.myIsCollidingHorizontally = true;
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                }
                if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
                  break;
                }
              }
            }
          }
        }
      }
    }
    return !collisionRuntimeParams.myIsCollidingHorizontally;
  };
}();
Object.defineProperty(CollisionCheck.prototype, "_horizontalPositionCheck", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_horizontalPositionHorizontalCheck", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_horizontalPositionVerticalCheck", { enumerable: false });

// js/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/vertical_collision_check.js
CollisionCheck.prototype._verticalCheck = function() {
  let newFeetPosition = vec3_create();
  let additionalFixedMovement = vec3_create();
  let zero7 = vec3_create(0, 0, 0);
  return function _verticalCheck(verticalMovement, originalMovementSign, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, outFixedMovement) {
    collisionRuntimeParams.myIsCollidingVertically = false;
    collisionRuntimeParams.myVerticalCollisionHit.reset();
    let movementSign = Math.pp_sign(verticalMovement.vec3_lengthSigned(up), -1);
    let isMovementDownward = movementSign < 0;
    outFixedMovement.vec3_copy(verticalMovement);
    if (collisionCheckParams.myVerticalMovementCheckEnabled) {
      outFixedMovement = this._verticalMovementAdjustment(verticalMovement, isMovementDownward, originalMovementSign, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, outFixedMovement);
      if (collisionCheckParams.myCheckVerticalBothDirection && (outFixedMovement.vec_equals(verticalMovement, 1e-5) || originalMovementSign == 0 || movementSign != originalMovementSign)) {
        newFeetPosition = feetPosition.vec3_add(outFixedMovement, newFeetPosition);
        let isOppositeMovementDownward = !isMovementDownward;
        additionalFixedMovement = this._verticalMovementAdjustment(zero7, isOppositeMovementDownward, originalMovementSign, newFeetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, additionalFixedMovement);
        outFixedMovement.vec3_add(additionalFixedMovement, outFixedMovement);
        isMovementDownward = !isMovementDownward;
      }
    }
    if (collisionCheckParams.myVerticalPositionCheckEnabled) {
      newFeetPosition = feetPosition.vec3_add(outFixedMovement, newFeetPosition);
      let canStay = this._verticalPositionCheck(newFeetPosition, isMovementDownward, height, up, forward, collisionCheckParams, collisionRuntimeParams);
      if (!canStay) {
        outFixedMovement.vec3_zero();
        collisionRuntimeParams.myHasSnappedOnGround = false;
        collisionRuntimeParams.myHasSnappedOnCeiling = false;
        collisionRuntimeParams.myHasPoppedOutGround = false;
        collisionRuntimeParams.myHasPoppedOutCeiling = false;
        collisionRuntimeParams.myHasReducedVerticalMovement = false;
      }
    }
    return outFixedMovement;
  };
}();
CollisionCheck.prototype._verticalMovementAdjustment = function() {
  let startOffset = vec3_create();
  let endOffset = vec3_create();
  let tempVector = vec3_create();
  let furtherDirection = vec3_create();
  let furtherDirectionPosition = vec3_create();
  let upNegate = vec3_create();
  let origin = vec3_create();
  let direction2 = vec3_create();
  return function _verticalMovementAdjustment(verticalMovement, isMovementDownward, originalMovementSign, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, outFixedMovement) {
    this._myDebugEnabled = collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugVerticalMovementEnabled;
    startOffset.vec3_zero();
    endOffset.vec3_zero();
    let popOutEnabled = false;
    let snapEnabled = false;
    if (isMovementDownward) {
      startOffset.vec3_zero();
      endOffset.vec3_copy(verticalMovement);
      if (collisionCheckParams.myGroundPopOutExtraDistance > 0 && collisionCheckParams.myGroundPopOutEnabled) {
        startOffset.vec3_add(up.vec3_scale(collisionCheckParams.myGroundPopOutExtraDistance + 1e-5, tempVector), startOffset);
        popOutEnabled = true;
      }
    } else {
      startOffset = up.vec3_scale(height, startOffset);
      endOffset = up.vec3_scale(height, endOffset).vec3_add(verticalMovement, endOffset);
      if (collisionCheckParams.myCeilingPopOutExtraDistance > 0 && collisionCheckParams.myCeilingPopOutEnabled) {
        startOffset.vec3_add(up.vec3_scale(-collisionCheckParams.myCeilingPopOutExtraDistance - 1e-5, tempVector), startOffset);
        popOutEnabled = true;
      }
    }
    if (isMovementDownward && originalMovementSign <= 0 && this._myPrevCollisionRuntimeParams.myIsOnGround && collisionCheckParams.mySnapOnGroundEnabled && collisionCheckParams.mySnapOnGroundExtraDistance > 0) {
      endOffset.vec3_add(up.vec3_scale(-collisionCheckParams.mySnapOnGroundExtraDistance - 1e-5, tempVector), endOffset);
      snapEnabled = true;
    } else if (!isMovementDownward && this._myPrevCollisionRuntimeParams.myIsOnCeiling && collisionCheckParams.mySnapOnCeilingEnabled && collisionCheckParams.mySnapOnCeilingExtraDistance > 0 && (originalMovementSign > 0 || originalMovementSign == 0 && (!this._myPrevCollisionRuntimeParams.myIsOnGround || !collisionCheckParams.mySnapOnGroundEnabled))) {
      endOffset.vec3_add(up.vec3_scale(collisionCheckParams.mySnapOnCeilingExtraDistance + 1e-5, tempVector), endOffset);
      snapEnabled = true;
    }
    outFixedMovement.vec3_zero();
    if (startOffset.vec3_distance(endOffset) > 1e-5) {
      let checkPositions = this._getVerticalCheckPositions(feetPosition, up, forward, collisionCheckParams, collisionRuntimeParams);
      furtherDirection.vec3_copy(up);
      if (!isMovementDownward) {
        furtherDirection.vec3_negate(furtherDirection);
      }
      let furtherDirectionPositionSet = false;
      for (let i = 0; i < checkPositions.length; i++) {
        let currentPosition = checkPositions[i];
        origin = currentPosition.vec3_add(startOffset, origin);
        direction2 = currentPosition.vec3_add(endOffset, direction2).vec3_sub(origin, direction2);
        let distance5 = direction2.vec3_length();
        direction2.vec3_normalize(direction2);
        let raycastResult = this._raycastAndDebug(origin, direction2, distance5, true, false, collisionCheckParams, collisionRuntimeParams);
        if (raycastResult.myHits.length > 0) {
          if (furtherDirectionPositionSet) {
            if (raycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(furtherDirectionPosition, furtherDirection)) {
              furtherDirectionPosition.vec3_copy(raycastResult.myHits[0].myPosition);
            }
          } else {
            furtherDirectionPositionSet = true;
            furtherDirectionPosition.vec3_copy(raycastResult.myHits[0].myPosition);
          }
        }
      }
      if (furtherDirectionPositionSet) {
        upNegate = up.vec3_negate(upNegate);
        if (isMovementDownward) {
          outFixedMovement = furtherDirectionPosition.vec3_sub(feetPosition, outFixedMovement).vec3_componentAlongAxis(up, outFixedMovement);
          if (snapEnabled && outFixedMovement.vec3_isFartherAlongAxis(verticalMovement, upNegate)) {
            collisionRuntimeParams.myHasSnappedOnGround = true;
          } else if (popOutEnabled && outFixedMovement.vec3_isFartherAlongAxis(verticalMovement, up)) {
            if (!outFixedMovement.vec3_isZero(1e-5) && (verticalMovement.vec3_isZero(1e-5) || !outFixedMovement.vec3_isConcordant(verticalMovement))) {
              collisionRuntimeParams.myHasPoppedOutGround = true;
            } else {
              collisionRuntimeParams.myHasReducedVerticalMovement = true;
            }
          } else {
            collisionRuntimeParams.myHasReducedVerticalMovement = true;
          }
        } else {
          outFixedMovement = furtherDirectionPosition.vec3_sub(feetPosition.vec3_add(up.vec3_scale(height, outFixedMovement), outFixedMovement), outFixedMovement).vec3_componentAlongAxis(up, outFixedMovement);
          if (snapEnabled && outFixedMovement.vec3_isFartherAlongAxis(verticalMovement, up)) {
            collisionRuntimeParams.myHasSnappedOnCeiling = true;
          } else if (popOutEnabled && outFixedMovement.vec3_isFartherAlongAxis(verticalMovement, upNegate)) {
            if (!outFixedMovement.vec3_isZero(1e-5) && (verticalMovement.vec3_isZero(1e-5) || !outFixedMovement.vec3_isConcordant(verticalMovement))) {
              collisionRuntimeParams.myHasPoppedOutCeiling = true;
            } else {
              collisionRuntimeParams.myHasReducedVerticalMovement = true;
            }
          } else {
            collisionRuntimeParams.myHasReducedVerticalMovement = true;
          }
        }
        if (!popOutEnabled && !outFixedMovement.vec3_isConcordant(verticalMovement)) {
          outFixedMovement.vec3_zero();
        }
        if (!collisionCheckParams.myVerticalMovementReduceEnabled && collisionRuntimeParams.myHasReducedVerticalMovement) {
          outFixedMovement.vec3_copy(verticalMovement);
          collisionRuntimeParams.myHasReducedVerticalMovement = false;
        }
      } else {
        outFixedMovement.vec3_copy(verticalMovement);
      }
    } else {
      outFixedMovement.vec3_copy(verticalMovement);
    }
    if (outFixedMovement.vec3_length() < 1e-5) {
      outFixedMovement.vec3_zero();
    }
    return outFixedMovement;
  };
}();
CollisionCheck.prototype._verticalPositionCheck = function() {
  let smallHeightFixOffset = vec3_create();
  let heightOffset = vec3_create();
  let startPosition = vec3_create();
  let endPosition = vec3_create();
  let direction2 = vec3_create();
  return function _verticalPositionCheck(feetPosition, checkUpward, height, up, forward, collisionCheckParams, collisionRuntimeParams) {
    if (height < 1e-5) {
      return true;
    }
    this._myDebugEnabled = collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugVerticalPositionEnabled;
    let checkPositions = this._getVerticalCheckPositions(feetPosition, up, forward, collisionCheckParams, collisionRuntimeParams);
    let isVerticalPositionOk = true;
    let atLeastOneIsOk = false;
    let adjustmentEpsilon = 1e-4;
    smallHeightFixOffset = up.vec3_scale(adjustmentEpsilon, smallHeightFixOffset);
    heightOffset = up.vec3_scale(height - adjustmentEpsilon, heightOffset);
    if (height - adjustmentEpsilon < adjustmentEpsilon * 10) {
      heightOffset = up.vec3_scale(adjustmentEpsilon * 10, heightOffset);
    }
    let insideHitSet = false;
    for (let i = 0; i < checkPositions.length; i++) {
      let currentPosition = checkPositions[i];
      if (checkUpward) {
        startPosition = currentPosition.vec3_add(smallHeightFixOffset, startPosition);
        endPosition = currentPosition.vec3_add(heightOffset, endPosition);
      } else {
        startPosition = currentPosition.vec3_add(heightOffset, startPosition);
        endPosition = currentPosition.vec3_add(smallHeightFixOffset, endPosition);
      }
      let origin = startPosition;
      direction2 = endPosition.vec3_sub(origin, direction2);
      let distance5 = direction2.vec3_length();
      direction2.vec3_normalize(direction2);
      let raycastResult = this._raycastAndDebug(origin, direction2, distance5, false, false, collisionCheckParams, collisionRuntimeParams);
      if (raycastResult.isColliding()) {
        let firstHitOutsideCollision = raycastResult.getFirstHitOutsideCollision();
        if (firstHitOutsideCollision != null) {
          isVerticalPositionOk = false;
          collisionRuntimeParams.myVerticalCollisionHit.copy(firstHitOutsideCollision);
          break;
        } else if (!insideHitSet) {
          insideHitSet = true;
          collisionRuntimeParams.myVerticalCollisionHit.copy(raycastResult.myHits[0]);
          if (!collisionCheckParams.myVerticalAllowHitInsideCollisionIfOneOk) {
            isVerticalPositionOk = false;
            break;
          }
        }
      } else {
        atLeastOneIsOk = true;
      }
    }
    collisionRuntimeParams.myIsCollidingVertically = !isVerticalPositionOk || !atLeastOneIsOk;
    return !collisionRuntimeParams.myIsCollidingVertically;
  };
}();
CollisionCheck.prototype._getVerticalCheckPositions = function() {
  let checkPositions = [];
  let cachedCheckPositions = [];
  let currentCachedCheckPositionIndex = 0;
  let _localGetCachedCheckPosition = function() {
    let item = null;
    while (cachedCheckPositions.length <= currentCachedCheckPositionIndex) {
      cachedCheckPositions.push(vec3_create());
    }
    item = cachedCheckPositions[currentCachedCheckPositionIndex];
    currentCachedCheckPositionIndex++;
    return item;
  };
  let currentDirection = vec3_create();
  return function _getVerticalCheckPositions(feetPosition, up, forward, collisionCheckParams, collisionRuntimeParams) {
    checkPositions.length = 0;
    currentCachedCheckPositionIndex = 0;
    if (collisionCheckParams.myGroundCircumferenceAddCenter) {
      let tempCheckPosition = _localGetCachedCheckPosition();
      tempCheckPosition.vec3_copy(feetPosition);
      checkPositions.push(tempCheckPosition);
    }
    let radiusStep = collisionCheckParams.myFeetRadius / collisionCheckParams.myGroundCircumferenceStepAmount;
    let sliceAngle = 360 / collisionCheckParams.myGroundCircumferenceSliceAmount;
    let currentStepRotation = 0;
    for (let i = 0; i < collisionCheckParams.myGroundCircumferenceStepAmount; i++) {
      let currentRadius = radiusStep * (i + 1);
      currentDirection = forward.vec3_rotateAxis(currentStepRotation, up, currentDirection);
      for (let j = 0; j < collisionCheckParams.myGroundCircumferenceSliceAmount; j++) {
        let tempCheckPosition = _localGetCachedCheckPosition();
        let sliceDirection = currentDirection.vec3_rotateAxis(sliceAngle * j, up, tempCheckPosition);
        checkPositions.push(feetPosition.vec3_add(sliceDirection.vec3_scale(currentRadius, sliceDirection), sliceDirection));
      }
      currentStepRotation += collisionCheckParams.myGroundCircumferenceRotationPerStep;
    }
    return checkPositions;
  };
}();
Object.defineProperty(CollisionCheck.prototype, "_verticalCheck", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_verticalMovementAdjustment", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_verticalPositionCheck", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_getVerticalCheckPositions", { enumerable: false });

// js/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_surface_check.js
CollisionCheck.prototype._updateSurfaceInfo = function() {
  let transformUp = vec3_create();
  let transformForward = vec3_create();
  let feetPosition = vec3_create();
  let transformOffsetLocalQuat = quat2_create();
  let offsetTransformQuat = quat2_create();
  let forwardForPerceivedAngle = vec3_create();
  let forwardForVertical = vec3_create();
  let zAxis = vec3_create(0, 0, 1);
  let xAxis = vec3_create(1, 0, 0);
  return function _updateSurfaceInfo(transformQuat4, collisionCheckParams, collisionRuntimeParams) {
    transformOffsetLocalQuat.quat2_setPositionRotationQuat(collisionCheckParams.myPositionOffsetLocal, collisionCheckParams.myRotationOffsetLocalQuat);
    offsetTransformQuat = transformOffsetLocalQuat.quat2_toWorld(transformQuat4, offsetTransformQuat);
    if (transformQuat4.vec_equals(offsetTransformQuat, 1e-5)) {
      offsetTransformQuat.quat2_copy(transformQuat4);
    }
    transformUp = offsetTransformQuat.quat2_getUp(transformUp);
    transformForward = offsetTransformQuat.quat2_getForward(transformForward);
    feetPosition = offsetTransformQuat.quat2_getPosition(feetPosition);
    let height = collisionCheckParams.myHeight;
    height = height - 1e-5;
    if (height < 1e-5) {
      height = 0;
    }
    forwardForPerceivedAngle.vec3_copy(transformForward);
    forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
    if (!collisionCheckParams.myCheckVerticalFixedForwardEnabled) {
      forwardForVertical.vec3_copy(transformForward);
    } else {
      if (collisionCheckParams.myCheckVerticalFixedForward.vec3_isOnAxis(transformUp)) {
        if (zAxis.vec3_isOnAxis(transformUp)) {
          forwardForVertical.vec3_copy(xAxis);
        } else {
          forwardForVertical.vec3_copy(zAxis);
        }
      }
      forwardForVertical = forwardForVertical.vec3_removeComponentAlongAxis(transformUp, forwardForVertical);
      forwardForVertical = forwardForVertical.vec3_normalize(forwardForVertical);
      if (forwardForVertical.vec_equals(collisionCheckParams.myCheckVerticalFixedForward, 1e-5)) {
        forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
      }
    }
    if (collisionCheckParams.myComputeGroundInfoEnabled) {
      this._gatherSurfaceInfo(feetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
    }
    if (collisionCheckParams.myComputeCeilingInfoEnabled) {
      this._gatherSurfaceInfo(feetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
    }
  };
}();
CollisionCheck.prototype._postSurfaceCheck = function() {
  let horizontalDirection = vec3_create();
  return function _postSurfaceCheck(fixedHorizontalMovement, originalVerticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams) {
    let isVerticalMovementZero = originalVerticalMovement.vec3_isZero(1e-5);
    let isVerticalMovemenDownward = Math.pp_sign(originalVerticalMovement.vec3_lengthSigned(transformUp), -1) < 0;
    let horizontalMovementIsZero = fixedHorizontalMovement.vec3_isZero(1e-5);
    horizontalDirection = fixedHorizontalMovement.vec3_normalize(horizontalDirection);
    let groundPerceivedAngle = this.computeSurfacePerceivedAngle(collisionRuntimeParams.myGroundNormal, horizontalDirection, transformUp, true);
    let ceilingPerceivedAngle = this.computeSurfacePerceivedAngle(collisionRuntimeParams.myCeilingNormal, horizontalDirection, transformUp, false);
    let mustRemainOnGroundOk = true;
    if (collisionCheckParams.myMustStayOnGround) {
      if (previousCollisionRuntimeParams.myIsOnGround && !collisionRuntimeParams.myIsOnGround && (isVerticalMovementZero || isVerticalMovemenDownward)) {
        mustRemainOnGroundOk = false;
      }
    }
    let mustRemainOnCeilingOk = true;
    if (collisionCheckParams.myMustStayOnCeiling) {
      if (previousCollisionRuntimeParams.myIsOnCeiling && !collisionRuntimeParams.myIsOnCeiling && (isVerticalMovementZero || isVerticalMovemenDownward)) {
        mustRemainOnCeilingOk = false;
      }
    }
    let mustStayBelowGroundAngleOk = true;
    if (collisionCheckParams.myMustStayBelowGroundAngleDownhill != null || collisionCheckParams.myMustStayBelowIgnorableGroundAngleDownhill) {
      let minAngle = null;
      if (!collisionCheckParams.myMustStayBelowIgnorableGroundAngleDownhill) {
        minAngle = collisionCheckParams.myMustStayBelowGroundAngleDownhill;
      } else if (collisionCheckParams.myMustStayBelowGroundAngleDownhill == null) {
        minAngle = collisionCheckParams.myGroundAngleToIgnore;
      } else {
        minAngle = Math.min(collisionCheckParams.myMustStayBelowGroundAngleDownhill, collisionCheckParams.myGroundAngleToIgnore);
      }
      if (!horizontalMovementIsZero && groundPerceivedAngle < 0 && previousCollisionRuntimeParams.myIsOnGround && previousCollisionRuntimeParams.myGroundAngle <= minAngle && collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundAngle > minAngle + 1e-4) {
        mustStayBelowGroundAngleOk = false;
      }
    }
    let mustStayBelowCeilingAngleOk = true;
    if (collisionCheckParams.myMustStayBelowCeilingAngleDownhill != null || collisionCheckParams.myMustStayBelowIgnorableCeilingAngleDownhill) {
      let minAngle = null;
      if (!collisionCheckParams.myMustStayBelowIgnorableCeilingAngleDownhill) {
        minAngle = collisionCheckParams.myMustStayBelowCeilingAngleDownhill;
      } else if (collisionCheckParams.myMustStayBelowCeilingAngleDownhill == null) {
        minAngle = collisionCheckParams.myCeilingAngleToIgnore;
      } else {
        minAngle = Math.min(collisionCheckParams.myMustStayBelowCeilingAngleDownhill, collisionCheckParams.myCeilingAngleToIgnore);
      }
      if (!horizontalMovementIsZero && groundPerceivedAngle < 0 && previousCollisionRuntimeParams.myIsOnCeiling && previousCollisionRuntimeParams.myCeilingAngle <= minAngle && collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingAngle > minAngle + 1e-4) {
        mustStayBelowCeilingAngleOk = false;
      }
    }
    let mustStayOnGroundHitAngleOk = true;
    if (collisionCheckParams.myMovementMustStayOnGroundHitAngle != null) {
      if (!horizontalMovementIsZero && previousCollisionRuntimeParams.myIsOnGround && previousCollisionRuntimeParams.myGroundHitMaxAngle <= collisionCheckParams.myMovementMustStayOnGroundHitAngle && collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundHitMaxAngle > collisionCheckParams.myMovementMustStayOnGroundHitAngle + 1e-4) {
        mustStayOnGroundHitAngleOk = false;
      }
    }
    let mustStayOnCeilingHitAngleOk = true;
    if (collisionCheckParams.myMovementMustStayOnCeilingHitAngle != null) {
      if (!horizontalMovementIsZero && previousCollisionRuntimeParams.myIsOnCeiling && previousCollisionRuntimeParams.myCeilingHitMaxAngle <= collisionCheckParams.myMovementMustStayOnCeilingHitAngle && collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingHitMaxAngle > collisionCheckParams.myMovementMustStayOnCeilingHitAngle + 1e-4) {
        mustStayOnCeilingHitAngleOk = false;
      }
    }
    let isOnValidGroundAngleUphill = true;
    let isOnValidGroundAngleDownhill = true;
    if (collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundAngle > collisionCheckParams.myGroundAngleToIgnore + 1e-4) {
      if (previousCollisionRuntimeParams.myIsOnGround && !horizontalMovementIsZero) {
        if (groundPerceivedAngle > 0) {
          isOnValidGroundAngleUphill = false;
          if (collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle != null && collisionRuntimeParams.myGroundAngle <= collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle + 1e-4) {
            isOnValidGroundAngleUphill = Math.abs(groundPerceivedAngle) <= collisionCheckParams.myGroundAngleToIgnore + 1e-4;
          }
        } else if (groundPerceivedAngle < 0) {
          if (previousCollisionRuntimeParams.myGroundAngle <= collisionCheckParams.myGroundAngleToIgnore + 1e-4) {
            if (collisionCheckParams.myMustStayOnValidGroundAngleDownhill) {
              isOnValidGroundAngleDownhill = false;
            }
          }
        }
      }
    }
    let isOnValidCeilingAngleUphill = true;
    let isOnValidCeilingAngleDownhill = true;
    if (collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingAngle > collisionCheckParams.myCeilingAngleToIgnore + 1e-4) {
      if (previousCollisionRuntimeParams.myIsOnCeiling && !horizontalMovementIsZero) {
        if (ceilingPerceivedAngle > 0) {
          isOnValidCeilingAngleUphill = false;
          if (collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle != null && collisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle + 1e-4) {
            isOnValidCeilingAngleUphill = Math.abs(ceilingPerceivedAngle) <= collisionCheckParams.myCeilingAngleToIgnore + 1e-4;
          }
        } else if (ceilingPerceivedAngle < 0) {
          if (previousCollisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myCeilingAngleToIgnore + 1e-4) {
            if (collisionCheckParams.myMustStayOnValidCeilingAngleDownhill) {
              isOnValidCeilingAngleDownhill = false;
            }
          }
        }
      }
    }
    return mustRemainOnGroundOk && mustRemainOnCeilingOk && mustStayBelowGroundAngleOk && mustStayBelowCeilingAngleOk && mustStayOnGroundHitAngleOk && mustStayOnCeilingHitAngleOk && isOnValidGroundAngleUphill && isOnValidGroundAngleDownhill && isOnValidCeilingAngleUphill && isOnValidCeilingAngleDownhill;
  };
}();
CollisionCheck.prototype._surfaceTooSteep = function() {
  let surfaceSteepResults = [false, false];
  return function _surfaceTooSteep(up, direction2, collisionCheckParams, collisionRuntimeParams) {
    let groundTooSteep = false;
    let ceilingTooSteep = false;
    if (collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundAngle > collisionCheckParams.myGroundAngleToIgnore + 1e-4) {
      let groundPerceivedAngle = this.computeSurfacePerceivedAngle(
        collisionRuntimeParams.myGroundNormal,
        direction2,
        up,
        true
      );
      groundTooSteep = groundPerceivedAngle > 0;
      if (groundTooSteep && collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle != null && collisionRuntimeParams.myGroundAngle <= collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle + 1e-4) {
        groundTooSteep = Math.abs(groundPerceivedAngle) > collisionCheckParams.myGroundAngleToIgnore + 1e-4;
      }
    }
    if (!groundTooSteep) {
      if (collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingAngle > collisionCheckParams.myCeilingAngleToIgnore + 1e-4) {
        let ceilingPerceivedAngle = this.computeSurfacePerceivedAngle(
          collisionRuntimeParams.myCeilingNormal,
          direction2,
          up,
          false
        );
        ceilingTooSteep = ceilingPerceivedAngle > 0;
        if (ceilingTooSteep && collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle != null && collisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle + 1e-4) {
          ceilingTooSteep = Math.abs(ceilingPerceivedAngle) > collisionCheckParams.myCeilingAngleToIgnore + 1e-4;
        }
      }
    }
    surfaceSteepResults[0] = groundTooSteep;
    surfaceSteepResults[1] = ceilingTooSteep;
    return surfaceSteepResults;
  };
}();
CollisionCheck.prototype._adjustVerticalMovementWithSurface = function() {
  let horizontalDirection = vec3_create();
  let extraVerticalMovement = vec3_create();
  return function _adjustVerticalMovementWithSurface(horizontalMovement, verticalMovement, up, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, outAdjustedVerticalMovement) {
    outAdjustedVerticalMovement.vec3_copy(verticalMovement);
    if (horizontalMovement.vec3_isZero(1e-5)) {
      return outAdjustedVerticalMovement;
    }
    let extraVerticalLength = 0;
    horizontalDirection = horizontalMovement.vec3_normalize(horizontalDirection);
    if (previousCollisionRuntimeParams.myIsOnGround) {
      let groundPerceivedAngle = this.computeSurfacePerceivedAngle(
        previousCollisionRuntimeParams.myGroundNormal,
        horizontalDirection,
        up,
        true
      );
      let groundExtraVerticalLength = horizontalMovement.vec3_length() * Math.tan(Math.pp_toRadians(Math.abs(groundPerceivedAngle)));
      groundExtraVerticalLength *= Math.pp_sign(groundPerceivedAngle);
      if (Math.abs(groundExtraVerticalLength) > 1e-5) {
        if (groundPerceivedAngle > 0) {
          if (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphill && (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle == null || Math.abs(groundPerceivedAngle) <= collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle) && (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle == null || previousCollisionRuntimeParams.myGroundAngle <= collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle)) {
            extraVerticalLength = groundExtraVerticalLength;
            collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill = true;
          }
        } else if (groundPerceivedAngle < 0) {
          if (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhill && (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle == null || Math.abs(groundPerceivedAngle) <= collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle) && (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle == null || previousCollisionRuntimeParams.myGroundAngle <= collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle)) {
            extraVerticalLength = groundExtraVerticalLength;
            collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill = true;
          }
        }
      }
    }
    if (previousCollisionRuntimeParams.myIsOnCeiling) {
      let ceilingPerceivedAngle = this.computeSurfacePerceivedAngle(
        previousCollisionRuntimeParams.myCeilingNormal,
        horizontalDirection,
        up,
        false
      );
      let ceilingExtraVerticalLength = horizontalMovement.vec3_length() * Math.tan(Math.pp_toRadians(Math.abs(ceilingPerceivedAngle)));
      ceilingExtraVerticalLength *= Math.pp_sign(ceilingPerceivedAngle);
      if (Math.abs(ceilingExtraVerticalLength) > 1e-5) {
        let sameSignThanGround = Math.pp_sign(extraVerticalLength) == Math.pp_sign(ceilingExtraVerticalLength);
        if (extraVerticalLength == 0 || sameSignThanGround && Math.abs(ceilingExtraVerticalLength) > Math.abs(extraVerticalLength)) {
          if (ceilingPerceivedAngle > 0) {
            if (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphill && (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxPerceivedAngle == null || Math.abs(ceilingPerceivedAngle) <= collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxPerceivedAngle) && (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle == null || previousCollisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle)) {
              extraVerticalLength = ceilingExtraVerticalLength;
              collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill = true;
              collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill = false;
            }
          } else if (ceilingPerceivedAngle < 0) {
            if (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhill && (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxPerceivedAngle == null || Math.abs(ceilingPerceivedAngle) <= collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxPerceivedAngle) && (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle == null || previousCollisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle)) {
              extraVerticalLength = ceilingExtraVerticalLength;
              collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill = true;
              collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill = false;
            }
          }
        }
      }
    }
    if (Math.abs(extraVerticalLength) > 1e-5) {
      let verticalMovementLength = verticalMovement.vec3_lengthSigned(up);
      let sameSignThanExtra = Math.pp_sign(extraVerticalLength) == Math.pp_sign(verticalMovementLength);
      extraVerticalMovement = up.vec3_scale(extraVerticalLength, extraVerticalMovement);
      if (verticalMovement.vec3_isZero(1e-5)) {
        outAdjustedVerticalMovement.vec3_copy(extraVerticalMovement);
      } else if (sameSignThanExtra) {
        outAdjustedVerticalMovement = verticalMovement.vec3_add(extraVerticalMovement, outAdjustedVerticalMovement);
      } else if (!sameSignThanExtra && (collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill || collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill)) {
        outAdjustedVerticalMovement = verticalMovement.vec3_add(extraVerticalMovement, outAdjustedVerticalMovement);
      } else {
        collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill = false;
        collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill = false;
        collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill = false;
        collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill = false;
      }
    }
    if (outAdjustedVerticalMovement.vec3_isZero(1e-6)) {
      outAdjustedVerticalMovement.vec3_zero();
    }
    return outAdjustedVerticalMovement;
  };
}();
CollisionCheck.prototype._adjustHorizontalMovementWithSurface = function() {
  let extraHorizontalMovement = vec3_create();
  let groundHorizontalDirection = vec3_create();
  let ceilingHorizontalDirection = vec3_create();
  let scaledCeilingHorizontalDirection = vec3_create();
  let scaledCeilingHorizontalDirectionAlongGroundHorizontalDirection = vec3_create();
  let scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection = vec3_create();
  return function _adjustHorizontalMovementWithSurface(horizontalMovement, verticalMovement, up, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, outAdjustedHorizontalMovement) {
    outAdjustedHorizontalMovement.vec3_copy(horizontalMovement);
    if (verticalMovement.vec3_isZero(1e-5)) {
      return outAdjustedHorizontalMovement;
    }
    let isMovementDownward = !verticalMovement.vec3_isConcordant(up);
    extraHorizontalMovement.vec3_zero();
    groundHorizontalDirection.vec3_zero();
    if (previousCollisionRuntimeParams.myIsOnGround) {
      groundHorizontalDirection = previousCollisionRuntimeParams.myGroundNormal.vec3_removeComponentAlongAxis(up, groundHorizontalDirection);
      if (!groundHorizontalDirection.vec3_isZero(1e-5)) {
        groundHorizontalDirection.vec3_normalize(groundHorizontalDirection);
        let groundExtraHorizontalLength = verticalMovement.vec3_length() / Math.tan(Math.pp_toRadians(previousCollisionRuntimeParams.myGroundAngle));
        groundExtraHorizontalLength *= isMovementDownward ? 1 : -1;
        if (Math.abs(groundExtraHorizontalLength) > 1e-5) {
          if (isMovementDownward) {
            if (collisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhill && (collisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle == null || previousCollisionRuntimeParams.myGroundAngle >= collisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle)) {
              extraHorizontalMovement = groundHorizontalDirection.vec3_scale(groundExtraHorizontalLength, extraHorizontalMovement);
              collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill = true;
            }
          }
        }
      }
    }
    if (previousCollisionRuntimeParams.myIsOnCeiling) {
      ceilingHorizontalDirection = previousCollisionRuntimeParams.myCeilingNormal.vec3_removeComponentAlongAxis(up, ceilingHorizontalDirection);
      if (!ceilingHorizontalDirection.vec3_isZero(1e-5)) {
        ceilingHorizontalDirection.vec3_normalize(ceilingHorizontalDirection);
        let ceilingExtraHorizontalLength = verticalMovement.vec3_length() / Math.tan(Math.pp_toRadians(previousCollisionRuntimeParams.myCeilingAngle));
        ceilingExtraHorizontalLength *= isMovementDownward ? -1 : 1;
        if (Math.abs(ceilingExtraHorizontalLength) > 1e-5) {
          let sameDirectionAsGround = ceilingHorizontalDirection.vec3_isConcordant(groundHorizontalDirection);
          if (extraHorizontalMovement.vec3_isZero() || sameDirectionAsGround) {
            if (!isMovementDownward) {
              if (collisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhill && (collisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle == null || previousCollisionRuntimeParams.myCeilingAngle >= collisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle)) {
                scaledCeilingHorizontalDirection = ceilingHorizontalDirection.vec3_scale(ceilingExtraHorizontalLength, scaledCeilingHorizontalDirection);
                if (!groundHorizontalDirection.vec3_isZero()) {
                  scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection = scaledCeilingHorizontalDirection.vec3_removeComponentAlongAxis(scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection);
                  scaledCeilingHorizontalDirectionAlongGroundHorizontalDirection = scaledCeilingHorizontalDirection.vec3_componentAlongAxis(scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection);
                  if (scaledCeilingHorizontalDirectionAlongGroundHorizontalDirection.vec3_isFartherAlongAxis(extraHorizontalMovement, groundHorizontalDirection)) {
                    collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill = false;
                    extraHorizontalMovement.vec3_copy(scaledCeilingHorizontalDirection);
                    collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill = true;
                  } else if (!scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection.vec3_isZero(1e-5)) {
                    extraHorizontalMovement = extraHorizontalMovement.vec3_add(scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection, extraHorizontalMovement);
                    collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill = true;
                  }
                } else {
                  extraHorizontalMovement.vec3_copy(scaledCeilingHorizontalDirection);
                  collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill = true;
                }
              }
            }
          }
        }
      }
    }
    if (!extraHorizontalMovement.vec3_isZero()) {
      if (horizontalMovement.vec3_isZero(1e-5)) {
        outAdjustedHorizontalMovement.vec3_copy(extraHorizontalMovement);
      } else if (extraHorizontalMovement.vec3_isConcordant(horizontalMovement)) {
        outAdjustedHorizontalMovement = horizontalMovement.vec3_add(extraHorizontalMovement, outAdjustedHorizontalMovement);
      } else {
        outAdjustedHorizontalMovement = horizontalMovement.vec3_add(extraHorizontalMovement, outAdjustedHorizontalMovement);
      }
    }
    if (outAdjustedHorizontalMovement.vec3_isZero(1e-6)) {
      outAdjustedHorizontalMovement.vec3_zero();
    }
    return outAdjustedHorizontalMovement;
  };
}();
CollisionCheck.prototype._computeExtraSurfaceVerticalMovement = function() {
  let direction2 = vec3_create();
  let tempVector = vec3_create();
  return function _computeExtraSurfaceVerticalMovement(horizontalMovement, up, collisionCheckParams, collisionRuntimeParams, outExtraSurfaceVerticalMovement) {
    outExtraSurfaceVerticalMovement.vec3_zero();
    if (!horizontalMovement.vec3_isZero()) {
      if (collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundAngle != 0) {
        direction2 = horizontalMovement.vec3_normalize(direction2);
        let groundPerceivedAngle = this.computeSurfacePerceivedAngle(
          collisionRuntimeParams.myGroundNormal,
          direction2,
          up,
          true
        );
        let extraVerticalLength = horizontalMovement.vec3_length() * Math.tan(Math.pp_toRadians(Math.abs(groundPerceivedAngle)));
        extraVerticalLength *= Math.pp_sign(groundPerceivedAngle);
        if (Math.abs(extraVerticalLength) > 1e-5 && (collisionCheckParams.mySnapOnGroundEnabled || extraVerticalLength > 0)) {
          outExtraSurfaceVerticalMovement.vec3_add(up.vec3_scale(extraVerticalLength, tempVector), outExtraSurfaceVerticalMovement);
        }
      } else if (collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingAngle != 0) {
        direction2 = horizontalMovement.vec3_normalize(direction2);
        let ceilingPerceivedAngle = this.computeSurfacePerceivedAngle(
          collisionRuntimeParams.myCeilingNormal,
          direction2,
          up,
          false
        );
        let extraVerticalLength = horizontalMovement.vec3_length() * Math.tan(Math.pp_toRadians(Math.abs(ceilingPerceivedAngle)));
        extraVerticalLength *= Math.pp_sign(ceilingPerceivedAngle);
        extraVerticalLength *= -1;
        if (Math.abs(extraVerticalLength) > 1e-5 && (collisionCheckParams.mySnapOnCeilingEnabled || extraVerticalLength < 0)) {
          outExtraSurfaceVerticalMovement.vec3_add(up.vec3_scale(extraVerticalLength, tempVector), outExtraSurfaceVerticalMovement);
        }
      }
    }
    return outExtraSurfaceVerticalMovement;
  };
}();
CollisionCheck.prototype._gatherSurfaceInfo = function() {
  let verticalDirection = vec3_create();
  let startOffset = vec3_create();
  let endOffset = vec3_create();
  let heightOffset = vec3_create();
  let smallOffset = vec3_create();
  let smallStartPosition = vec3_create();
  let smallEndPosition = vec3_create();
  let surfaceNormal = vec3_create();
  let surfaceHitMaxNormal = vec3_create();
  let hitFromCurrentPosition = vec3_create();
  let startPosition = vec3_create();
  let endPosition = vec3_create();
  let direction2 = vec3_create();
  return function _gatherSurfaceInfo(feetPosition, height, up, forwardForPerceivedAngle, forwardForVertical, isGround, collisionCheckParams, collisionRuntimeParams) {
    this._myDebugEnabled = collisionCheckParams.myDebugEnabled && (isGround && collisionCheckParams.myDebugGroundInfoEnabled || !isGround && collisionCheckParams.myDebugCeilingInfoEnabled);
    let checkPositions = this._getVerticalCheckPositions(feetPosition, up, forwardForVertical, collisionCheckParams, collisionRuntimeParams);
    verticalDirection.vec3_copy(up);
    let distanceToBeOnSurface = collisionCheckParams.myDistanceToBeOnGround;
    let distanceToComputeSurfaceInfo = collisionCheckParams.myDistanceToComputeGroundInfo;
    let distanceToFindSurfaceDistance = collisionCheckParams.myFindGroundDistanceMaxOutsideDistance;
    let verticalFixToBeOnSurface = collisionCheckParams.myVerticalFixToBeOnGround;
    let verticalFixToComputeSurfaceInfo = collisionCheckParams.myVerticalFixToComputeGroundInfo;
    let verticalFixToFindSurfaceDistance = collisionCheckParams.myFindGroundDistanceMaxInsideDistance;
    let isOnSurfaceIfInsideHit = collisionCheckParams.myIsOnGroundIfInsideHit;
    let isBaseInsideCollisionCheckEnabled = collisionCheckParams.myGroundIsBaseInsideCollisionCheckEnabled;
    if (!isGround) {
      verticalDirection.vec3_negate(verticalDirection);
      distanceToBeOnSurface = collisionCheckParams.myDistanceToBeOnCeiling;
      distanceToComputeSurfaceInfo = collisionCheckParams.myDistanceToComputeCeilingInfo;
      distanceToFindSurfaceDistance = collisionCheckParams.myFindCeilingDistanceMaxOutsideDistance;
      verticalFixToBeOnSurface = collisionCheckParams.myVerticalFixToBeOnCeiling;
      verticalFixToComputeSurfaceInfo = collisionCheckParams.myVerticalFixToComputeCeilingInfo;
      verticalFixToFindSurfaceDistance = collisionCheckParams.myFindCeilingDistanceMaxInsideDistance;
      isOnSurfaceIfInsideHit = collisionCheckParams.myIsOnCeilingIfInsideHit;
      isBaseInsideCollisionCheckEnabled = collisionCheckParams.myCeilingIsBaseInsideCollisionCheckEnabled;
    }
    startOffset = verticalDirection.vec3_scale(Math.max(verticalFixToBeOnSurface, verticalFixToComputeSurfaceInfo, verticalFixToFindSurfaceDistance, 1e-5), startOffset);
    endOffset = verticalDirection.vec3_negate(endOffset).vec3_scale(Math.max(distanceToBeOnSurface, distanceToComputeSurfaceInfo, distanceToFindSurfaceDistance, 1e-5), endOffset);
    heightOffset.vec3_zero();
    if (!isGround) {
      heightOffset = up.vec3_scale(height, heightOffset);
    }
    smallOffset = verticalDirection.vec3_scale(1e-4, smallOffset);
    let isOnSurface = false;
    let surfaceAngle = 0;
    let surfacePerceivedAngle = 0;
    surfaceNormal.vec3_zero();
    let surfaceHitMaxAngle = 0;
    surfaceHitMaxNormal.vec3_zero();
    let surfaceDistance = null;
    let isBaseInsideCollision = checkPositions.length > 0;
    for (let i = 0; i < checkPositions.length; i++) {
      let currentPosition = checkPositions[i];
      currentPosition.vec3_add(heightOffset, currentPosition);
      let baseHitIsInsideCollision = false;
      if (isBaseInsideCollisionCheckEnabled) {
        smallStartPosition = currentPosition.vec3_add(smallOffset, smallStartPosition);
        smallEndPosition = currentPosition.vec3_sub(smallOffset, smallEndPosition);
        let origin = smallStartPosition;
        direction2 = smallEndPosition.vec3_sub(origin, direction2);
        let distance5 = direction2.vec3_length();
        direction2.vec3_normalize(direction2);
        let raycastResult = this._raycastAndDebug(origin, direction2, distance5, false, false, collisionCheckParams, collisionRuntimeParams);
        if (raycastResult.isColliding()) {
          baseHitIsInsideCollision = raycastResult.myHits[0].myInsideCollision;
        }
      }
      isBaseInsideCollision &&= baseHitIsInsideCollision;
      if (!baseHitIsInsideCollision) {
        startPosition = currentPosition.vec3_add(startOffset, startPosition);
        endPosition = currentPosition.vec3_add(endOffset, endPosition);
        let origin = startPosition;
        direction2 = endPosition.vec3_sub(origin, direction2);
        let distance5 = direction2.vec3_length();
        direction2.vec3_normalize(direction2);
        let raycastResult = this._raycastAndDebug(origin, direction2, distance5, true, false, collisionCheckParams, collisionRuntimeParams);
        if (raycastResult.isColliding()) {
          hitFromCurrentPosition = raycastResult.myHits[0].myPosition.vec3_sub(currentPosition, hitFromCurrentPosition);
          let hitFromCurrentPositionLength = hitFromCurrentPosition.vec3_lengthSigned(verticalDirection);
          if (hitFromCurrentPositionLength >= 0 && hitFromCurrentPositionLength <= verticalFixToBeOnSurface + 1e-5 || hitFromCurrentPositionLength < 0 && Math.abs(hitFromCurrentPositionLength) <= distanceToBeOnSurface + 1e-5) {
            isOnSurface = true;
          }
          if (hitFromCurrentPositionLength >= 0 && hitFromCurrentPositionLength <= verticalFixToComputeSurfaceInfo + 1e-5 || hitFromCurrentPositionLength < 0 && Math.abs(hitFromCurrentPositionLength) <= distanceToComputeSurfaceInfo + 1e-5) {
            let currentSurfaceNormal = raycastResult.myHits[0].myNormal;
            surfaceNormal.vec3_add(currentSurfaceNormal, surfaceNormal);
            let surfaceHitAngle = currentSurfaceNormal.vec3_angle(verticalDirection);
            if (surfaceHitAngle > surfaceHitMaxAngle) {
              surfaceHitMaxAngle = surfaceHitAngle;
              surfaceHitMaxNormal.vec3_copy(currentSurfaceNormal);
            }
          }
          if (hitFromCurrentPositionLength >= 0 && hitFromCurrentPositionLength <= verticalFixToFindSurfaceDistance + 1e-5 || hitFromCurrentPositionLength < 0 && Math.abs(hitFromCurrentPositionLength) <= distanceToFindSurfaceDistance + 1e-5) {
            if (surfaceDistance == null) {
              surfaceDistance = -hitFromCurrentPositionLength;
            } else {
              if (Math.abs(hitFromCurrentPositionLength) < Math.abs(surfaceDistance)) {
                surfaceDistance = -hitFromCurrentPositionLength;
              }
            }
          }
        }
      } else if (isOnSurfaceIfInsideHit) {
        isOnSurface = true;
      }
    }
    if (!surfaceNormal.vec3_isZero()) {
      surfaceNormal.vec3_normalize(surfaceNormal);
      surfaceAngle = surfaceNormal.vec3_angle(verticalDirection);
      if (surfaceAngle <= 1e-4) {
        surfaceAngle = 0;
        surfaceNormal.vec3_copy(verticalDirection);
      } else if (surfaceAngle >= 180 - 1e-4) {
        surfaceAngle = 180;
        surfaceNormal = verticalDirection.vec3_negate(surfaceNormal);
      }
      surfacePerceivedAngle = this.computeSurfacePerceivedAngle(surfaceNormal, forwardForPerceivedAngle, up, isGround);
    }
    if (isGround) {
      collisionRuntimeParams.myRealIsOnGround = isOnSurface;
      collisionRuntimeParams.myGroundAngle = surfaceAngle;
      collisionRuntimeParams.myGroundPerceivedAngle = surfacePerceivedAngle;
      collisionRuntimeParams.myGroundNormal.vec3_copy(surfaceNormal);
      collisionRuntimeParams.myGroundHitMaxAngle = surfaceHitMaxAngle;
      collisionRuntimeParams.myGroundHitMaxNormal.vec3_copy(surfaceHitMaxNormal);
      collisionRuntimeParams.myGroundDistance = surfaceDistance;
      collisionRuntimeParams.myGroundIsBaseInsideCollision = isBaseInsideCollision;
      if (isOnSurface && (collisionCheckParams.myIsOnGroundMaxSurfaceAngle == null || collisionRuntimeParams.myGroundAngle <= collisionCheckParams.myIsOnGroundMaxSurfaceAngle)) {
        collisionRuntimeParams.myIsOnGround = isOnSurface;
      }
    } else {
      collisionRuntimeParams.myRealIsOnCeiling = isOnSurface;
      collisionRuntimeParams.myCeilingAngle = surfaceAngle;
      collisionRuntimeParams.myCeilingPerceivedAngle = surfacePerceivedAngle;
      collisionRuntimeParams.myCeilingNormal.vec3_copy(surfaceNormal);
      collisionRuntimeParams.myCeilingHitMaxAngle = surfaceHitMaxAngle;
      collisionRuntimeParams.myCeilingHitMaxNormal.vec3_copy(surfaceHitMaxNormal);
      collisionRuntimeParams.myCeilingDistance = surfaceDistance;
      collisionRuntimeParams.myCeilingIsBaseInsideCollision = isBaseInsideCollision;
      if (isOnSurface && (collisionCheckParams.myIsOnCeilingMaxSurfaceAngle == null || collisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myIsOnCeilingMaxSurfaceAngle)) {
        collisionRuntimeParams.myIsOnCeiling = isOnSurface;
      }
    }
  };
}();
CollisionCheck.prototype.computeSurfacePerceivedAngle = function() {
  let forwardOnSurface = vec3_create();
  let verticalDirection = vec3_create();
  return function computeSurfacePerceivedAngle(surfaceNormal, forward, up, isGround = true) {
    let surfacePerceivedAngle = 0;
    verticalDirection.vec3_copy(up);
    if (!isGround) {
      verticalDirection.vec3_negate(verticalDirection);
    }
    let surfaceAngle = surfaceNormal.vec3_angle(verticalDirection);
    if (surfaceAngle <= Math.PP_EPSILON_DEGREES) {
      surfaceAngle = 0;
    } else if (surfaceAngle >= 180 - Math.PP_EPSILON_DEGREES) {
      surfaceAngle = 180;
    }
    forwardOnSurface = forward.vec3_projectOnPlaneAlongAxis(surfaceNormal, up, forwardOnSurface);
    surfacePerceivedAngle = forwardOnSurface.vec3_angle(forward);
    let isFartherOnUp = forwardOnSurface.vec3_isFartherAlongAxis(forward, up);
    if (!isFartherOnUp && isGround || isFartherOnUp && !isGround) {
      surfacePerceivedAngle *= -1;
    }
    if (Math.abs(surfacePerceivedAngle) >= surfaceAngle) {
      if (surfaceAngle != 0 && surfaceAngle != 180) {
        surfacePerceivedAngle = surfaceAngle * Math.pp_sign(surfacePerceivedAngle);
      } else {
        surfacePerceivedAngle = surfaceAngle;
      }
    }
    return surfacePerceivedAngle;
  };
}();
Object.defineProperty(CollisionCheck.prototype, "_surfaceTooSteep", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_computeExtraSurfaceVerticalMovement", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_gatherSurfaceInfo", { enumerable: false });
Object.defineProperty(CollisionCheck.prototype, "_updateSurfaceInfo", { enumerable: false });

// js/pp/gameplay/experimental/character_controller/collision/character_collision_results.js
var CharacterCollisionResults = class {
  constructor() {
    this.myCheckType = null;
    this.myTransformResults = new CharacterCollisionTransformResults();
    this.myMovementResults = new CharacterCollisionMovementResults();
    this.myHorizontalMovementResults = new CharacterCollisionMovementResults();
    this.myVerticalMovementResults = new CharacterCollisionMovementResults();
    this.myTeleportResults = new CharacterCollisionTeleportResults();
    this.myCheckTransformResults = new CharacterCollisionCheckTransformResults();
    this.myWallSlideResults = new CharacterCollisionWallSlideResults();
    this.myGroundInfo = new CharacterCollisionSurfaceInfo();
    this.myCeilingInfo = new CharacterCollisionSurfaceInfo();
    this.myGroundResults = new CharacterCollisionSurfaceResults();
    this.myCeilingResults = new CharacterCollisionSurfaceResults();
    this.mySplitMovementResults = new CharacterCollisionSplitMovementResults();
    this.myDebugResults = new CharacterCollisionDebugResults();
    this.myInternalResults = new CharacterCollisionInternalResults();
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionCheckType = {
  CHECK_MOVEMENT: 0,
  CHECK_TELEPORT: 1,
  CHECK_TRANSFORM: 2,
  UPDATE_SURFACE_INFO: 3,
  UPDATE_GROUND_INFO: 4,
  UPDATE_CEILING_INFO: 5
};
var CharacterCollisionSurfaceInfo = class {
  constructor() {
    this.myOnSurface = false;
    this.mySurfaceAngle = 0;
    this.mySurfacePerceivedAngle = 0;
    this.mySurfaceNormal = vec3_create();
    this.mySurfaceHitMaxAngle = 0;
    this.mySurfaceHitMaxNormal = vec3_create();
    this.mySurfaceDistance = null;
    this.myBaseInsideCollision = false;
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionWallSlideResults = class {
  constructor() {
    this.myHasSlid = false;
    this.mySlideMovementAngle = 0;
    this.mySlideMovementWallAngle = 0;
    this.myWallNormal = vec3_create();
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionTransformResults = class {
  constructor() {
    this.myInitialTransformQuat = quat2_create();
    this.myFinalTransformQuat = quat2_create();
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionMovementResults = class {
  constructor() {
    this.myInitialMovement = vec3_create();
    this.myFinalMovement = vec3_create();
    this.myMovementFailed = false;
    this.myMovementCollided = false;
    this.myReferenceCollisionHit = new RaycastHit();
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionTeleportResults = class {
  constructor() {
    this.myInitialTeleportTransformQuat = quat2_create();
    this.myFinalTeleportTransformQuat = quat2_create();
    this.myTeleportFailed = false;
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionCheckTransformResults = class {
  constructor() {
    this.myInitialCheckTransformQuat = quat2_create();
    this.myFinalCheckTransformQuat = quat2_create();
    this.myCheckTransformFailed = false;
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionSurfaceResults = class {
  constructor() {
    this.myHasSnappedOnSurface = false;
    this.myHasPoppedOutSurface = false;
    this.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill = false;
    this.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill = false;
    this.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill = false;
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionSplitMovementResults = class {
  constructor() {
    this.myStepsToPerform = 0;
    this.myStepsPerformed = 0;
    this.myMovementInterrupted = false;
    this.myMovementChecked = vec3_create();
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionDebugResults = class {
  constructor() {
    this._myRaycastsPerformed = 0;
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionInternalResults = class {
  constructor() {
    this.myLastRelevantInitialHorizontalMovement = vec3_create();
    this.myLastRelevantAdjustedInitialHorizontalMovement = vec3_create();
    this.myLastRelevantFinalHorizontalMovement = vec3_create();
    this.myLastRelevantInitialVerticalMovement = vec3_create();
    this.myLastRelevantAdjustedInitialVerticalMovement = vec3_create();
    this.myLastRelevantFinalVerticalMovement = vec3_create();
    this.myLastRelevantHasWallSlid = false;
    this.myHasWallSlidTowardOppositeDirection = false;
    this.myLastRelevantWallSlideFlickerPrevented = false;
    this.myWallSlideFlickerPreventionForceCheckCounter = 0;
    this.myWallSlide90DegreesDirectionSign = 0;
    this.myWallSlide90DegreesRecomputeDirectionSign = true;
  }
  reset() {
  }
  copy(other) {
  }
};
CharacterCollisionResults.prototype.reset = function reset() {
  this.myCheckType = null;
  this.myTransformResults.reset();
  this.myMovementResults.reset();
  this.myHorizontalMovementResults.reset();
  this.myVerticalMovementResults.reset();
  this.myTeleportResults.reset();
  this.myCheckTransformResults.reset();
  this.myWallSlideResults.reset();
  this.myGroundInfo.reset();
  this.myCeilingInfo.reset();
  this.myGroundResults.reset();
  this.myCeilingResults.reset();
  this.mySplitMovementResults.reset();
  this.myInternalResults.reset();
};
CharacterCollisionResults.prototype.copy = function copy23(other) {
  this.myCheckType = other.myCheckType;
  this.myTransformResults.copy(other.myTransformResults);
  this.myMovementResults.copy(other.myMovementResults);
  this.myHorizontalMovementResults.copy(other.myHorizontalMovementResults);
  this.myVerticalMovementResults.copy(other.myVerticalMovementResults);
  this.myTeleportResults.copy(other.myTeleportResults);
  this.myCheckTransformResults.copy(other.myCheckTransformResults);
  this.myWallSlideResults.copy(other.myWallSlideResults);
  this.myGroundInfo.copy(other.myGroundInfo);
  this.myCeilingInfo.copy(other.myCeilingInfo);
  this.myGroundResults.copy(other.myGroundResults);
  this.myCeilingResults.copy(other.myCeilingResults);
  this.mySplitMovementResults.copy(other.mySplitMovementResults);
  this.myInternalResults.copy(other.myInternalResults);
};
CharacterCollisionSurfaceInfo.prototype.reset = function reset2() {
  this.myOnSurface = false;
  this.mySurfaceAngle = 0;
  this.mySurfacePerceivedAngle = 0;
  this.mySurfaceNormal.vec3_zero();
  this.mySurfaceHitMaxAngle = 0;
  this.mySurfaceHitMaxNormal.vec3_zero();
  this.mySurfaceDistance = null;
  this.myBaseInsideCollision = false;
};
CharacterCollisionSurfaceInfo.prototype.copy = function copy24(other) {
  this.myOnSurface = other.myOnSurface;
  this.mySurfaceAngle = other.mySurfaceAngle;
  this.mySurfacePerceivedAngle = other.mySurfacePerceivedAngle;
  this.mySurfaceNormal.vec3_copy(other.mySurfaceNormal);
  this.mySurfaceHitMaxAngle = other.mySurfaceHitMaxAngle;
  this.mySurfaceHitMaxNormal.vec3_copy(other.mySurfaceHitMaxNormal);
  this.mySurfaceDistance = other.mySurfaceDistance;
  this.myBaseInsideCollision = other.myBaseInsideCollision;
};
CharacterCollisionWallSlideResults.prototype.reset = function reset3() {
  this.myHasSlid = false;
  this.mySlideMovementAngle = 0;
  this.mySlideMovementWallAngle = 0;
  this.myWallNormal.vec3_zero();
};
CharacterCollisionWallSlideResults.prototype.copy = function copy25(other) {
  this.myHasSlid = other.myHasSlid;
  this.mySlideMovementAngle = other.mySlideMovementAngle;
  this.mySlideMovementWallAngle = other.mySlideMovementWallAngle;
  this.myWallNormal.vec3_copy(other.myWallNormal);
};
CharacterCollisionTransformResults.prototype.reset = function reset4() {
  this.myInitialTransformQuat.quat2_identity();
  this.myFinalTransformQuat.quat2_identity();
};
CharacterCollisionTransformResults.prototype.copy = function copy26(other) {
  this.myInitialTransformQuat.quat2_copy(other.myInitialTransformQuat);
  this.myFinalTransformQuat.quat2_copy(other.myFinalTransformQuat);
};
CharacterCollisionMovementResults.prototype.reset = function reset5() {
  this.myInitialMovement.vec3_zero();
  this.myFinalMovement.vec3_zero();
  this.myMovementFailed = false;
  this.myMovementCollided = false;
  this.myReferenceCollisionHit.reset();
};
CharacterCollisionMovementResults.prototype.copy = function copy27(other) {
  this.myInitialMovement.vec3_copy(other.myInitialMovement);
  this.myFinalMovement.vec3_copy(other.myFinalMovement);
  this.myMovementFailed = other.myMovementFailed;
  this.myMovementCollided = other.myMovementCollided;
  this.myReferenceCollisionHit.copy(other.myReferenceCollisionHit);
};
CharacterCollisionTeleportResults.prototype.reset = function reset6() {
  this.myInitialTeleportTransformQuat.quat2_identity();
  this.myFinalTeleportTransformQuat.quat2_identity();
  this.myTeleportFailed = false;
};
CharacterCollisionTeleportResults.prototype.copy = function copy28(other) {
  this.myInitialTeleportTransformQuat.quat2_copy(other.myInitialTeleportTransformQuat);
  this.myFinalTeleportTransformQuat.quat2_copy(other.myFinalTeleportTransformQuat);
  this.myTeleportFailed = other.myTeleportFailed;
};
CharacterCollisionCheckTransformResults.prototype.reset = function reset7() {
  this.myInitialCheckTransformQuat.quat2_identity();
  this.myFinalCheckTransformQuat.quat2_identity();
  this.myCheckTransformFailed = false;
};
CharacterCollisionCheckTransformResults.prototype.copy = function copy29(other) {
  this.myInitialCheckTransformQuat.quat2_copy(other.myInitialCheckTransformQuat);
  this.myFinalCheckTransformQuat.quat2_copy(other.myFinalCheckTransformQuat);
  this.myCheckTransformFailed = other.myCheckTransformFailed;
};
CharacterCollisionSurfaceResults.prototype.reset = function reset8() {
  this.myHasSnappedOnSurface = false;
  this.myHasPoppedOutSurface = false;
  this.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill = false;
  this.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill = false;
  this.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill = false;
};
CharacterCollisionSurfaceResults.prototype.copy = function copy30(other) {
  this.myHasSnappedOnSurface = other.myHasSnappedOnSurface;
  this.myHasPoppedOutSurface = other.myHasPoppedOutSurface;
  this.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill = other.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill;
  this.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill = other.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill;
  this.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill = other.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill;
};
CharacterCollisionSplitMovementResults.prototype.reset = function reset9() {
  this.myStepsToPerform = 0;
  this.myStepsPerformed = 0;
  this.myMovementInterrupted = false;
  this.myMovementChecked.vec3_zero();
};
CharacterCollisionSplitMovementResults.prototype.copy = function copy31(other) {
  this.myStepsToPerform = other.myStepsToPerform;
  this.myStepsPerformed = other.myStepsPerformed;
  this.myMovementInterrupted = other.myMovementInterrupted;
  this.myMovementChecked.vec3_copy(other.myMovementChecked);
};
CharacterCollisionDebugResults.prototype.reset = function reset10() {
  this._myRaycastsPerformed = 0;
};
CharacterCollisionDebugResults.prototype.copy = function copy32(other) {
  this._myRaycastsPerformed = other._myRaycastsPerformed;
};
CharacterCollisionInternalResults.prototype.reset = function reset11() {
};
CharacterCollisionInternalResults.prototype.copy = function copy33(other) {
  this.myLastRelevantInitialHorizontalMovement.vec3_copy(other.myLastRelevantInitialHorizontalMovement);
  this.myLastRelevantAdjustedInitialHorizontalMovement.vec3_copy(other.myLastRelevantAdjustedInitialHorizontalMovement);
  this.myLastRelevantFinalHorizontalMovement.vec3_copy(other.myLastRelevantFinalHorizontalMovement);
  this.myLastRelevantInitialVerticalMovement.vec3_copy(other.myLastRelevantInitialVerticalMovement);
  this.myLastRelevantAdjustedInitialVerticalMovement.vec3_copy(other.myLastRelevantAdjustedInitialVerticalMovement);
  this.myLastRelevantFinalVerticalMovement.vec3_copy(other.myLastRelevantFinalVerticalMovement);
  this.myLastRelevantHasWallSlid = other.myLastRelevantHasWallSlid;
  this.myHasWallSlidTowardOppositeDirection = other.myHasWallSlidTowardOppositeDirection;
  this.myLastRelevantWallSlideFlickerPrevented = other.myLastRelevantWallSlideFlickerPrevented;
  this.myWallSlideFlickerPreventionForceCheckCounter = other.myWallSlideFlickerPreventionForceCheckCounter;
  this.myWallSlide90DegreesDirectionSign = other.myWallSlide90DegreesDirectionSign;
  this.myWallSlide90DegreesRecomputeDirectionSign = other.myWallSlide90DegreesRecomputeDirectionSign;
};

// js/pp/gameplay/experimental/character_controller/collision/collision_check_bridge.js
var _myCollisionChecks = /* @__PURE__ */ new WeakMap();
function getCollisionCheck(engine2 = Globals.getMainEngine()) {
  return _myCollisionChecks.get(engine2);
}
function setCollisionCheck(collisionCheck, engine2 = Globals.getMainEngine()) {
  _myCollisionChecks.set(engine2, collisionCheck);
}
function initBridge(engine2 = Globals.getMainEngine()) {
  if (!_myCollisionChecks.has(engine2)) {
    CollisionCheckBridge.setCollisionCheck(new CollisionCheck(engine2), engine2);
  }
}
var checkMovement = function() {
  let collisionCheckParams = new CollisionCheckParams();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  return function checkMovement2(movement, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults(), engine2 = Globals.getMainEngine()) {
    CollisionCheckBridge.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
    CollisionCheckBridge.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
    CollisionCheckBridge.getCollisionCheck(engine2).move(movement, currentTransformQuat, collisionCheckParams, collisionRuntimeParams);
    CollisionCheckBridge.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults);
  };
}();
var checkTeleportToTransform = function() {
  let teleportPosition = vec3_create();
  let collisionCheckParams = new CollisionCheckParams();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  return function checkTeleportToTransform2(teleportTransformQuat, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults(), engine2 = Globals.getMainEngine()) {
    CollisionCheckBridge.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
    CollisionCheckBridge.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
    teleportPosition = teleportTransformQuat.quat2_getPosition(teleportPosition);
    CollisionCheckBridge.getCollisionCheck(engine2).teleport(teleportPosition, teleportTransformQuat, collisionCheckParams, collisionRuntimeParams);
    CollisionCheckBridge.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults);
  };
}();
var checkTransform = function() {
  let collisionCheckParams = new CollisionCheckParams();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  return function checkTransform2(checkTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults(), engine2 = Globals.getMainEngine()) {
    CollisionCheckBridge.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
    CollisionCheckBridge.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
    CollisionCheckBridge.getCollisionCheck(engine2).positionCheck(true, checkTransformQuat, collisionCheckParams, collisionRuntimeParams);
    CollisionCheckBridge.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, checkTransformQuat, outCharacterCollisionResults);
  };
}();
var updateGroundInfo = function() {
  let collisionCheckParams = new CollisionCheckParams();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  return function updateGroundInfo2(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults(), engine2 = Globals.getMainEngine()) {
    CollisionCheckBridge.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
    CollisionCheckBridge.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
    collisionCheckParams.myComputeCeilingInfoEnabled = false;
    CollisionCheckBridge.getCollisionCheck(engine2).updateSurfaceInfo(currentTransformQuat, collisionCheckParams, collisionRuntimeParams);
    CollisionCheckBridge.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults);
  };
}();
var updateCeilingInfo = function() {
  let collisionCheckParams = new CollisionCheckParams();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  return function updateCeilingInfo2(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults(), engine2 = Globals.getMainEngine()) {
    CollisionCheckBridge.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
    CollisionCheckBridge.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
    collisionCheckParams.myComputeGroundInfoEnabled = false;
    CollisionCheckBridge.getCollisionCheck(engine2).updateSurfaceInfo(currentTransformQuat, collisionCheckParams, collisionRuntimeParams);
    CollisionCheckBridge.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults);
  };
}();
function convertCharacterCollisionResultsToCollisionRuntimeParams(characterCollisionResults, outCollisionRuntimeParams) {
  outCollisionRuntimeParams.reset();
  characterCollisionResults.myTransformResults.myInitialTransformQuat.quat2_getPosition(outCollisionRuntimeParams.myOriginalPosition);
  characterCollisionResults.myTransformResults.myFinalTransformQuat.quat2_getPosition(outCollisionRuntimeParams.myNewPosition);
  characterCollisionResults.myTransformResults.myInitialTransformQuat.quat2_getForward(outCollisionRuntimeParams.myOriginalForward);
  characterCollisionResults.myTransformResults.myInitialTransformQuat.quat2_getUp(outCollisionRuntimeParams.myOriginalUp);
  outCollisionRuntimeParams.myOriginalMovement.vec3_copy(characterCollisionResults.myMovementResults.myInitialMovement);
  outCollisionRuntimeParams.myFixedMovement.vec3_copy(characterCollisionResults.myMovementResults.myFinalMovement);
  outCollisionRuntimeParams.myLastValidOriginalHorizontalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantInitialHorizontalMovement);
  outCollisionRuntimeParams.myLastValidOriginalVerticalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantInitialVerticalMovement);
  outCollisionRuntimeParams.myLastValidEndHorizontalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantFinalHorizontalMovement);
  outCollisionRuntimeParams.myLastValidEndVerticalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantFinalVerticalMovement);
  outCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantAdjustedInitialHorizontalMovement);
  outCollisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantAdjustedInitialVerticalMovement);
  outCollisionRuntimeParams.myIsOnGround = characterCollisionResults.myGroundInfo.myOnSurface;
  outCollisionRuntimeParams.myGroundAngle = characterCollisionResults.myGroundInfo.mySurfaceAngle;
  outCollisionRuntimeParams.myGroundPerceivedAngle = characterCollisionResults.myGroundInfo.mySurfacePerceivedAngle;
  outCollisionRuntimeParams.myGroundNormal.vec3_copy(characterCollisionResults.myGroundInfo.mySurfaceNormal);
  outCollisionRuntimeParams.myGroundHitMaxAngle = characterCollisionResults.myGroundInfo.mySurfaceHitMaxAngle;
  outCollisionRuntimeParams.myGroundHitMaxNormal.vec3_copy(characterCollisionResults.myGroundInfo.mySurfaceHitMaxNormal);
  outCollisionRuntimeParams.myGroundDistance = characterCollisionResults.myGroundInfo.mySurfaceDistance;
  outCollisionRuntimeParams.myGroundIsBaseInsideCollision = characterCollisionResults.myGroundInfo.myBaseInsideCollision;
  outCollisionRuntimeParams.myIsOnCeiling = characterCollisionResults.myCeilingInfo.myOnSurface;
  outCollisionRuntimeParams.myCeilingAngle = characterCollisionResults.myCeilingInfo.mySurfaceAngle;
  outCollisionRuntimeParams.myCeilingPerceivedAngle = characterCollisionResults.myCeilingInfo.mySurfacePerceivedAngle;
  outCollisionRuntimeParams.myCeilingNormal.vec3_copy(characterCollisionResults.myCeilingInfo.mySurfaceNormal);
  outCollisionRuntimeParams.myCeilingHitMaxAngle = characterCollisionResults.myCeilingInfo.mySurfaceHitMaxAngle;
  outCollisionRuntimeParams.myCeilingHitMaxNormal.vec3_copy(characterCollisionResults.myCeilingInfo.mySurfaceHitMaxNormal);
  outCollisionRuntimeParams.myCeilingDistance = characterCollisionResults.myCeilingInfo.mySurfaceDistance;
  outCollisionRuntimeParams.myCeilingIsBaseInsideCollision = characterCollisionResults.myCeilingInfo.myBaseInsideCollision;
  outCollisionRuntimeParams.myHorizontalMovementCanceled = characterCollisionResults.myHorizontalMovementResults.myMovementFailed;
  outCollisionRuntimeParams.myIsCollidingHorizontally = characterCollisionResults.myHorizontalMovementResults.myMovementCollided;
  outCollisionRuntimeParams.myHorizontalCollisionHit.copy(characterCollisionResults.myHorizontalMovementResults.myReferenceCollisionHit);
  outCollisionRuntimeParams.myVerticalMovementCanceled = characterCollisionResults.myVerticalMovementResults.myMovementFailed;
  outCollisionRuntimeParams.myIsCollidingVertically = characterCollisionResults.myVerticalMovementResults.myMovementCollided;
  outCollisionRuntimeParams.myVerticalCollisionHit.copy(characterCollisionResults.myVerticalMovementResults.myReferenceCollisionHit);
  outCollisionRuntimeParams.myHasSnappedOnGround = characterCollisionResults.myGroundResults.myHasSnappedOnSurface;
  outCollisionRuntimeParams.myHasSnappedOnCeiling = characterCollisionResults.myCeilingResults.myHasSnappedOnSurface;
  outCollisionRuntimeParams.myHasPoppedOutGround = characterCollisionResults.myGroundResults.myHasPoppedOutSurface;
  outCollisionRuntimeParams.myHasPoppedOutCeiling = characterCollisionResults.myCeilingResults.myHasPoppedOutSurface;
  outCollisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill = characterCollisionResults.myGroundResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill;
  outCollisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill = characterCollisionResults.myGroundResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill;
  outCollisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill = characterCollisionResults.myGroundResults.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill;
  outCollisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill = characterCollisionResults.myCeilingResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill;
  outCollisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill = characterCollisionResults.myCeilingResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill;
  outCollisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill = characterCollisionResults.myCeilingResults.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill;
  outCollisionRuntimeParams.myIsSliding = characterCollisionResults.myWallSlideResults.myHasSlid;
  outCollisionRuntimeParams.mySlidingMovementAngle = characterCollisionResults.myWallSlideResults.mySlideMovementAngle;
  outCollisionRuntimeParams.mySlidingCollisionAngle = characterCollisionResults.myWallSlideResults.mySlideMovementWallAngle;
  outCollisionRuntimeParams.mySlidingWallNormal.vec3_copy(characterCollisionResults.myWallSlideResults.myWallNormal);
  outCollisionRuntimeParams.myIsSlidingIntoOppositeDirection = characterCollisionResults.myInternalResults.myHasWallSlidTowardOppositeDirection;
  outCollisionRuntimeParams.myIsSlidingFlickerPrevented = characterCollisionResults.myInternalResults.myLastRelevantWallSlideFlickerPrevented;
  outCollisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter = characterCollisionResults.myInternalResults.myWallSlideFlickerPreventionForceCheckCounter;
  outCollisionRuntimeParams.mySliding90DegreesSign = characterCollisionResults.myInternalResults.myWallSlide90DegreesDirectionSign;
  outCollisionRuntimeParams.mySlidingRecompute90DegreesSign = characterCollisionResults.myInternalResults.myWallSlide90DegreesRecomputeDirectionSign;
  outCollisionRuntimeParams.myLastValidIsSliding = characterCollisionResults.myInternalResults.myLastRelevantHasWallSlid;
  outCollisionRuntimeParams.mySlidingPreviousHorizontalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantFinalHorizontalMovement);
  outCollisionRuntimeParams.myOriginalTeleportPosition.vec3_copy(characterCollisionResults.myTeleportResults.myInitialTeleportTransformQuat);
  outCollisionRuntimeParams.myFixedTeleportPosition.vec3_copy(characterCollisionResults.myTeleportResults.myFinalTeleportTransformQuat);
  outCollisionRuntimeParams.myTeleportCanceled = characterCollisionResults.myTeleportResults.myTeleportFailed;
  outCollisionRuntimeParams.myIsPositionOk = characterCollisionResults.myCheckTransformResults.myCheckTransformFailed;
  characterCollisionResults.myCheckTransformResults.myInitialCheckTransformQuat.quat2_getPosition(outCollisionRuntimeParams.myOriginalPositionCheckPosition);
  characterCollisionResults.myCheckTransformResults.myFinalCheckTransformQuat.quat2_getPosition(outCollisionRuntimeParams.myFixedPositionCheckPosition);
  outCollisionRuntimeParams.myIsTeleport = characterCollisionResults.myCheckType == CharacterCollisionCheckType.CHECK_TELEPORT;
  outCollisionRuntimeParams.myIsMove = characterCollisionResults.myCheckType == CharacterCollisionCheckType.CHECK_MOVEMENT;
  outCollisionRuntimeParams.myIsPositionCheck = characterCollisionResults.myCheckType == CharacterCollisionCheckType.CHECK_TRANSFORM;
  outCollisionRuntimeParams.mySplitMovementSteps = characterCollisionResults.mySplitMovementResults.myStepsToPerform;
  outCollisionRuntimeParams.mySplitMovementStepsPerformed = characterCollisionResults.mySplitMovementResults.myStepsPerformed;
  outCollisionRuntimeParams.mySplitMovementStop = characterCollisionResults.mySplitMovementResults.myMovementInterrupted;
  outCollisionRuntimeParams.mySplitMovementMovementChecked.vec3_copy(characterCollisionResults.mySplitMovementResults.myMovementChecked);
  return outCollisionRuntimeParams;
}
var convertCollisionRuntimeParamsToCharacterCollisionResults = function() {
  let rotationQuat = quat_create();
  return function convertCollisionRuntimeParamsToCharacterCollisionResults2(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults) {
    outCharacterCollisionResults.reset();
    if (collisionRuntimeParams.myIsMove) {
      outCharacterCollisionResults.myCheckType = CharacterCollisionCheckType.CHECK_MOVEMENT;
    } else if (collisionRuntimeParams.myIsTeleport) {
      outCharacterCollisionResults.myCheckType = CharacterCollisionCheckType.CHECK_TELEPORT;
    } else if (collisionRuntimeParams.myIsPositionCheck) {
      outCharacterCollisionResults.myCheckType = CharacterCollisionCheckType.CHECK_TRANSFORM;
    }
    rotationQuat.quat_setForward(collisionRuntimeParams.myOriginalForward, collisionRuntimeParams.myOriginalUp);
    outCharacterCollisionResults.myTransformResults.myInitialTransformQuat.quat2_setPositionRotationQuat(collisionRuntimeParams.myOriginalPosition, rotationQuat);
    outCharacterCollisionResults.myTransformResults.myFinalTransformQuat.quat2_setPositionRotationQuat(collisionRuntimeParams.myNewPosition, rotationQuat);
    outCharacterCollisionResults.myMovementResults.myInitialMovement.vec3_copy(collisionRuntimeParams.myOriginalMovement);
    outCharacterCollisionResults.myMovementResults.myFinalMovement.vec3_copy(collisionRuntimeParams.myFixedMovement);
    outCharacterCollisionResults.myMovementResults.myMovementFailed = collisionRuntimeParams.myHorizontalMovementCanceled && collisionRuntimeParams.myVerticalMovementCanceled;
    outCharacterCollisionResults.myMovementResults.myMovementCollided = collisionRuntimeParams.myIsCollidingHorizontally || collisionRuntimeParams.myIsCollidingVertically;
    if (collisionRuntimeParams.myIsCollidingHorizontally) {
      outCharacterCollisionResults.myMovementResults.myReferenceCollisionHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
    } else if (collisionRuntimeParams.myIsCollidingVertically) {
      outCharacterCollisionResults.myMovementResults.myReferenceCollisionHit.copy(collisionRuntimeParams.myVerticalCollisionHit);
    }
    outCharacterCollisionResults.myHorizontalMovementResults.myMovementFailed = collisionRuntimeParams.myHorizontalMovementCanceled;
    outCharacterCollisionResults.myHorizontalMovementResults.myMovementCollided = collisionRuntimeParams.myIsCollidingHorizontally;
    outCharacterCollisionResults.myHorizontalMovementResults.myReferenceCollisionHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
    outCharacterCollisionResults.myHorizontalMovementResults.myInitialMovement = collisionRuntimeParams.myOriginalMovement.vec3_removeComponentAlongAxis(collisionRuntimeParams.myOffsetUp, outCharacterCollisionResults.myHorizontalMovementResults.myInitialMovement);
    outCharacterCollisionResults.myHorizontalMovementResults.myFinalMovement = collisionRuntimeParams.myFixedMovement.vec3_removeComponentAlongAxis(collisionRuntimeParams.myOffsetUp, outCharacterCollisionResults.myHorizontalMovementResults.myFinalMovement);
    outCharacterCollisionResults.myVerticalMovementResults.myMovementFailed = collisionRuntimeParams.myVerticalMovementCanceled;
    outCharacterCollisionResults.myVerticalMovementResults.myMovementCollided = collisionRuntimeParams.myIsCollidingVertically;
    outCharacterCollisionResults.myVerticalMovementResults.myReferenceCollisionHit.copy(collisionRuntimeParams.myVerticalCollisionHit);
    outCharacterCollisionResults.myVerticalMovementResults.myInitialMovement = collisionRuntimeParams.myOriginalMovement.vec3_componentAlongAxis(collisionRuntimeParams.myOffsetUp, outCharacterCollisionResults.myVerticalMovementResults.myInitialMovement);
    outCharacterCollisionResults.myVerticalMovementResults.myFinalMovement = collisionRuntimeParams.myFixedMovement.vec3_componentAlongAxis(collisionRuntimeParams.myOffsetUp, outCharacterCollisionResults.myVerticalMovementResults.myFinalMovement);
    outCharacterCollisionResults.myTeleportResults.myInitialTeleportTransformQuat.quat2_copy(outCharacterCollisionResults.myTransformResults.myInitialTransformQuat);
    outCharacterCollisionResults.myTeleportResults.myInitialTeleportTransformQuat.quat2_setPosition(collisionRuntimeParams.myOriginalTeleportPosition);
    outCharacterCollisionResults.myTeleportResults.myFinalTeleportTransformQuat.quat2_copy(outCharacterCollisionResults.myTransformResults.myFinalTransformQuat);
    outCharacterCollisionResults.myTeleportResults.myFinalTeleportTransformQuat.quat2_setPosition(collisionRuntimeParams.myFixedTeleportPosition);
    outCharacterCollisionResults.myTeleportResults.myTeleportFailed = collisionRuntimeParams.myTeleportCanceled;
    outCharacterCollisionResults.myCheckTransformResults.myInitialCheckTransformQuat.quat2_copy(outCharacterCollisionResults.myTransformResults.myInitialTransformQuat);
    outCharacterCollisionResults.myCheckTransformResults.myInitialCheckTransformQuat.quat2_setPosition(collisionRuntimeParams.myOriginalPositionCheckPosition);
    outCharacterCollisionResults.myCheckTransformResults.myFinalCheckTransformQuat.quat2_copy(outCharacterCollisionResults.myTransformResults.myFinalTransformQuat);
    outCharacterCollisionResults.myCheckTransformResults.myFinalCheckTransformQuat.quat2_setPosition(collisionRuntimeParams.myFixedPositionCheckPosition);
    outCharacterCollisionResults.myCheckTransformResults.myCheckTransformFailed = !collisionRuntimeParams.myIsPositionOk;
    outCharacterCollisionResults.myWallSlideResults.myHasSlid = collisionRuntimeParams.myIsSliding;
    outCharacterCollisionResults.myWallSlideResults.mySlideMovementAngle = collisionRuntimeParams.mySlidingMovementAngle;
    outCharacterCollisionResults.myWallSlideResults.mySlideMovementWallAngle = collisionRuntimeParams.mySlidingCollisionAngle;
    outCharacterCollisionResults.myWallSlideResults.myWallNormal.vec3_copy(collisionRuntimeParams.mySlidingWallNormal);
    outCharacterCollisionResults.myGroundInfo.myOnSurface = collisionRuntimeParams.myIsOnGround;
    outCharacterCollisionResults.myGroundInfo.mySurfaceAngle = collisionRuntimeParams.myGroundAngle;
    outCharacterCollisionResults.myGroundInfo.mySurfacePerceivedAngle = collisionRuntimeParams.myGroundPerceivedAngle;
    outCharacterCollisionResults.myGroundInfo.mySurfaceNormal.vec3_copy(collisionRuntimeParams.myGroundNormal);
    outCharacterCollisionResults.myGroundInfo.mySurfaceHitMaxAngle = collisionRuntimeParams.myGroundHitMaxAngle;
    outCharacterCollisionResults.myGroundInfo.mySurfaceHitMaxNormal.vec3_copy(collisionRuntimeParams.myGroundHitMaxNormal);
    outCharacterCollisionResults.myGroundInfo.mySurfaceDistance = collisionRuntimeParams.myGroundDistance;
    outCharacterCollisionResults.myGroundInfo.myBaseInsideCollision = collisionRuntimeParams.myGroundIsBaseInsideCollision;
    outCharacterCollisionResults.myCeilingInfo.myOnSurface = collisionRuntimeParams.myIsOnCeiling;
    outCharacterCollisionResults.myCeilingInfo.mySurfaceAngle = collisionRuntimeParams.myCeilingAngle;
    outCharacterCollisionResults.myCeilingInfo.mySurfacePerceivedAngle = collisionRuntimeParams.myCeilingPerceivedAngle;
    outCharacterCollisionResults.myCeilingInfo.mySurfaceNormal.vec3_copy(collisionRuntimeParams.myCeilingNormal);
    outCharacterCollisionResults.myCeilingInfo.mySurfaceHitMaxAngle = collisionRuntimeParams.myCeilingHitMaxAngle;
    outCharacterCollisionResults.myCeilingInfo.mySurfaceHitMaxNormal.vec3_copy(collisionRuntimeParams.myCeilingHitMaxNormal);
    outCharacterCollisionResults.myCeilingInfo.mySurfaceDistance = collisionRuntimeParams.myCeilingDistance;
    outCharacterCollisionResults.myCeilingInfo.myBaseInsideCollision = collisionRuntimeParams.myCeilingIsBaseInsideCollision;
    outCharacterCollisionResults.myGroundResults.myHasSnappedOnSurface = collisionRuntimeParams.myHasSnappedOnGround;
    outCharacterCollisionResults.myGroundResults.myHasPoppedOutSurface = collisionRuntimeParams.myHasPoppedOutGround;
    outCharacterCollisionResults.myCeilingResults.myHasSnappedOnSurface = collisionRuntimeParams.myHasSnappedOnCeiling;
    outCharacterCollisionResults.myCeilingResults.myHasPoppedOutSurface = collisionRuntimeParams.myHasPoppedOutCeiling;
    outCharacterCollisionResults.myGroundResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill = collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill;
    outCharacterCollisionResults.myGroundResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill = collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill;
    outCharacterCollisionResults.myGroundResults.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill = collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill;
    outCharacterCollisionResults.myCeilingResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill = collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill;
    outCharacterCollisionResults.myCeilingResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill = collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill;
    outCharacterCollisionResults.myCeilingResults.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill = collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill;
    outCharacterCollisionResults.mySplitMovementResults.myStepsToPerform = collisionRuntimeParams.mySplitMovementSteps;
    outCharacterCollisionResults.mySplitMovementResults.myStepsPerformed = collisionRuntimeParams.mySplitMovementStepsPerformed;
    outCharacterCollisionResults.mySplitMovementResults.myMovementInterrupted = collisionRuntimeParams.mySplitMovementStop;
    outCharacterCollisionResults.mySplitMovementResults.myMovementChecked.vec3_copy(collisionRuntimeParams.mySplitMovementMovementChecked);
    outCharacterCollisionResults.myInternalResults.myLastRelevantInitialHorizontalMovement.vec3_copy(collisionRuntimeParams.myLastValidOriginalHorizontalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantFinalHorizontalMovement.vec3_copy(collisionRuntimeParams.myLastValidEndHorizontalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantInitialVerticalMovement.vec3_copy(collisionRuntimeParams.myLastValidOriginalVerticalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantFinalVerticalMovement.vec3_copy(collisionRuntimeParams.myLastValidEndVerticalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantAdjustedInitialHorizontalMovement.vec3_copy(collisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantAdjustedInitialVerticalMovement.vec3_copy(collisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantHasWallSlid = collisionRuntimeParams.myLastValidIsSliding;
    outCharacterCollisionResults.myInternalResults.myHasWallSlidTowardOppositeDirection = collisionRuntimeParams.myIsSlidingIntoOppositeDirection;
    outCharacterCollisionResults.myInternalResults.myLastRelevantWallSlideFlickerPrevented = collisionRuntimeParams.myIsSlidingFlickerPrevented;
    outCharacterCollisionResults.myInternalResults.myWallSlideFlickerPreventionForceCheckCounter = collisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter;
    outCharacterCollisionResults.myInternalResults.myWallSlide90DegreesDirectionSign = collisionRuntimeParams.mySliding90DegreesSign;
    outCharacterCollisionResults.myInternalResults.myWallSlide90DegreesRecomputeDirectionSign = collisionRuntimeParams.mySlidingRecompute90DegreesSign;
    outCharacterCollisionResults.myTransformResults.myInitialTransformQuat.quat2_copy(currentTransformQuat);
    return outCharacterCollisionResults;
  };
}();
var convertCharacterColliderSetupToCollisionCheckParams = function() {
  return function convertCharacterColliderSetupToCollisionCheckParams2(characterColliderSetup, outCollisionCheckParams) {
    outCollisionCheckParams.myHeight = characterColliderSetup.myHeight;
    outCollisionCheckParams.myRadius = characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckConeRadius;
    outCollisionCheckParams.myDistanceFromFeetToIgnore = characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckFeetDistanceToIgnore;
    outCollisionCheckParams.myDistanceFromHeadToIgnore = characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckHeadDistanceToIgnore;
    outCollisionCheckParams.myHorizontalMovementCheckEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementStepEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckSplitMovementEnabled;
    outCollisionCheckParams.myHorizontalMovementStepMaxLength = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckSplitMovementMaxStepLength;
    outCollisionCheckParams.myHorizontalMovementRadialStepAmount = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckRadialSteps;
    outCollisionCheckParams.myHorizontalMovementCheckDiagonalOutward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckDiagonalInward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckStraight = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalStraightCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckHorizontalBorder = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalRadialCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalStraight = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalDiagonalUpwardInward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalDiagonalDownwardOutward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalDiagonalDownwardInward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalStraightDiagonalUpward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalStraightDiagonalDownward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalRadialDiagonalOutwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalRadialDiagonalInwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementHorizontalStraightCentralCheckEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalStraightCentralCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementVerticalStraightCentralCheckEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightCentralCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled;
    outCollisionCheckParams.myHorizontalPositionCheckEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionCheckEnabled;
    outCollisionCheckParams.myHalfConeAngle = characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckConeHalfAngle;
    outCollisionCheckParams.myHalfConeSliceAmount = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionCheckConeHalfSlices;
    outCollisionCheckParams.myCheckConeBorder = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHorizontalBorderCheckEnabled;
    outCollisionCheckParams.myCheckConeRay = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHorizontalRadialCheckEnabled;
    outCollisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision;
    outCollisionCheckParams.myHorizontalPositionCheckVerticalDirectionType = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckDirection;
    outCollisionCheckParams.myCheckHeight = characterColliderSetup.myHorizontalCheckParams.myHorizontalHeightCheckEnabled;
    outCollisionCheckParams.myCheckHeightVerticalMovement = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHeightVerticalCheckEnabled;
    outCollisionCheckParams.myCheckHeightVerticalPosition = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHeightVerticalCheckEnabled;
    outCollisionCheckParams.myCheckHeightTopMovement = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHeightHorizontalCheckEnabled;
    outCollisionCheckParams.myCheckHeightTopPosition = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHeightHorizontalCheckEnabled;
    outCollisionCheckParams.myCheckHeightConeOnCollision = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit;
    outCollisionCheckParams.myCheckHeightConeOnCollisionKeepHit = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit;
    outCollisionCheckParams.myHeightCheckStepAmountMovement = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHeightCheckSteps;
    outCollisionCheckParams.myHeightCheckStepAmountPosition = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHeightCheckSteps;
    outCollisionCheckParams.myCheckVerticalStraight = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalStraightCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalRayOutward = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalRayInward = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalRadialDiagonalInwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalBorderOutward = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalBorderInward = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalBorderDiagonalInwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalBorderRayOutward = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalRadialBorderDiagonalOutwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalBorderRayInward = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalRadialBorderDiagonalInwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalSearchFartherVerticalHit = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckGetFarthestHit;
    outCollisionCheckParams.myCheckHorizontalFixedForwardEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckFixedForwardEnabled;
    outCollisionCheckParams.myCheckHorizontalFixedForward.vec3_copy(characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckFixedForward);
    outCollisionCheckParams.myVerticalMovementCheckEnabled = characterColliderSetup.myVerticalCheckParams.myVerticalMovementCheckEnabled;
    outCollisionCheckParams.myVerticalPositionCheckEnabled = characterColliderSetup.myVerticalCheckParams.myVerticalPositionCheckEnabled;
    outCollisionCheckParams.myFeetRadius = characterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRadius;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhill = characterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhill;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphill = characterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle = characterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfaceAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle = characterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfaceAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle = characterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle = characterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle;
    outCollisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhill = characterColliderSetup.myGroundParams.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhill;
    outCollisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle = characterColliderSetup.myGroundParams.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhillMinSurfaceAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhill = characterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhill;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphill = characterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = characterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfaceAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = characterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfaceAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxPerceivedAngle = characterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxPerceivedAngle = characterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle;
    outCollisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhill = characterColliderSetup.myCeilingParams.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhill;
    outCollisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle = characterColliderSetup.myCeilingParams.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhillMinSurfaceAngle;
    outCollisionCheckParams.myCheckVerticalFixedForwardEnabled = characterColliderSetup.myVerticalCheckParams.myVerticalCheckFixedForwardEnabled;
    outCollisionCheckParams.myCheckVerticalFixedForward.vec3_copy(characterColliderSetup.myVerticalCheckParams.myVerticalCheckFixedForward);
    outCollisionCheckParams.myCheckVerticalBothDirection = characterColliderSetup.myVerticalCheckParams.myVerticalMovementCheckPerformCheckOnBothSides;
    outCollisionCheckParams.myVerticalMovementReduceEnabled = characterColliderSetup.myVerticalCheckParams.myVerticalMovementCheckReductionEnabled;
    outCollisionCheckParams.myGroundCircumferenceAddCenter = characterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceCentralCheckEnabled;
    outCollisionCheckParams.myGroundCircumferenceSliceAmount = characterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceSlices;
    outCollisionCheckParams.myGroundCircumferenceStepAmount = characterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRadialSteps;
    outCollisionCheckParams.myGroundCircumferenceRotationPerStep = characterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRotationPerRadialStep;
    outCollisionCheckParams.myVerticalAllowHitInsideCollisionIfOneOk = characterColliderSetup.myVerticalCheckParams.myVerticalCheckAllowHitsInsideCollisionIfOneValid;
    outCollisionCheckParams.myHorizontalBlockLayerFlags.copy(characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckBlockLayerFlags);
    outCollisionCheckParams.myVerticalBlockLayerFlags.copy(characterColliderSetup.myVerticalCheckParams.myVerticalCheckBlockLayerFlags);
    outCollisionCheckParams.myHorizontalObjectsToIgnore.pp_copy(characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckObjectsToIgnore);
    outCollisionCheckParams.myVerticalObjectsToIgnore.pp_copy(characterColliderSetup.myVerticalCheckParams.myVerticalCheckObjectsToIgnore);
    outCollisionCheckParams.mySnapOnGroundEnabled = characterColliderSetup.myGroundParams.mySurfaceSnapEnabled;
    outCollisionCheckParams.mySnapOnGroundExtraDistance = characterColliderSetup.myGroundParams.mySurfaceSnapMaxDistance;
    outCollisionCheckParams.mySnapOnCeilingEnabled = characterColliderSetup.myCeilingParams.mySurfaceSnapEnabled;
    outCollisionCheckParams.mySnapOnCeilingExtraDistance = characterColliderSetup.myCeilingParams.mySurfaceSnapMaxDistance;
    outCollisionCheckParams.myGroundPopOutEnabled = characterColliderSetup.myGroundParams.mySurfacePopOutEnabled;
    outCollisionCheckParams.myGroundPopOutExtraDistance = characterColliderSetup.myGroundParams.mySurfacePopOutMaxDistance;
    outCollisionCheckParams.myCeilingPopOutEnabled = characterColliderSetup.myCeilingParams.mySurfacePopOutEnabled;
    outCollisionCheckParams.myCeilingPopOutExtraDistance = characterColliderSetup.myCeilingParams.mySurfacePopOutMaxDistance;
    outCollisionCheckParams.myGroundAngleToIgnore = characterColliderSetup.myGroundParams.mySurfaceAngleToIgnore;
    outCollisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle = characterColliderSetup.myGroundParams.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle;
    outCollisionCheckParams.myCeilingAngleToIgnore = characterColliderSetup.myCeilingParams.mySurfaceAngleToIgnore;
    outCollisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle = characterColliderSetup.myCeilingParams.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle;
    outCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreHeight = characterColliderSetup.myGroundParams.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance;
    outCollisionCheckParams.myHorizontalMovementCeilingAngleIgnoreHeight = characterColliderSetup.myCeilingParams.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance;
    outCollisionCheckParams.myHorizontalPositionGroundAngleIgnoreHeight = characterColliderSetup.myGroundParams.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance;
    outCollisionCheckParams.myHorizontalPositionCeilingAngleIgnoreHeight = characterColliderSetup.myCeilingParams.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance;
    outCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = characterColliderSetup.myGroundParams.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft;
    outCollisionCheckParams.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft = characterColliderSetup.myCeilingParams.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft;
    outCollisionCheckParams.myComputeGroundInfoEnabled = characterColliderSetup.myGroundParams.myCollectSurfaceInfo;
    outCollisionCheckParams.myComputeCeilingInfoEnabled = characterColliderSetup.myCeilingParams.myCollectSurfaceInfo;
    outCollisionCheckParams.myDistanceToBeOnGround = characterColliderSetup.myGroundParams.myOnSurfaceMaxOutsideDistance;
    outCollisionCheckParams.myDistanceToComputeGroundInfo = characterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxOutsideDistance;
    outCollisionCheckParams.myDistanceToBeOnCeiling = characterColliderSetup.myCeilingParams.myOnSurfaceMaxOutsideDistance;
    outCollisionCheckParams.myDistanceToComputeCeilingInfo = characterColliderSetup.myCeilingParams.myCollectSurfaceNormalMaxOutsideDistance;
    outCollisionCheckParams.myVerticalFixToBeOnGround = characterColliderSetup.myGroundParams.myOnSurfaceMaxInsideDistance;
    outCollisionCheckParams.myVerticalFixToComputeGroundInfo = characterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxInsideDistance;
    outCollisionCheckParams.myVerticalFixToBeOnCeiling = characterColliderSetup.myCeilingParams.myOnSurfaceMaxInsideDistance;
    outCollisionCheckParams.myVerticalFixToComputeCeilingInfo = characterColliderSetup.myCeilingParams.myCollectSurfaceNormalMaxInsideDistance;
    outCollisionCheckParams.myGroundIsBaseInsideCollisionCheckEnabled = characterColliderSetup.myGroundParams.myBaseInsideCollisionCheckEnabled;
    outCollisionCheckParams.myCeilingIsBaseInsideCollisionCheckEnabled = characterColliderSetup.myCeilingParams.myBaseInsideCollisionCheckEnabled;
    outCollisionCheckParams.myIsOnGroundIfInsideHit = characterColliderSetup.myGroundParams.myOnSurfaceIfBaseInsideCollision;
    outCollisionCheckParams.myIsOnCeilingIfInsideHit = characterColliderSetup.myCeilingParams.myOnSurfaceIfBaseInsideCollision;
    outCollisionCheckParams.myFindGroundDistanceMaxOutsideDistance = characterColliderSetup.myGroundParams.myFindSurfaceDistanceMaxOutsideDistance;
    outCollisionCheckParams.myFindGroundDistanceMaxInsideDistance = characterColliderSetup.myGroundParams.myFindSurfaceDistanceMaxInsideDistance;
    outCollisionCheckParams.myFindCeilingDistanceMaxOutsideDistance = characterColliderSetup.myCeilingParams.myFindSurfaceDistanceMaxOutsideDistance;
    outCollisionCheckParams.myFindCeilingDistanceMaxInsideDistance = characterColliderSetup.myCeilingParams.myFindSurfaceDistanceMaxInsideDistance;
    outCollisionCheckParams.myAllowGroundSteepFix = characterColliderSetup.myGroundParams.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle;
    outCollisionCheckParams.myAllowCeilingSteepFix = characterColliderSetup.myCeilingParams.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle;
    outCollisionCheckParams.myMustStayOnGround = characterColliderSetup.myGroundParams.myMovementMustStayOnSurface;
    outCollisionCheckParams.myMustStayOnCeiling = characterColliderSetup.myCeilingParams.myMovementMustStayOnSurface;
    outCollisionCheckParams.myRegatherGroundInfoOnSurfaceCheckFail = characterColliderSetup.myGroundParams.myRecollectSurfaceInfoOnSurfaceCheckFailed;
    outCollisionCheckParams.myRegatherCeilingInfoOnSurfaceCheckFail = characterColliderSetup.myCeilingParams.myRecollectSurfaceInfoOnSurfaceCheckFailed;
    outCollisionCheckParams.myMustStayBelowIgnorableGroundAngleDownhill = characterColliderSetup.myGroundParams.myMovementMustStayOnIgnorableSurfaceAngleDownhill;
    outCollisionCheckParams.myMustStayBelowIgnorableCeilingAngleDownhill = characterColliderSetup.myCeilingParams.myMovementMustStayOnIgnorableSurfaceAngleDownhill;
    outCollisionCheckParams.myMustStayBelowGroundAngleDownhill = characterColliderSetup.myGroundParams.myMovementMustStayOnSurfaceAngleDownhill;
    outCollisionCheckParams.myMustStayBelowCeilingAngleDownhill = characterColliderSetup.myCeilingParams.myMovementMustStayOnSurfaceAngleDownhill;
    outCollisionCheckParams.myMovementMustStayOnGroundHitAngle = characterColliderSetup.myGroundParams.myMovementMustStayOnSurfaceHitMaxAngle;
    outCollisionCheckParams.myMovementMustStayOnCeilingHitAngle = characterColliderSetup.myCeilingParams.myMovementMustStayOnSurfaceHitMaxAngle;
    outCollisionCheckParams.myTeleportMustBeOnIgnorableGroundAngle = characterColliderSetup.myGroundParams.myTeleportMustBeOnIgnorableSurfaceAngle;
    outCollisionCheckParams.myCheckTransformMustBeOnIgnorableGroundAngle = characterColliderSetup.myGroundParams.myCheckTransformMustBeOnIgnorableSurfaceAngle;
    outCollisionCheckParams.myTeleportMustBeOnIgnorableCeilingAngle = characterColliderSetup.myCeilingParams.myTeleportMustBeOnIgnorableSurfaceAngle;
    outCollisionCheckParams.myCheckTransformMustBeOnIgnorableCeilingAngle = characterColliderSetup.myCeilingParams.myCheckTransformMustBeOnIgnorableSurfaceAngle;
    outCollisionCheckParams.myTeleportMustBeOnGroundAngle = characterColliderSetup.myGroundParams.myTeleportMustBeOnSurfaceAngle;
    outCollisionCheckParams.myCheckTransformMustBeOnGroundAngle = characterColliderSetup.myGroundParams.myCheckTransformMustBeOnSurfaceAngle;
    outCollisionCheckParams.myTeleportMustBeOnCeilingAngle = characterColliderSetup.myCeilingParams.myTeleportMustBeOnSurfaceAngle;
    outCollisionCheckParams.myCheckTransformMustBeOnCeilingAngle = characterColliderSetup.myCeilingParams.myCheckTransformMustBeOnSurfaceAngle;
    outCollisionCheckParams.myTeleportMustBeOnGround = characterColliderSetup.myGroundParams.myTeleportMustBeOnSurface;
    outCollisionCheckParams.myCheckTransformMustBeOnGround = characterColliderSetup.myGroundParams.myCheckTransformMustBeOnSurface;
    outCollisionCheckParams.myTeleportMustBeOnCeiling = characterColliderSetup.myCeilingParams.myTeleportMustBeOnSurface;
    outCollisionCheckParams.myCheckTransformMustBeOnCeiling = characterColliderSetup.myCeilingParams.myCheckTransformMustBeOnSurface;
    outCollisionCheckParams.mySlidingEnabled = characterColliderSetup.myWallSlideParams.myWallSlideEnabled;
    outCollisionCheckParams.mySlidingHorizontalMovementCheckBetterNormal = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckGetBetterReferenceHit;
    outCollisionCheckParams.mySlidingMaxAttempts = characterColliderSetup.myWallSlideParams.myWallSlideMaxAttempts;
    outCollisionCheckParams.mySlidingCheckBothDirections = characterColliderSetup.myWallSlideParams.myCheckBothWallSlideDirections;
    outCollisionCheckParams.mySlidingFlickeringPreventionType = characterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionMode;
    outCollisionCheckParams.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding = characterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding;
    outCollisionCheckParams.mySlidingFlickerPreventionCheckAnywayCounter = characterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionForceCheckCounter;
    outCollisionCheckParams.mySlidingAdjustSign90Degrees = characterColliderSetup.myWallSlideParams.my90DegreesWallSlideAdjustDirectionSign;
    outCollisionCheckParams.mySplitMovementEnabled = characterColliderSetup.mySplitMovementParams.mySplitMovementEnabled;
    outCollisionCheckParams.mySplitMovementMaxLength = characterColliderSetup.mySplitMovementParams.mySplitMovementMaxStepLength;
    outCollisionCheckParams.mySplitMovementMaxStepsEnabled = characterColliderSetup.mySplitMovementParams.mySplitMovementMaxSteps != null;
    outCollisionCheckParams.mySplitMovementMaxSteps = characterColliderSetup.mySplitMovementParams.mySplitMovementMaxSteps;
    outCollisionCheckParams.mySplitMovementStepEqualLength = characterColliderSetup.mySplitMovementParams.mySplitMovementMaxStepLength == null;
    outCollisionCheckParams.mySplitMovementStepEqualLengthMinLength = characterColliderSetup.mySplitMovementParams.mySplitMovementMinStepLength;
    outCollisionCheckParams.mySplitMovementStopWhenHorizontalMovementCanceled = characterColliderSetup.mySplitMovementParams.mySplitMovementStopOnHorizontalMovementFailed;
    outCollisionCheckParams.mySplitMovementStopWhenVerticalMovementCanceled = characterColliderSetup.mySplitMovementParams.mySplitMovementStopOnVerticalMovementFailed;
    outCollisionCheckParams.mySplitMovementStopCallback = characterColliderSetup.mySplitMovementParams.mySplitMovementStopOnCallback;
    outCollisionCheckParams.mySplitMovementStopReturnPrevious = characterColliderSetup.mySplitMovementParams.mySplitMovementStopReturnPreviousResults;
    outCollisionCheckParams.myPositionOffsetLocal.vec3_copy(characterColliderSetup.myAdditionalParams.myPositionOffsetLocal);
    outCollisionCheckParams.myRotationOffsetLocalQuat.quat_copy(characterColliderSetup.myAdditionalParams.myRotationOffsetLocalQuat);
    outCollisionCheckParams.myDebugEnabled = characterColliderSetup.myDebugParams.myVisualDebugEnabled;
    outCollisionCheckParams.myDebugHorizontalMovementEnabled = characterColliderSetup.myDebugParams.myVisualDebugHorizontalMovementCheckEnabled;
    outCollisionCheckParams.myDebugHorizontalPositionEnabled = characterColliderSetup.myDebugParams.myVisualDebugHorizontalPositionCheckEnabled;
    outCollisionCheckParams.myDebugVerticalMovementEnabled = characterColliderSetup.myDebugParams.myVisualDebugVerticalMovementCheckEnabled;
    outCollisionCheckParams.myDebugVerticalPositionEnabled = characterColliderSetup.myDebugParams.myVisualDebugVerticalPositionCheckEnabled;
    outCollisionCheckParams.myDebugSlidingEnabled = characterColliderSetup.myDebugParams.myVisualDebugSlideEnabled;
    outCollisionCheckParams.myDebugGroundInfoEnabled = characterColliderSetup.myDebugParams.myVisualDebugGroundInfoEnabled;
    outCollisionCheckParams.myDebugCeilingInfoEnabled = characterColliderSetup.myDebugParams.myVisualDebugGroundInfoEnabled;
    outCollisionCheckParams.myDebugRuntimeParamsEnabled = characterColliderSetup.myDebugParams.myVisualDebugResultsEnabled;
    outCollisionCheckParams.myDebugMovementEnabled = characterColliderSetup.myDebugParams.myVisualDebugMovementEnabled;
    return outCollisionCheckParams;
  };
}();
var CollisionCheckBridge = {
  getCollisionCheck,
  setCollisionCheck,
  initBridge,
  checkMovement,
  checkTeleportToTransform,
  checkTransform,
  updateGroundInfo,
  updateCeilingInfo,
  convertCharacterCollisionResultsToCollisionRuntimeParams,
  convertCollisionRuntimeParamsToCharacterCollisionResults,
  convertCharacterColliderSetupToCollisionCheckParams
};

// js/pp/gameplay/experimental/character_controller/collision/character_collider_setup.js
var CharacterColliderSetup = class {
  constructor() {
    this.myHeight = 0;
    this.myHorizontalCheckParams = new CharacterColliderHorizontalCheckParams();
    this.myVerticalCheckParams = new CharacterColliderVerticalCheckParams();
    this.myWallSlideParams = new CharacterColliderWallSlideParams();
    this.myGroundParams = new CharacterColliderSurfaceParams();
    this.myCeilingParams = new CharacterColliderSurfaceParams();
    this.mySplitMovementParams = new CharacterColliderSplitMovementParams();
    this.myAdditionalParams = new CharacterColliderAdditionalParams();
    this.myDebugParams = new CharacterColliderDebugParams();
  }
  copy(other) {
  }
};
var CharacterColliderHorizontalPositionVerticalCheckDirection = {
  UPWARD: 0,
  // Gives less issues with a ground based movement, but may also collide a bit more, resulting in less sliding
  DOWNWARD: 1,
  // Gives less issues with a ceiling based movement (unusual), but may also collide a bit more, resulting in less sliding and more stuck in front of a wall
  BOTH: 2
  // Check both directions, more expensive (2x checks) and better prevent collisions, sliding more, but is more expensive and gives more issues           
  //                                                                                                                                                  _
  // The issues means that a small step at the end of a slope, maybe due to 2 rectangles, one for the floor and the other for the slope like this -> /   
  // can create a small step if the floor rectangle is a bit above the end of the slope, this will make the character get stuck thinking it's a wall
  // BOTH do a more "aggressive" vertical check that makes the character get less stuck in other situations, but can get stuck in this one
  // The better solution is to properly create the level, and if possible combine the 2 rectangles by having the floor a little below the end of the slope (like this -> /-)
  // The step that is created "on the other side" in fact can easily be ignored thanks to the myHorizontalCheckFeetDistanceToIgnore param
  // If the level is properly created the best solution should be UPWARD
  // and also myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision = false
};
var CharacterColliderHorizontalCheckParams = class {
  constructor() {
    this.myHorizontalCheckConeRadius = 0;
    this.myHorizontalCheckConeHalfAngle = 0;
    this.myHorizontalHeightCheckEnabled = false;
    this.myHorizontalCheckFeetDistanceToIgnore = 0;
    this.myHorizontalCheckHeadDistanceToIgnore = 0;
    this.myHorizontalCheckFixedForwardEnabled = false;
    this.myHorizontalCheckFixedForward = vec3_create();
    this.myHorizontalMovementCheckEnabled = false;
    this.myHorizontalMovementCheckRadialSteps = 0;
    this.myHorizontalMovementCheckSplitMovementEnabled = false;
    this.myHorizontalMovementCheckSplitMovementMaxSteps = null;
    this.myHorizontalMovementCheckSplitMovementMaxStepLength = null;
    this.myHorizontalMovementCheckSplitMovementMinStepLength = null;
    this.myHorizontalMovementCheckGetBetterReferenceHit = false;
    this.myHorizontalMovementHorizontalRadialCheckEnabled = false;
    this.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled = false;
    this.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled = false;
    this.myHorizontalMovementHorizontalStraightCheckEnabled = false;
    this.myHorizontalMovementHorizontalStraightCentralCheckEnabled = false;
    this.myHorizontalMovementHeightCheckSteps = 0;
    this.myHorizontalMovementHeightHorizontalCheckEnabled = false;
    this.myHorizontalMovementHeightVerticalCheckEnabled = false;
    this.myHorizontalMovementVerticalRadialDiagonalOutwardCheckEnabled = false;
    this.myHorizontalMovementVerticalRadialDiagonalInwardCheckEnabled = false;
    this.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled = false;
    this.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled = false;
    this.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled = false;
    this.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightCentralCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = false;
    this.myHorizontalPositionCheckEnabled = false;
    this.myHorizontalPositionCheckConeHalfSlices = 0;
    this.myHorizontalPositionHorizontalBorderCheckEnabled = false;
    this.myHorizontalPositionHorizontalRadialCheckEnabled = false;
    this.myHorizontalPositionHeightCheckSteps = 0;
    this.myHorizontalPositionHeightHorizontalCheckEnabled = false;
    this.myHorizontalPositionHeightVerticalCheckEnabled = false;
    this.myHorizontalPositionVerticalStraightCheckEnabled = false;
    this.myHorizontalPositionVerticalStraightCentralCheckEnabled = false;
    this.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled = false;
    this.myHorizontalPositionVerticalRadialDiagonalInwardCheckEnabled = false;
    this.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled = false;
    this.myHorizontalPositionVerticalBorderDiagonalInwardCheckEnabled = false;
    this.myHorizontalPositionVerticalRadialBorderDiagonalOutwardCheckEnabled = false;
    this.myHorizontalPositionVerticalRadialBorderDiagonalInwardCheckEnabled = false;
    this.myHorizontalPositionVerticalCheckGetFarthestHit = false;
    this.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit = false;
    this.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit = false;
    this.myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision = false;
    this.myHorizontalPositionVerticalCheckDirection = CharacterColliderHorizontalPositionVerticalCheckDirection.UPWARD;
    this.myHorizontalCheckBlockLayerFlags = new PhysicsLayerFlags();
    this.myHorizontalCheckObjectsToIgnore = [];
  }
  copy(other) {
  }
};
var CharacterColliderVerticalCheckParams = class {
  constructor() {
    this.myVerticalCheckCircumferenceRadius = 0;
    this.myVerticalCheckCircumferenceSlices = 0;
    this.myVerticalCheckCircumferenceCentralCheckEnabled = false;
    this.myVerticalCheckCircumferenceRadialSteps = 0;
    this.myVerticalCheckCircumferenceRotationPerRadialStep = 0;
    this.myVerticalCheckFixedForwardEnabled = false;
    this.myVerticalCheckFixedForward = vec3_create();
    this.myVerticalMovementCheckEnabled = false;
    this.myVerticalMovementCheckReductionEnabled = false;
    this.myVerticalMovementCheckPerformCheckOnBothSides = false;
    this.myVerticalPositionCheckEnabled = false;
    this.myVerticalCheckAllowHitsInsideCollisionIfOneValid = false;
    this.myVerticalCheckBlockLayerFlags = new PhysicsLayerFlags();
    this.myVerticalCheckObjectsToIgnore = [];
  }
  copy(other) {
  }
};
var CharacterColliderSlideFlickerPreventionMode = {
  NONE: 0,
  USE_PREVIOUS_RESULTS: 1,
  // Allow some flicker before stabilizing but avoid stopping for a 1 frame flicker only (false positive), is also less expensive
  COLLISION_ANGLE_ABOVE_90_DEGREES: 2,
  // Prevents most flicker apart those on almost flat surface, can have some false positive, always check when sliding into opposite direction
  COLLISION_ANGLE_ABOVE_90_DEGREES_OR_MOVEMENT_ANGLE_ABOVE_85_DEGREES: 3,
  // Less flicker than COLLISION_ANGLE_ABOVE_90_DEGREES but more false positive, always check when sliding into opposite direction
  ALWAYS: 4
  // Less flicker than COLLISION_ANGLE_ABOVE_90_DEGREES_OR_MOVEMENT_ANGLE_ABOVE_85_DEGREES but more false positive
};
var CharacterColliderWallSlideParams = class {
  constructor() {
    this.myWallSlideEnabled = false;
    this.myWallSlideMaxAttempts = 0;
    this.myCheckBothWallSlideDirections = false;
    this.myWallSlideFlickerPreventionMode = CharacterColliderSlideFlickerPreventionMode.NONE;
    this.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding = false;
    this.myWallSlideFlickerPreventionForceCheckCounter = 0;
    this.my90DegreesWallSlideAdjustDirectionSign = false;
  }
  copy(other) {
  }
};
var CharacterColliderSurfaceParams = class {
  constructor() {
    this.mySurfaceSnapEnabled = false;
    this.mySurfaceSnapMaxDistance = 0;
    this.mySurfacePopOutEnabled = false;
    this.mySurfacePopOutMaxDistance = 0;
    this.mySurfaceAngleToIgnore = 0;
    this.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle = null;
    this.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance = null;
    this.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance = null;
    this.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft = null;
    this.myCollectSurfaceInfo = false;
    this.myOnSurfaceMaxOutsideDistance = 0;
    this.myOnSurfaceMaxInsideDistance = 0;
    this.myBaseInsideCollisionCheckEnabled = false;
    this.myOnSurfaceIfBaseInsideCollision = false;
    this.myCollectSurfaceNormalMaxOutsideDistance = 0;
    this.myCollectSurfaceNormalMaxInsideDistance = 0;
    this.myFindSurfaceDistanceMaxOutsideDistance = 0;
    this.myFindSurfaceDistanceMaxInsideDistance = 0;
    this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhill = false;
    this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill = false;
    this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfaceAngle = null;
    this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfaceAngle = null;
    this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle = null;
    this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle = null;
    this.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhill = false;
    this.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhillMinSurfaceAngle = null;
    this.myMovementMustStayOnSurface = false;
    this.myMovementMustStayOnSurfaceHitMaxAngle = null;
    this.myMovementMustStayOnIgnorableSurfaceAngleDownhill = false;
    this.myMovementMustStayOnSurfaceAngleDownhill = null;
    this.myTeleportMustBeOnSurface = false;
    this.myTeleportMustBeOnIgnorableSurfaceAngle = false;
    this.myTeleportMustBeOnSurfaceAngle = null;
    this.myCheckTransformMustBeOnSurface = false;
    this.myCheckTransformMustBeOnIgnorableSurfaceAngle = false;
    this.myCheckTransformMustBeOnSurfaceAngle = null;
    this.myRecollectSurfaceInfoOnSurfaceCheckFailed = false;
    this.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle = false;
  }
  copy(other) {
  }
};
var CharacterColliderSplitMovementParams = class {
  constructor() {
    this.mySplitMovementEnabled = false;
    this.mySplitMovementMaxSteps = null;
    this.mySplitMovementMaxStepLength = null;
    this.mySplitMovementMinStepLength = null;
    this.mySplitMovementStopOnHorizontalMovementFailed = false;
    this.mySplitMovementStopOnVerticalMovementFailed = false;
    this.mySplitMovementStopReturnPreviousResults = false;
  }
  copy(other) {
  }
};
var CharacterColliderAdditionalParams = class {
  constructor() {
    this.myPositionOffsetLocal = vec3_create();
    this.myRotationOffsetLocalQuat = quat_create();
  }
  copy(other) {
  }
};
var CharacterColliderDebugParams = class {
  constructor() {
    this.myVisualDebugEnabled = false;
    this.myVisualDebugMovementEnabled = false;
    this.myVisualDebugHorizontalMovementCheckEnabled = false;
    this.myVisualDebugHorizontalPositionCheckEnabled = false;
    this.myVisualDebugVerticalMovementCheckEnabled = false;
    this.myVisualDebugVerticalPositionCheckEnabled = false;
    this.myVisualDebugSlideEnabled = false;
    this.myVisualDebugGroundInfoEnabled = false;
    this.myVisualDebugCeilingInfoEnabled = false;
    this.myVisualDebugResultsEnabled = false;
  }
  copy(other) {
  }
};
CharacterColliderSetup.prototype.copy = function copy34(other) {
  this.myHeight = other.myHeight;
  this.myHorizontalCheckParams.copy(other.myHorizontalCheckParams);
  this.myVerticalCheckParams.copy(other.myVerticalCheckParams);
  this.myWallSlideParams.copy(other.myWallSlideParams);
  this.myGroundParams.copy(other.myGroundParams);
  this.myCeilingParams.copy(other.myCeilingParams);
  this.mySplitMovementParams.copy(other.mySplitMovementParams);
  this.myAdditionalParams.copy(other.myAdditionalParams);
  this.myDebugParams.copy(other.myDebugParams);
};
CharacterColliderHorizontalCheckParams.prototype.copy = function copy35(other) {
  this.myHorizontalCheckConeRadius = other.myHorizontalCheckConeRadius;
  this.myHorizontalCheckConeHalfAngle = other.myHorizontalCheckConeHalfAngle;
  this.myHorizontalHeightCheckEnabled = other.myHorizontalHeightCheckEnabled;
  this.myHorizontalCheckFeetDistanceToIgnore = other.myHorizontalCheckFeetDistanceToIgnore;
  this.myHorizontalCheckHeadDistanceToIgnore = other.myHorizontalCheckHeadDistanceToIgnore;
  this.myHorizontalCheckFixedForwardEnabled = other.myHorizontalCheckFixedForwardEnabled;
  this.myHorizontalCheckFixedForward.vec3_copy(other.myHorizontalCheckFixedForward);
  this.myHorizontalMovementCheckEnabled = other.myHorizontalMovementCheckEnabled;
  this.myHorizontalMovementCheckRadialSteps = other.myHorizontalMovementCheckRadialSteps;
  this.myHorizontalMovementCheckSplitMovementEnabled = other.myHorizontalMovementCheckSplitMovementEnabled;
  this.myHorizontalMovementCheckSplitMovementMaxSteps = other.myHorizontalMovementCheckSplitMovementMaxSteps;
  this.myHorizontalMovementCheckSplitMovementMaxStepLength = other.myHorizontalMovementCheckSplitMovementMaxStepLength;
  this.myHorizontalMovementCheckSplitMovementMinStepLength = other.myHorizontalMovementCheckSplitMovementMinStepLength;
  this.myHorizontalMovementCheckGetBetterReferenceHit = other.myHorizontalMovementCheckGetBetterReferenceHit;
  this.myHorizontalMovementHorizontalRadialCheckEnabled = other.myHorizontalMovementHorizontalRadialCheckEnabled;
  this.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled = other.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled;
  this.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled = other.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled;
  this.myHorizontalMovementHorizontalStraightCheckEnabled = other.myHorizontalMovementHorizontalStraightCheckEnabled;
  this.myHorizontalMovementHorizontalStraightCentralCheckEnabled = other.myHorizontalMovementHorizontalStraightCentralCheckEnabled;
  this.myHorizontalMovementHeightCheckSteps = other.myHorizontalMovementHeightCheckSteps;
  this.myHorizontalMovementHeightVerticalCheckEnabled = other.myHorizontalMovementHeightVerticalCheckEnabled;
  this.myHorizontalMovementHeightHorizontalCheckEnabled = other.myHorizontalMovementHeightHorizontalCheckEnabled;
  this.myHorizontalMovementVerticalRadialDiagonalOutwardCheckEnabled = other.myHorizontalMovementVerticalRadialDiagonalOutwardCheckEnabled;
  this.myHorizontalMovementVerticalRadialDiagonalInwardCheckEnabled = other.myHorizontalMovementVerticalRadialDiagonalInwardCheckEnabled;
  this.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled = other.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled;
  this.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled = other.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled;
  this.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled = other.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled;
  this.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled = other.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled;
  this.myHorizontalMovementVerticalStraightCheckEnabled = other.myHorizontalMovementVerticalStraightCheckEnabled;
  this.myHorizontalMovementVerticalStraightCentralCheckEnabled = other.myHorizontalMovementVerticalStraightCentralCheckEnabled;
  this.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled;
  this.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled;
  this.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled;
  this.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled;
  this.myHorizontalPositionCheckEnabled = other.myHorizontalPositionCheckEnabled;
  this.myHorizontalPositionCheckConeHalfSlices = other.myHorizontalPositionCheckConeHalfSlices;
  this.myHorizontalPositionHorizontalBorderCheckEnabled = other.myHorizontalPositionHorizontalBorderCheckEnabled;
  this.myHorizontalPositionHorizontalRadialCheckEnabled = other.myHorizontalPositionHorizontalRadialCheckEnabled;
  this.myHorizontalPositionHeightCheckSteps = other.myHorizontalPositionHeightCheckSteps;
  this.myHorizontalPositionHeightHorizontalCheckEnabled = other.myHorizontalPositionHeightHorizontalCheckEnabled;
  this.myHorizontalPositionHeightVerticalCheckEnabled = other.myHorizontalPositionHeightVerticalCheckEnabled;
  this.myHorizontalPositionVerticalStraightCheckEnabled = other.myHorizontalPositionVerticalStraightCheckEnabled;
  this.myHorizontalPositionVerticalStraightCentralCheckEnabled = other.myHorizontalPositionVerticalStraightCentralCheckEnabled;
  this.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled = other.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled;
  this.myHorizontalPositionVerticalRadialDiagonalInwardCheckEnabled = other.myHorizontalPositionVerticalRadialDiagonalInwardCheckEnabled;
  this.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled = other.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled;
  this.myHorizontalPositionVerticalBorderDiagonalInwardCheckEnabled = other.myHorizontalPositionVerticalBorderDiagonalInwardCheckEnabled;
  this.myHorizontalPositionVerticalRadialBorderDiagonalOutwardCheckEnabled = other.myHorizontalPositionVerticalRadialBorderDiagonalOutwardCheckEnabled;
  this.myHorizontalPositionVerticalRadialBorderDiagonalInwardCheckEnabled = other.myHorizontalPositionVerticalRadialBorderDiagonalInwardCheckEnabled;
  this.myHorizontalPositionVerticalCheckGetFarthestHit = other.myHorizontalPositionVerticalCheckGetFarthestHit;
  this.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit = other.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit;
  this.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit = other.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit;
  this.myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision = other.myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision;
  this.myHorizontalPositionVerticalCheckDirection = other.myHorizontalPositionVerticalCheckDirection;
  this.myHorizontalCheckBlockLayerFlags.setMask(other.myHorizontalCheckBlockLayerFlags.getMask());
  this.myHorizontalCheckObjectsToIgnore.pp_copy(other.myHorizontalCheckObjectsToIgnore);
};
CharacterColliderVerticalCheckParams.prototype.copy = function copy36(other) {
  this.myVerticalCheckCircumferenceRadius = other.myVerticalCheckCircumferenceRadius;
  this.myVerticalCheckCircumferenceSlices = other.myVerticalCheckCircumferenceSlices;
  this.myVerticalCheckCircumferenceCentralCheckEnabled = other.myVerticalCheckCircumferenceCentralCheckEnabled;
  this.myVerticalCheckCircumferenceRadialSteps = other.myVerticalCheckCircumferenceRadialSteps;
  this.myVerticalCheckCircumferenceRotationPerRadialStep = other.myVerticalCheckCircumferenceRotationPerRadialStep;
  this.myVerticalCheckFixedForwardEnabled = other.myVerticalCheckFixedForwardEnabled;
  this.myVerticalCheckFixedForward.vec3_copy(other.myVerticalCheckFixedForward);
  this.myVerticalMovementCheckEnabled = other.myVerticalMovementCheckEnabled;
  this.myVerticalMovementCheckReductionEnabled = other.myVerticalMovementCheckReductionEnabled;
  this.myVerticalMovementCheckPerformCheckOnBothSides = other.myVerticalMovementCheckPerformCheckOnBothSides;
  this.myVerticalPositionCheckEnabled = other.myVerticalPositionCheckEnabled;
  this.myVerticalCheckAllowHitsInsideCollisionIfOneValid = other.myVerticalCheckAllowHitsInsideCollisionIfOneValid;
  this.myVerticalCheckBlockLayerFlags.setMask(other.myVerticalCheckBlockLayerFlags.getMask());
  this.myVerticalCheckObjectsToIgnore.pp_copy(other.myVerticalCheckObjectsToIgnore);
};
CharacterColliderWallSlideParams.prototype.copy = function copy37(other) {
  this.myWallSlideEnabled = other.myWallSlideEnabled;
  this.myWallSlideMaxAttempts = other.myWallSlideMaxAttempts;
  this.myCheckBothWallSlideDirections = other.myCheckBothWallSlideDirections;
  this.myWallSlideFlickerPreventionMode = other.myWallSlideFlickerPreventionMode;
  this.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding = other.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding;
  this.myWallSlideFlickerPreventionForceCheckCounter = other.myWallSlideFlickerPreventionForceCheckCounter;
  this.my90DegreesWallSlideAdjustDirectionSign = other.my90DegreesWallSlideAdjustDirectionSign;
};
CharacterColliderSurfaceParams.prototype.copy = function copy38(other) {
  this.mySurfaceSnapEnabled = other.mySurfaceSnapEnabled;
  this.mySurfaceSnapMaxDistance = other.mySurfaceSnapMaxDistance;
  this.mySurfacePopOutEnabled = other.mySurfacePopOutEnabled;
  this.mySurfacePopOutMaxDistance = other.mySurfacePopOutMaxDistance;
  this.mySurfaceAngleToIgnore = other.mySurfaceAngleToIgnore;
  this.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle = other.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle;
  this.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance = other.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance;
  this.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance = other.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance;
  this.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft = other.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft;
  this.myCollectSurfaceInfo = other.myCollectSurfaceInfo;
  this.myOnSurfaceMaxOutsideDistance = other.myOnSurfaceMaxOutsideDistance;
  this.myOnSurfaceMaxInsideDistance = other.myOnSurfaceMaxInsideDistance;
  this.myBaseInsideCollisionCheckEnabled = other.myBaseInsideCollisionCheckEnabled;
  this.myOnSurfaceIfBaseInsideCollision = other.myOnSurfaceIfBaseInsideCollision;
  this.myCollectSurfaceNormalMaxOutsideDistance = other.myCollectSurfaceNormalMaxOutsideDistance;
  this.myCollectSurfaceNormalMaxInsideDistance = other.myCollectSurfaceNormalMaxInsideDistance;
  this.myFindSurfaceDistanceMaxOutsideDistance = other.myFindSurfaceDistanceMaxOutsideDistance;
  this.myFindSurfaceDistanceMaxInsideDistance = other.myFindSurfaceDistanceMaxInsideDistance;
  this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhill = other.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhill;
  this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill = other.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill;
  this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfaceAngle = other.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfaceAngle;
  this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfaceAngle = other.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfaceAngle;
  this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle = other.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle;
  this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle = other.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle;
  this.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhill = other.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhill;
  this.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhillMinSurfaceAngle = other.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhillMinSurfaceAngle;
  this.myMovementMustStayOnSurface = other.myMovementMustStayOnSurface;
  this.myMovementMustStayOnSurfaceHitMaxAngle = other.myMovementMustStayOnSurfaceHitMaxAngle;
  this.myMovementMustStayOnIgnorableSurfaceAngleDownhill = other.myMovementMustStayOnIgnorableSurfaceAngleDownhill;
  this.myMovementMustStayOnSurfaceAngleDownhill = other.myMovementMustStayOnSurfaceAngleDownhill;
  this.myTeleportMustBeOnSurface = other.myTeleportMustBeOnSurface;
  this.myTeleportMustBeOnIgnorableSurfaceAngle = other.myTeleportMustBeOnIgnorableSurfaceAngle;
  this.myTeleportMustBeOnSurfaceAngle = other.myTeleportMustBeOnSurfaceAngle;
  this.myCheckTransformMustBeOnSurface = other.myCheckTransformMustBeOnSurface;
  this.myCheckTransformMustBeOnIgnorableSurfaceAngle = other.myCheckTransformMustBeOnIgnorableSurfaceAngle;
  this.myCheckTransformMustBeOnSurfaceAngle = other.myCheckTransformMustBeOnSurfaceAngle;
  this.myRecollectSurfaceInfoOnSurfaceCheckFailed = other.myRecollectSurfaceInfoOnSurfaceCheckFailed;
  this.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle = other.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle;
};
CharacterColliderSplitMovementParams.prototype.copy = function copy39(other) {
  this.mySplitMovementEnabled = other.mySplitMovementEnabled;
  this.mySplitMovementMaxSteps = other.mySplitMovementMaxSteps;
  this.mySplitMovementMaxStepLength = other.mySplitMovementMaxStepLength;
  this.mySplitMovementMinStepLength = other.mySplitMovementMinStepLength;
  this.mySplitMovementStopOnHorizontalMovementFailed = other.mySplitMovementStopOnHorizontalMovementFailed;
  this.mySplitMovementStopOnVerticalMovementFailed = other.mySplitMovementStopOnVerticalMovementFailed;
  this.mySplitMovementStopReturnPreviousResults = other.mySplitMovementStopReturnPreviousResults;
};
CharacterColliderAdditionalParams.prototype.copy = function copy40(other) {
  this.myPositionOffsetLocal.vec3_copy(other.myPositionOffsetLocal);
  this.myRotationOffsetLocalQuat.quat_copy(other.myRotationOffsetLocalQuat);
};
CharacterColliderDebugParams.prototype.copy = function copy41(other) {
  this.myVisualDebugEnabled = other.myVisualDebugEnabled;
  this.myVisualDebugMovementEnabled = other.myVisualDebugMovementEnabled;
  this.myVisualDebugHorizontalMovementCheckEnabled = other.myVisualDebugHorizontalMovementCheckEnabled;
  this.myVisualDebugHorizontalPositionCheckEnabled = other.myVisualDebugHorizontalPositionCheckEnabled;
  this.myVisualDebugVerticalMovementCheckEnabled = other.myVisualDebugVerticalMovementCheckEnabled;
  this.myVisualDebugVerticalPositionCheckEnabled = other.myVisualDebugVerticalPositionCheckEnabled;
  this.myVisualDebugSlideEnabled = other.myVisualDebugSlideEnabled;
  this.myVisualDebugGroundInfoEnabled = other.myVisualDebugGroundInfoEnabled;
  this.myVisualDebugCeilingInfoEnabled = other.myVisualDebugCeilingInfoEnabled;
  this.myVisualDebugResultsEnabled = other.myVisualDebugResultsEnabled;
};

// js/pp/gameplay/experimental/character_controller/collision/character_collider_setup_utils.js
var CharacterColliderSetupSimplifiedCreationAccuracyLevel = {
  VERY_LOW: 0,
  LOW: 1,
  MEDIUM: 2,
  HIGH: 3,
  VERY_HIGH: 4
};
var CharacterColliderSetupSimplifiedCreationParams = class {
  constructor() {
    this.myHeight = 0;
    this.myRadius = 0;
    this.myAccuracyLevel = CharacterColliderSetupSimplifiedCreationAccuracyLevel.VERY_LOW;
    this.myIsPlayer = false;
    this.myCheckOnlyFeet = false;
    this.myMaxSpeed = 0;
    this.myAverageFPS = 72;
    this.myCanFly = false;
    this.myShouldSlideAlongWall = false;
    this.myCollectGroundInfo = false;
    this.myShouldSnapOnGround = false;
    this.myMaxDistanceToSnapOnGround = 0;
    this.myMaxWalkableGroundAngle = 0;
    this.myMaxWalkableGroundStepHeight = 0;
    this.myShouldNotFallFromEdges = false;
    this.myHorizontalCheckBlockLayerFlags = new PhysicsLayerFlags();
    this.myHorizontalCheckObjectsToIgnore = [];
    this.myVerticalCheckBlockLayerFlags = new PhysicsLayerFlags();
    this.myVerticalCheckObjectsToIgnore = [];
    this.myHorizontalCheckDebugEnabled = false;
    this.myVerticalCheckDebugEnabled = false;
  }
};
function createSimplified(simplifiedCreationParams, outCharacterColliderSetup = new CharacterColliderSetup()) {
  outCharacterColliderSetup.myHeight = simplifiedCreationParams.myHeight;
  outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckConeRadius = simplifiedCreationParams.myRadius;
  outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRadius = simplifiedCreationParams.myRadius / 2;
  outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckFixedForwardEnabled = true;
  outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckFixedForward.vec3_set(0, 0, 1);
  if (!simplifiedCreationParams.myCheckOnlyFeet || simplifiedCreationParams.myCanFly) {
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalHeightCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalPositionCheckEnabled = true;
  }
  outCharacterColliderSetup.myWallSlideParams.myWallSlideEnabled = simplifiedCreationParams.myShouldSlideAlongWall;
  outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckFeetDistanceToIgnore = simplifiedCreationParams.myMaxWalkableGroundStepHeight;
  outCharacterColliderSetup.myGroundParams.mySurfaceSnapMaxDistance = simplifiedCreationParams.myMaxDistanceToSnapOnGround;
  outCharacterColliderSetup.myGroundParams.mySurfacePopOutMaxDistance = simplifiedCreationParams.myMaxDistanceToSnapOnGround > 0 ? simplifiedCreationParams.myMaxDistanceToSnapOnGround : simplifiedCreationParams.myRadius > 0.1 ? 0.1 : 0.01;
  outCharacterColliderSetup.myGroundParams.mySurfacePopOutMaxDistance = Math.max(outCharacterColliderSetup.myGroundParams.mySurfacePopOutMaxDistance, outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckFeetDistanceToIgnore);
  outCharacterColliderSetup.myGroundParams.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft = simplifiedCreationParams.myRadius * 0.75;
  outCharacterColliderSetup.myGroundParams.myCollectSurfaceInfo = simplifiedCreationParams.myCollectGroundInfo || simplifiedCreationParams.myMaxWalkableGroundAngle > 0;
  outCharacterColliderSetup.myGroundParams.mySurfaceSnapEnabled = simplifiedCreationParams.myShouldSnapOnGround;
  outCharacterColliderSetup.myGroundParams.mySurfacePopOutEnabled = true;
  outCharacterColliderSetup.myGroundParams.mySurfaceAngleToIgnore = simplifiedCreationParams.myMaxWalkableGroundAngle;
  outCharacterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngle = true;
  outCharacterColliderSetup.myGroundParams.myOnSurfaceMaxOutsideDistance = 1e-3;
  outCharacterColliderSetup.myGroundParams.myOnSurfaceMaxInsideDistance = 1e-3;
  outCharacterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxOutsideDistance = simplifiedCreationParams.myRadius > 0.1 ? 0.1 : 0.01;
  outCharacterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxInsideDistance = outCharacterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxOutsideDistance;
  outCharacterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhill = true;
  outCharacterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill = true;
  if (simplifiedCreationParams.myCanFly) {
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckHeadDistanceToIgnore = outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckFeetDistanceToIgnore;
    outCharacterColliderSetup.myCeilingParams.myCollectSurfaceInfo = outCharacterColliderSetup.myGroundParams.myCollectSurfaceInfo;
    outCharacterColliderSetup.myCeilingParams.mySurfacePopOutEnabled = outCharacterColliderSetup.myGroundParams.mySurfacePopOutEnabled;
    outCharacterColliderSetup.myCeilingParams.mySurfaceAngleToIgnore = outCharacterColliderSetup.myGroundParams.mySurfaceAngleToIgnore;
    outCharacterColliderSetup.myCeilingParams.mySurfaceSnapMaxDistance = outCharacterColliderSetup.myGroundParams.mySurfaceSnapMaxDistance;
    outCharacterColliderSetup.myCeilingParams.mySurfacePopOutMaxDistance = outCharacterColliderSetup.myGroundParams.mySurfacePopOutMaxDistance;
    outCharacterColliderSetup.myCeilingParams.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft = outCharacterColliderSetup.myGroundParams.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft;
    outCharacterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngle = outCharacterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngle;
    outCharacterColliderSetup.myCeilingParams.myOnSurfaceMaxOutsideDistance = outCharacterColliderSetup.myGroundParams.myOnSurfaceMaxOutsideDistance;
    outCharacterColliderSetup.myCeilingParams.myOnSurfaceMaxInsideDistance = outCharacterColliderSetup.myGroundParams.myOnSurfaceMaxInsideDistance;
    outCharacterColliderSetup.myCeilingParams.myCollectSurfaceNormalMaxOutsideDistance = outCharacterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxOutsideDistance;
    outCharacterColliderSetup.myCeilingParams.myCollectSurfaceNormalMaxInsideDistance = outCharacterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxInsideDistance;
    outCharacterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhill = outCharacterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhill;
    outCharacterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill = outCharacterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill;
  }
  if (simplifiedCreationParams.myShouldNotFallFromEdges) {
    outCharacterColliderSetup.myGroundParams.myMovementMustStayOnSurface = true;
    outCharacterColliderSetup.myGroundParams.myMovementMustStayOnSurfaceAngleDownhill = Math.max(60, outCharacterColliderSetup.myGroundParams.mySurfaceAngleToIgnore);
  }
  outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckBlockLayerFlags.copy(simplifiedCreationParams.myHorizontalCheckBlockLayerFlags);
  outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckObjectsToIgnore.pp_copy(simplifiedCreationParams.myHorizontalCheckObjectsToIgnore);
  outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckBlockLayerFlags.copy(simplifiedCreationParams.myVerticalCheckBlockLayerFlags);
  outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckObjectsToIgnore.pp_copy(simplifiedCreationParams.myVerticalCheckObjectsToIgnore);
  if (simplifiedCreationParams.myHorizontalCheckDebugEnabled) {
    outCharacterColliderSetup.myDebugParams.myVisualDebugEnabled = true;
    outCharacterColliderSetup.myDebugParams.myVisualDebugHorizontalMovementCheckEnabled = true;
    outCharacterColliderSetup.myDebugParams.myVisualDebugHorizontalPositionCheckEnabled = true;
  }
  if (simplifiedCreationParams.myVerticalCheckDebugEnabled) {
    outCharacterColliderSetup.myDebugParams.myVisualDebugEnabled = true;
    outCharacterColliderSetup.myDebugParams.myVisualDebugVerticalMovementCheckEnabled = true;
    outCharacterColliderSetup.myDebugParams.myVisualDebugVerticalPositionCheckEnabled = true;
  }
  if (simplifiedCreationParams.myAccuracyLevel >= CharacterColliderSetupSimplifiedCreationAccuracyLevel.VERY_LOW) {
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckConeHalfAngle = 60;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHeightVerticalCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHeightVerticalCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckEnabled = false;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionCheckConeHalfSlices = 1;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHeightCheckSteps = 1;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHorizontalRadialCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalStraightCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceSlices = 4;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceCentralCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRadialSteps = 1;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalMovementCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalMovementCheckReductionEnabled = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckAllowHitsInsideCollisionIfOneValid = true;
    if (simplifiedCreationParams.myIsPlayer) {
      outCharacterColliderSetup.myWallSlideParams.myWallSlideMaxAttempts = 2;
      outCharacterColliderSetup.myWallSlideParams.my90DegreesWallSlideAdjustDirectionSign = true;
    }
  }
  if (simplifiedCreationParams.myAccuracyLevel >= CharacterColliderSetupSimplifiedCreationAccuracyLevel.LOW) {
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckRadialSteps = 1;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHeightCheckSteps = 1;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalStraightCentralCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRadialSteps = 2;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRotationPerRadialStep = 180 / outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceSlices;
    outCharacterColliderSetup.myWallSlideParams.myWallSlideMaxAttempts = 2;
    outCharacterColliderSetup.myWallSlideParams.myCheckBothWallSlideDirections = false;
    outCharacterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionMode = CharacterColliderSlideFlickerPreventionMode.NONE;
    outCharacterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding = false;
    outCharacterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionForceCheckCounter = 0;
    outCharacterColliderSetup.myWallSlideParams.my90DegreesWallSlideAdjustDirectionSign = false;
  }
  if (simplifiedCreationParams.myAccuracyLevel >= CharacterColliderSetupSimplifiedCreationAccuracyLevel.MEDIUM) {
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHeightHorizontalCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionCheckConeHalfSlices = 2;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHeightHorizontalCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHorizontalBorderCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalMovementCheckPerformCheckOnBothSides = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceSlices = 6;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRadialSteps = 2;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRotationPerRadialStep = 180 / outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceSlices;
    outCharacterColliderSetup.myWallSlideParams.myWallSlideMaxAttempts = 3;
    outCharacterColliderSetup.myWallSlideParams.my90DegreesWallSlideAdjustDirectionSign = true;
    if (simplifiedCreationParams.myIsPlayer) {
      outCharacterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionMode = CharacterColliderSlideFlickerPreventionMode.USE_PREVIOUS_RESULTS;
      outCharacterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding = true;
      outCharacterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionForceCheckCounter = 4;
    }
  }
  if (simplifiedCreationParams.myAccuracyLevel >= CharacterColliderSetupSimplifiedCreationAccuracyLevel.HIGH) {
    if (outCharacterColliderSetup.myWallSlideParams.myWallSlideEnabled) {
      outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckGetBetterReferenceHit = true;
      outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit = true;
      outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit = true;
    }
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalStraightCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalStraightCentralCheckEnabled = false;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = false;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceSlices = 8;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRadialSteps = 2;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRotationPerRadialStep = 180 / outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceSlices;
    outCharacterColliderSetup.myWallSlideParams.myWallSlideMaxAttempts = 4;
    if (simplifiedCreationParams.myIsPlayer) {
      outCharacterColliderSetup.myWallSlideParams.myCheckBothWallSlideDirections = true;
    }
    outCharacterColliderSetup.myGroundParams.myBaseInsideCollisionCheckEnabled = true;
    outCharacterColliderSetup.myCeilingParams.myBaseInsideCollisionCheckEnabled = true;
    if (simplifiedCreationParams.myMaxSpeed / simplifiedCreationParams.myAverageFPS > simplifiedCreationParams.myRadius) {
      outCharacterColliderSetup.mySplitMovementParams.mySplitMovementEnabled = true;
      outCharacterColliderSetup.mySplitMovementParams.mySplitMovementMaxSteps = Math.ceil(simplifiedCreationParams.myMaxSpeed / simplifiedCreationParams.myAverageFPS / simplifiedCreationParams.myRadius);
      outCharacterColliderSetup.mySplitMovementParams.mySplitMovementMinStepLength = simplifiedCreationParams.myRadius * 0.75;
    }
  }
  if (simplifiedCreationParams.myAccuracyLevel >= CharacterColliderSetupSimplifiedCreationAccuracyLevel.VERY_HIGH) {
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHeightCheckSteps = 2;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalRadialCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightCentralCheckEnabled = false;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = false;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHeightCheckSteps = 2;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit = true;
    outCharacterColliderSetup.myGroundParams.myRecollectSurfaceInfoOnSurfaceCheckFailed = true;
    outCharacterColliderSetup.myCeilingParams.myRecollectSurfaceInfoOnSurfaceCheckFailed = outCharacterColliderSetup.myGroundParams.myRecollectSurfaceInfoOnSurfaceCheckFailed;
  }
  return outCharacterColliderSetup;
}
function createTeleportColliderSetupFromMovementColliderSetup(movementColliderSetup, outTeleportColliderSetup = new CharacterColliderSetup()) {
  outTeleportColliderSetup.copy(movementColliderSetup);
  outTeleportColliderSetup.myHorizontalCheckParams.myHorizontalCheckConeHalfAngle = 180;
  outTeleportColliderSetup.myHorizontalCheckParams.myHorizontalPositionCheckConeHalfSlices = Math.round(outTeleportColliderSetup.myHorizontalCheckParams.myHorizontalCheckConeHalfAngle / movementColliderSetup.myHorizontalCheckParams.myHorizontalCheckConeHalfAngle * movementColliderSetup.myHorizontalCheckParams.myHorizontalPositionCheckConeHalfSlices);
  outTeleportColliderSetup.myHorizontalCheckParams.myHorizontalCheckFixedForwardEnabled = true;
  outTeleportColliderSetup.myHorizontalCheckParams.myHorizontalCheckFixedForward.vec3_set(0, 0, 1);
  return outTeleportColliderSetup;
}
var CharacterColliderSetupUtils = {
  createSimplified,
  createTeleportColliderSetupFromMovementColliderSetup
};

// js/pp/gameplay/experimental/character_controller/collision/character_collision_system.js
var CharacterCollisionSystem = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this._myLastCheckRaycastsPerformed = 0;
    this._myCurrentFrameRaycastsPerformed = 0;
    this._myMaxFrameRaycastsPerformed = 0;
    this.myEngine = engine2;
    CollisionCheckBridge.initBridge(this.myEngine);
  }
  update(dt) {
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    this._myCurrentFrameRaycastsPerformed = 0;
    CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts = 0;
  }
  checkMovement(movement, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    CollisionCheckBridge.checkMovement(movement, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults, this.myEngine);
    this._myLastCheckRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
    this._myCurrentFrameRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
  checkTeleportToPosition(teleportPosition, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
  }
  checkTeleportToTransform(teleportTransformQuat, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    CollisionCheckBridge.checkTeleportToTransform(teleportTransformQuat, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults, this.myEngine);
    this._myLastCheckRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
    this._myCurrentFrameRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
  checkTransform(checkTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    CollisionCheckBridge.checkTransform(checkTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults, this.myEngine);
    this._myLastCheckRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
    this._myCurrentFrameRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
  updateSurfaceInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    let currentFramePerformedRaycasts = this._myCurrentFrameRaycastsPerformed;
    this.updateGroundInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults);
    this.updateCeilingInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults);
    this._myLastCheckRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts - currentFramePerformedRaycasts;
    this._myCurrentFrameRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
  updateGroundInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    CollisionCheckBridge.updateGroundInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults, this.myEngine);
    this._myLastCheckRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
    this._myCurrentFrameRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
  updateCeilingInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    CollisionCheckBridge.updateCeilingInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults, this.myEngine);
    this._myLastCheckRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
    this._myCurrentFrameRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
};
CharacterCollisionSystem.prototype.checkTeleportToPosition = function() {
  let teleportTransformQuat = quat2_create();
  return function checkTeleportToPosition(teleportPosition, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults) {
    teleportTransformQuat.quat2_copy(currentTransformQuat);
    teleportTransformQuat.quat2_setPosition(teleportPosition);
    this.checkTeleportToTransform(teleportTransformQuat, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults);
  };
}();

// js/pp/gameplay/experimental/character_controller/collision/components/character_collision_system_component.js
var CharacterCollisionSystemComponent = class extends Component {
  init() {
    this._myCharacterCollisionSystem = null;
    if (!Globals.hasCharacterCollisionSystem(this.engine)) {
      this._myCharacterCollisionSystem = new CharacterCollisionSystem(this.engine);
      Globals.setCharacterCollisionSystem(this._myCharacterCollisionSystem, this.engine);
    }
  }
  update(dt) {
    if (this._myCharacterCollisionSystem != null) {
      this._myCharacterCollisionSystem.update(dt);
    }
  }
  onDestroy() {
    if (this._myCharacterCollisionSystem != null && Globals.getCharacterCollisionSystem(this.engine) == this._myCharacterCollisionSystem) {
      Globals.removeCharacterCollisionSystem(this.engine);
    }
  }
};
__publicField(CharacterCollisionSystemComponent, "TypeName", "pp-character-collision-system");
__publicField(CharacterCollisionSystemComponent, "Properties", {});

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/player_head_manager.js
var PlayerHeadManagerParams = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this.mySessionChangeResyncEnabled = false;
    this.myBlurEndResyncEnabled = false;
    this.myBlurEndResyncRotation = false;
    this.myResetTransformOnViewResetEnabled = true;
    this.myNextEnterSessionResyncHeight = false;
    this.myEnterSessionResyncHeight = false;
    this.myExitSessionResyncHeight = false;
    this.myExitSessionResyncVerticalAngle = false;
    this.myExitSessionRemoveRightTilt = false;
    this.myExitSessionAdjustMaxVerticalAngle = false;
    this.myExitSessionMaxVerticalAngle = 0;
    this.myHeightOffsetVRWithFloor = null;
    this.myHeightOffsetVRWithoutFloor = null;
    this.myHeightOffsetNonVR = null;
    this.myNextEnterSessionFloorHeight = null;
    this.myEnterSessionFloorHeight = null;
    this.myRotateFeetKeepUp = false;
    this.myForeheadExtraHeight = 0;
    this.myEngine = engine2;
    this.myDebugEnabled = false;
  }
};
var PlayerHeadManager = class {
  constructor(params = new PlayerHeadManagerParams()) {
    this._myParams = params;
    this._myCurrentHead = Globals.getPlayerObjects(this._myParams.myEngine).myHead;
    this._mySessionChangeResyncHeadTransform = null;
    this._myBlurRecoverHeadTransform = null;
    this._myCurrentHeadTransformLocalQuat = quat2_create();
    this._myDelaySessionChangeResyncCounter = 0;
    this._myDelayBlurEndResyncCounter = 0;
    this._myDelayBlurEndResyncTimer = new Timer(5, false);
    this._myVisibilityHidden = false;
    this._mySessionActive = false;
    this._mySessionBlurred = false;
    this._myIsSyncedDelayCounter = 0;
    this._myViewResetEventListener = null;
    this._myActive = true;
    this._myDestroyed = false;
    this._myResyncCounterFrames = 3;
    this._myIsSyncedDelayCounterFrames = 1;
  }
  start() {
    this._updateHeightOffset();
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, true, this._myParams.myEngine);
  }
  setActive(active) {
    this._myActive = active;
  }
  getParams() {
    return this._myParams;
  }
  paramsUpdated() {
    this._updateHeightOffset();
  }
  getPlayer() {
    return Globals.getPlayerObjects(this._myParams.myEngine).myPlayer;
  }
  getHead() {
    return this._myCurrentHead;
  }
  getHeightHead() {
    return this.getHeightEyes() + this._myParams.myForeheadExtraHeight;
  }
  getHeightEyes() {
  }
  getTransformFeetQuat(outTransformFeetQuat = quat2_create()) {
  }
  getTransformHeadQuat(outTransformFeetQuat = quat2_create()) {
    return this.getHead().pp_getTransformQuat(outTransformFeetQuat);
  }
  getPositionFeet(outPositionFeet = vec3_create()) {
  }
  getPositionHead(outPositionHead = vec3_create()) {
    return this._myCurrentHead.pp_getPosition(outPositionHead);
  }
  getRotationFeetQuat(outRotationFeetQuat = quat_create()) {
  }
  getRotationHeadQuat(outRotationHeadQuat = quat_create()) {
    return this.getHead().pp_getRotationQuat(outRotationHeadQuat);
  }
  isSynced() {
    return this._myIsSyncedDelayCounter == 0 && this._myDelaySessionChangeResyncCounter == 0 && this._myDelayBlurEndResyncCounter == 0 && !this._myDelayBlurEndResyncTimer.isRunning() && !this._mySessionBlurred;
  }
  setHeightHead(height, setOnlyForActiveOne = false) {
    if (!setOnlyForActiveOne || !this._mySessionActive) {
      this._myParams.myHeightOffsetNonVR = height;
    }
    if (!setOnlyForActiveOne || this._mySessionActive) {
      this._myParams.myHeightOffsetVRWithoutFloor = height;
      if (this._myParams.myHeightOffsetVRWithFloor == null) {
        this._myParams.myHeightOffsetVRWithFloor = 0;
      }
      let isFloor = XRUtils.isReferenceSpaceFloorBased(this._myParams.myEngine) || XRUtils.isDeviceEmulated();
      if (this._mySessionActive && isFloor) {
        this._myParams.myHeightOffsetVRWithFloor = this._myParams.myHeightOffsetVRWithFloor + (height - this.getHeightHead());
      } else if (!this._mySessionActive) {
        this._myParams.myNextEnterSessionFloorHeight = height;
      }
    }
    this._updateHeightOffset();
  }
  moveFeet(movement) {
  }
  moveHead(movement) {
    this.moveFeet(movement);
  }
  teleportPositionHead(teleportPosition) {
  }
  teleportPositionFeet(teleportPosition) {
  }
  teleportPlayerToHeadTransformQuat(headTransformQuat) {
  }
  rotateFeetQuat(rotationQuat, keepUpOverride = null) {
  }
  rotateHeadQuat(rotationQuat) {
  }
  canRotateFeet() {
    return true;
  }
  canRotateHead() {
    return !this._mySessionActive;
  }
  setRotationFeetQuat(rotationQuat, keepUpOverride = null) {
  }
  setRotationHeadQuat() {
  }
  lookAtFeet(position, up = null, keepUpOverride = null) {
  }
  lookToFeet(direction2, up = null, keepUpOverride = null) {
  }
  lookAtHead(position, up = null) {
  }
  lookToHead(direction2, up = null) {
  }
  update(dt) {
    if (this._myIsSyncedDelayCounter != 0) {
      this._myIsSyncedDelayCounter--;
      this._myIsSyncedDelayCounter = Math.max(0, this._myIsSyncedDelayCounter);
    }
    if (this._myDelaySessionChangeResyncCounter > 0) {
      this._myDelaySessionChangeResyncCounter--;
      if (this._myDelaySessionChangeResyncCounter == 0) {
        this._sessionChangeResync();
        this._myIsSyncedDelayCounter = this._myIsSyncedDelayCounterFrames;
      }
    }
    if (this._myDelayBlurEndResyncCounter > 0 && !this._myDelayBlurEndResyncTimer.isRunning()) {
      this._myDelayBlurEndResyncCounter--;
      if (this._myDelayBlurEndResyncCounter == 0) {
        this._blurEndResync();
        this._myIsSyncedDelayCounter = this._myIsSyncedDelayCounterFrames;
      }
    }
    if (this._myDelayBlurEndResyncTimer.isRunning()) {
      if (this._myDelayBlurEndResyncCounter > 0) {
        this._myDelayBlurEndResyncCounter--;
      } else {
        this._myDelayBlurEndResyncTimer.update(dt);
        if (this._myDelayBlurEndResyncTimer.isDone()) {
          this._blurEndResync();
          this._myIsSyncedDelayCounter = this._myIsSyncedDelayCounterFrames;
        }
      }
    }
    if (this.isSynced()) {
      this._myCurrentHead.pp_getTransformLocalQuat(this._myCurrentHeadTransformLocalQuat);
    }
    if (this._myParams.myDebugEnabled && Globals.isDebugEnabled(this._myParams.myEngine)) {
      this._debugUpdate(dt);
    }
  }
  _debugUpdate(dt) {
    Globals.getDebugVisualManager(this._myParams.myEngine).drawLineEnd(0, this.getPositionFeet(), this.getPositionHead(), vec4_create(1, 0, 0, 1), 0.01);
    console.error(this.getHeightEyes());
  }
  destroy() {
    this._myDestroyed = true;
    XRUtils.getReferenceSpace(this._myParams.myEngine)?.removeEventListener?.("reset", this._myViewResetEventListener);
    XRUtils.getSession(this._myParams.myEngine)?.removeEventListener("visibilitychange", this._myVisibilityChangeEventListener);
    XRUtils.unregisterSessionStartEndEventListeners(this, this._myParams.myEngine);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
PlayerHeadManager.prototype.getHeightEyes = function() {
  let headPosition = vec3_create();
  return function getHeightEyes() {
    headPosition = this._myCurrentHead.pp_getPosition(headPosition);
    let eyesHeight = this._getPositionHeight(headPosition);
    return eyesHeight;
  };
}();
PlayerHeadManager.prototype.getTransformFeetQuat = function() {
  let feetPosition = vec3_create();
  let feetRotationQuat = quat_create();
  return function getTransformFeetQuat(outTransformFeetQuat = quat2_create()) {
    outTransformFeetQuat.quat2_setPositionRotationQuat(this.getPositionFeet(feetPosition), this.getRotationFeetQuat(feetRotationQuat));
    return outTransformFeetQuat;
  };
}();
PlayerHeadManager.prototype.getRotationFeetQuat = function() {
  let playerUp = vec3_create();
  let headForward = vec3_create();
  return function getRotationFeetQuat(outRotationFeetQuat = quat_create()) {
    playerUp = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
    headForward = this._myCurrentHead.pp_getForward(headForward);
    let angleWithUp = headForward.vec3_angle(playerUp);
    let mingAngle = 10;
    if (angleWithUp < mingAngle) {
      headForward = this._myCurrentHead.pp_getDown(headForward);
    } else if (angleWithUp > 180 - mingAngle) {
      headForward = this._myCurrentHead.pp_getUp(headForward);
    }
    headForward = headForward.vec3_removeComponentAlongAxis(playerUp, headForward);
    headForward.vec3_normalize(headForward);
    outRotationFeetQuat.quat_setUp(playerUp, headForward);
    return outRotationFeetQuat;
  };
}();
PlayerHeadManager.prototype.getPositionFeet = function() {
  let headPosition = vec3_create();
  let playerUp = vec3_create();
  return function getPositionFeet(outPositionFeet = vec3_create()) {
    headPosition = this._myCurrentHead.pp_getPosition(headPosition);
    let headHeight = this._getPositionHeight(headPosition);
    playerUp = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
    outPositionFeet = headPosition.vec3_sub(playerUp.vec3_scale(headHeight, outPositionFeet), outPositionFeet);
    return outPositionFeet;
  };
}();
PlayerHeadManager.prototype.moveFeet = function moveFeet(movement) {
  Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_translate(movement);
};
PlayerHeadManager.prototype.rotateFeetQuat = function() {
  let playerUp = vec3_create();
  let rotationAxis = vec3_create();
  let currentHeadPosition = vec3_create();
  let currentFeetRotation = quat_create();
  let newFeetRotation = quat_create();
  let fixedNewFeetRotation = quat_create();
  let newFeetForward = vec3_create();
  let fixedRotation = quat_create();
  let newHeadPosition = vec3_create();
  let headAdjustmentMovement = vec3_create();
  return function rotateFeetQuat(rotationQuat, keepUpOverride = null) {
    let angle4 = rotationQuat.quat_getAngleRadians();
    if (angle4 <= 1e-5) {
      return;
    }
    currentHeadPosition = this._myCurrentHead.pp_getPosition(currentHeadPosition);
    playerUp = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
    rotationAxis = rotationQuat.quat_getAxis(rotationAxis);
    if (!rotationAxis.vec3_isOnAxis(playerUp) && (keepUpOverride == null && this._myParams.myFeetRotationKeepUp || keepUpOverride)) {
      currentFeetRotation = this.getRotationFeetQuat(currentFeetRotation);
      newFeetRotation = currentFeetRotation.quat_rotateQuat(rotationQuat, newFeetRotation);
      newFeetForward = newFeetRotation.quat_getForward(newFeetForward);
      fixedNewFeetRotation.quat_copy(newFeetRotation);
      fixedNewFeetRotation.quat_setUp(playerUp, newFeetForward);
      fixedRotation = currentFeetRotation.quat_rotationToQuat(fixedNewFeetRotation, fixedRotation);
    } else {
      fixedRotation.quat_copy(rotationQuat);
    }
    Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_rotateAroundQuat(fixedRotation, currentHeadPosition);
    newHeadPosition = this._myCurrentHead.pp_getPosition(newHeadPosition);
    headAdjustmentMovement = currentHeadPosition.vec3_sub(newHeadPosition, headAdjustmentMovement);
    if (headAdjustmentMovement.vec3_length() > 1e-5) {
      this.moveFeet(headAdjustmentMovement);
    }
  };
}();
PlayerHeadManager.prototype.rotateHeadQuat = function() {
  let newHeadRotation = quat_create();
  let newHeadUp = vec3_create();
  return function rotateHeadQuat(rotationQuat) {
    if (this.canRotateHead()) {
      this._myCurrentHead.pp_rotateQuat(rotationQuat);
      newHeadRotation = this._myCurrentHead.pp_getRotationQuat(newHeadRotation);
      Globals.getPlayerObjects(this._myParams.myEngine).myHead.pp_setRotationQuat(newHeadRotation);
      newHeadRotation = newHeadRotation.quat_rotateAxisRadians(Math.PI, newHeadRotation.quat_getUp(newHeadUp), newHeadRotation);
      Globals.getPlayerObjects(this._myParams.myEngine).myCameraNonXR.pp_setRotationQuat(newHeadRotation);
    }
  };
}();
PlayerHeadManager.prototype.setRotationFeetQuat = function() {
  let currentRotationQuat = quat_create();
  let rotationQuatToRotate = quat_create();
  return function setRotationFeetQuat(rotationQuat, keepUpOverride = null) {
    currentRotationQuat = this.getRotationFeetQuat(currentRotationQuat);
    rotationQuatToRotate = currentRotationQuat.quat_rotationToQuat(rotationQuat, rotationQuatToRotate);
    this.rotateFeetQuat(rotationQuatToRotate, keepUpOverride);
  };
}();
PlayerHeadManager.prototype.setRotationHeadQuat = function() {
  let currentRotationQuat = quat_create();
  let rotationQuatToRotate = quat_create();
  return function setRotationHeadQuat(rotationQuat) {
    currentRotationQuat = this.getRotationHeadQuat(currentRotationQuat);
    rotationQuatToRotate = currentRotationQuat.quat_rotationToQuat(rotationQuat, rotationQuatToRotate);
    this.rotateHeadQuat(rotationQuatToRotate);
  };
}();
PlayerHeadManager.prototype.teleportPositionHead = function() {
  let currentHeadPosition = vec3_create();
  let teleportMovementToPerform = vec3_create();
  return function teleportPositionHead(teleportPosition) {
    currentHeadPosition = this._myCurrentHead.pp_getPosition(currentHeadPosition);
    teleportMovementToPerform = teleportPosition.vec3_sub(currentHeadPosition, teleportMovementToPerform);
    this.moveFeet(teleportMovementToPerform);
  };
}();
PlayerHeadManager.prototype.teleportPositionFeet = function() {
  let currentFeetPosition = vec3_create();
  let teleportMovementToPerform = vec3_create();
  return function teleportPositionFeet(teleportPosition) {
    currentFeetPosition = this.getPositionFeet(currentFeetPosition);
    teleportMovementToPerform = teleportPosition.vec3_sub(currentFeetPosition, teleportMovementToPerform);
    this.moveFeet(teleportMovementToPerform);
  };
}();
PlayerHeadManager.prototype.teleportPlayerToHeadTransformQuat = function() {
  let headPosition = vec3_create();
  let playerUp = vec3_create();
  let flatCurrentPlayerPosition = vec3_create();
  let flatNewPlayerPosition = vec3_create();
  let teleportMovement = vec3_create();
  let playerForward = vec3_create();
  let headForward = vec3_create();
  let rotationToPerform = quat_create();
  return function teleportPlayerToHeadTransformQuat(headTransformQuat) {
    headPosition = headTransformQuat.quat2_getPosition(headPosition);
    playerUp = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
    flatCurrentPlayerPosition = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getPosition(flatCurrentPlayerPosition).vec3_removeComponentAlongAxis(playerUp, flatCurrentPlayerPosition);
    flatNewPlayerPosition = headPosition.vec3_removeComponentAlongAxis(playerUp, flatNewPlayerPosition);
    teleportMovement = flatNewPlayerPosition.vec3_sub(flatCurrentPlayerPosition, teleportMovement);
    Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_translate(teleportMovement);
    playerForward = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getForward(playerForward);
    headForward = headTransformQuat.quat2_getForward(headForward);
    rotationToPerform = playerForward.vec3_rotationToPivotedQuat(headForward, playerUp, rotationToPerform);
    Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_rotateQuat(rotationToPerform);
  };
}();
PlayerHeadManager.prototype.lookAtFeet = function() {
  let direction2 = vec3_create();
  let feetPosition = vec3_create();
  return function lookAtFeet(position, up = null, keepUpOverride = null) {
    feetPosition = this.getPositionFeet(feetPosition);
    direction2 = position.vec3_sub(feetPosition, direction2).vec3_normalize(direction2);
    this.lookToFeet(direction2, up, keepUpOverride);
  };
}();
PlayerHeadManager.prototype.lookToFeet = function() {
  let feetRotation = quat_create();
  return function lookToFeet(direction2, up = null, keepUpOverride = null) {
    feetRotation = this.getRotationFeetQuat(feetRotation);
    feetRotation.quat_setForward(direction2, up);
    this.setRotationFeetQuat(feetRotation, keepUpOverride);
  };
}();
PlayerHeadManager.prototype.lookAtHead = function() {
  let direction2 = vec3_create();
  let headPosition = vec3_create();
  return function lookAtHead(position, up = null) {
    headPosition = this.getPositionHead(headPosition);
    direction2 = position.vec3_sub(headPosition, direction2).vec3_normalize(direction2);
    this.lookToHead(direction2, up);
  };
}();
PlayerHeadManager.prototype.lookToHead = function() {
  let headRotation = quat_create();
  return function lookToHead(direction2, up = null) {
    headRotation = this.getRotationHeadQuat(headRotation);
    headRotation.quat_setForward(direction2, up);
    this.setRotationHeadQuat(headRotation);
  };
}();
PlayerHeadManager.prototype._getPositionHeight = function() {
  let playerPosition = vec3_create();
  let playerUp = vec3_create();
  let heightVector = vec3_create();
  return function _getPositionHeight(position) {
    playerPosition = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getPosition(playerPosition);
    playerUp = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
    heightVector = position.vec3_sub(playerPosition, heightVector).vec3_componentAlongAxis(playerUp, heightVector);
    let height = heightVector.vec3_length();
    if (!playerUp.vec3_isConcordant(heightVector)) {
      height = -height;
    }
    return height;
  };
}();
PlayerHeadManager.prototype._onXRSessionStart = function() {
  return function _onXRSessionStart(manualCall, session) {
    this._myBlurRecoverHeadTransform = null;
    this._myVisibilityHidden = false;
    this._myDelaySessionChangeResyncCounter = 0;
    this._myDelayBlurEndResyncCounter = 0;
    this._myDelayBlurEndResyncTimer.reset();
    let referenceSpace = XRUtils.getReferenceSpace(this._myParams.myEngine);
    if (referenceSpace.addEventListener != null) {
      this._myViewResetEventListener = this._onViewReset.bind(this);
      referenceSpace.addEventListener("reset", this._myViewResetEventListener);
    }
    this._myVisibilityChangeEventListener = function(event) {
      if (event.session.visibilityState != "visible") {
        if (!this._mySessionBlurred) {
          this._onXRSessionBlurStart(event.session);
        }
        this._myVisibilityHidden = session.visibilityState == "hidden";
      } else {
        if (this._mySessionBlurred) {
          this._onXRSessionBlurEnd(event.session);
        }
        this._myVisibilityHidden = false;
      }
    }.bind(this);
    session.addEventListener("visibilitychange", this._myVisibilityChangeEventListener);
    if (this._myParams.mySessionChangeResyncEnabled && !manualCall && this._myActive) {
      if (this._myDelaySessionChangeResyncCounter == 0) {
        this._mySessionChangeResyncHeadTransform = this._getHeadTransformFromLocal(this._myCurrentHeadTransformLocalQuat);
      }
      this._myDelaySessionChangeResyncCounter = this._myResyncCounterFrames;
    } else {
      this._myDelaySessionChangeResyncCounter = 0;
      this._mySessionChangeResyncHeadTransform = null;
    }
    this._mySessionActive = true;
    this._mySessionBlurred = false;
    if (this._myActive) {
      this._updateHeightOffset();
    }
  };
}();
PlayerHeadManager.prototype._onXRSessionEnd = function() {
  return function _onXRSessionEnd(session) {
    if (this._myParams.mySessionChangeResyncEnabled && this._myActive) {
      if (this._myDelaySessionChangeResyncCounter == 0) {
        let previousHeadTransform = this._getHeadTransformFromLocal(this._myCurrentHeadTransformLocalQuat);
        if (this._myBlurRecoverHeadTransform != null) {
          previousHeadTransform = this._myBlurRecoverHeadTransform;
        }
        this._mySessionChangeResyncHeadTransform = previousHeadTransform;
      }
      this._myDelaySessionChangeResyncCounter = this._myResyncCounterFrames;
    } else {
      this._myDelaySessionChangeResyncCounter = 0;
      this._mySessionChangeResyncHeadTransform = null;
    }
    this._myVisibilityChangeEventListener = null;
    this._myViewResetEventListener = null;
    this._myBlurRecoverHeadTransform = null;
    this._myVisibilityHidden = false;
    this._myDelayBlurEndResyncCounter = 0;
    this._myDelayBlurEndResyncTimer.reset();
    this._mySessionActive = false;
    this._mySessionBlurred = false;
    if (this._myActive) {
      this._updateHeightOffset();
    }
  };
}();
PlayerHeadManager.prototype._onXRSessionBlurStart = function() {
  return function _onXRSessionBlurStart(session) {
    if (this._myActive) {
      if (this._myParams.myBlurEndResyncEnabled && this._myBlurRecoverHeadTransform == null && this._mySessionActive) {
        if (this._myDelaySessionChangeResyncCounter > 0) {
          this._myBlurRecoverHeadTransform = this._mySessionChangeResyncHeadTransform;
        } else {
          this._myBlurRecoverHeadTransform = this._getHeadTransformFromLocal(this._myCurrentHeadTransformLocalQuat);
        }
      } else if (!this._mySessionActive || !this._myParams.myBlurEndResyncEnabled) {
        this._myBlurRecoverHeadTransform = null;
      }
    }
    this._myDelayBlurEndResyncCounter = 0;
    this._mySessionBlurred = true;
  };
}();
PlayerHeadManager.prototype._onXRSessionBlurEnd = function() {
  return function _onXRSessionBlurEnd(session) {
    if (this._myActive) {
      if (this._myDelaySessionChangeResyncCounter == 0) {
        if (this._myParams.myBlurEndResyncEnabled && this._myBlurRecoverHeadTransform != null && this._mySessionActive) {
          this._myDelayBlurEndResyncCounter = this._myResyncCounterFrames;
          if (this._myVisibilityHidden) {
          }
        } else {
          this._myBlurRecoverHeadTransform = null;
          this._myDelayBlurEndResyncCounter = 0;
        }
      } else {
        this._myDelaySessionChangeResyncCounter = this._myResyncCounterFrames;
        this._myBlurRecoverHeadTransform = null;
      }
    }
    this._mySessionBlurred = false;
  };
}();
PlayerHeadManager.prototype._onViewReset = function() {
  return function _onViewReset() {
    if (this._myActive) {
      if (this._myParams.myResetTransformOnViewResetEnabled && this._mySessionActive && this.isSynced()) {
        this.teleportPlayerToHeadTransformQuat(this._getHeadTransformFromLocal(this._myCurrentHeadTransformLocalQuat));
      }
    }
  };
}();
PlayerHeadManager.prototype._blurEndResync = function() {
  let playerUp = vec3_create();
  let currentHeadPosition = vec3_create();
  let recoverHeadPosition = vec3_create();
  let flatCurrentHeadPosition = vec3_create();
  let flatRecoverHeadPosition = vec3_create();
  let recoverMovement = vec3_create();
  let recoverHeadForward = vec3_create();
  let currentHeadForward = vec3_create();
  let rotationToPerform = quat_create();
  return function _blurEndResync() {
    if (this._myBlurRecoverHeadTransform != null) {
      if (this._mySessionChangeResyncHeadTransform != null) {
        this._myBlurRecoverHeadTransform = null;
        this._sessionChangeResync();
      } else {
        playerUp = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
        currentHeadPosition = this._myCurrentHead.pp_getPosition(currentHeadPosition);
        recoverHeadPosition = this._myBlurRecoverHeadTransform.quat2_getPosition(recoverHeadPosition);
        flatCurrentHeadPosition = currentHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatCurrentHeadPosition);
        flatRecoverHeadPosition = recoverHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatRecoverHeadPosition);
        recoverMovement = flatRecoverHeadPosition.vec3_sub(flatCurrentHeadPosition, recoverMovement);
        this.moveFeet(recoverMovement);
        recoverHeadForward = this._myBlurRecoverHeadTransform.quat2_getForward(recoverHeadForward);
        currentHeadForward = this._myCurrentHead.pp_getForward(currentHeadForward);
        rotationToPerform = currentHeadForward.vec3_rotationToPivotedQuat(recoverHeadForward, playerUp, rotationToPerform);
        if (this._myParams.myBlurEndResyncRotation) {
          this.rotateFeetQuat(rotationToPerform);
        }
        this._myBlurRecoverHeadTransform = null;
      }
    }
  };
}();
PlayerHeadManager.prototype._sessionChangeResync = function() {
  let currentHeadPosition = vec3_create();
  let resyncHeadPosition = vec3_create();
  let resyncHeadRotation = quat_create();
  let playerUp = vec3_create();
  let flatCurrentHeadPosition = vec3_create();
  let flatResyncHeadPosition = vec3_create();
  let resyncMovement = vec3_create();
  let resyncHeadForward = vec3_create();
  let resyncHeadUp = vec3_create();
  let resyncHeadRight = vec3_create();
  let playerPosition = vec3_create();
  let newPlayerPosition = vec3_create();
  let fixedHeadRight = vec3_create();
  let fixedHeadLeft = vec3_create();
  let fixedHeadUp = vec3_create();
  let fixedHeadForward = vec3_create();
  let fixedHeadRotation = quat_create();
  return function _sessionChangeResync() {
    if (this._myBlurRecoverHeadTransform == null && this._mySessionChangeResyncHeadTransform != null) {
      if (this._mySessionActive) {
        currentHeadPosition = this._myCurrentHead.pp_getPosition(currentHeadPosition);
        resyncHeadPosition = this._mySessionChangeResyncHeadTransform.quat2_getPosition(resyncHeadPosition);
        resyncHeadRotation = this._mySessionChangeResyncHeadTransform.quat2_getRotationQuat(resyncHeadRotation);
        playerUp = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
        flatCurrentHeadPosition = currentHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatCurrentHeadPosition);
        flatResyncHeadPosition = resyncHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatResyncHeadPosition);
        resyncMovement = flatResyncHeadPosition.vec3_sub(flatCurrentHeadPosition, resyncMovement);
        this.moveFeet(resyncMovement);
        let isFloor = XRUtils.isReferenceSpaceFloorBased(this._myParams.myEngine) || XRUtils.isDeviceEmulated();
        if (this._myParams.myEnterSessionResyncHeight || this._myParams.myNextEnterSessionResyncHeight) {
          this._myParams.myNextEnterSessionResyncHeight = false;
          let resyncHeadHeight = this._getPositionHeight(resyncHeadPosition);
          let currentHeadHeight = this._getPositionHeight(currentHeadPosition);
          this._myParams.myHeightOffsetVRWithoutFloor = resyncHeadHeight + this._myParams.myForeheadExtraHeight;
          if (this._myParams.myHeightOffsetVRWithFloor == null) {
            this._myParams.myHeightOffsetVRWithFloor = 0;
          }
          this._myParams.myHeightOffsetVRWithFloor = this._myParams.myHeightOffsetVRWithFloor + (resyncHeadHeight - currentHeadHeight);
          this._updateHeightOffset();
        } else if (isFloor && (this._myParams.myNextEnterSessionFloorHeight != null || this._myParams.myEnterSessionFloorHeight != null)) {
          let floorHeight = this._myParams.myNextEnterSessionFloorHeight != null ? this._myParams.myNextEnterSessionFloorHeight : this._myParams.myEnterSessionFloorHeight;
          floorHeight -= this._myParams.myForeheadExtraHeight;
          let currentHeadHeight = this._getPositionHeight(currentHeadPosition);
          if (this._myParams.myHeightOffsetVRWithFloor == null) {
            this._myParams.myHeightOffsetVRWithFloor = 0;
          }
          this._myParams.myHeightOffsetVRWithFloor = this._myParams.myHeightOffsetVRWithFloor + (floorHeight - currentHeadHeight);
          this._updateHeightOffset();
        }
        this._resyncHeadRotationForward(resyncHeadRotation);
      } else {
        playerUp = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
        resyncHeadPosition = this._mySessionChangeResyncHeadTransform.quat2_getPosition(resyncHeadPosition);
        flatResyncHeadPosition = resyncHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatResyncHeadPosition);
        playerPosition = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getPosition(playerPosition);
        newPlayerPosition = flatResyncHeadPosition.vec3_add(playerPosition.vec3_componentAlongAxis(playerUp, newPlayerPosition), newPlayerPosition);
        Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_setPosition(newPlayerPosition);
        Globals.getPlayerObjects(this._myParams.myEngine).myCameraNonXR.pp_resetPositionLocal();
        if (this._myParams.myExitSessionResyncHeight) {
          let resyncHeadHeight = this._getPositionHeight(resyncHeadPosition);
          this._myParams.myHeightOffsetNonVR = resyncHeadHeight + this._myParams.myForeheadExtraHeight;
          this._updateHeightOffset();
        }
        resyncHeadRotation = this._mySessionChangeResyncHeadTransform.quat2_getRotationQuat(resyncHeadRotation);
        if (this._myParams.myExitSessionRemoveRightTilt || this._myParams.myExitSessionAdjustMaxVerticalAngle || !this._myParams.myExitSessionResyncVerticalAngle) {
          resyncHeadForward = resyncHeadRotation.quat_getForward(resyncHeadForward);
          resyncHeadUp = resyncHeadRotation.quat_getUp(resyncHeadUp);
          fixedHeadRight = resyncHeadForward.vec3_cross(playerUp, fixedHeadRight);
          fixedHeadRight.vec3_normalize(fixedHeadRight);
          if (!resyncHeadUp.vec3_isConcordant(playerUp)) {
            let angleForwardUp = resyncHeadForward.vec3_angle(playerUp);
            let negateAngle = 45;
            if (angleForwardUp > 180 - negateAngle || angleForwardUp < negateAngle) {
              fixedHeadRight.vec3_negate(fixedHeadRight);
            }
          }
          if (fixedHeadRight.vec3_isZero(1e-6)) {
            fixedHeadRight = resyncHeadRotation.quat_getRight(fixedHeadRight);
          }
          fixedHeadUp = fixedHeadRight.vec3_cross(resyncHeadForward, fixedHeadUp);
          fixedHeadUp.vec3_normalize(fixedHeadUp);
          fixedHeadForward = fixedHeadUp.vec3_cross(fixedHeadRight, fixedHeadForward);
          fixedHeadForward.vec3_normalize(fixedHeadForward);
          fixedHeadRotation.quat_fromAxes(fixedHeadRight.vec3_negate(fixedHeadLeft), fixedHeadUp, fixedHeadForward);
          resyncHeadRotation.quat_copy(fixedHeadRotation);
        }
        if (this._myParams.myExitSessionAdjustMaxVerticalAngle || !this._myParams.myExitSessionResyncVerticalAngle) {
          resyncHeadUp = resyncHeadRotation.quat_getUp(resyncHeadUp);
          resyncHeadRight = resyncHeadRotation.quat_getRight(resyncHeadRight);
          let maxVerticalAngle = Math.max(0, this._myParams.myExitSessionMaxVerticalAngle - 1e-4);
          if (!this._myParams.myExitSessionResyncVerticalAngle) {
            maxVerticalAngle = 0;
          }
          let angleWithUp = Math.pp_angleClamp(resyncHeadUp.vec3_angleSigned(playerUp, resyncHeadRight));
          if (Math.abs(angleWithUp) > maxVerticalAngle) {
            let fixAngle = (Math.abs(angleWithUp) - maxVerticalAngle) * Math.pp_sign(angleWithUp);
            resyncHeadRotation = resyncHeadRotation.quat_rotateAxis(fixAngle, resyncHeadRight, resyncHeadRotation);
          }
        }
        this.setRotationHeadQuat(resyncHeadRotation);
      }
      if (this._mySessionActive) {
        this._myParams.myNextEnterSessionFloorHeight = null;
        this._myFirstEnterSessionResyncDone = true;
      }
      this._mySessionChangeResyncHeadTransform = null;
    }
  };
}();
PlayerHeadManager.prototype._resyncHeadRotationForward = function() {
  let playerUp = vec3_create();
  let resyncHeadForward = vec3_create();
  let resyncHeadUp = vec3_create();
  let fixedResyncHeadRotation = quat_create();
  return function _resyncHeadRotationForward(resyncHeadRotation) {
    playerUp = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getUp(playerUp);
    resyncHeadForward = resyncHeadRotation.quat_getForward(resyncHeadForward);
    resyncHeadUp = resyncHeadRotation.quat_getUp(resyncHeadUp);
    fixedResyncHeadRotation.quat_copy(resyncHeadRotation);
    fixedResyncHeadRotation.quat_setUp(playerUp, resyncHeadForward);
    if (!resyncHeadUp.vec3_isConcordant(playerUp)) {
      fixedResyncHeadRotation.quat_rotateAxis(180, playerUp, fixedResyncHeadRotation);
    }
    this.setRotationFeetQuat(fixedResyncHeadRotation);
    return;
  };
}();
PlayerHeadManager.prototype._updateHeightOffset = function() {
  return function _updateHeightOffset() {
    if (this._mySessionActive) {
      if (XRUtils.isDeviceEmulated()) {
        this._setReferenceSpaceHeightOffset(0, 0);
      } else if (XRUtils.isReferenceSpaceFloorBased(this._myParams.myEngine)) {
        this._setReferenceSpaceHeightOffset(this._myParams.myHeightOffsetVRWithFloor, 0);
      } else {
        this._setReferenceSpaceHeightOffset(this._myParams.myHeightOffsetVRWithoutFloor, this._myParams.myForeheadExtraHeight);
      }
    } else {
      this._setReferenceSpaceHeightOffset(this._myParams.myHeightOffsetNonVR, this._myParams.myForeheadExtraHeight);
    }
  };
}();
PlayerHeadManager.prototype._setReferenceSpaceHeightOffset = function() {
  let referenceSpacePosition = vec3_create();
  return function _setReferenceSpaceHeightOffset(offset2, amountToRemove) {
    if (offset2 != null) {
      referenceSpacePosition = Globals.getPlayerObjects(this._myParams.myEngine).myReferenceSpace.pp_getPositionLocal(referenceSpacePosition);
      Globals.getPlayerObjects(this._myParams.myEngine).myReferenceSpace.pp_setPositionLocal([referenceSpacePosition[0], offset2 - amountToRemove, referenceSpacePosition[2]]);
    }
  };
}();
PlayerHeadManager.prototype._getHeadTransformFromLocal = function() {
  return function _getHeadTransformFromLocal(transformLocal) {
    return this._myCurrentHead.pp_convertTransformLocalToWorldQuat(transformLocal);
  };
}();
Object.defineProperty(PlayerHeadManager.prototype, "_getPositionHeight", { enumerable: false });
Object.defineProperty(PlayerHeadManager.prototype, "_onXRSessionStart", { enumerable: false });
Object.defineProperty(PlayerHeadManager.prototype, "_onXRSessionEnd", { enumerable: false });
Object.defineProperty(PlayerHeadManager.prototype, "_onXRSessionBlurStart", { enumerable: false });
Object.defineProperty(PlayerHeadManager.prototype, "_onXRSessionBlurEnd", { enumerable: false });
Object.defineProperty(PlayerHeadManager.prototype, "_onViewReset", { enumerable: false });
Object.defineProperty(PlayerHeadManager.prototype, "_blurEndResync", { enumerable: false });
Object.defineProperty(PlayerHeadManager.prototype, "_sessionChangeResync", { enumerable: false });
Object.defineProperty(PlayerHeadManager.prototype, "_setReferenceSpaceHeightOffset", { enumerable: false });

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/player_transform_manager.js
var PlayerTransformManagerSyncFlag = {
  BODY_COLLIDING: 0,
  HEAD_COLLIDING: 1,
  FAR: 2,
  FLOATING: 3
};
var PlayerTransformManagerParams = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this.myPlayerHeadManager = null;
    this.myMovementCollisionCheckParams = null;
    this.myTeleportCollisionCheckParams = null;
    this.myTeleportCollisionCheckParamsCopyFromMovement = false;
    this.myTeleportCollisionCheckParamsCheck360 = false;
    this.myAlwaysSyncPositionWithReal = false;
    this.myAlwaysSyncHeadPositionWithReal = false;
    this.mySyncEnabledFlagMap = /* @__PURE__ */ new Map();
    this.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, true);
    this.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, true);
    this.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.FAR, true);
    this.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, true);
    this.mySyncPositionFlagMap = /* @__PURE__ */ new Map();
    this.mySyncPositionFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, true);
    this.mySyncPositionFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, false);
    this.mySyncPositionFlagMap.set(PlayerTransformManagerSyncFlag.FAR, true);
    this.mySyncPositionFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, true);
    this.mySyncPositionHeadFlagMap = /* @__PURE__ */ new Map();
    this.mySyncPositionHeadFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, false);
    this.mySyncPositionHeadFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, true);
    this.mySyncPositionHeadFlagMap.set(PlayerTransformManagerSyncFlag.FAR, false);
    this.mySyncPositionHeadFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, false);
    this.mySyncRotationFlagMap = /* @__PURE__ */ new Map();
    this.mySyncRotationFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, false);
    this.mySyncRotationFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, false);
    this.mySyncRotationFlagMap.set(PlayerTransformManagerSyncFlag.FAR, false);
    this.mySyncRotationFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, false);
    this.mySyncHeightFlagMap = /* @__PURE__ */ new Map();
    this.mySyncHeightFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, false);
    this.mySyncHeightFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, false);
    this.mySyncHeightFlagMap.set(PlayerTransformManagerSyncFlag.FAR, false);
    this.mySyncHeightFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, false);
    this.myIsLeaningValidAboveDistance = false;
    this.myLeaningValidDistance = 0;
    this.myIsFloatingValidIfVerticalMovement = false;
    this.myIsFloatingValidIfVerticalMovementAndRealOnGround = false;
    this.myIsFloatingValidIfRealOnGround = false;
    this.myIsFloatingValidIfSteepGround = false;
    this.myIsFloatingValidIfVerticalMovementAndSteepGround = false;
    this.myFloatingSplitCheckEnabled = false;
    this.myFloatingSplitCheckMaxLength = 0;
    this.myFloatingSplitCheckMaxSteps = null;
    this.myFloatingSplitCheckStepEqualLength = false;
    this.myFloatingSplitCheckStepEqualLengthMinLength = 0;
    this.myMaxDistanceFromRealToSyncEnabled = false;
    this.myMaxDistanceFromRealToSync = 0;
    this.myHeadRadius = 0;
    this.myHeadCollisionBlockLayerFlags = new PhysicsLayerFlags();
    this.myHeadCollisionObjectsToIgnore = [];
    this.myRotateOnlyIfSynced = false;
    this.myResetRealResetRotationIfUpChanged = true;
    this.myRealMovementAllowVerticalAdjustments = false;
    this.myUpdateRealPositionValid = false;
    this.myUpdatePositionValid = false;
    this.myMinHeight = null;
    this.myMaxHeight = null;
    this.myIsBodyCollidingWhenHeightBelowValue = null;
    this.myIsBodyCollidingWhenHeightAboveValue = null;
    this.myIsBodyCollidingExtraCheckCallback = null;
    this.myIsLeaningExtraCheckCallback = null;
    this.myIsHoppingExtraCheckCallback = null;
    this.myIsFarExtraCheckCallback = null;
    this.myResetToValidOnEnterSession = false;
    this.myResetToValidOnExitSession = false;
    this.myAlwaysResetRealPositionNonVR = false;
    this.myAlwaysResetRealRotationNonVR = false;
    this.myAlwaysResetRealHeightNonVR = false;
    this.myAlwaysResetRealPositionVR = false;
    this.myAlwaysResetRealRotationVR = false;
    this.myAlwaysResetRealHeightVR = false;
    this.myNeverResetRealPositionNonVR = false;
    this.myNeverResetRealRotationNonVR = false;
    this.myNeverResetRealHeightNonVR = false;
    this.myNeverResetRealPositionVR = false;
    this.myNeverResetRealRotationVR = false;
    this.myNeverResetRealHeightVR = false;
    this.myResetRealOnMove = false;
    this.myResetRealOnTeleport = false;
    this.mySyncPositionDisabled = false;
    this.myEngine = engine2;
    this.myDebugEnabled = false;
  }
  destroy() {
    this._myDestroyed = true;
    XRUtils.unregisterSessionStartEndEventListeners(this, this._myParams.myEngine);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
var PlayerTransformManager = class {
  constructor(params) {
    this._myParams = params;
    this._myRealMovementCollisionCheckParams = null;
    this._generateRealMovementParamsFromMovementParams();
    this._myCollisionRuntimeParams = new CollisionRuntimeParams();
    this._myRealCollisionRuntimeParams = new CollisionRuntimeParams();
    if (this._myParams.myTeleportCollisionCheckParamsCopyFromMovement) {
      this._generateTeleportParamsFromMovementParams();
    }
    this._myHeadCollisionCheckParams = null;
    this._setupHeadCollisionCheckParams();
    this._myValidPosition = vec3_create();
    this._myValidRotationQuat = quat_create();
    this._myValidHeight = 0;
    this._myValidPositionHead = vec3_create();
    this._myIsBodyColliding = false;
    this._myIsHeadColliding = false;
    this._myIsLeaning = false;
    this._myIsHopping = false;
    this._myIsFar = false;
    this._myLastValidMovementDirection = vec3_create();
    this._myIsRealPositionValid = false;
    this._myIsPositionValid = false;
    this._myResetRealOnSynced = false;
    this._myActive = true;
    this._myDestroyed = false;
  }
  start() {
    this.resetToReal(true);
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myParams.myEngine);
  }
  getParams() {
    return this._myParams;
  }
  setActive(active) {
    this._myActive = active;
  }
  // update should be before to check the new valid transform and if the head new transform is fine
  // then update movements, so that they will use the proper transform
  // pre/post update?
  // For sliding if previous frame no horizontal movement then reset sliding on pre update
  // In generale capire come fare per risolvere i problemi quando c' un move solo verticale che sputtana i dati dello sliding precedente
  // che servono per far slidare bene anche dopo, magari un flag per dire non aggiornare le cose relative al movimento orizzontale
  // o un move check solo verticale
  update(dt) {
  }
  move(movement, outCollisionRuntimeParams = null, forceMove = false) {
  }
  teleportPosition(position, outCollisionRuntimeParams = null, forceTeleport = false) {
  }
  teleportPositionRotationQuat(position, rotationQuat, outCollisionRuntimeParams = null, forceTeleport = false) {
  }
  teleportTransformQuat(transformQuat4, outCollisionRuntimeParams = null, forceTeleport = false) {
  }
  // Quick way to force teleport to a position and reset the real to this
  forceTeleportAndReset(position, rotationQuat) {
    this.teleportPositionRotationQuat(position, rotationQuat, null, true);
    this.resetReal(true, true);
  }
  rotateQuat(rotationQuat) {
  }
  setRotationQuat(rotationQuat) {
  }
  setHeight(height, forceSet = false) {
  }
  getPlayer() {
    return this._myParams.myPlayerHeadManager.getPlayer();
  }
  getHead() {
    return this._myParams.myPlayerHeadManager.getHead();
  }
  getTransformQuat(outTransformQuat = quat2_create()) {
    return outTransformQuat.quat2_setPositionRotationQuat(this.getPosition(this._myValidPosition), this.getRotationQuat(this._myValidRotationQuat));
  }
  getPosition(outPosition = vec3_create()) {
    return outPosition.vec3_copy(this._myValidPosition);
  }
  getRotationQuat(outRotation = quat_create()) {
    return outRotation.quat_copy(this._myValidRotationQuat);
  }
  getPositionHead(outPosition = vec3_create()) {
    return outPosition.vec3_copy(this._myValidPositionHead);
  }
  getTransformHeadQuat(outTransformQuat = quat2_create()) {
    return outTransformQuat.quat2_setPositionRotationQuat(this.getPositionHead(this._myValidPositionHead), this.getRotationQuat(this._myValidRotationQuat));
  }
  getHeight() {
    return this._myValidHeight;
  }
  getTransformRealQuat(outTransformQuat = quat2_create()) {
    return this.getPlayerHeadManager().getTransformFeetQuat(outTransformQuat);
  }
  getTransformHeadRealQuat(outTransformQuat = quat2_create()) {
    return this.getPlayerHeadManager().getTransformHeadQuat(outTransformQuat);
  }
  getPositionReal(outPosition = vec3_create()) {
    return this.getPlayerHeadManager().getPositionFeet(outPosition);
  }
  getPositionHeadReal(outPosition = vec3_create()) {
    return this.getPlayerHeadManager().getPositionHead(outPosition);
  }
  getRotationRealQuat(outRotation = quat_create()) {
    return this.getPlayerHeadManager().getRotationFeetQuat(outRotation);
  }
  getHeightReal() {
    return this._myParams.myPlayerHeadManager.getHeightHead();
  }
  isSynced(syncFlagMap = null) {
    let isBodyColliding = this.isBodyColliding() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.BODY_COLLIDING));
    let isHeadColliding = this.isHeadColliding() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.HEAD_COLLIDING));
    let isFar = this.isFar() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.FAR));
    let isFloating = this.isFloating() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.FLOATING));
    return !isBodyColliding && !isHeadColliding && !isFar && !isFloating;
  }
  resetReal(resetPosition2 = true, resetRotation2 = false, resetHeight = false, resetHeadToReal = true, updateRealFlags = false) {
  }
  updateReal() {
    this._updateReal(0);
  }
  resetToReal(resetToPlayerInsteadOfHead = false, updateRealFlags = false) {
    if (resetToPlayerInsteadOfHead) {
      this._myValidPosition = this.getPlayerHeadManager().getPlayer().pp_getPosition(this._myValidPosition);
    } else {
      this._myValidPosition = this.getPositionReal(this._myValidPosition);
    }
    if (!this._myParams.myAlwaysSyncPositionWithReal) {
      this._myValidPositionHead = this.getPositionHeadReal(this._myValidPositionHead);
    }
    if (resetToPlayerInsteadOfHead) {
      this._myValidRotationQuat = this.getPlayerHeadManager().getPlayer().pp_getRotationQuat(this._myValidRotationQuat);
    } else {
      this._myValidRotationQuat = this.getRotationRealQuat(this._myValidRotationQuat);
    }
    this._myValidHeight = Math.pp_clamp(this.getHeightReal(), this._myParams.myMinHeight, this._myParams.myMaxHeight);
    if (updateRealFlags) {
      this._updateReal(0);
    }
  }
  resetHeadToReal() {
    if (!this._myParams.myAlwaysSyncPositionWithReal) {
      this._myValidPositionHead = this.getPositionHeadReal(this._myValidPositionHead);
    }
  }
  isBodyColliding() {
    return this._myIsBodyColliding;
  }
  isHeadColliding() {
    return this._myIsHeadColliding;
  }
  isFloating() {
    return this.isLeaning() || this.isHopping();
  }
  isLeaning() {
    return this._myIsLeaning;
  }
  isHopping() {
    return this._myIsHopping;
  }
  isFar() {
    return this._myIsFar;
  }
  getDistanceToReal() {
  }
  getDistanceToRealHead() {
  }
  getPlayerHeadManager() {
    return this._myParams.myPlayerHeadManager;
  }
  getMovementCollisionCheckParams() {
    return this._myParams.myMovementCollisionCheckParams;
  }
  getTeleportCollisionCheckParams() {
    return this._myParams.myTeleportCollisionCheckParams;
  }
  collisionCheckParamsUpdated() {
    if (this._myParams.myTeleportCollisionCheckParamsCopyFromMovement) {
      this._generateTeleportParamsFromMovementParams();
    }
    this._generateRealMovementParamsFromMovementParams();
  }
  isPositionValid() {
    return this._myIsPositionValid;
  }
  isRealPositionValid() {
    return this._myIsRealPositionValid;
  }
  getCollisionRuntimeParams() {
    return this._myCollisionRuntimeParams;
  }
  getRealCollisionRuntimeParams() {
    return this._myRealCollisionRuntimeParams;
  }
  _updateCollisionHeight() {
    let validHeight = this.getHeight();
    let realHeight = Math.pp_clamp(this.getHeightReal(), this._myParams.myMinHeight, this._myParams.myMaxHeight);
    this._myParams.myMovementCollisionCheckParams.myHeight = validHeight;
    this._myParams.myTeleportCollisionCheckParams.myHeight = validHeight;
    this._myRealMovementCollisionCheckParams.myHeight = realHeight;
  }
  _setupHeadCollisionCheckParams() {
    this._myHeadCollisionCheckParams = new CollisionCheckParams();
    let params = this._myHeadCollisionCheckParams;
    params.myRadius = this._myParams.myHeadRadius;
    params.myDistanceFromFeetToIgnore = 0;
    params.myDistanceFromHeadToIgnore = 0;
    params.mySplitMovementEnabled = true;
    params.mySplitMovementMaxLength = 0.5;
    params.mySplitMovementMaxStepsEnabled = true;
    params.mySplitMovementMaxSteps = 2;
    params.mySplitMovementStopWhenHorizontalMovementCanceled = true;
    params.mySplitMovementStopWhenVerticalMovementCanceled = true;
    params.myHorizontalMovementCheckEnabled = true;
    params.myHorizontalMovementRadialStepAmount = 1;
    params.myHorizontalMovementCheckDiagonalOutward = true;
    params.myHorizontalMovementCheckDiagonalInward = true;
    params.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = true;
    params.myHorizontalMovementCheckVerticalDiagonalUpwardInward = true;
    params.myHorizontalPositionCheckEnabled = true;
    params.myHalfConeAngle = 180;
    params.myHalfConeSliceAmount = 3;
    params.myCheckConeBorder = true;
    params.myCheckConeRay = true;
    params.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = false;
    params.myHorizontalPositionCheckVerticalDirectionType = 0;
    params.myHeight = params.myRadius;
    params.myPositionOffsetLocal.vec3_set(0, -params.myRadius / 2, 0);
    params.myCheckHeight = true;
    params.myCheckHeightVerticalMovement = true;
    params.myCheckHeightVerticalPosition = true;
    params.myHeightCheckStepAmountMovement = 2;
    params.myHeightCheckStepAmountPosition = 2;
    params.myCheckHeightTopMovement = true;
    params.myCheckHeightTopPosition = true;
    params.myCheckVerticalStraight = true;
    params.myCheckVerticalFixedForwardEnabled = true;
    params.myCheckVerticalFixedForward = vec3_create(0, 0, 1);
    params.myCheckHorizontalFixedForwardEnabled = true;
    params.myCheckHorizontalFixedForward = vec3_create(0, 0, 1);
    params.myVerticalMovementCheckEnabled = true;
    params.myVerticalPositionCheckEnabled = true;
    params.myGroundCircumferenceAddCenter = true;
    params.myGroundCircumferenceSliceAmount = 6;
    params.myGroundCircumferenceStepAmount = 2;
    params.myGroundCircumferenceRotationPerStep = 30;
    params.myFeetRadius = params.myRadius;
    params.myHorizontalBlockLayerFlags.copy(this._myParams.myHeadCollisionBlockLayerFlags);
    params.myHorizontalObjectsToIgnore.pp_copy(this._myParams.myHeadCollisionObjectsToIgnore);
    params.myVerticalBlockLayerFlags.copy(this._myParams.myHeadCollisionBlockLayerFlags);
    params.myVerticalObjectsToIgnore.pp_copy(this._myParams.myHeadCollisionObjectsToIgnore);
    params.myDebugEnabled = false;
    params.myDebugHorizontalMovementEnabled = true;
    params.myDebugHorizontalPositionEnabled = false;
    params.myDebugVerticalMovementEnabled = false;
    params.myDebugVerticalPositionEnabled = false;
    params.myDebugSlidingEnabled = false;
    params.myDebugGroundInfoEnabled = false;
    params.myDebugCeilingInfoEnabled = false;
    params.myDebugRuntimeParamsEnabled = false;
    params.myDebugMovementEnabled = false;
  }
  _generateTeleportParamsFromMovementParams() {
    if (this._myParams.myTeleportCollisionCheckParams == null) {
      this._myParams.myTeleportCollisionCheckParams = new CollisionCheckParams();
    }
    if (this._myParams.myTeleportCollisionCheckParamsCheck360) {
      this._myParams.myTeleportCollisionCheckParams = CollisionCheckUtils.generate360TeleportParamsFromMovementParams(this._myParams.myMovementCollisionCheckParams, this._myParams.myTeleportCollisionCheckParams);
    } else {
      this._myParams.myTeleportCollisionCheckParams.copy(this._myParams.myMovementCollisionCheckParams);
    }
  }
  _generateRealMovementParamsFromMovementParams() {
    if (this._myRealMovementCollisionCheckParams == null) {
      this._myRealMovementCollisionCheckParams = new CollisionCheckParams();
    }
    let params = this._myRealMovementCollisionCheckParams;
    params.copy(this._myParams.myMovementCollisionCheckParams);
    params.mySplitMovementEnabled = true;
    params.mySplitMovementMaxLength = 0.5;
    params.mySplitMovementMaxStepsEnabled = true;
    params.mySplitMovementMaxSteps = 2;
    params.mySplitMovementStopWhenHorizontalMovementCanceled = true;
    params.mySplitMovementStopWhenVerticalMovementCanceled = true;
    params.mySlidingEnabled = false;
    if (!this._myParams.myRealMovementAllowVerticalAdjustments) {
      params.mySnapOnGroundEnabled = false;
      params.mySnapOnCeilingEnabled = false;
      params.myGroundPopOutEnabled = false;
      params.myCeilingPopOutEnabled = false;
      params.myAdjustVerticalMovementWithGroundAngleDownhill = false;
      params.myAdjustVerticalMovementWithGroundAngleUphill = false;
      params.myAdjustVerticalMovementWithCeilingAngleDownhill = false;
      params.myAdjustVerticalMovementWithCeilingAngleUphill = false;
      params.myAdjustHorizontalMovementWithGroundAngleDownhill = false;
      params.myAdjustHorizontalMovementWithCeilingAngleDownhill = false;
      params.myVerticalMovementReduceEnabled = false;
    }
    params.myIsOnGroundIfInsideHit = true;
    params.myDebugEnabled = false;
    params.myDebugHorizontalMovementEnabled = false;
    params.myDebugHorizontalPositionEnabled = false;
    params.myDebugVerticalMovementEnabled = false;
    params.myDebugVerticalPositionEnabled = false;
    params.myDebugSlidingEnabled = false;
    params.myDebugGroundInfoEnabled = true;
    params.myDebugCeilingInfoEnabled = true;
    params.myDebugRuntimeParamsEnabled = false;
    params.myDebugMovementEnabled = false;
  }
  _onXRSessionStart(session) {
    if (this._myActive) {
      if (this._myParams.myResetToValidOnEnterSession) {
        this._myResetRealOnSynced = true;
      }
    }
  }
  _onXRSessionEnd() {
    if (this._myActive) {
      if (this._myParams.myResetToValidOnExitSession) {
        this._myResetRealOnSynced = true;
      }
    }
  }
  _debugUpdate(dt) {
    Globals.getDebugVisualManager(this._myParams.myEngine).drawPoint(0, this._myValidPosition, vec4_create(1, 0, 0, 1), 0.05);
    Globals.getDebugVisualManager(this._myParams.myEngine).drawLineEnd(0, this._myValidPosition, this.getPositionReal(), vec4_create(1, 0, 0, 1), 0.05);
    Globals.getDebugVisualManager(this._myParams.myEngine).drawLine(0, this._myValidPosition, this._myValidRotationQuat.quat_getForward(), 0.15, vec4_create(0, 1, 0, 1), 0.025);
    Globals.getDebugVisualManager(this._myParams.myEngine).drawPoint(0, this._myValidPositionHead, vec4_create(1, 1, 0, 1), 0.05);
  }
  destroy() {
    this._myDestroyed = true;
    XRUtils.unregisterSessionStartEndEventListeners(this, this._myParams.myEngine);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
PlayerTransformManager.prototype.getDistanceToReal = function() {
  let position = vec3_create();
  let realPosition = vec3_create();
  return function getDistanceToReal() {
    realPosition = this.getPositionReal(realPosition);
    return realPosition.vec3_distance(this.getPosition(position));
  };
}();
PlayerTransformManager.prototype.getDistanceToRealHead = function() {
  let position = vec3_create();
  let realPosition = vec3_create();
  return function getDistanceToRealHead() {
    realPosition = this.getPositionHeadReal(realPosition);
    return realPosition.vec3_distance(this.getPositionHead(position));
  };
}();
PlayerTransformManager.prototype.resetReal = function() {
  let realUp = vec3_create();
  let validUp = vec3_create();
  let position = vec3_create();
  let rotationQuat = quat_create();
  return function resetReal(resetPosition2 = true, resetRotation2 = false, resetHeight = false, resetHeadToReal = true, updateRealFlags = false) {
    let playerHeadManager = this.getPlayerHeadManager();
    if (resetPosition2) {
      playerHeadManager.teleportPositionFeet(this.getPosition(position));
    }
    realUp = this.getPlayerHeadManager().getRotationFeetQuat(rotationQuat).quat_getUp(realUp);
    validUp = this.getRotationQuat(rotationQuat).quat_getUp(validUp);
    if (resetRotation2 || realUp.vec3_angle(validUp) > Math.PP_EPSILON_DEGREES && this._myParams.myResetRealResetRotationIfUpChanged) {
      playerHeadManager.setRotationFeetQuat(this.getRotationQuat(rotationQuat), false);
    }
    if (resetHeight) {
      playerHeadManager.setHeightHead(this.getHeight(), true);
    }
    if (updateRealFlags) {
      this._updateReal(0);
    }
    if (resetHeadToReal) {
      this.resetHeadToReal();
    }
  };
}();
PlayerTransformManager.prototype.update = function() {
  let transformQuat4 = quat2_create();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  let transformUp = vec3_create();
  let horizontalDirection = vec3_create();
  let rotationQuat = quat_create();
  return function update(dt) {
    this._updateReal(dt);
    if (this._myResetRealOnSynced) {
      if (this.getPlayerHeadManager().isSynced()) {
        this._myResetRealOnSynced = false;
        if (XRUtils.isSessionActive(this._myParams.myEngine)) {
          this.resetReal(
            !this._myParams.myNeverResetRealPositionVR,
            !this._myParams.myNeverResetRealRotationVR,
            !this._myParams.myNeverResetRealHeightVR,
            true,
            true
          );
        } else {
          this.resetReal(
            !this._myParams.myNeverResetRealPositionNonVR,
            !this._myParams.myNeverResetRealRotationNonVR,
            !this._myParams.myNeverResetRealHeightNonVR,
            true,
            true
          );
        }
      }
    }
    if (this._myParams.myUpdatePositionValid) {
      transformQuat4 = this.getTransformQuat(transformQuat4);
      transformUp = transformQuat4.quat2_getUp(transformUp);
      rotationQuat = transformQuat4.quat2_getRotationQuat(rotationQuat);
      horizontalDirection = this._myLastValidMovementDirection.vec3_removeComponentAlongAxis(transformUp, horizontalDirection);
      if (!horizontalDirection.vec3_isZero(1e-5)) {
        horizontalDirection.vec3_normalize(horizontalDirection);
        rotationQuat.quat_setForward(horizontalDirection);
        transformQuat4.quat2_setRotationQuat(rotationQuat);
      }
      let debugBackup = this._myParams.myMovementCollisionCheckParams.myDebugEnabled;
      this._myParams.myMovementCollisionCheckParams.myDebugEnabled = false;
      CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).positionCheck(true, transformQuat4, this._myParams.myMovementCollisionCheckParams, collisionRuntimeParams);
      this._myParams.myMovementCollisionCheckParams.myDebugEnabled = debugBackup;
      this._myIsPositionValid = collisionRuntimeParams.myIsPositionOk;
    }
    if (this._myParams.myDebugEnabled && Globals.isDebugEnabled(this._myParams.myEngine)) {
      this._debugUpdate(dt);
    }
  };
}();
PlayerTransformManager.prototype._updateReal = function() {
  let movementToCheck = vec3_create();
  let position = vec3_create();
  let positionReal = vec3_create();
  let transformQuat4 = quat2_create();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  let newPosition = vec3_create();
  let newPositionHead = vec3_create();
  let movementStep = vec3_create();
  let currentMovementStep = vec3_create();
  let transformUp = vec3_create();
  let verticalMovement = vec3_create();
  let movementChecked = vec3_create();
  let newFeetPosition = vec3_create();
  let floatingTransformQuat = quat2_create();
  let horizontalDirection = vec3_create();
  let rotationQuat = quat_create();
  return function _updateReal(dt) {
    if (this.getPlayerHeadManager().isSynced()) {
      this._updateCollisionHeight();
      this._myIsBodyColliding = false;
      this._myIsHeadColliding = false;
      this._myIsLeaning = false;
      this._myIsHopping = false;
      this._myIsFar = false;
      movementToCheck = this.getPositionReal(positionReal).vec3_sub(this.getPosition(position), movementToCheck);
      if (movementToCheck.vec3_length() > 1e-4) {
        this._myLastValidMovementDirection = movementToCheck.vec3_normalize(this._myLastValidMovementDirection);
      }
      if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.FAR)) {
        if (this._myParams.myMaxDistanceFromRealToSyncEnabled && movementToCheck.vec3_length() > this._myParams.myMaxDistanceFromRealToSync) {
          this._myIsFar = true;
        } else if (this._myParams.myIsFarExtraCheckCallback != null && this._myParams.myIsFarExtraCheckCallback(this)) {
          this._myIsFar = true;
        }
      }
      collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
      collisionRuntimeParams.myIsOnGround = true;
      transformQuat4 = this.getTransformQuat(transformQuat4);
      newPosition.vec3_copy(this._myValidPosition);
      if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.BODY_COLLIDING)) {
        CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).move(movementToCheck, transformQuat4, this._myRealMovementCollisionCheckParams, collisionRuntimeParams);
        if (!collisionRuntimeParams.myHorizontalMovementCanceled && !collisionRuntimeParams.myVerticalMovementCanceled) {
          if (Math.pp_clamp(
            this._myRealMovementCollisionCheckParams.myHeight,
            this._myParams.myIsBodyCollidingWhenHeightBelowValue,
            this._myParams.myIsBodyCollidingWhenHeightAboveValue
          ) != this._myRealMovementCollisionCheckParams.myHeight) {
            this._myIsBodyColliding = true;
          } else {
            if (this._myParams.myIsBodyCollidingExtraCheckCallback != null && this._myParams.myIsBodyCollidingExtraCheckCallback(this)) {
              this._myIsBodyColliding = true;
            } else {
              this._myIsBodyColliding = false;
              newPosition.vec3_copy(collisionRuntimeParams.myNewPosition);
            }
          }
        } else {
          this._myIsBodyColliding = true;
        }
      }
      if (this._myParams.myAlwaysSyncPositionWithReal) {
        newPosition.vec3_copy(positionReal);
      }
      if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.FLOATING)) {
        if (!this._myIsBodyColliding) {
          movementToCheck = newPosition.vec3_sub(position, movementToCheck);
        } else {
          movementToCheck = positionReal.vec3_sub(position, movementToCheck);
        }
        collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
        floatingTransformQuat.quat2_setPositionRotationQuat(this._myValidPosition, this._myValidRotationQuat);
        CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).updateSurfaceInfo(floatingTransformQuat, this._myRealMovementCollisionCheckParams, collisionRuntimeParams);
        if (collisionRuntimeParams.myIsOnGround) {
          transformUp = transformQuat4.quat2_getUp(transformUp);
          verticalMovement = movementToCheck.vec3_componentAlongAxis(transformUp, verticalMovement);
          let isVertical = !verticalMovement.vec3_isZero(1e-5);
          if (!isVertical || !this._myParams.myIsFloatingValidIfVerticalMovement) {
            let movementStepAmount = 1;
            movementStep.vec3_copy(movementToCheck);
            if (!movementToCheck.vec3_isZero(1e-5) && this._myParams.myFloatingSplitCheckEnabled) {
              let equalStepLength = movementToCheck.vec3_length() / this._myParams.myFloatingSplitCheckMaxSteps;
              if (!this._myParams.myFloatingSplitCheckStepEqualLength || equalStepLength < this._myParams.myFloatingSplitCheckStepEqualLengthMinLength) {
                let maxLength = this._myParams.myFloatingSplitCheckStepEqualLength ? this._myParams.myFloatingSplitCheckStepEqualLengthMinLength : this._myParams.myFloatingSplitCheckMaxLength;
                movementStepAmount = Math.ceil(movementToCheck.vec3_length() / maxLength);
                if (movementStepAmount > 1) {
                  movementStep = movementStep.vec3_normalize(movementStep).vec3_scale(maxLength, movementStep);
                  movementStepAmount = this._myParams.myFloatingSplitCheckMaxSteps != null ? Math.min(movementStepAmount, this._myParams.myFloatingSplitCheckMaxSteps) : movementStepAmount;
                }
                movementStepAmount = Math.max(1, movementStepAmount);
                if (movementStepAmount == 1) {
                  movementStep.vec3_copy(movementToCheck);
                }
              } else {
                movementStepAmount = this._myParams.myFloatingSplitCheckMaxSteps;
                if (movementStepAmount > 1) {
                  movementStep = movementStep.vec3_normalize(movementStep).vec3_scale(equalStepLength, movementStep);
                }
              }
            }
            let isOnValidGroundAngle = collisionRuntimeParams.myGroundAngle <= this._myRealMovementCollisionCheckParams.myGroundAngleToIgnore + 1e-4;
            movementChecked.vec3_zero();
            newFeetPosition.vec3_copy(this._myValidPosition);
            collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
            let atLeastOneNotOnGround = false;
            let isOneOnGroundBetweenNoGround = false;
            let isLastOnGround = false;
            let isOneOnSteepGround = false;
            for (let i = 0; i < movementStepAmount; i++) {
              if (movementStepAmount == 1 || i != movementStepAmount - 1) {
                currentMovementStep.vec3_copy(movementStep);
              } else {
                currentMovementStep = movementToCheck.vec3_sub(movementChecked, currentMovementStep);
              }
              newFeetPosition = newFeetPosition.vec3_add(currentMovementStep, newFeetPosition);
              floatingTransformQuat.quat2_setPositionRotationQuat(newFeetPosition, this._myValidRotationQuat);
              collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
              CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).updateSurfaceInfo(floatingTransformQuat, this._myRealMovementCollisionCheckParams, collisionRuntimeParams);
              movementChecked = movementChecked.vec3_add(currentMovementStep, movementChecked);
              if (!collisionRuntimeParams.myIsOnGround) {
                atLeastOneNotOnGround = true;
              } else {
                if (collisionRuntimeParams.myGroundAngle > this._myRealMovementCollisionCheckParams.myGroundAngleToIgnore + 1e-4) {
                  isOneOnSteepGround = true;
                }
                if (atLeastOneNotOnGround) {
                  isOneOnGroundBetweenNoGround = true;
                }
                if (i == movementStepAmount - 1) {
                  isLastOnGround = true;
                }
              }
            }
            let isFloatingOnSteepGroundFail = isOneOnSteepGround && isOnValidGroundAngle && !this._myParams.myIsFloatingValidIfSteepGround && (!isVertical || !this._myParams.myIsFloatingValidIfVerticalMovementAndSteepGround);
            if (atLeastOneNotOnGround || isFloatingOnSteepGroundFail) {
              if (isOneOnGroundBetweenNoGround) {
                this._myIsHopping = true;
              } else {
                this._myIsLeaning = true;
              }
            } else {
              this._myIsLeaning = false;
              this._myIsHopping = false;
              if (this._myParams.myIsLeaningExtraCheckCallback != null && this._myParams.myIsLeaningExtraCheckCallback(this)) {
                this._myIsLeaning = true;
              } else if (this._myParams.myIsHoppingExtraCheckCallback != null && this._myParams.myIsHoppingExtraCheckCallback(this)) {
                this._myIsHopping = true;
              }
            }
            if (this._myIsLeaning) {
              let distance5 = movementToCheck.vec3_length();
              if (this._myParams.myIsLeaningValidAboveDistance && distance5 > this._myParams.myLeaningValidDistance) {
                this._myIsLeaning = false;
              }
            }
            if (this._myIsLeaning || this._myIsHopping) {
              if (isLastOnGround && this._myParams.myIsFloatingValidIfRealOnGround) {
                this._myIsLeaning = false;
                this._myIsHopping = false;
              } else if (isLastOnGround && isVertical && this._myParams.myIsFloatingValidIfVerticalMovementAndRealOnGround) {
                this._myIsLeaning = false;
                this._myIsHopping = false;
              }
            }
          }
        }
      }
      movementToCheck = this.getPositionHeadReal(positionReal).vec3_sub(this.getPositionHead(position), movementToCheck);
      collisionRuntimeParams.reset();
      transformQuat4 = this.getTransformHeadQuat(transformQuat4);
      newPositionHead.vec3_copy(this._myValidPositionHead);
      if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.HEAD_COLLIDING)) {
        CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).move(movementToCheck, transformQuat4, this._myHeadCollisionCheckParams, collisionRuntimeParams);
        if (!collisionRuntimeParams.myHorizontalMovementCanceled && !collisionRuntimeParams.myVerticalMovementCanceled) {
          this._myIsHeadColliding = false;
          newPositionHead.vec3_copy(collisionRuntimeParams.myNewPosition);
        } else {
          this._myIsHeadColliding = true;
        }
      }
      if (this._myParams.myAlwaysSyncHeadPositionWithReal) {
        newPositionHead.vec3_copy(positionReal);
      }
      if ((this.isSynced(this._myParams.mySyncPositionFlagMap) || this._myParams.myAlwaysSyncPositionWithReal) && !this._myParams.mySyncPositionDisabled) {
        this._myValidPosition.vec3_copy(newPosition);
      }
      if (this.isSynced(this._myParams.mySyncPositionHeadFlagMap) || this._myParams.myAlwaysSyncHeadPositionWithReal || this.isSynced(this._myParams.mySyncPositionFlagMap) && this._myParams.myAlwaysSyncPositionWithReal) {
        this._myValidPositionHead = this.getPositionHeadReal(newPositionHead);
      }
      if (this.isSynced(this._myParams.mySyncRotationFlagMap)) {
        this._myValidRotationQuat = this.getRotationRealQuat(this._myValidRotationQuat);
      }
      if (this.isSynced(this._myParams.mySyncHeightFlagMap)) {
        this._myValidHeight = this._myRealMovementCollisionCheckParams.myHeight;
        this._updateCollisionHeight();
      }
      if (this._myParams.myUpdateRealPositionValid) {
        transformQuat4 = this.getTransformRealQuat(transformQuat4);
        transformUp = transformQuat4.quat2_getUp(transformUp);
        rotationQuat = transformQuat4.quat2_getRotationQuat(rotationQuat);
        horizontalDirection = this._myLastValidMovementDirection.vec3_removeComponentAlongAxis(transformUp, horizontalDirection);
        if (!horizontalDirection.vec3_isZero(1e-5)) {
          horizontalDirection.vec3_normalize(horizontalDirection);
          rotationQuat.quat_setForward(horizontalDirection);
          transformQuat4.quat2_setRotationQuat(rotationQuat);
        }
        let debugBackup = this._myParams.myMovementCollisionCheckParams.myDebugEnabled;
        this._myParams.myMovementCollisionCheckParams.myDebugEnabled = false;
        CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).positionCheck(true, transformQuat4, this._myParams.myMovementCollisionCheckParams, this._myRealCollisionRuntimeParams);
        this._myIsRealPositionValid = this._myRealCollisionRuntimeParams.myIsPositionOk;
        this._myParams.myMovementCollisionCheckParams.myDebugEnabled = debugBackup;
      }
    }
  };
}();
PlayerTransformManager.prototype.move = function() {
  let transformQuat4 = quat2_create();
  let fixedMovement = vec3_create();
  return function move(movement, outCollisionRuntimeParams = null, forceMove = false) {
    transformQuat4 = this.getTransformQuat(transformQuat4);
    CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).move(movement, transformQuat4, this._myParams.myMovementCollisionCheckParams, this._myCollisionRuntimeParams);
    if (outCollisionRuntimeParams != null) {
      outCollisionRuntimeParams.copy(this._myCollisionRuntimeParams);
    }
    if (!forceMove) {
      fixedMovement.vec3_copy(this._myCollisionRuntimeParams.myFixedMovement);
    } else {
      fixedMovement.vec3_copy(movement);
    }
    if (!fixedMovement.vec3_isZero(1e-5)) {
      this._myValidPosition.vec3_add(fixedMovement, this._myValidPosition);
      this.getPlayerHeadManager().moveFeet(fixedMovement);
    }
    if (this._myParams.myResetRealOnMove) {
      if (!this.isSynced()) {
        if (XRUtils.isSessionActive(this._myParams.myEngine)) {
          this.resetReal(
            !this._myParams.myNeverResetRealPositionVR,
            !this._myParams.myNeverResetRealRotationVR,
            !this._myParams.myNeverResetRealHeightVR,
            true
          );
        } else {
          this.resetReal(
            !this._myParams.myNeverResetRealPositionNonVR,
            !this._myParams.myNeverResetRealRotationNonVR,
            !this._myParams.myNeverResetRealHeightNonVR,
            true
          );
        }
      }
    }
  };
}();
PlayerTransformManager.prototype.teleportPosition = function() {
  let teleportTransformQuat = quat2_create();
  return function teleportPosition(teleportPosition, outCollisionRuntimeParams = null, forceTeleport = false) {
    teleportTransformQuat = this.getTransformQuat(teleportTransformQuat);
    teleportTransformQuat.quat2_setPosition(teleportPosition);
    this.teleportTransformQuat(teleportTransformQuat, outCollisionRuntimeParams, forceTeleport);
  };
}();
PlayerTransformManager.prototype.teleportPositionRotationQuat = function() {
  let teleportTransformQuat = quat2_create();
  return function teleportPositionRotationQuat(teleportPosition, teleportRotationQuat, outCollisionRuntimeParams = null, forceTeleport = false) {
    teleportTransformQuat = this.getTransformQuat(teleportTransformQuat);
    teleportTransformQuat.quat2_setPositionRotationQuat(teleportPosition, teleportRotationQuat);
    this.teleportTransformQuat(teleportTransformQuat, outCollisionRuntimeParams, forceTeleport);
  };
}();
PlayerTransformManager.prototype.teleportTransformQuat = function() {
  let currentPosition = vec3_create();
  let teleportPositionVec = vec3_create();
  let teleportRotation = quat_create();
  let rotatedTransformQuat = quat2_create();
  let fixedMovement = vec3_create();
  return function teleportTransformQuat(teleportTransformQuat, outCollisionRuntimeParams = null, forceTeleport = false) {
    currentPosition = this.getPosition(currentPosition);
    teleportPositionVec = teleportTransformQuat.quat2_getPosition(teleportPositionVec);
    teleportRotation = teleportTransformQuat.quat2_getRotationQuat(teleportRotation);
    rotatedTransformQuat.quat2_setPositionRotationQuat(currentPosition, teleportRotation);
    CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).teleport(teleportPositionVec, rotatedTransformQuat, this._myParams.myTeleportCollisionCheckParams, this._myCollisionRuntimeParams);
    if (outCollisionRuntimeParams != null) {
      outCollisionRuntimeParams.copy(this._myCollisionRuntimeParams);
    }
    fixedMovement.vec3_zero();
    if (!forceTeleport) {
      if (!this._myCollisionRuntimeParams.myTeleportCanceled) {
        fixedMovement = this._myCollisionRuntimeParams.myFixedTeleportPosition.vec3_sub(currentPosition, fixedMovement);
      }
    } else {
      fixedMovement = teleportPositionVec.vec3_sub(currentPosition, fixedMovement);
    }
    if (!this._myCollisionRuntimeParams.myTeleportCanceled || forceTeleport) {
      this._myValidRotationQuat.quat_copy(teleportRotation);
      this.getPlayerHeadManager().setRotationFeetQuat(teleportRotation);
    }
    if (!fixedMovement.vec3_isZero(1e-5)) {
      this._myValidPosition.vec3_add(fixedMovement, this._myValidPosition);
      this.getPlayerHeadManager().moveFeet(fixedMovement);
    }
    if (this._myParams.myResetRealOnTeleport) {
      if (!this.isSynced()) {
        if (XRUtils.isSessionActive(this._myParams.myEngine)) {
          this.resetReal(
            !this._myParams.myNeverResetRealPositionVR,
            !this._myParams.myNeverResetRealRotationVR,
            !this._myParams.myNeverResetRealHeightVR,
            true
          );
        } else {
          this.resetReal(
            !this._myParams.myNeverResetRealPositionNonVR,
            !this._myParams.myNeverResetRealRotationNonVR,
            !this._myParams.myNeverResetRealHeightNonVR,
            true
          );
        }
      }
    }
  };
}();
PlayerTransformManager.prototype.rotateQuat = function() {
  return function rotateQuat4(rotationQuat) {
    this._myValidRotationQuat.quat_rotateQuat(rotationQuat, this._myValidRotationQuat);
    this.getPlayerHeadManager().rotateFeetQuat(rotationQuat);
  };
}();
PlayerTransformManager.prototype.setRotationQuat = function() {
  let rotationToPerform = quat_create();
  return function setRotationQuat4(rotationQuat) {
    rotationToPerform = this._myValidRotationQuat.quat_rotationToQuat(rotationQuat, rotationToPerform);
    this.rotateQuat(rotationToPerform);
  };
}();
PlayerTransformManager.prototype.setHeight = function() {
  let transformQuat4 = quat2_create();
  return function setHeight(height, forceSet = false) {
    let fixedHeight = Math.pp_clamp(height, this._myParams.myMinHeight, this._myParams.myMaxHeight);
    let previousHeight = this.getHeight();
    this._myValidHeight = fixedHeight;
    this._updateCollisionHeight();
    transformQuat4 = this.getTransformQuat(transformQuat4);
    CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).positionCheck(true, transformQuat4, this._myParams.myMovementCollisionCheckParams, this._myCollisionRuntimeParams);
    if (this._myCollisionRuntimeParams.myIsPositionOk || forceSet) {
      this.getPlayerHeadManager().setHeightHead(this.getHeight(), true);
    } else {
      this._myValidHeight = previousHeight;
    }
    this._updateCollisionHeight();
  };
}();

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion_rotate.js
var PlayerLocomotionRotateParams = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this.myPlayerHeadManager = null;
    this.myMaxRotationSpeed = 0;
    this.myIsSnapTurn = false;
    this.mySnapTurnOnlyVR = false;
    this.mySmoothSnapEnabled = true;
    this.mySmoothSnapSpeedDegrees = 240;
    this.myRotationMinStickIntensityThreshold = 0;
    this.mySnapTurnActivateThreshold = 0;
    this.mySnapTurnResetThreshold = 0;
    this.myClampVerticalAngle = true;
    this.myMaxVerticalAngle = 0;
    this.myHandedness = Handedness.RIGHT;
    this.myEngine = engine2;
  }
};
var PlayerLocomotionRotate = class {
  constructor(params) {
    this._myParams = params;
    this._mySnapCharge = false;
    this._mySmoothSnapHorizontalRunning = false;
    this._mySmoothSnapHorizontalAngleToPerform = 0;
    this._mySmoothSnapVerticalRunning = false;
    this._mySmoothSnapVerticalAngleToPerform = 0;
  }
  start() {
  }
  stop() {
    this._mySmoothSnapHorizontalRunning = false;
    this._mySmoothSnapHorizontalAngleToPerform = 0;
    this._mySmoothSnapVerticalRunning = false;
    this._mySmoothSnapVerticalAngleToPerform = 0;
  }
  getParams() {
    return this._myParams;
  }
  update(dt) {
    this._rotateHeadHorizontally(dt);
    if (this._myParams.myPlayerHeadManager.canRotateHead()) {
      this._rotateHeadVertically(dt);
    }
  }
};
PlayerLocomotionRotate.prototype._rotateHeadHorizontally = function() {
  let playerUp = vec3_create();
  let headRotation = quat_create();
  return function _rotateHeadHorizontally(dt) {
    playerUp = this._myParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    headRotation.quat_identity();
    let axes = Globals.getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
    if (!this._myParams.myIsSnapTurn || this._myParams.mySnapTurnOnlyVR && !XRUtils.isSessionActive(this._myParams.myEngine)) {
      if (Math.abs(axes[0]) > this._myParams.myRotationMinStickIntensityThreshold) {
        let rotationIntensity = -axes[0];
        let speed = Math.pp_lerp(0, this._myParams.myMaxRotationSpeed, Math.abs(rotationIntensity)) * Math.pp_sign(rotationIntensity);
        headRotation.quat_fromAxis(speed * dt, playerUp);
      }
    } else {
      if (!this._mySnapCharge) {
        if (Math.abs(axes.vec2_length()) < this._myParams.mySnapTurnResetThreshold) {
          this._mySnapCharge = true;
        }
      } else if (!this._mySmoothSnapHorizontalRunning) {
        if (Math.abs(axes[0]) > this._myParams.mySnapTurnActivateThreshold) {
          let angleToRotate = -Math.pp_sign(axes[0]) * this._myParams.mySnapTurnAngle;
          if (!this._myParams.mySmoothSnapEnabled) {
            headRotation.quat_fromAxis(angleToRotate, playerUp);
          } else {
            this._mySmoothSnapHorizontalRunning = true;
            this._mySmoothSnapHorizontalAngleToPerform = angleToRotate;
          }
          this._mySnapCharge = false;
        }
      }
    }
    if (this._mySmoothSnapHorizontalRunning) {
      let angleToRotate = Math.pp_sign(this._mySmoothSnapHorizontalAngleToPerform) * (this._myParams.mySmoothSnapSpeedDegrees * dt);
      if (Math.abs(angleToRotate) > Math.abs(this._mySmoothSnapHorizontalAngleToPerform) - Math.PP_EPSILON) {
        angleToRotate = this._mySmoothSnapHorizontalAngleToPerform;
      }
      headRotation.quat_fromAxis(angleToRotate, playerUp);
      this._mySmoothSnapHorizontalAngleToPerform -= angleToRotate;
      if (Math.abs(this._mySmoothSnapHorizontalAngleToPerform) < Math.PP_EPSILON) {
        this._mySmoothSnapHorizontalRunning = false;
        this._mySmoothSnapHorizontalAngleToPerform = 0;
      }
    }
    if (headRotation.quat_getAngle() > Math.PP_EPSILON_DEGREES) {
      this._myParams.myPlayerTransformManager.rotateQuat(headRotation);
    }
  };
}();
PlayerLocomotionRotate.prototype._rotateHeadVertically = function() {
  let headForward = vec3_create();
  let headUp = vec3_create();
  let referenceUp = vec3_create();
  let referenceUpNegate = vec3_create();
  let referenceRight = vec3_create();
  let newUp = vec3_create();
  let headRotation = quat_create();
  return function _rotateHeadVertically(dt) {
    let head = this._myParams.myPlayerHeadManager.getHead();
    headForward = head.pp_getForward(headForward);
    headUp = head.pp_getUp(headUp);
    referenceUp = this._myParams.myPlayerHeadManager.getPlayer().pp_getUp(referenceUp);
    referenceUpNegate = referenceUp.vec3_negate(referenceUpNegate);
    referenceRight = headForward.vec3_cross(referenceUp, referenceRight);
    let minAngle = 1;
    if (headForward.vec3_angle(referenceUp) < minAngle) {
      referenceRight = headUp.vec3_negate(referenceRight).vec3_cross(referenceUp, referenceRight);
    } else if (headForward.vec3_angle(referenceUpNegate) < minAngle) {
      referenceRight = headUp.vec3_cross(referenceUp, referenceRight);
    } else if (!headUp.vec3_isConcordant(referenceUp)) {
      referenceRight.vec3_negate(referenceRight);
    }
    referenceRight.vec3_normalize(referenceRight);
    let axes = Globals.getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
    let angleToRotate = 0;
    if (!this._myParams.myIsSnapTurn || this._myParams.mySnapTurnOnlyVR && !XRUtils.isSessionActive(this._myParams.myEngine)) {
      if (Math.abs(axes[1]) > this._myParams.myRotationMinStickIntensityThreshold) {
        let rotationIntensity = axes[1];
        angleToRotate = Math.pp_lerp(0, this._myParams.myMaxRotationSpeed, Math.abs(rotationIntensity)) * Math.pp_sign(rotationIntensity) * dt;
      }
    } else {
      if (!this._mySnapCharge) {
        if (Math.abs(axes.vec2_length()) < this._myParams.mySnapTurnResetThreshold) {
          this._mySnapCharge = true;
        }
      } else if (!this._mySmoothSnapVerticalRunning) {
        if (Math.abs(axes[1]) > this._myParams.mySnapTurnActivateThreshold) {
          angleToRotate = Math.pp_sign(axes[1]) * this._myParams.mySnapTurnAngle;
          let angleWithUp = Math.pp_angleClamp(headUp.vec3_angleSigned(referenceUp, referenceRight));
          let snapStep = Math.round(angleWithUp / this._myParams.mySnapTurnAngle);
          let snapAngle = Math.pp_angleClamp(snapStep * this._myParams.mySnapTurnAngle);
          let angleToAlign = -Math.pp_angleDistanceSigned(angleWithUp, snapAngle);
          if (Math.abs(angleToAlign) > 1) {
            if (Math.pp_sign(angleToRotate) == Math.pp_sign(angleToAlign)) {
              angleToRotate = angleToAlign;
            } else {
              angleToRotate = -Math.pp_sign(angleToAlign) * this._myParams.mySnapTurnAngle + angleToAlign;
            }
          } else if (Math.abs(angleToAlign) > Math.PP_EPSILON_DEGREES) {
            angleToRotate += angleToAlign;
          }
          if (this._myParams.mySmoothSnapEnabled) {
            this._mySmoothSnapVerticalRunning = true;
            this._mySmoothSnapVerticalAngleToPerform = angleToRotate;
          }
          this._mySnapCharge = false;
        }
      }
    }
    if (this._mySmoothSnapVerticalRunning) {
      angleToRotate = Math.pp_sign(this._mySmoothSnapVerticalAngleToPerform) * (this._myParams.mySmoothSnapSpeedDegrees * dt);
      if (Math.abs(angleToRotate) > Math.abs(this._mySmoothSnapVerticalAngleToPerform) - Math.PP_EPSILON) {
        angleToRotate = this._mySmoothSnapVerticalAngleToPerform;
      }
      this._mySmoothSnapVerticalAngleToPerform -= angleToRotate;
      if (Math.abs(this._mySmoothSnapVerticalAngleToPerform) < Math.PP_EPSILON) {
        this._mySmoothSnapVerticalRunning = false;
        this._mySmoothSnapVerticalAngleToPerform = 0;
      }
    }
    if (angleToRotate != 0) {
      headRotation.quat_fromAxis(angleToRotate, referenceRight);
      this._myParams.myPlayerHeadManager.rotateHeadQuat(headRotation);
      if (this._myParams.myClampVerticalAngle) {
        let maxVerticalAngle = this._myParams.myMaxVerticalAngle - 1e-4;
        newUp = head.pp_getUp(newUp);
        let angleWithUp = Math.pp_angleClamp(newUp.vec3_angleSigned(referenceUp, referenceRight));
        if (Math.abs(angleWithUp) > maxVerticalAngle) {
          let fixAngle = (Math.abs(angleWithUp) - maxVerticalAngle) * Math.pp_sign(angleWithUp);
          headRotation.quat_fromAxis(fixAngle, referenceRight);
          this._myParams.myPlayerHeadManager.rotateHeadQuat(headRotation);
        }
      }
    }
  };
}();
Object.defineProperty(PlayerLocomotionRotate.prototype, "_rotateHeadHorizontally", { enumerable: false });
Object.defineProperty(PlayerLocomotionRotate.prototype, "_rotateHeadVertically", { enumerable: false });

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion_movement.js
var PlayerLocomotionMovementRuntimeParams = class {
  constructor() {
    this.myIsFlying = false;
    this.myGravitySpeed = 0;
    this.myCollisionRuntimeParams = null;
    this.myIsTeleportDetecting = false;
    this.myIsTeleporting = false;
    this.myTeleportJustPerformed = false;
  }
};
var PlayerLocomotionMovement = class {
  constructor(locomotionRuntimeParams) {
    this._myLocomotionRuntimeParams = locomotionRuntimeParams;
  }
  getRuntimeParams() {
    return this._myLocomotionRuntimeParams;
  }
  start() {
  }
  stop() {
  }
  canStop() {
    return true;
  }
};

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/player_obscure_manager.js
var PlayerObscureManagerParams = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this.myPlayerTransformManager = null;
    this.myEnabled = true;
    this.myObscureObject = null;
    this.myObscureMaterial = null;
    this.myObscureRadius = 0;
    this.myObscureFadeOutSeconds = 0.1;
    this.myObscureFadeInSeconds = 0.1;
    this.myObscureFadeEasingFunction = EasingFunction.linear;
    this.myDistanceToStartObscureWhenHeadColliding = 0;
    this.myDistanceToStartObscureWhenBodyColliding = 0;
    this.myDistanceToStartObscureWhenFloating = 0;
    this.myDistanceToStartObscureWhenFar = 0;
    this.myRelativeDistanceToMaxObscureWhenHeadColliding = 0;
    this.myRelativeDistanceToMaxObscureWhenBodyColliding = 0;
    this.myRelativeDistanceToMaxObscureWhenFloating = 0;
    this.myRelativeDistanceToMaxObscureWhenFar = 0;
    this.myObscureLevelRelativeDistanceEasingFunction = EasingFunction.linear;
    this.myEngine = engine2;
  }
};
var PlayerObscureManager = class {
  constructor(params) {
    this._myParams = params;
    this._myObscureMaterial = null;
    this._myObscureParentObject = null;
    this._myCurrentObscureLevel = 0;
    this._myTargetObscureLevel = 0;
    this._myLastTargetObscureLevel = null;
    this._myLastIsFadingIn = null;
    this._myFadeTimer = new Timer(0, false);
    this._myFSM = new FSM();
    this._myFSM.addState("init");
    this._myFSM.addState("inactive");
    this._myFSM.addState("idle", this._idleUpdate.bind(this));
    this._myFSM.addState("fading", this._fadingUpdate.bind(this));
    this._myFSM.addTransition("init", "inactive", "end", this._setObscureLevel.bind(this, 0));
    this._myFSM.addTransition("inactive", "idle", "start");
    this._myFSM.addTransition("idle", "fading", "fade", this._startFading.bind(this));
    this._myFSM.addTransition("fading", "idle", "done", this._fadingDone.bind(this));
    this._myFSM.addTransition("inactive", "inactive", "stop", this._setObscureLevel.bind(this, 0));
    this._myFSM.addTransition("idle", "inactive", "stop", this._setObscureLevel.bind(this, 0));
    this._myFSM.addTransition("fading", "inactive", "stop", this._setObscureLevel.bind(this, 0));
    this._myFSM.init("init");
    this._setupVisuals();
    this._myFSM.perform("end");
    this._myDestroyed = false;
  }
  start() {
    this._myFSM.perform("start");
  }
  stop() {
    this._myFSM.perform("stop");
  }
  getParams() {
    return this._myParams;
  }
  update(dt) {
    this._myObscureParentObject.pp_resetTransformLocal();
    this._updateObscured();
    this._myFSM.update(dt);
    this._setObscureVisible(this.isObscured());
  }
  isStarted() {
    return !this._myFSM.isInState("inactive");
  }
  isObscured() {
    return this._myCurrentObscureLevel > 0;
  }
  isFading() {
    return this._myFSM.isInState("fading");
  }
  isFadingIn() {
    return this.isFading() && this._myCurrentObscureLevel > this._myTargetObscureLevel;
  }
  isFadingOut() {
    return this.isFading() && this._myCurrentObscureLevel <= this._myTargetObscureLevel;
  }
  getObscureLevel() {
    return this._myCurrentObscureLevel;
  }
  getTargetObscureLevel() {
    return this._myTargetObscureLevel;
  }
  getCurrentObscureLevel() {
    this._myCurrentObscureLevel;
  }
  overrideObscureLevel(obscureLevel, instantFade = false) {
    this._myObscureLevelOverride = obscureLevel;
    if (instantFade && this.isStarted()) {
      this._setObscureLevel(obscureLevel);
    }
  }
  resetObscureLevelOverride() {
    this._myObscureLevelOverride = null;
  }
  _idleUpdate(dt) {
    if (Math.abs(this._myTargetObscureLevel - this._myCurrentObscureLevel) > Math.PP_EPSILON) {
      this._myFSM.perform("fade");
    }
  }
  _fadingUpdate(dt) {
    if (Math.abs(this._myTargetObscureLevel - this._myCurrentObscureLevel) <= Math.PP_EPSILON) {
      this._myFSM.perform("done");
      return;
    }
    if (this._myLastTargetObscureLevel != this._myTargetObscureLevel) {
      this._refreshFadeTimer();
      this._myLastTargetObscureLevel = this._myTargetObscureLevel;
    }
    this._myFadeTimer.update(dt);
    let newObscureLevel = this._myParams.myObscureFadeEasingFunction(this._myFadeTimer.getPercentage());
    let isFadingIn = this._myCurrentObscureLevel > this._myTargetObscureLevel;
    if (!isFadingIn) {
      newObscureLevel = Math.min(newObscureLevel, this._myTargetObscureLevel);
    } else {
      newObscureLevel = Math.pp_clamp(1 - newObscureLevel, 0, 1);
      newObscureLevel = Math.max(newObscureLevel, this._myTargetObscureLevel);
    }
    this._setObscureAlpha(newObscureLevel);
    this._myCurrentObscureLevel = newObscureLevel;
    if (Math.abs(this._myTargetObscureLevel - this._myCurrentObscureLevel) <= Math.PP_EPSILON || this._myFadeTimer.isDone()) {
      this._myFSM.perform("done");
    }
  }
  _startFading() {
    this._myLastTargetObscureLevel = null;
    this._myLastIsFadingIn = null;
  }
  _fadingDone() {
    this._setObscureLevel(this._myTargetObscureLevel);
  }
  _refreshFadeTimer() {
    let isFadingIn = this._myCurrentObscureLevel > this._myTargetObscureLevel;
    if (this._myLastIsFadingIn != isFadingIn) {
      this._setFadeTimerToObscureLevel(isFadingIn);
    }
    this._myLastIsFadingIn = isFadingIn;
  }
  _setFadeTimerToObscureLevel(isFadingIn) {
    let percentage = 0;
    let closestPercentage = 0;
    let steps = 1e3;
    let increment = 1 / steps;
    while (percentage < 1) {
      if (Math.abs(this._myParams.myObscureFadeEasingFunction(percentage) - this._myCurrentObscureLevel) < Math.abs(this._myParams.myObscureFadeEasingFunction(closestPercentage) - this._myCurrentObscureLevel)) {
        closestPercentage = percentage;
      }
      percentage += increment;
    }
    if (Math.abs(this._myParams.myObscureFadeEasingFunction(1) - this._myCurrentObscureLevel) < Math.abs(this._myParams.myObscureFadeEasingFunction(closestPercentage) - this._myCurrentObscureLevel)) {
      closestPercentage = 1;
    }
    if (isFadingIn) {
      this._myFadeTimer.start(this._myParams.myObscureFadeInSeconds);
      this._myFadeTimer.setPercentage(Math.pp_clamp(1 - closestPercentage, 0, 1));
    } else {
      this._myFadeTimer.start(this._myParams.myObscureFadeOutSeconds);
      this._myFadeTimer.setPercentage(Math.pp_clamp(closestPercentage, 0, 1));
    }
  }
  _setObscureLevel(obscureLevel) {
    this._myTargetObscureLevel = obscureLevel;
    this._myCurrentObscureLevel = obscureLevel;
    this._setObscureAlpha(obscureLevel);
    this._setObscureVisible(this.isObscured());
  }
  _setObscureAlpha(alpha) {
    if (this._myParams.myObscureObject == null) {
      MaterialUtils.setAlpha(this._myObscureMaterial, alpha);
    } else {
      MaterialUtils.setObjectAlpha(this._myParams.myObscureObject, alpha);
    }
  }
  _updateObscured() {
    this._myTargetObscureLevel = 0;
    if (this._myParams.myEnabled) {
      if (this._myObscureLevelOverride != null) {
        this._myTargetObscureLevel = this._myObscureLevelOverride;
      } else {
        if (this._myParams.myPlayerTransformManager.isHeadColliding()) {
          let distance5 = this._myParams.myPlayerTransformManager.getDistanceToRealHead();
          let relativeDistance = distance5 - this._myParams.myDistanceToStartObscureWhenHeadColliding;
          if (relativeDistance >= 0) {
            let relativeDistancePercentage = Math.pp_clamp(relativeDistance / this._myParams.myRelativeDistanceToMaxObscureWhenHeadColliding, 0, 1);
            let targetObscureLevel = this._myParams.myObscureLevelRelativeDistanceEasingFunction(relativeDistancePercentage);
            this._myTargetObscureLevel = Math.max(this._myTargetObscureLevel, targetObscureLevel);
          }
        }
        if (this._myParams.myPlayerTransformManager.isBodyColliding()) {
          let distance5 = this._myParams.myPlayerTransformManager.getDistanceToReal();
          let relativeDistance = distance5 - this._myParams.myDistanceToStartObscureWhenBodyColliding;
          if (relativeDistance >= 0) {
            let relativeDistancePercentage = Math.pp_clamp(relativeDistance / this._myParams.myRelativeDistanceToMaxObscureWhenBodyColliding, 0, 1);
            let targetObscureLevel = this._myParams.myObscureLevelRelativeDistanceEasingFunction(relativeDistancePercentage);
            this._myTargetObscureLevel = Math.max(this._myTargetObscureLevel, targetObscureLevel);
          }
        }
        if (this._myParams.myPlayerTransformManager.isFloating()) {
          let distance5 = this._myParams.myPlayerTransformManager.getDistanceToReal();
          let relativeDistance = distance5 - this._myParams.myDistanceToStartObscureWhenFloating;
          if (relativeDistance >= 0) {
            let relativeDistancePercentage = Math.pp_clamp(relativeDistance / this._myParams.myRelativeDistanceToMaxObscureWhenFloating, 0, 1);
            let targetObscureLevel = this._myParams.myObscureLevelRelativeDistanceEasingFunction(relativeDistancePercentage);
            this._myTargetObscureLevel = Math.max(this._myTargetObscureLevel, targetObscureLevel);
          }
        }
        if (this._myParams.myPlayerTransformManager.isFar()) {
          let distance5 = this._myParams.myPlayerTransformManager.getDistanceToReal();
          let relativeDistance = distance5 - this._myParams.myDistanceToStartObscureWhenFar;
          if (relativeDistance >= 0) {
            let relativeDistancePercentage = Math.pp_clamp(relativeDistance / this._myParams.myRelativeDistanceToMaxObscureWhenFar, 0, 1);
            let targetObscureLevel = this._myParams.myObscureLevelRelativeDistanceEasingFunction(relativeDistancePercentage);
            this._myTargetObscureLevel = Math.max(this._myTargetObscureLevel, targetObscureLevel);
          }
        }
      }
    }
  }
  _setupVisuals() {
    this._myObscureMaterial = null;
    if (this._myParams.myObscureMaterial != null) {
      this._myObscureMaterial = this._myParams.myObscureMaterial;
    } else {
      this._myObscureMaterial = Globals.getDefaultMaterials(this._myParams.myEngine).myFlatTransparentNoDepth.clone();
      this._myObscureMaterial.color = vec4_create(0, 0, 0, 1);
    }
    this._myObscureParentObject = Globals.getPlayerObjects(this._myParams.myEngine).myCauldron.pp_addObject();
    let obscureVisualParams = new VisualMeshParams(this._myParams.myEngine);
    obscureVisualParams.myMesh = Globals.getDefaultMeshes(this._myParams.myEngine).myInvertedSphere;
    obscureVisualParams.myMaterial = this._myParams.myObscureMaterial != null ? this._myParams.myObscureMaterial : this._myObscureMaterial;
    obscureVisualParams.myParent = this._myObscureParentObject;
    obscureVisualParams.myLocal = true;
    obscureVisualParams.myTransform.mat4_setScale(vec3_create(this._myParams.myObscureRadius, this._myParams.myObscureRadius, this._myParams.myObscureRadius));
    this._myObscureVisual = new VisualMesh(obscureVisualParams);
    if (this._myParams.myObscureObject != null) {
      this._myParams.myObscureObject.pp_setParent(this._myObscureParentObject, false);
      this._myParams.myObscureObject.pp_resetTransformLocal();
    }
    this._setObscureVisible(false);
  }
  _setObscureVisible(visible) {
    if (this._myParams.myObscureObject == null) {
      this._myObscureVisual.setVisible(visible);
    } else {
      this._myObscureVisual.setVisible(false);
      this._myParams.myObscureObject.pp_setActive(visible);
    }
    if (visible) {
      this._myObscureParentObject.pp_setParent(this._myParams.myPlayerTransformManager.getHead(), false);
    } else {
      this._myObscureParentObject.pp_setParent(Globals.getPlayerObjects(this._myParams.myEngine)?.myCauldron, false);
    }
  }
  destroy() {
    this._myDestroyed = true;
    this._myObscureVisual.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_detection_visualizer.js
var PlayerLocomotionTeleportDetectionVisualizerParams = class {
  constructor() {
    this.myTeleportValidMaterial = null;
    this.myTeleportInvalidMaterial = null;
    this.myTeleportPositionObject = null;
    this.myTeleportPositionObjectRotateWithHead = true;
    this.myTeleportParableLineEndOffset = 0.05;
    this.myTeleportParableMinVerticalDistanceToShowVerticalLine = 0.8;
    this.myTeleportParableShowVerticalLineMaxLength = 0.3;
    this.myTeleportParablePositionUpOffset = 0.05;
    this.myTeleportParablePositionVisualAlignOnSurface = true;
    this.myVisualTeleportPositionLerpEnabled = true;
    this.myVisualTeleportPositionLerpFactor = 10;
    this.myVisualTeleportPositionMinDistanceToResetLerp = 5e-3;
    this.myVisualTeleportPositionMinDistanceToLerp = 0.15;
    this.myVisualTeleportPositionMaxDistanceToLerp = 5;
    this.myVisualTeleportPositionMinDistanceToCloseLerpFactor = 0.02;
    this.myVisualTeleportPositionCloseLerpFactor = 30;
    this.myVisualTeleportPositionMinAngleDistanceToResetLerp = 0.1;
    this.myVisualTeleportPositionMinAngleDistanceToLerp = 1;
    this.myVisualTeleportPositionMaxAngleDistanceToLerp = 180;
  }
};
var PlayerLocomotionTeleportDetectionVisualizer = class {
  constructor(teleportParams, teleportRuntimeParams, detectionRuntimeParams) {
    this._myDetectionRuntimeParams = detectionRuntimeParams;
    this._myTeleportParams = teleportParams;
    this._myTeleportRuntimeParams = teleportRuntimeParams;
    this._myVisualTeleportTransformQuatReset = true;
    this._myVisualTeleportTransformQuat = quat2_create();
    this._myVisualTeleportTransformPositionLerping = false;
    this._myVisualTeleportTransformRotationLerping = false;
    this._setupVisuals();
    this._myDestroyed = false;
  }
  start() {
  }
  end() {
    this._myVisualTeleportTransformQuatReset = true;
    this._myVisualTeleportTransformPositionLerping = false;
    this._myVisualTeleportTransformRotationLerping = false;
    this._hideTeleportPosition();
  }
  update(dt) {
    if (this._myDetectionRuntimeParams.myTeleportDetectionValid) {
      this._showTeleportPosition(dt);
    } else {
      this._myVisualTeleportTransformQuatReset = true;
      this._myVisualTeleportTransformPositionLerping = false;
      this._myVisualTeleportTransformRotationLerping = false;
      this._hideTeleportPosition();
    }
  }
  _showTeleportPosition(dt) {
    this._hideTeleportPosition();
    this._showTeleportParable(dt);
  }
  _hideTeleportPosition() {
    for (let visualLine of this._myValidVisualLines) {
      visualLine.setVisible(false);
    }
    for (let visualLine of this._myInvalidVisualLines) {
      visualLine.setVisible(false);
    }
    this._myValidVisualPoint.setVisible(false);
    this._myInvalidVisualPoint.setVisible(false);
    this._myValidVisualVerticalArrow.setVisible(false);
    this._myValidVisualTeleportPositionTorus.setVisible(false);
    this._myValidVisualTeleportPositionTorusInner.setVisible(false);
    if (this._myTeleportParams.myVisualizerParams.myTeleportPositionObject != null) {
      this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_setActive(false);
    }
  }
  _addVisualLines(amount) {
    for (let i = 0; i < amount; i++) {
      {
        let visualParams = new VisualLineParams(this._myTeleportParams.myEngine);
        if (this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial != null) {
          visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial;
        } else {
          visualParams.myMaterial = this._myTeleportValidMaterial;
        }
        this._myValidVisualLines.push(new VisualLine(visualParams));
      }
      {
        let visualParams = new VisualLineParams(this._myTeleportParams.myEngine);
        if (this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial != null) {
          visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportInvalidMaterial;
        } else {
          visualParams.myMaterial = this._myTeleportInvalidMaterial;
        }
        this._myInvalidVisualLines.push(new VisualLine(visualParams));
      }
    }
  }
  destroy() {
    this._myDestroyed = true;
    for (let visual of this._myValidVisualLines) {
      visual.destroy();
    }
    for (let visual of this._myInvalidVisualLines) {
      visual.destroy();
    }
    this._myValidVisualPoint.destroy();
    this._myInvalidVisualPoint.destroy();
    this._myValidVisualVerticalArrow.destroy();
    this._myValidVisualTeleportPositionTorus.destroy();
    this._myValidVisualTeleportPositionTorusInner.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
PlayerLocomotionTeleportDetectionVisualizer.prototype._setupVisuals = function() {
  let innerTorusPosition = vec3_create();
  return function _setupVisuals() {
    this._myTeleportValidMaterial = Globals.getDefaultMaterials(this._myTeleportParams.myEngine).myFlatOpaque.clone();
    this._myTeleportValidMaterial.color = vec4_create(0, 0.5, 1, 1);
    this._myTeleportInvalidMaterial = Globals.getDefaultMaterials(this._myTeleportParams.myEngine).myFlatOpaque.clone();
    this._myTeleportInvalidMaterial.color = vec4_create(0.75, 0.05, 0, 1);
    this._myValidVisualLines = [];
    this._myInvalidVisualLines = [];
    this._addVisualLines(30);
    {
      let visualParams = new VisualPointParams(this._myTeleportParams.myEngine);
      if (this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial != null) {
        visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial;
      } else {
        visualParams.myMaterial = this._myTeleportValidMaterial;
      }
      this._myValidVisualPoint = new VisualPoint(visualParams);
    }
    {
      let visualParams = new VisualPointParams(this._myTeleportParams.myEngine);
      if (this._myTeleportParams.myVisualizerParams.myTeleportInvalidMaterial != null) {
        visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportInvalidMaterial;
      } else {
        visualParams.myMaterial = this._myTeleportInvalidMaterial;
      }
      this._myInvalidVisualPoint = new VisualPoint(visualParams);
    }
    {
      let visualParams = new VisualArrowParams(this._myTeleportParams.myEngine);
      if (this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial != null) {
        visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial;
      } else {
        visualParams.myMaterial = this._myTeleportValidMaterial;
      }
      this._myValidVisualVerticalArrow = new VisualArrow(visualParams);
    }
    this._myVisualTeleportPositionObject = Globals.getPlayerObjects(this._myTeleportParams.myEngine).myCauldron.pp_addObject();
    {
      let visualParams = new VisualTorusParams(this._myTeleportParams.myEngine);
      visualParams.myRadius = 0.175;
      visualParams.mySegmentsAmount = 24;
      visualParams.mySegmentThickness = 0.02;
      if (this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial != null) {
        visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial;
      } else {
        visualParams.myMaterial = this._myTeleportValidMaterial;
      }
      visualParams.myParent = this._myVisualTeleportPositionObject;
      visualParams.myLocal = true;
      this._myValidVisualTeleportPositionTorus = new VisualTorus(visualParams);
    }
    {
      let visualParams = new VisualTorusParams(this._myTeleportParams.myEngine);
      visualParams.myRadius = 0.04;
      visualParams.mySegmentsAmount = 24;
      visualParams.mySegmentThickness = 0.02;
      if (this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial != null) {
        visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial;
      } else {
        visualParams.myMaterial = this._myTeleportValidMaterial;
      }
      visualParams.myParent = this._myVisualTeleportPositionObject;
      visualParams.myLocal = true;
      let visualTorusParams = this._myValidVisualTeleportPositionTorus.getParams();
      let innerTorusCenter = (visualTorusParams.myRadius - visualTorusParams.mySegmentThickness / 2) / 2;
      innerTorusPosition.vec3_set(0, 0, innerTorusCenter);
      visualParams.myTransform.mat4_setPosition(innerTorusPosition);
      this._myValidVisualTeleportPositionTorusInner = new VisualTorus(visualParams);
    }
    if (this._myTeleportParams.myVisualizerParams.myTeleportPositionObject != null) {
      this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_setParent(this._myVisualTeleportPositionObject);
      this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_resetTransformLocal();
      this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_setActive(false);
    }
    this._hideTeleportPosition();
  };
}();
PlayerLocomotionTeleportDetectionVisualizer.prototype._showTeleportParable = function() {
  let currentPosition = vec3_create();
  let nextPosition = vec3_create();
  let playerUp = vec3_create();
  let upDifference = vec3_create();
  return function _showTeleportParable(dt) {
    let showParableDistance = Math.max(this._myDetectionRuntimeParams.myParableDistance - this._myTeleportParams.myVisualizerParams.myTeleportParableLineEndOffset);
    let lastParableIndex = this._myDetectionRuntimeParams.myParable.getPositionIndexByDistance(showParableDistance);
    let lastParableIndexDistance = this._myDetectionRuntimeParams.myParable.getDistance(lastParableIndex);
    if (lastParableIndex + 1 > this._myValidVisualLines.length) {
      this._addVisualLines(lastParableIndex + 1, this._myValidVisualLines.length);
    }
    for (let i = 0; i <= lastParableIndex; i++) {
      currentPosition = this._myDetectionRuntimeParams.myParable.getPosition(i, currentPosition);
      nextPosition = this._myDetectionRuntimeParams.myParable.getPosition(i + 1, nextPosition);
      let visuaLine = this._myDetectionRuntimeParams.myTeleportPositionValid ? this._myValidVisualLines[i] : this._myInvalidVisualLines[i];
      let currentVisualLineParams = visuaLine.getParams();
      if (i == lastParableIndex) {
        let stepLength = Math.max(0, showParableDistance - lastParableIndexDistance);
        nextPosition = nextPosition.vec3_sub(currentPosition, nextPosition).vec3_normalize(nextPosition);
        nextPosition = currentPosition.vec3_add(nextPosition.vec3_scale(stepLength, nextPosition), nextPosition);
      }
      currentVisualLineParams.setStartEnd(currentPosition, nextPosition);
      currentVisualLineParams.myThickness = 5e-3;
      visuaLine.paramsUpdated();
      visuaLine.setVisible(true);
      if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugShowEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
        Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawPoint(0, currentPosition, vec4_create(1, 0, 0, 1), 0.01);
      }
    }
    let visualPoint = this._myDetectionRuntimeParams.myTeleportPositionValid ? this._myValidVisualPoint : this._myInvalidVisualPoint;
    let visualPointParams = visualPoint.getParams();
    visualPointParams.myPosition.vec3_copy(nextPosition);
    visualPointParams.myRadius = 0.01;
    visualPoint.paramsUpdated();
    visualPoint.setVisible(true);
    if (this._myDetectionRuntimeParams.myTeleportPositionValid) {
      playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
      upDifference = nextPosition.vec3_sub(this._myTeleportRuntimeParams.myTeleportPosition, upDifference).vec3_componentAlongAxis(playerUp, upDifference);
      let upDistance = upDifference.vec3_length();
      if (upDistance >= this._myTeleportParams.myVisualizerParams.myTeleportParableMinVerticalDistanceToShowVerticalLine) {
        let lineLength = Math.min(upDistance - this._myTeleportParams.myVisualizerParams.myTeleportParableMinVerticalDistanceToShowVerticalLine, this._myTeleportParams.myVisualizerParams.myTeleportParableShowVerticalLineMaxLength);
        let visualArrowParams = this._myValidVisualVerticalArrow.getParams();
        visualArrowParams.myStart.vec3_copy(nextPosition);
        visualArrowParams.myDirection = playerUp.vec3_negate(visualArrowParams.myDirection);
        visualArrowParams.myLength = lineLength;
        visualArrowParams.myThickness = 5e-3;
        visualArrowParams.myArrowThickness = visualPointParams.myRadius;
        visualArrowParams.myArrowLength = visualArrowParams.myArrowThickness * 3.5 / 1.5;
        this._myValidVisualVerticalArrow.paramsUpdated();
        this._myValidVisualVerticalArrow.setVisible(true);
      }
      this._showTeleportParablePosition(dt);
    } else {
      this._myVisualTeleportTransformQuatReset = true;
      this._myVisualTeleportTransformPositionLerping = false;
      this._myVisualTeleportTransformRotationLerping = false;
    }
  };
}();
PlayerLocomotionTeleportDetectionVisualizer.prototype._showTeleportParablePosition = function() {
  let playerUp = vec3_create();
  let feetTransformQuat = quat2_create();
  let feetRotationQuat = quat_create();
  let parableFirstPosition = vec3_create();
  let parableSecondPosition = vec3_create();
  let parableDirection = vec3_create();
  let visualPosition = vec3_create();
  let visualForward = vec3_create();
  let visualRotationQuat = quat_create();
  let currentVisualTeleportTransformQuat = quat2_create();
  let currentVisualTeleportPosition = vec3_create();
  let currentVisualTeleportRotationQuat = quat_create();
  let differenceRotationQuat = quat_create();
  return function _showTeleportParablePosition(dt) {
    playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    feetTransformQuat = this._myTeleportParams.myPlayerHeadManager.getTransformFeetQuat(feetTransformQuat);
    feetRotationQuat = feetTransformQuat.quat2_getRotationQuat(feetRotationQuat);
    feetRotationQuat = feetRotationQuat.quat_rotateAxis(this._myTeleportRuntimeParams.myTeleportRotationOnUp, playerUp, feetRotationQuat);
    visualPosition = this._myTeleportRuntimeParams.myTeleportPosition.vec3_add(playerUp.vec3_scale(this._myTeleportParams.myVisualizerParams.myTeleportParablePositionUpOffset, visualPosition), visualPosition);
    visualForward = feetRotationQuat.quat_getForward(visualForward);
    if (!this._myTeleportParams.myVisualizerParams.myTeleportPositionObjectRotateWithHead) {
      parableFirstPosition = this._myDetectionRuntimeParams.myParable.getPosition(0, parableFirstPosition);
      parableSecondPosition = this._myDetectionRuntimeParams.myParable.getPosition(1, parableSecondPosition);
      parableDirection = parableSecondPosition.vec3_sub(parableFirstPosition, parableDirection).vec3_removeComponentAlongAxis(playerUp, parableDirection);
      if (parableDirection.vec3_length() > Math.PP_EPSILON) {
        visualForward = parableDirection.vec3_normalize(visualForward);
      }
    }
    if (this._myTeleportParams.myVisualizerParams.myTeleportParablePositionVisualAlignOnSurface) {
      visualRotationQuat.quat_setUp(this._myDetectionRuntimeParams.myTeleportSurfaceNormal, visualForward);
    } else {
      visualRotationQuat.quat_setUp(playerUp, visualForward);
    }
    this._myVisualTeleportTransformQuat.quat2_setPositionRotationQuat(visualPosition, visualRotationQuat);
    if (this._myVisualTeleportTransformQuatReset || !this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionLerpEnabled) {
      this._myVisualTeleportPositionObject.pp_setTransformQuat(this._myVisualTeleportTransformQuat);
      this._myVisualTeleportTransformQuatReset = false;
    } else {
      currentVisualTeleportTransformQuat = this._myVisualTeleportPositionObject.pp_getTransformQuat(currentVisualTeleportTransformQuat);
      currentVisualTeleportPosition = currentVisualTeleportTransformQuat.quat2_getPosition(currentVisualTeleportPosition);
      currentVisualTeleportRotationQuat = currentVisualTeleportTransformQuat.quat2_getRotationQuat(currentVisualTeleportRotationQuat);
      currentVisualTeleportRotationQuat.quat_rotationToQuat(visualRotationQuat, differenceRotationQuat);
      let positionDistance = currentVisualTeleportPosition.vec3_distance(visualPosition);
      let rotationAngleDistance = differenceRotationQuat.quat_getAngle();
      if ((!this._myVisualTeleportTransformPositionLerping || positionDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinDistanceToResetLerp) && (positionDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinDistanceToLerp || positionDistance > this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMaxDistanceToLerp)) {
        this._myVisualTeleportTransformPositionLerping = false;
        currentVisualTeleportPosition.vec3_copy(visualPosition);
      } else {
        this._myVisualTeleportTransformPositionLerping = true;
        let interpolationFactor = this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionLerpFactor * dt;
        if (positionDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinDistanceToCloseLerpFactor) {
          interpolationFactor = this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionCloseLerpFactor * dt;
        }
        currentVisualTeleportPosition.vec3_lerp(visualPosition, interpolationFactor, currentVisualTeleportPosition);
      }
      if ((!this._myVisualTeleportTransformRotationLerping || rotationAngleDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinAngleDistanceToResetLerp) && (rotationAngleDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinAngleDistanceToLerp || positionDistance > this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMaxAngleDistanceToLerp)) {
        this._myVisualTeleportTransformRotationLerping = false;
        currentVisualTeleportRotationQuat.quat_copy(visualRotationQuat);
      } else {
        let interpolationFactor = this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionLerpFactor * dt;
        this._myVisualTeleportTransformRotationLerping = true;
        currentVisualTeleportRotationQuat.quat_slerp(visualRotationQuat, interpolationFactor, currentVisualTeleportRotationQuat);
      }
      currentVisualTeleportTransformQuat.quat2_setPositionRotationQuat(currentVisualTeleportPosition, currentVisualTeleportRotationQuat);
      this._myVisualTeleportPositionObject.pp_setTransformQuat(currentVisualTeleportTransformQuat);
    }
    {
      let visualParams = this._myValidVisualTeleportPositionTorus.getParams();
      visualParams.myRadius = 0.175;
      visualParams.mySegmentsAmount = 24;
      visualParams.mySegmentThickness = 0.02;
      this._myValidVisualTeleportPositionTorus.paramsUpdated();
    }
    {
      let visualParams = this._myValidVisualTeleportPositionTorusInner.getParams();
      visualParams.myRadius = 0.04;
      visualParams.mySegmentsAmount = 24;
      visualParams.mySegmentThickness = 0.02;
      this._myValidVisualTeleportPositionTorusInner.paramsUpdated();
    }
    if (this._myTeleportParams.myVisualizerParams.myTeleportPositionObject == null) {
      this._myValidVisualTeleportPositionTorus.setVisible(true);
      this._myValidVisualTeleportPositionTorusInner.setVisible(true);
    } else {
      this._myValidVisualTeleportPositionTorus.setVisible(false);
      this._myValidVisualTeleportPositionTorusInner.setVisible(false);
      this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_setActive(true);
    }
    if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugShowEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
      Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawPoint(0, this._myTeleportRuntimeParams.myTeleportPosition, vec4_create(0, 0, 1, 1), 0.02);
    }
  };
}();

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_parable.js
var PlayerLocomotionTeleportParable = class {
  constructor() {
    this._myStartPosition = vec3_create();
    this._myForward = vec3_create();
    this._myUp = vec3_create();
    this._mySpeed = 0;
    this._myGravity = 0;
    this._myStepLength = 0;
  }
  setStartPosition(startPosition) {
    this._myStartPosition.vec3_copy(startPosition);
  }
  setForward(forward) {
    this._myForward.vec3_copy(forward);
  }
  setUp(up) {
    this._myUp.vec3_copy(up);
  }
  setSpeed(speed) {
    this._mySpeed = speed;
  }
  setGravity(gravity) {
    this._myGravity = gravity;
  }
  setStepLength(stepLength) {
    this._myStepLength = stepLength;
  }
  getPosition(positionIndex, outPosition = vec3_create()) {
  }
  getDistance(positionIndex) {
  }
  getPositionIndexByDistance(distance5) {
  }
  getPositionByDistance(distance5, outPosition = vec3_create()) {
  }
  getDistanceOverFlatDistance(flatDistance, maxParableDistance) {
  }
  getFlatDistanceOverDistance(distance5) {
  }
};
PlayerLocomotionTeleportParable.prototype.getPosition = function() {
  let forwardPosition = vec3_create();
  let upPosition = vec3_create();
  return function getPosition4(positionIndex, outPosition = vec3_create()) {
    let deltaTimePerStep = this._myStepLength / this._mySpeed;
    let elapsedTime = deltaTimePerStep * positionIndex;
    forwardPosition = this._myForward.vec3_scale(this._mySpeed * elapsedTime, forwardPosition);
    forwardPosition = forwardPosition.vec3_add(this._myStartPosition, forwardPosition);
    upPosition = this._myUp.vec3_scale(this._myGravity * elapsedTime * elapsedTime / 2, upPosition);
    outPosition = forwardPosition.vec3_add(upPosition, outPosition);
    return outPosition;
  };
}();
PlayerLocomotionTeleportParable.prototype.getDistance = function() {
  let currentPosition = vec3_create();
  let prevPosition = vec3_create();
  return function getDistance(positionIndex) {
    let distance5 = 0;
    prevPosition.vec3_copy(this._myStartPosition);
    for (let i = 1; i <= positionIndex; i++) {
      currentPosition = this.getPosition(i, currentPosition);
      distance5 += currentPosition.vec3_distance(prevPosition);
      prevPosition.vec3_copy(currentPosition);
    }
    return distance5;
  };
}();
PlayerLocomotionTeleportParable.prototype.getPositionIndexByDistance = function() {
  let currentPosition = vec3_create();
  let prevPosition = vec3_create();
  return function getPositionIndexByDistance(distance5) {
    let currentDistance = 0;
    let currentIndex = 0;
    prevPosition = this.getPosition(currentIndex, prevPosition);
    while (currentDistance < distance5) {
      currentPosition = this.getPosition(currentIndex + 1, currentPosition);
      currentDistance += currentPosition.vec3_distance(prevPosition);
      currentIndex++;
      prevPosition.vec3_copy(currentPosition);
    }
    return Math.max(0, currentIndex - 1);
  };
}();
PlayerLocomotionTeleportParable.prototype.getPositionByDistance = function() {
  let currentPosition = vec3_create();
  let prevPosition = vec3_create();
  let prevToCurrent = vec3_create();
  return function getPositionByDistance(distance5, outPosition = vec3_create()) {
    let currentDistance = 0;
    let currentIndex = 0;
    let found = false;
    prevPosition = this.getPosition(currentIndex, prevPosition);
    while (!found) {
      currentPosition = this.getPosition(currentIndex + 1, currentPosition);
      currentDistance += currentPosition.vec3_distance(prevPosition);
      currentIndex++;
      if (currentDistance > distance5) {
        let lengthToRemove = currentDistance - distance5;
        prevToCurrent = currentPosition.vec3_sub(prevPosition, prevToCurrent);
        let lengthToAdd = prevToCurrent.vec3_length() - lengthToRemove;
        prevToCurrent.vec3_normalize(prevToCurrent);
        outPosition = prevPosition.vec3_add(prevToCurrent.vec3_scale(lengthToAdd, outPosition), outPosition);
        found = true;
      }
      prevPosition.vec3_copy(currentPosition);
    }
    return outPosition;
  };
}();
PlayerLocomotionTeleportParable.prototype.getDistanceOverFlatDistance = function() {
  let currentPosition = vec3_create();
  let flatCurrentPosition = vec3_create();
  let flatStartPosition = vec3_create();
  let prevPosition = vec3_create();
  let prevToCurrent = vec3_create();
  let startToCurrentFlat = vec3_create();
  return function getDistanceOverFlatDistance(flatDistance, maxParableDistance) {
    if (flatDistance < 1e-5) {
      return 0;
    }
    let currentDistance = 0;
    let currentIndex = 0;
    flatStartPosition = this._myStartPosition.vec3_removeComponentAlongAxis(this._myUp, flatStartPosition);
    prevPosition = this.getPosition(currentIndex, prevPosition);
    let distanceOverFlatDistance = 0;
    while (currentDistance <= maxParableDistance) {
      currentPosition = this.getPosition(currentIndex + 1, currentPosition);
      currentDistance += currentPosition.vec3_distance(prevPosition);
      currentIndex++;
      flatCurrentPosition = currentPosition.vec3_removeComponentAlongAxis(this._myUp, flatCurrentPosition);
      startToCurrentFlat = flatCurrentPosition.vec3_sub(flatStartPosition, startToCurrentFlat);
      let currentFlatDistance = startToCurrentFlat.vec3_length();
      if (currentFlatDistance >= flatDistance) {
        let flatDifference = currentFlatDistance - flatDistance;
        prevToCurrent = currentPosition.vec3_sub(prevPosition, prevToCurrent);
        let angleWithFlat = prevToCurrent.vec3_angleRadians(startToCurrentFlat);
        let cos = Math.cos(angleWithFlat);
        let lengthToRemove = prevToCurrent.vec3_length();
        if (cos != 0) {
          lengthToRemove = flatDifference / Math.cos(angleWithFlat);
        }
        distanceOverFlatDistance = currentDistance - lengthToRemove;
        break;
      } else {
        distanceOverFlatDistance = currentDistance;
      }
      prevPosition.vec3_copy(currentPosition);
    }
    return Math.min(maxParableDistance, distanceOverFlatDistance);
  };
}();
PlayerLocomotionTeleportParable.prototype.getFlatDistanceOverDistance = function() {
  let positionByDistance = vec3_create();
  let flatPositionByDistance = vec3_create();
  let flatStartPosition = vec3_create();
  return function getFlatDistanceOverDistance(distance5) {
    positionByDistance = this.getPositionByDistance(distance5, positionByDistance);
    flatPositionByDistance = positionByDistance.vec3_removeComponentAlongAxis(this._myUp, flatPositionByDistance);
    flatStartPosition = this._myStartPosition.vec3_removeComponentAlongAxis(this._myUp, flatStartPosition);
    return flatStartPosition.vec3_distance(flatPositionByDistance);
  };
}();

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_state.js
var PlayerLocomotionTeleportState = class extends State {
  constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
    super();
    this._myLocomotionRuntimeParams = locomotionRuntimeParams;
    this._myTeleportParams = teleportParams;
    this._myTeleportRuntimeParams = teleportRuntimeParams;
    this._myTeleportAsMovementFailed = false;
  }
};
PlayerLocomotionTeleportState.prototype._checkTeleport = function() {
  return function _checkTeleport(teleportPosition, feetTransformQuat, collisionRuntimeParams, checkTeleportCollisionRuntimeParams = null) {
    CollisionCheckBridge.getCollisionCheck(this._myTeleportParams.myEngine).teleport(teleportPosition, feetTransformQuat, this._myTeleportParams.myCollisionCheckParams, collisionRuntimeParams);
    if (checkTeleportCollisionRuntimeParams != null) {
      checkTeleportCollisionRuntimeParams.copy(collisionRuntimeParams);
    }
  };
}();
PlayerLocomotionTeleportState.prototype._checkTeleportAsMovement = function() {
  let checkTeleportMovementCollisionRuntimeParams = new CollisionRuntimeParams();
  let feetRotationQuat = quat_create();
  let feetPosition = vec3_create();
  let feetUp = vec3_create();
  let teleportFeetForward = vec3_create();
  let teleportFeetRotationQuat = quat_create();
  let teleportFeetTransformQuat = quat2_create();
  let currentFeetPosition = vec3_create();
  let fixedTeleportPosition = vec3_create();
  let teleportMovement = vec3_create();
  let extraVerticalMovement = vec3_create();
  let movementToTeleportPosition = vec3_create();
  let movementFeetTransformQuat = quat2_create();
  return function _checkTeleportAsMovement(teleportPosition, feetTransformQuat, collisionRuntimeParams, checkTeleportCollisionRuntimeParams) {
    feetPosition = feetTransformQuat.quat2_getPosition(feetPosition);
    feetRotationQuat = feetTransformQuat.quat2_getRotationQuat(feetRotationQuat);
    feetUp = feetRotationQuat.quat_getUp(feetUp);
    teleportFeetForward = teleportPosition.vec3_sub(feetPosition, teleportFeetForward).vec3_removeComponentAlongAxis(feetUp, teleportFeetForward);
    teleportFeetForward.vec3_normalize(teleportFeetForward);
    if (teleportFeetForward.vec3_isZero(1e-5)) {
      teleportFeetForward = feetRotationQuat.quat_getForward(teleportFeetForward);
    }
    teleportFeetRotationQuat.quat_setUp(feetUp, teleportFeetForward);
    teleportFeetTransformQuat.quat2_setPositionRotationQuat(feetPosition, teleportFeetRotationQuat);
    this._checkTeleport(teleportPosition, teleportFeetTransformQuat, collisionRuntimeParams, checkTeleportCollisionRuntimeParams);
    if (!collisionRuntimeParams.myTeleportCanceled) {
      let teleportMovementValid = false;
      checkTeleportMovementCollisionRuntimeParams.copy(collisionRuntimeParams);
      fixedTeleportPosition.vec3_copy(collisionRuntimeParams.myNewPosition);
      currentFeetPosition.vec3_copy(feetPosition);
      for (let i = 0; i < this._myTeleportParams.myTeleportAsMovementMaxSteps; i++) {
        teleportMovement = fixedTeleportPosition.vec3_sub(currentFeetPosition, teleportMovement);
        if (this._myTeleportParams.myTeleportAsMovementRemoveVerticalMovement) {
          teleportMovement = teleportMovement.vec3_removeComponentAlongAxis(feetUp, teleportMovement);
        }
        if (this._myTeleportParams.myTeleportAsMovementExtraVerticalMovementPerMeter != 0) {
          let meters = teleportMovement.vec3_length();
          let extraVerticalMovementValue = meters * this._myTeleportParams.myTeleportAsMovementExtraVerticalMovementPerMeter;
          extraVerticalMovement = feetUp.vec3_scale(extraVerticalMovementValue, extraVerticalMovement);
          teleportMovement = teleportMovement.vec3_add(extraVerticalMovement, teleportMovement);
        }
        movementFeetTransformQuat.quat2_setPositionRotationQuat(currentFeetPosition, feetRotationQuat);
        CollisionCheckBridge.getCollisionCheck(this._myTeleportParams.myEngine).move(teleportMovement, movementFeetTransformQuat, this._myTeleportParams.myCollisionCheckParams, checkTeleportMovementCollisionRuntimeParams);
        if (!checkTeleportMovementCollisionRuntimeParams.myHorizontalMovementCanceled && !checkTeleportMovementCollisionRuntimeParams.myVerticalMovementCanceled) {
          movementToTeleportPosition = fixedTeleportPosition.vec3_sub(checkTeleportMovementCollisionRuntimeParams.myNewPosition, movementToTeleportPosition);
          if (movementToTeleportPosition.vec3_length() < this._myTeleportParams.myTeleportAsMovementMaxDistanceFromTeleportPosition + 1e-5) {
            teleportMovementValid = true;
            break;
          } else {
            teleportMovement.vec3_copy(movementToTeleportPosition);
            currentFeetPosition.vec3_copy(checkTeleportMovementCollisionRuntimeParams.myNewPosition);
          }
        } else {
          break;
        }
      }
      if (!teleportMovementValid) {
        collisionRuntimeParams.myTeleportCanceled = true;
      }
      this._myTeleportAsMovementFailed = !teleportMovementValid;
    }
  };
}();
PlayerLocomotionTeleportState.prototype._teleportToPosition = function() {
  let playerUp = vec3_create();
  let feetTransformQuat = quat2_create();
  let newFeetTransformQuat = quat2_create();
  let newFeetRotationQuat = quat_create();
  let teleportRotation = quat_create();
  return function _teleportToPosition(teleportPosition, rotationOnUp, collisionRuntimeParams, forceTeleport = false) {
    this._myTeleportAsMovementFailed = false;
    playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    feetTransformQuat = this._myTeleportParams.myPlayerHeadManager.getTransformFeetQuat(feetTransformQuat);
    newFeetRotationQuat = feetTransformQuat.quat2_getRotationQuat(newFeetRotationQuat);
    if (rotationOnUp != 0) {
      newFeetRotationQuat = newFeetRotationQuat.quat_rotateAxis(rotationOnUp, playerUp, newFeetRotationQuat);
    }
    newFeetTransformQuat.quat2_setPositionRotationQuat(teleportPosition, newFeetRotationQuat);
    if (Globals.getGamepads(this._myTeleportParams.myEngine)[InputUtils.getOppositeHandedness(this._myTeleportParams.myHandedness)].getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).isPressed()) {
      CollisionCheckBridge.getCollisionCheck(this._myTeleportParams.myEngine).positionCheck(true, newFeetTransformQuat, this._myTeleportParams.myCollisionCheckParams, collisionRuntimeParams);
      this._myTeleportParams.myPlayerHeadManager.teleportPositionFeet(teleportPosition);
      if (rotationOnUp != 0) {
        teleportRotation.quat_fromAxis(rotationOnUp, playerUp);
        this._myTeleportParams.myPlayerHeadManager.rotateFeetQuat(teleportRotation);
      }
    } else {
      this._myTeleportParams.myPlayerTransformManager.teleportTransformQuat(newFeetTransformQuat, collisionRuntimeParams, forceTeleport);
    }
  };
}();

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_detection_state.js
var PlayerLocomotionTeleportDetectionParams = class {
  constructor() {
    this.myMaxDistance = 0;
    this.myMaxHeightDifference = 0;
    this.myGroundAngleToIgnoreUpward = 0;
    this.myMustBeOnGround = false;
    this.myTeleportBlockLayerFlags = new PhysicsLayerFlags();
    this.myTeleportFloorLayerFlags = new PhysicsLayerFlags();
    this.myParableForwardMinAngleToBeValidUp = 30;
    this.myParableForwardMinAngleToBeValidDown = 0;
    this.myTeleportParableStartReferenceObject = null;
    this.myTeleportParableStartPositionOffset = vec3_create(0, -0.04, 0.08);
    this.myTeleportParableStartRotationOffset = vec3_create(30, 0, 0);
    this.myTeleportParableSpeed = 15;
    this.myTeleportParableGravity = -30;
    this.myTeleportParableStepLength = 0.25;
    this.myRotationOnUpMinStickIntensity = 0.5;
    this.myRotationOnUpEnabled = false;
    this.myTeleportFeetPositionMustBeVisible = false;
    this.myTeleportHeadPositionMustBeVisible = false;
    this.myTeleportHeadOrFeetPositionMustBeVisible = false;
    this.myVisibilityCheckRadius = 0.05;
    this.myVisibilityCheckFeetPositionVerticalOffset = 0.1;
    this.myVisibilityCheckDistanceFromHitThreshold = 0.1;
    this.myVisibilityCheckCircumferenceSliceAmount = 6;
    this.myVisibilityCheckCircumferenceStepAmount = 1;
    this.myVisibilityCheckCircumferenceRotationPerStep = 30;
    this.myVisibilityBlockLayerFlags = new PhysicsLayerFlags();
  }
};
var PlayerLocomotionTeleportDetectionRuntimeParams = class {
  constructor() {
    this.myTeleportDetectionValid = false;
    this.myTeleportPositionValid = false;
    this.myTeleportSurfaceNormal = vec3_create();
    this.myParable = new PlayerLocomotionTeleportParable();
  }
};
var PlayerLocomotionTeleportDetectionState = class extends PlayerLocomotionTeleportState {
  constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
    super(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myDetectionRuntimeParams = new PlayerLocomotionTeleportDetectionRuntimeParams();
    this._myVisualizer = new PlayerLocomotionTeleportDetectionVisualizer(this._myTeleportParams, this._myTeleportRuntimeParams, this._myDetectionRuntimeParams);
    this._myTeleportRotationOnUpNext = 0;
    this._myDestroyed = false;
  }
  start() {
    this._myLocomotionRuntimeParams.myIsTeleportDetecting = true;
    this._myTeleportRuntimeParams.myTeleportRotationOnUp = 0;
    this._myTeleportRotationOnUpNext = 0;
    this._myDetectionRuntimeParams.myParable.setSpeed(this._myTeleportParams.myDetectionParams.myTeleportParableSpeed);
    this._myDetectionRuntimeParams.myParable.setGravity(this._myTeleportParams.myDetectionParams.myTeleportParableGravity);
    this._myDetectionRuntimeParams.myParable.setStepLength(this._myTeleportParams.myDetectionParams.myTeleportParableStepLength);
    this._myTeleportParams.myPlayerTransformManager.resetReal();
    this._myVisualizer.start();
  }
  end() {
    this._myLocomotionRuntimeParams.myIsTeleportDetecting = false;
    this._myVisualizer.end();
  }
  update(dt, fsm) {
    this._detectTeleportPosition();
    this._myVisualizer.update(dt);
    if (this._confirmTeleport()) {
      if (this._myDetectionRuntimeParams.myTeleportPositionValid) {
        fsm.perform("teleport");
      } else {
        fsm.perform("cancel");
      }
    } else if (this._cancelTeleport()) {
      fsm.perform("cancel");
    }
  }
  _confirmTeleport() {
    let confirmTeleport = false;
    if (!XRUtils.isSessionActive(this._myTeleportParams.myEngine)) {
      if (Globals.getMouse(this._myTeleportParams.myEngine).isInsideView()) {
        confirmTeleport = Globals.getMouse(this._myTeleportParams.myEngine).isButtonPressEnd(MouseButtonID.MIDDLE);
      }
    } else {
      let axes = Globals.getGamepads(this._myTeleportParams.myEngine)[this._myTeleportParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
      if (axes.vec2_length() <= this._myTeleportParams.myStickIdleThreshold) {
        confirmTeleport = true;
      }
    }
    return confirmTeleport;
  }
  _cancelTeleport() {
    let cancelTeleport = false;
    if (!XRUtils.isSessionActive(this._myTeleportParams.myEngine)) {
      cancelTeleport = Globals.getMouse(this._myTeleportParams.myEngine).isButtonPressEnd(MouseButtonID.RIGHT) || !Globals.getMouse(this._myTeleportParams.myEngine).isInsideView();
    } else {
      cancelTeleport = Globals.getGamepads(this._myTeleportParams.myEngine)[this._myTeleportParams.myHandedness].getButtonInfo(GamepadButtonID.THUMBSTICK).isPressed();
    }
    return cancelTeleport;
  }
  _detectTeleportPosition() {
    if (XRUtils.isSessionActive(this._myTeleportParams.myEngine)) {
      this._detectTeleportRotationVR();
      this._detectTeleportPositionVR();
    } else {
      this._myTeleportRuntimeParams.myTeleportRotationOnUp = 0;
      this._myTeleportRotationOnUpNext = 0;
      this._detectTeleportPositionNonVR();
    }
  }
  destroy() {
    this._myDestroyed = true;
    this._myVisualizer.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
PlayerLocomotionTeleportDetectionState.prototype._detectTeleportPositionNonVR = function() {
  let mousePosition = vec3_create();
  let mouseDirection = vec3_create();
  let playerUp = vec3_create();
  return function _detectTeleportPositionNonVR(dt) {
    this._myDetectionRuntimeParams.myTeleportPositionValid = false;
    this._myDetectionRuntimeParams.myTeleportDetectionValid = true;
    playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    Globals.getMouse(this._myTeleportParams.myEngine).getOriginWorld(mousePosition);
    Globals.getMouse(this._myTeleportParams.myEngine).getDirectionWorld(mouseDirection);
    this._detectTeleportPositionParable(mousePosition, mouseDirection, playerUp);
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._detectTeleportPositionVR = function() {
  let teleportStartTransformLocal = quat2_create();
  let teleportStartTransformWorld = quat2_create();
  let teleportStartPosition = vec3_create();
  let teleportDirection = vec3_create();
  let playerUp = vec3_create();
  let playerUpNegate = vec3_create();
  return function _detectTeleportPositionVR(dt) {
    this._myDetectionRuntimeParams.myTeleportPositionValid = false;
    this._myDetectionRuntimeParams.myTeleportDetectionValid = false;
    if (this._myTeleportParams.myDetectionParams.myTeleportParableStartReferenceObject == null) {
      let referenceObject = Globals.getPlayerObjects(this._myTeleportParams.myEngine).myHands[this._myTeleportParams.myHandedness];
      teleportStartTransformLocal.quat2_setPositionRotationDegrees(this._myTeleportParams.myDetectionParams.myTeleportParableStartPositionOffset, this._myTeleportParams.myDetectionParams.myTeleportParableStartRotationOffset);
      teleportStartTransformWorld = referenceObject.pp_convertTransformObjectToWorldQuat(teleportStartTransformLocal, teleportStartTransformWorld);
    } else {
      let referenceObject = this._myTeleportParams.myDetectionParams.myTeleportParableStartReferenceObject;
      referenceObject.pp_getTransformQuat(teleportStartTransformWorld);
    }
    teleportStartPosition = teleportStartTransformWorld.quat2_getPosition(teleportStartPosition);
    teleportDirection = teleportStartTransformWorld.quat2_getForward(teleportDirection);
    playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    playerUpNegate = playerUp.vec3_negate(playerUpNegate);
    if (teleportDirection.vec3_angle(playerUp) >= this._myTeleportParams.myDetectionParams.myParableForwardMinAngleToBeValidUp && teleportDirection.vec3_angle(playerUpNegate) >= this._myTeleportParams.myDetectionParams.myParableForwardMinAngleToBeValidDown) {
      this._myDetectionRuntimeParams.myTeleportDetectionValid = true;
    }
    if (this._myDetectionRuntimeParams.myTeleportDetectionValid) {
      this._detectTeleportPositionParable(teleportStartPosition, teleportDirection, playerUp);
    }
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._detectTeleportPositionParable = function() {
  let parablePosition = vec3_create();
  let prevParablePosition = vec3_create();
  let parableFinalPosition = vec3_create();
  let raycastParams = new RaycastParams();
  let raycastResult = new RaycastResults();
  let parableHitPosition = vec3_create();
  let parableHitNormal = vec3_create();
  let verticalHitOrigin = vec3_create();
  let verticalHitDirection = vec3_create();
  let flatTeleportHorizontalHitNormal = vec3_create();
  let flatParableHitNormal = vec3_create();
  let flatParableDirectionNegate = vec3_create();
  let teleportCollisionRuntimeParams = new CollisionRuntimeParams();
  let objectsEqualCallback = (first2, second) => first2.pp_equals(second);
  return function _detectTeleportPositionParable(startPosition, direction2, up) {
    this._myDetectionRuntimeParams.myParable.setStartPosition(startPosition);
    this._myDetectionRuntimeParams.myParable.setForward(direction2);
    this._myDetectionRuntimeParams.myParable.setUp(up);
    let currentPositionIndex = 1;
    let positionFlatDistance = 0;
    let positionParableDistance = 0;
    prevParablePosition = this._myDetectionRuntimeParams.myParable.getPosition(currentPositionIndex - 1, prevParablePosition);
    raycastParams.myIgnoreHitsInsideCollision = true;
    raycastParams.myBlockLayerFlags.setMask(this._myTeleportParams.myDetectionParams.myTeleportBlockLayerFlags.getMask());
    raycastParams.myPhysics = Globals.getPhysics(this._myTeleportParams.myEngine);
    raycastParams.myObjectsToIgnore.pp_copy(this._myTeleportParams.myCollisionCheckParams.myHorizontalObjectsToIgnore);
    for (let objectToIgnore of this._myTeleportParams.myCollisionCheckParams.myVerticalObjectsToIgnore) {
      raycastParams.myObjectsToIgnore.pp_pushUnique(objectToIgnore, objectsEqualCallback);
    }
    let maxParableDistance = this._myTeleportParams.myDetectionParams.myMaxDistance * 2;
    do {
      parablePosition = this._myDetectionRuntimeParams.myParable.getPosition(currentPositionIndex, parablePosition);
      raycastParams.myOrigin.vec3_copy(prevParablePosition);
      raycastParams.myDirection = parablePosition.vec3_sub(prevParablePosition, raycastParams.myDirection);
      raycastParams.myDistance = raycastParams.myDirection.vec3_length();
      raycastParams.myDirection.vec3_normalize(raycastParams.myDirection);
      raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
      if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
        Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
      }
      prevParablePosition.vec3_copy(parablePosition);
      positionFlatDistance = parablePosition.vec3_sub(startPosition, parablePosition).vec3_removeComponentAlongAxis(up, parablePosition).vec3_length();
      positionParableDistance = this._myDetectionRuntimeParams.myParable.getDistance(currentPositionIndex);
      currentPositionIndex++;
    } while (positionFlatDistance <= this._myTeleportParams.myDetectionParams.myMaxDistance && positionParableDistance <= maxParableDistance && !raycastResult.isColliding());
    let maxParableDistanceOverFlatDistance = this._myDetectionRuntimeParams.myParable.getDistanceOverFlatDistance(this._myTeleportParams.myDetectionParams.myMaxDistance, maxParableDistance);
    let fixedPositionParableDistance = positionParableDistance;
    if (positionParableDistance > maxParableDistanceOverFlatDistance || positionParableDistance > maxParableDistance) {
      fixedPositionParableDistance = Math.min(maxParableDistanceOverFlatDistance, maxParableDistance);
    }
    this._myDetectionRuntimeParams.myParableDistance = fixedPositionParableDistance;
    let hitCollisionValid = false;
    let bottomCheckMaxLength = 100;
    if (raycastResult.isColliding()) {
      let hit = raycastResult.myHits.pp_first();
      let hitParableDistance = positionParableDistance - (raycastParams.myDistance - hit.myDistance);
      if (hitParableDistance <= fixedPositionParableDistance) {
        hitCollisionValid = true;
        this._myDetectionRuntimeParams.myParableDistance = hitParableDistance;
        teleportCollisionRuntimeParams.reset();
        this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
        this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
        this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
        parableHitPosition.vec3_copy(hit.myPosition);
        parableHitNormal.vec3_copy(hit.myNormal);
        if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed) {
          verticalHitOrigin = hit.myPosition.vec3_add(hit.myNormal.vec3_scale(0.01, verticalHitOrigin), verticalHitOrigin);
          verticalHitDirection = up.vec3_negate(verticalHitDirection);
          raycastParams.myOrigin.vec3_copy(verticalHitOrigin);
          raycastParams.myDirection.vec3_copy(verticalHitDirection);
          raycastParams.myDistance = bottomCheckMaxLength;
          raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
          if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
            Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
          }
          if (raycastResult.isColliding()) {
            let hit2 = raycastResult.myHits.pp_first();
            teleportCollisionRuntimeParams.reset();
            this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit2, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
            this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
            this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
            if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed && teleportCollisionRuntimeParams.myTeleportCanceled && teleportCollisionRuntimeParams.myIsCollidingHorizontally) {
              flatTeleportHorizontalHitNormal = teleportCollisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_removeComponentAlongAxis(up, flatTeleportHorizontalHitNormal);
              if (!flatTeleportHorizontalHitNormal.vec3_isZero(1e-5)) {
                flatTeleportHorizontalHitNormal.vec3_normalize(flatTeleportHorizontalHitNormal);
                let backwardStep = this._myTeleportParams.myCollisionCheckParams.myRadius * 1.1;
                raycastParams.myOrigin = verticalHitOrigin.vec3_add(flatTeleportHorizontalHitNormal.vec3_scale(backwardStep, raycastParams.myOrigin), raycastParams.myOrigin);
                raycastParams.myDirection.vec3_copy(verticalHitDirection);
                raycastParams.myDistance = bottomCheckMaxLength;
                raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
                if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
                  Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawPoint(0, raycastParams.myOrigin, vec4_create(0, 0, 0, 1), 0.03);
                  Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
                }
                if (raycastResult.isColliding()) {
                  let hit3 = raycastResult.myHits.pp_first();
                  teleportCollisionRuntimeParams.reset();
                  this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit3, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
                  this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
                  this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
                }
              }
            } else {
            }
            if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed) {
              flatParableHitNormal = parableHitNormal.vec3_removeComponentAlongAxis(up, flatParableHitNormal);
              if (!flatParableHitNormal.vec3_isZero(1e-5)) {
                flatParableHitNormal.vec3_normalize(flatParableHitNormal);
                let backwardStep = this._myTeleportParams.myCollisionCheckParams.myRadius * 1.1;
                raycastParams.myOrigin = verticalHitOrigin.vec3_add(flatParableHitNormal.vec3_scale(backwardStep, raycastParams.myOrigin), raycastParams.myOrigin);
                raycastParams.myDirection.vec3_copy(verticalHitDirection);
                raycastParams.myDistance = bottomCheckMaxLength;
                raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
                if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
                  Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawPoint(0, raycastParams.myOrigin, vec4_create(0, 0, 0, 1), 0.03);
                  Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
                }
                if (raycastResult.isColliding()) {
                  let hit3 = raycastResult.myHits.pp_first();
                  teleportCollisionRuntimeParams.reset();
                  this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit3, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
                  this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
                  this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
                }
              }
            } else {
            }
            if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed) {
              flatParableDirectionNegate = direction2.vec3_negate(flatParableDirectionNegate).vec3_removeComponentAlongAxis(up, flatParableDirectionNegate).vec3_normalize(flatParableDirectionNegate);
              if (!flatParableDirectionNegate.vec3_isZero(1e-5)) {
                flatParableDirectionNegate.vec3_normalize(flatParableDirectionNegate);
                let backwardStep = this._myTeleportParams.myCollisionCheckParams.myRadius * 1.1;
                raycastParams.myOrigin = verticalHitOrigin.vec3_add(flatParableDirectionNegate.vec3_scale(backwardStep, raycastParams.myOrigin), raycastParams.myOrigin);
                raycastParams.myDirection.vec3_copy(verticalHitDirection);
                raycastParams.myDistance = bottomCheckMaxLength;
                raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
                if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
                  Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawPoint(0, raycastParams.myOrigin, vec4_create(0, 0, 0, 1), 0.03);
                  Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
                }
                if (raycastResult.isColliding()) {
                  let hit3 = raycastResult.myHits.pp_first();
                  teleportCollisionRuntimeParams.reset();
                  this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit3, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
                  this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
                  this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
                }
              }
            } else {
            }
          }
        } else {
        }
      }
    }
    if (!hitCollisionValid) {
      parableFinalPosition = this._myDetectionRuntimeParams.myParable.getPositionByDistance(this._myDetectionRuntimeParams.myParableDistance, parableFinalPosition);
      verticalHitOrigin.vec3_copy(parableFinalPosition);
      verticalHitDirection = up.vec3_negate(verticalHitDirection);
      raycastParams.myOrigin.vec3_copy(verticalHitOrigin);
      raycastParams.myDirection.vec3_copy(verticalHitDirection);
      raycastParams.myDistance = bottomCheckMaxLength;
      raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
      if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
        Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
      }
      if (raycastResult.isColliding()) {
        let hit = raycastResult.myHits.pp_first();
        teleportCollisionRuntimeParams.reset();
        this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
        this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
        this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
        if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed && teleportCollisionRuntimeParams.myTeleportCanceled && teleportCollisionRuntimeParams.myIsCollidingHorizontally) {
          flatTeleportHorizontalHitNormal = teleportCollisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_removeComponentAlongAxis(up, flatTeleportHorizontalHitNormal);
          if (!flatTeleportHorizontalHitNormal.vec3_isZero(1e-5)) {
            flatTeleportHorizontalHitNormal.vec3_normalize(flatTeleportHorizontalHitNormal);
            let backwardStep = this._myTeleportParams.myCollisionCheckParams.myRadius * 1.1;
            raycastParams.myOrigin = verticalHitOrigin.vec3_add(flatTeleportHorizontalHitNormal.vec3_scale(backwardStep, raycastParams.myOrigin), raycastParams.myOrigin);
            raycastParams.myDirection.vec3_copy(verticalHitDirection);
            raycastParams.myDistance = bottomCheckMaxLength;
            raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
            if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
              Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawPoint(0, raycastParams.myOrigin, vec4_create(0, 0, 0, 1), 0.03);
              Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
            }
            if (raycastResult.isColliding()) {
              let hit2 = raycastResult.myHits.pp_first();
              teleportCollisionRuntimeParams.reset();
              this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit2, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
              this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
              this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
            }
          }
        }
        if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed) {
          flatParableDirectionNegate = direction2.vec3_negate(flatParableDirectionNegate).vec3_removeComponentAlongAxis(up, flatParableDirectionNegate).vec3_normalize(flatParableDirectionNegate);
          if (!flatParableDirectionNegate.vec3_isZero(1e-5)) {
            flatParableDirectionNegate.vec3_normalize(flatParableDirectionNegate);
            let backwardStep = this._myTeleportParams.myCollisionCheckParams.myRadius * 1.1;
            raycastParams.myOrigin = verticalHitOrigin.vec3_add(flatParableDirectionNegate.vec3_scale(backwardStep, raycastParams.myOrigin), raycastParams.myOrigin);
            raycastParams.myDirection.vec3_copy(verticalHitDirection);
            raycastParams.myDistance = bottomCheckMaxLength;
            raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
            if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
              Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawPoint(0, raycastParams.myOrigin, vec4_create(0, 0, 0, 1), 0.03);
              Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
            }
            if (raycastResult.isColliding()) {
              let hit2 = raycastResult.myHits.pp_first();
              teleportCollisionRuntimeParams.reset();
              this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit2, this._myTeleportRuntimeParams.myTeleportRotationOnUp, teleportCollisionRuntimeParams);
              this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
              this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
            }
          }
        }
      }
    }
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._detectTeleportRotationVR = function() {
  let axesVec3 = vec3_create();
  let axesForward = vec3_create(0, 0, 1);
  let axesUp = vec3_create(0, 1, 0);
  return function _detectTeleportRotationVR(dt) {
    let axes = Globals.getGamepads(this._myTeleportParams.myEngine)[this._myTeleportParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
    if (axes.vec2_length() > this._myTeleportParams.myDetectionParams.myRotationOnUpMinStickIntensity) {
      this._myTeleportRuntimeParams.myTeleportRotationOnUp = this._myTeleportRotationOnUpNext;
      axesVec3.vec3_set(axes[0], 0, axes[1]);
      this._myTeleportRotationOnUpNext = axesVec3.vec3_angleSigned(axesForward, axesUp);
    }
    if (!this._myTeleportParams.myDetectionParams.myRotationOnUpEnabled) {
      this._myTeleportRuntimeParams.myTeleportRotationOnUp = 0;
      this._myTeleportRotationOnUpNext = 0;
    }
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._isTeleportHitValid = function() {
  let raycastParams = new RaycastParams();
  let raycastResult = new RaycastResults();
  let playerUp = vec3_create();
  let objectsEqualCallback = (first2, second) => first2.pp_equals(second);
  return function _isTeleportHitValid(hit, rotationOnUp, checkTeleportCollisionRuntimeParams) {
    let isValid = false;
    this._myTeleportAsMovementFailed = false;
    if (hit.isValid() && !hit.myInsideCollision) {
      playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
      let hitValidEvenWhenNotConcordant = true;
      if (hit.myNormal.vec3_isConcordant(playerUp) || hitValidEvenWhenNotConcordant) {
        raycastParams.myIgnoreHitsInsideCollision = true;
        raycastParams.myBlockLayerFlags.setMask(this._myTeleportParams.myDetectionParams.myTeleportFloorLayerFlags.getMask());
        raycastParams.myPhysics = Globals.getPhysics(this._myTeleportParams.myEngine);
        raycastParams.myObjectsToIgnore.pp_copy(this._myTeleportParams.myCollisionCheckParams.myHorizontalObjectsToIgnore);
        for (let objectToIgnore of this._myTeleportParams.myCollisionCheckParams.myVerticalObjectsToIgnore) {
          raycastParams.myObjectsToIgnore.pp_pushUnique(objectToIgnore, objectsEqualCallback);
        }
        let distanceToCheck = 0.01;
        raycastParams.myOrigin = hit.myPosition.vec3_add(hit.myNormal.vec3_scale(distanceToCheck, raycastParams.myOrigin), raycastParams.myOrigin);
        raycastParams.myDirection = hit.myNormal.vec3_negate(raycastParams.myDirection);
        raycastParams.myDistance = distanceToCheck * 1.25;
        raycastParams.myDirection.vec3_normalize(raycastParams.myDirection);
        raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
        if (raycastResult.isColliding()) {
          let floorHit = raycastResult.myHits.pp_first();
          if (floorHit.myObject.pp_equals(hit.myObject)) {
            isValid = this._isTeleportPositionValid(hit.myPosition, rotationOnUp, checkTeleportCollisionRuntimeParams);
          }
        }
      }
    }
    return isValid;
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._isTeleportPositionValid = function() {
  let playerUp = vec3_create();
  let feetTransformQuat = quat2_create();
  let feetRotationQuat = quat_create();
  let feetPosition = vec3_create();
  let differenceOnUpVector = vec3_create();
  let teleportCheckCollisionRuntimeParams = new CollisionRuntimeParams();
  return function _isTeleportPositionValid(teleportPosition, rotationOnUp, checkTeleportCollisionRuntimeParams) {
    let isValid = false;
    let positionVisible = this._isTeleportPositionVisible(teleportPosition);
    if (positionVisible) {
      playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
      feetTransformQuat = this._myTeleportParams.myPlayerHeadManager.getTransformFeetQuat(feetTransformQuat);
      feetPosition = feetTransformQuat.quat2_getPosition(feetPosition);
      if (rotationOnUp != 0) {
        feetRotationQuat = feetTransformQuat.quat2_getRotationQuat(feetRotationQuat);
        feetRotationQuat = feetRotationQuat.quat_rotateAxis(rotationOnUp, playerUp, feetRotationQuat);
        feetTransformQuat.quat2_setPositionRotationQuat(feetPosition, feetRotationQuat);
      }
      let differenceOnUp = teleportPosition.vec3_sub(feetPosition, differenceOnUpVector).vec3_componentAlongAxis(playerUp, differenceOnUpVector).vec3_length();
      if (differenceOnUp < this._myTeleportParams.myDetectionParams.myMaxHeightDifference + 1e-5) {
        let teleportCheckValid = false;
        teleportCheckCollisionRuntimeParams.copy(this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
        if (!this._myTeleportParams.myPerformTeleportAsMovement) {
          this._checkTeleport(teleportPosition, feetTransformQuat, teleportCheckCollisionRuntimeParams, checkTeleportCollisionRuntimeParams);
        } else {
          this._checkTeleportAsMovement(teleportPosition, feetTransformQuat, teleportCheckCollisionRuntimeParams, checkTeleportCollisionRuntimeParams);
        }
        if (!teleportCheckCollisionRuntimeParams.myTeleportCanceled) {
          teleportCheckValid = true;
        }
        if (teleportCheckValid && (!this._myTeleportParams.myDetectionParams.myMustBeOnGround || teleportCheckCollisionRuntimeParams.myIsOnGround)) {
          let groundAngleValid = true;
          let isTeleportingUpward = teleportCheckCollisionRuntimeParams.myNewPosition.vec3_isFartherAlongAxis(feetPosition, playerUp);
          if (isTeleportingUpward) {
            groundAngleValid = teleportCheckCollisionRuntimeParams.myGroundAngle < this._myTeleportParams.myDetectionParams.myGroundAngleToIgnoreUpward + 1e-4;
          }
          if (groundAngleValid) {
            isValid = true;
          }
        }
      }
    }
    return isValid;
  };
}();

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_teleport_blink_state.js
var PlayerLocomotionTeleportTeleportBlinkState = class extends PlayerLocomotionTeleportState {
  constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
    super(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myBlinkSphere = Globals.getPlayerObjects(this._myTeleportParams.myEngine).myCauldron.pp_addObject();
    this._myBlinkSphereMeshComponent = this._myBlinkSphere.pp_addComponent(MeshComponent);
    this._myBlinkSphereMeshComponent.mesh = Globals.getDefaultMeshes(this._myTeleportParams.myEngine).myInvertedSphere;
    this._myBlinkSphereMeshComponent.material = Globals.getDefaultMaterials(this._myTeleportParams.myEngine).myFlatTransparentNoDepth.clone();
    this._myBlinkSphereMaterialColor = vec4_create(
      this._myTeleportParams.myTeleportParams.myBlinkSphereColor[0] / 255,
      this._myTeleportParams.myTeleportParams.myBlinkSphereColor[1] / 255,
      this._myTeleportParams.myTeleportParams.myBlinkSphereColor[2] / 255,
      0
    );
    this._myBlinkSphereMeshComponent.material.color = this._myBlinkSphereMaterialColor;
    this._myBlinkSphere.pp_resetTransformLocal();
    this._myBlinkSphere.pp_setScaleLocal(this._myTeleportParams.myTeleportParams.myBlinkSphereScale);
    this._myBlinkSphere.pp_setActive(false);
    this._myFSM = new FSM();
    this._myFSM.addState("init");
    this._myFSM.addState("idle");
    this._myFSM.addState("fade_out", this._fadeOutUpdate.bind(this));
    this._myFSM.addState("wait", new TimerState(this._myTeleportParams.myTeleportParams.myBlinkWaitSeconds, "done"));
    this._myFSM.addState("fade_in", this._fadeInUpdate.bind(this));
    this._myFSM.addTransition("init", "idle", "start");
    this._myFSM.addTransition("idle", "fade_out", "teleport", this._startFadeOut.bind(this));
    this._myFSM.addTransition("fade_out", "wait", "done", this._teleport.bind(this));
    this._myFSM.addTransition("wait", "fade_in", "done", this._startFadeIn.bind(this));
    this._myFSM.addTransition("fade_in", "idle", "done", this._teleportDone.bind(this));
    this._myFSM.addTransition("idle", "idle", "stop");
    this._myFSM.addTransition("fade_out", "idle", "stop", this._stop.bind(this, true));
    this._myFSM.addTransition("wait", "idle", "stop", this._stop.bind(this, false));
    this._myFSM.addTransition("fade_in", "idle", "stop", this._stop.bind(this, false));
    this._myFSM.init("init");
    this._myFSM.perform("start");
    this._myFadeInTimer = new Timer(this._myTeleportParams.myTeleportParams.myBlinkFadeInSeconds);
    this._myFadeOutTimer = new Timer(this._myTeleportParams.myTeleportParams.myBlinkFadeOutSeconds);
    this._myFadeOutAlphaOverTime = new NumberOverFactor(0, 1, 0, 1);
    this._myFadeInAlphaOverTime = new NumberOverFactor(1, 0, 0, 1);
  }
  start(fsm) {
    this._myParentFSM = fsm;
    this._myFSM.perform("teleport");
  }
  end() {
    this._myBlinkSphere.pp_setActive(false);
    this._myBlinkSphere.pp_setParent(Globals.getPlayerObjects(this._myTeleportParams.myEngine).myCauldron, false);
    this._myFSM.perform("stop");
  }
  update(dt, fsm) {
    this._myBlinkSphere.pp_setParent(this._myTeleportParams.myPlayerHeadManager.getHead(), false);
    this._myBlinkSphere.pp_resetTransformLocal();
    this._myFSM.update(dt);
  }
  _startFadeOut() {
    this._myFadeOutTimer.start();
    this._myBlinkSphereMaterialColor[3] = 0;
    this._myBlinkSphereMeshComponent.material.color = this._myBlinkSphereMaterialColor;
    this._myBlinkSphere.pp_setActive(true);
    this._myLocomotionRuntimeParams.myIsTeleporting = true;
  }
  _startFadeIn() {
    this._myFadeInTimer.start();
  }
  _fadeOutUpdate(dt, fsm) {
    this._myFadeOutTimer.update(dt);
    let alpha = this._myFadeOutAlphaOverTime.get(this._myFadeOutTimer.getPercentage());
    this._myBlinkSphereMaterialColor[3] = alpha;
    this._myBlinkSphereMeshComponent.material.color = this._myBlinkSphereMaterialColor;
    if (this._myFadeOutTimer.isDone()) {
      fsm.perform("done");
    }
  }
  _fadeInUpdate(dt, fsm) {
    this._myFadeInTimer.update(dt);
    let alpha = this._myFadeInAlphaOverTime.get(this._myFadeInTimer.getPercentage());
    this._myBlinkSphereMaterialColor[3] = alpha;
    this._myBlinkSphereMeshComponent.material.color = this._myBlinkSphereMaterialColor;
    if (this._myFadeInTimer.isDone()) {
      fsm.perform("done");
    }
  }
  _teleportDone() {
    this._myBlinkSphere.pp_setActive(false);
    this._myParentFSM.performDelayed("done");
  }
  _stop(teleport) {
    this._myBlinkSphere.pp_setActive(false);
    if (teleport) {
      this._teleport();
    }
  }
  _teleport() {
    this._myLocomotionRuntimeParams.myIsTeleporting = false;
    this._myLocomotionRuntimeParams.myTeleportJustPerformed = true;
    this._teleportToPosition(this._myTeleportRuntimeParams.myTeleportPosition, this._myTeleportRuntimeParams.myTeleportRotationOnUp, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
  }
};

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_teleport_shift_state.js
var PlayerLocomotionTeleportTeleportShiftState = class extends PlayerLocomotionTeleportState {
  constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
    super(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myFSM = new FSM();
    this._myFSM.addState("init");
    this._myFSM.addState("idle");
    this._myFSM.addState("shifting", this._shiftingUpdate.bind(this));
    this._myFSM.addTransition("init", "idle", "start");
    this._myFSM.addTransition("idle", "shifting", "teleport", this._startShifting.bind(this));
    this._myFSM.addTransition("shifting", "idle", "done", this._teleportDone.bind(this));
    this._myFSM.addTransition("idle", "idle", "stop");
    this._myFSM.addTransition("shifting", "idle", "stop", this._stop.bind(this));
    this._myFSM.init("init");
    this._myFSM.perform("start");
    this._myShiftMovementTimer = new Timer(this._myTeleportParams.myTeleportParams.myShiftMovementSeconds);
    this._myShiftRotateTimer = new Timer(this._myTeleportParams.myTeleportParams.myShiftRotateSeconds, false);
    this._myFeetStartPosition = vec3_create();
    this._myCurrentRotationOnUp = 0;
    this._myStartRotationOnUp = 0;
  }
  start(fsm) {
    this._myParentFSM = fsm;
    this._myFSM.perform("teleport");
  }
  end() {
    this._myFSM.perform("stop");
  }
  update(dt, fsm) {
    this._myFSM.update(dt);
  }
  _startShifting() {
    this._myTeleportParams.myPlayerTransformManager.getParams().mySyncPositionDisabled = true;
    this._myLocomotionRuntimeParams.myIsTeleporting = true;
    this._myFeetStartPosition = this._myTeleportParams.myPlayerHeadManager.getPositionFeet(this._myFeetStartPosition);
    this._myShiftMovementTimer.start(this._myTeleportParams.myTeleportParams.myShiftMovementSeconds);
    if (this._myTeleportParams.myTeleportParams.myShiftMovementSecondsMultiplierOverDistanceFunction) {
      let distance5 = this._myTeleportRuntimeParams.myTeleportPosition.vec3_distance(this._myFeetStartPosition);
      let multiplier = this._myTeleportParams.myTeleportParams.myShiftMovementSecondsMultiplierOverDistanceFunction(distance5);
      this._myShiftMovementTimer.start(this._myTeleportParams.myTeleportParams.myShiftMovementSeconds * multiplier);
    }
    this._myShiftRotateTimer.reset(this._myTeleportParams.myTeleportParams.myShiftRotateSeconds);
    if (this._myTeleportParams.myTeleportParams.myShiftRotateSecondsMultiplierOverAngleFunction) {
      let multiplier = this._myTeleportParams.myTeleportParams.myShiftRotateSecondsMultiplierOverAngleFunction(Math.abs(this._myTeleportRuntimeParams.myTeleportRotationOnUp));
      this._myShiftRotateTimer.reset(this._myTeleportParams.myTeleportParams.myShiftRotateSeconds * multiplier);
    }
    this._myStartRotationOnUp = this._myTeleportRuntimeParams.myTeleportRotationOnUp;
    this._myCurrentRotationOnUp = 0;
  }
  _stop() {
    this._teleport();
  }
  _teleportDone() {
    this._teleport();
    this._myParentFSM.performDelayed("done");
  }
  _teleport() {
    this._myTeleportParams.myPlayerTransformManager.getParams().mySyncPositionDisabled = false;
    this._myLocomotionRuntimeParams.myIsTeleporting = false;
    this._myLocomotionRuntimeParams.myTeleportJustPerformed = true;
    this._teleportToPosition(this._myTeleportRuntimeParams.myTeleportPosition, this._myStartRotationOnUp - this._myCurrentRotationOnUp, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
  }
};
PlayerLocomotionTeleportTeleportShiftState.prototype._shiftingUpdate = function() {
  let movementToTeleportFeet = vec3_create();
  let newFeetPosition = vec3_create();
  return function _shiftingUpdate(dt, fsm) {
    this._myShiftMovementTimer.update(dt);
    this._myShiftRotateTimer.update(dt);
    if (this._myShiftRotateTimer.isDone() && this._myShiftMovementTimer.isDone()) {
      fsm.perform("done");
    } else {
      newFeetPosition.vec3_copy(this._myTeleportRuntimeParams.myTeleportPosition);
      if (this._myShiftMovementTimer.isStarted() || this._myShiftMovementTimer.isJustDone()) {
        let interpolationFactor = this._myTeleportParams.myTeleportParams.myShiftMovementEasingFunction(this._myShiftMovementTimer.getPercentage());
        if (interpolationFactor >= this._myTeleportParams.myTeleportParams.myShiftRotateStartAfterMovementPercentage && !this._myShiftRotateTimer.isStarted()) {
          this._myShiftRotateTimer.start();
          this._myShiftRotateTimer.update(dt);
        }
        movementToTeleportFeet = this._myTeleportRuntimeParams.myTeleportPosition.vec3_sub(this._myFeetStartPosition, movementToTeleportFeet);
        movementToTeleportFeet.vec3_scale(interpolationFactor, movementToTeleportFeet);
        newFeetPosition = this._myFeetStartPosition.vec3_add(movementToTeleportFeet, newFeetPosition);
      }
      let rotationOnUp = 0;
      if (this._myShiftRotateTimer.isRunning() || this._myShiftRotateTimer.isJustDone()) {
        let interpolationFactor = this._myTeleportParams.myTeleportParams.myShiftRotateEasingFunction(this._myShiftRotateTimer.getPercentage());
        let newCurrentRotationOnUp = this._myStartRotationOnUp * interpolationFactor;
        rotationOnUp = newCurrentRotationOnUp - this._myCurrentRotationOnUp;
        this._myCurrentRotationOnUp = newCurrentRotationOnUp;
      }
      this._teleportToPosition(newFeetPosition, rotationOnUp, this._myLocomotionRuntimeParams.myCollisionRuntimeParams, true);
    }
  };
}();
Object.defineProperty(PlayerLocomotionTeleportTeleportShiftState.prototype, "_shiftingUpdate", { enumerable: false });

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_teleport_state.js
var PlayerLocomotionTeleportTeleportType = {
  INSTANT: 0,
  BLINK: 1,
  SHIFT: 2
};
var PlayerLocomotionTeleportTeleportParams = class {
  constructor() {
    this.myTeleportType = PlayerLocomotionTeleportTeleportType.SHIFT;
    this.myBlinkFadeOutSeconds = 0.1;
    this.myBlinkFadeInSeconds = 0.1;
    this.myBlinkWaitSeconds = 0.1;
    this.myBlinkSphereColor = vec3_create();
    this.myBlinkSphereScale = 0.1;
    this.myShiftMovementSeconds = 0.15;
    this.myShiftMovementSecondsMultiplierOverDistanceFunction = null;
    this.myShiftMovementEasingFunction = EasingFunction.easeInOut;
    this.myShiftRotateSeconds = 1;
    this.myShiftRotateSecondsMultiplierOverAngleFunction = null;
    this.myShiftRotateEasingFunction = EasingFunction.easeOut;
    this.myShiftRotateStartAfterMovementPercentage = 0.7;
    this.myShiftRotateSecondsMultiplierOverAngleFunction = function(angle4) {
      return EasingFunction.easeOut(angle4 / 180);
    };
  }
};
var PlayerLocomotionTeleportTeleportState = class extends PlayerLocomotionTeleportState {
  constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
    super(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myFSM = new FSM();
    this._myFSM.addState("init");
    this._myFSM.addState("idle");
    this._myBlinkState = new PlayerLocomotionTeleportTeleportBlinkState(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myShiftState = new PlayerLocomotionTeleportTeleportShiftState(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myFSM.addState("instant_teleport", this._instantUpdate.bind(this));
    this._myFSM.addState("blink_teleport", this._myBlinkState);
    this._myFSM.addState("shift_teleport", this._myShiftState);
    this._myFSM.addTransition("init", "idle", "start");
    this._myFSM.addTransition("idle", "instant_teleport", "start_instant");
    this._myFSM.addTransition("idle", "blink_teleport", "start_blink");
    this._myFSM.addTransition("idle", "shift_teleport", "start_shift");
    this._myFSM.addTransition("instant_teleport", "idle", "done", this._teleportDone.bind(this));
    this._myFSM.addTransition("blink_teleport", "idle", "done", this._teleportDone.bind(this));
    this._myFSM.addTransition("shift_teleport", "idle", "done", this._teleportDone.bind(this));
    this._myFSM.addTransition("idle", "idle", "stop");
    this._myFSM.addTransition("instant_teleport", "idle", "stop", this._instantStop.bind(this));
    this._myFSM.addTransition("blink_teleport", "idle", "stop");
    this._myFSM.addTransition("shift_teleport", "idle", "stop");
    this._myFSM.init("init");
    this._myFSM.perform("start");
  }
  start(fsm) {
    this._myParentFSM = fsm;
    switch (this._myTeleportParams.myTeleportParams.myTeleportType) {
      case PlayerLocomotionTeleportTeleportType.INSTANT:
        this._myFSM.perform("start_instant");
        break;
      case PlayerLocomotionTeleportTeleportType.BLINK:
        this._myFSM.perform("start_blink");
        break;
      case PlayerLocomotionTeleportTeleportType.SHIFT:
        this._myFSM.perform("start_shift");
        break;
      default:
        this._myFSM.perform("start_instant");
    }
  }
  end() {
  }
  update(dt, fsm) {
    this._myFSM.update(dt);
  }
  completeTeleport() {
    this._myFSM.perform("stop");
    this._teleportToPosition(this._myTeleportRuntimeParams.myTeleportPosition, this._myTeleportRuntimeParams.myTeleportRotationOnUp, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
  }
  _instantUpdate(dt, fsm) {
    this._teleportToPosition(this._myTeleportRuntimeParams.myTeleportPosition, this._myTeleportRuntimeParams.myTeleportRotationOnUp, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
    this._myLocomotionRuntimeParams.myTeleportJustPerformed = true;
    fsm.perform("done");
  }
  _instantStop(fsm) {
    this._instantUpdate(0, fsm);
  }
  _teleportDone() {
    this._myTeleportParams.myPlayerTransformManager.resetReal();
    this._myParentFSM.performDelayed("done");
  }
};

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport.js
var PlayerLocomotionTeleportParams = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this.myPlayerHeadManager = null;
    this.myCollisionCheckParams = null;
    this.myDetectionParams = new PlayerLocomotionTeleportDetectionParams();
    this.myVisualizerParams = new PlayerLocomotionTeleportDetectionVisualizerParams();
    this.myTeleportParams = new PlayerLocomotionTeleportTeleportParams();
    this.myHandedness = Handedness.LEFT;
    this.myPerformTeleportAsMovement = false;
    this.myTeleportAsMovementMaxDistanceFromTeleportPosition = 1e-3;
    this.myTeleportAsMovementMaxSteps = 2;
    this.myTeleportAsMovementRemoveVerticalMovement = true;
    this.myTeleportAsMovementExtraVerticalMovementPerMeter = 1;
    this.myStickIdleThreshold = 0.1;
    this.myAdjustPositionEveryFrame = false;
    this.myGravityAcceleration = 0;
    this.myMaxGravitySpeed = 0;
    this.myEngine = engine2;
    this.myDebugEnabled = false;
    this.myDebugDetectEnabled = false;
    this.myDebugShowEnabled = false;
    this.myDebugVisibilityEnabled = false;
  }
};
var PlayerLocomotionTeleportRuntimeParams = class {
  constructor() {
    this.myTeleportPosition = vec3_create();
    this.myTeleportRotationOnUp = 0;
  }
};
var PlayerLocomotionTeleport = class extends PlayerLocomotionMovement {
  constructor(teleportParams, locomotionRuntimeParams) {
    super(locomotionRuntimeParams);
    this._myTeleportParams = teleportParams;
    this._myTeleportRuntimeParams = new PlayerLocomotionTeleportRuntimeParams();
    this._myStickIdleCharge = true;
    this._myDetectionState = new PlayerLocomotionTeleportDetectionState(this._myTeleportParams, this._myTeleportRuntimeParams, this._myLocomotionRuntimeParams);
    this._myTeleportState = new PlayerLocomotionTeleportTeleportState(this._myTeleportParams, this._myTeleportRuntimeParams, this._myLocomotionRuntimeParams);
    this._myFSM = new FSM();
    this._myFSM.addState("init");
    this._myFSM.addState("idle", this._idleUpdate.bind(this));
    this._myFSM.addState("detect", this._myDetectionState);
    this._myFSM.addState("teleport", this._myTeleportState);
    this._myFSM.addTransition("init", "idle", "start");
    this._myFSM.addTransition("idle", "detect", "detect");
    this._myFSM.addTransition("detect", "teleport", "teleport");
    this._myFSM.addTransition("detect", "idle", "cancel");
    this._myFSM.addTransition("teleport", "idle", "done");
    this._myFSM.addTransition("idle", "idle", "stop");
    this._myFSM.addTransition("detect", "idle", "stop");
    this._myFSM.addTransition("teleport", "idle", "stop", this._completeTeleport.bind(this));
    this._myFSM.init("init");
    this._myFSM.perform("start");
    this._myDestroyed = false;
  }
  start() {
  }
  stop() {
    this._myFSM.perform("stop");
  }
  canStop() {
    return this._myFSM.isInState("idle");
  }
  getParams() {
    return this._myTeleportParams;
  }
  getTeleportRuntimeParams() {
    return this._myTeleportRuntimeParams;
  }
  update(dt) {
    this._myLocomotionRuntimeParams.myTeleportJustPerformed = false;
    this._myFSM.update(dt);
    if (!this._myLocomotionRuntimeParams.myIsTeleporting && (this._myTeleportParams.myAdjustPositionEveryFrame || this._myTeleportParams.myGravityAcceleration != 0)) {
      this._applyGravity(dt);
    }
    if (this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnGround) {
      this._myLocomotionRuntimeParams.myIsFlying = false;
    }
  }
  _idleUpdate(dt) {
    if (this._startDetecting()) {
      this._myFSM.perform("detect");
    }
  }
  _startDetecting() {
    let startDetecting = false;
    if (!XRUtils.isSessionActive(this._myTeleportParams.myEngine)) {
      startDetecting = Globals.getMouse(this._myTeleportParams.myEngine).isButtonPressStart(MouseButtonID.MIDDLE) && Globals.getMouse(this._myTeleportParams.myEngine).isTargetingRenderCanvas();
    } else {
      let axes = Globals.getGamepads(this._myTeleportParams.myEngine)[this._myTeleportParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
      if (axes.vec2_length() <= this._myTeleportParams.myStickIdleThreshold) {
        this._myStickIdleCharge = true;
      }
      if (this._myStickIdleCharge && axes[1] >= 0.75) {
        this._myStickIdleCharge = false;
        startDetecting = true;
      }
    }
    return startDetecting;
  }
  _completeTeleport() {
    this._myTeleportState.completeTeleport();
  }
  destroy() {
    this._myDestroyed = true;
    this._myDetectionState.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
PlayerLocomotionTeleport.prototype._applyGravity = function() {
  let playerUp = vec3_create();
  let gravityMovement = vec3_create();
  let feetTransformQuat = quat2_create();
  return function _applyGravity(dt) {
    playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    gravityMovement.vec3_zero();
    if (!this._myLocomotionRuntimeParams.myIsFlying && !this._myLocomotionRuntimeParams.myIsTeleporting) {
      this._myLocomotionRuntimeParams.myGravitySpeed += this._myTeleportParams.myGravityAcceleration * dt;
      if (Math.abs(this._myLocomotionRuntimeParams.myGravitySpeed) > Math.abs(this._myTeleportParams.myMaxGravitySpeed)) {
        this._myLocomotionRuntimeParams.myGravitySpeed = Math.pp_sign(this._myTeleportParams.myGravityAcceleration) * Math.abs(this._myTeleportParams.myMaxGravitySpeed);
      }
      gravityMovement = playerUp.vec3_scale(this._myLocomotionRuntimeParams.myGravitySpeed * dt, gravityMovement);
    } else {
      this._myLocomotionRuntimeParams.myGravitySpeed = 0;
    }
    feetTransformQuat = this._myTeleportParams.myPlayerHeadManager.getTransformFeetQuat(feetTransformQuat);
    CollisionCheckBridge.getCollisionCheck(this._myTeleportParams.myEngine).move(gravityMovement, feetTransformQuat, this._myTeleportParams.myCollisionCheckParams, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
    if (!this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myVerticalMovementCanceled) {
      this._myTeleportParams.myPlayerHeadManager.teleportPositionFeet(this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myNewPosition);
    }
    if (this._myLocomotionRuntimeParams.myGravitySpeed > 0 && this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnCeiling || this._myLocomotionRuntimeParams.myGravitySpeed < 0 && this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnGround) {
      this._myLocomotionRuntimeParams.myGravitySpeed = 0;
    }
  };
}();

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion.js
var PlayerLocomotionDirectionReferenceType = {
  HEAD: 0,
  HAND: 1,
  CUSTOM_OBJECT: 2
};
var PlayerLocomotionType = {
  SMOOTH: 0,
  TELEPORT: 1
};
var PlayerLocomotionParams = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this.myDefaultLocomotionType = PlayerLocomotionType.SMOOTH;
    this.mySwitchLocomotionTypeShortcutEnabled = true;
    this.myDefaultHeight = 0;
    this.myMaxSpeed = 0;
    this.myMaxRotationSpeed = 0;
    this.myGravityAcceleration = 0;
    this.myMaxGravitySpeed = 0;
    this.myCharacterRadius = 0;
    this.mySpeedSlowDownPercentageOnWallSlid = 1;
    this.myIsSnapTurn = false;
    this.mySnapTurnOnlyVR = false;
    this.mySnapTurnAngle = 0;
    this.mySnapTurnSpeedDegrees = 0;
    this.myFlyEnabled = false;
    this.myStartFlying = false;
    this.myMinAngleToFlyUpNonVR = 0;
    this.myMinAngleToFlyDownNonVR = 0;
    this.myMinAngleToFlyUpVR = 0;
    this.myMinAngleToFlyDownVR = 0;
    this.myMinAngleToFlyRight = 0;
    this.myMainHand = Handedness.LEFT;
    this.myDirectionInvertForwardWhenUpsideDown = true;
    this.myVRDirectionReferenceType = PlayerLocomotionDirectionReferenceType.HEAD;
    this.myVRDirectionReferenceObject = null;
    this.myForeheadExtraHeight = 0;
    this.myTeleportType = PlayerLocomotionTeleportTeleportType.INSTANT;
    this.myTeleportMaxDistance = 0;
    this.myTeleportMaxHeightDifference = 0;
    this.myTeleportRotationOnUpEnabled = null;
    this.myTeleportValidMaterial = null;
    this.myTeleportInvalidMaterial = null;
    this.myTeleportPositionObject = null;
    this.myTeleportPositionObjectRotateWithHead = null;
    this.myTeleportParableStartReferenceObject = null;
    this.mySyncWithRealWorldPositionOnlyIfValid = true;
    this.myViewOcclusionInsideWallsEnabled = true;
    this.myColliderAccuracy = null;
    this.myColliderCheckOnlyFeet = false;
    this.myColliderSlideAlongWall = false;
    this.myColliderMaxWalkableGroundAngle = 0;
    this.myColliderSnapOnGround = false;
    this.myColliderMaxDistanceToSnapOnGround = 0;
    this.myColliderMaxWalkableGroundStepHeight = 0;
    this.myColliderPreventFallingFromEdges = false;
    this.myDebugHorizontalEnabled = false;
    this.myDebugVerticalEnabled = false;
    this.myMoveThroughCollisionShortcutEnabled = false;
    this.myMoveHeadShortcutEnabled = false;
    this.myTripleSpeedShortcutEnabled = false;
    this.myPhysicsBlockLayerFlags = new PhysicsLayerFlags();
    this.myEngine = engine2;
  }
};
var PlayerLocomotion = class {
  constructor(params) {
    this._myParams = params;
    this._myCollisionCheckParamsMovement = new CollisionCheckParams();
    this._setupCollisionCheckParamsMovement();
    this._myCollisionCheckParamsTeleport = null;
    this._setupCollisionCheckParamsTeleport();
    this._myCollisionRuntimeParams = new CollisionRuntimeParams();
    this._myMovementRuntimeParams = new PlayerLocomotionMovementRuntimeParams();
    this._myMovementRuntimeParams.myIsFlying = this._myParams.myStartFlying;
    this._myMovementRuntimeParams.myCollisionRuntimeParams = this._myCollisionRuntimeParams;
    {
      let params2 = new PlayerHeadManagerParams(this._myParams.myEngine);
      params2.mySessionChangeResyncEnabled = true;
      params2.myBlurEndResyncEnabled = true;
      params2.myBlurEndResyncRotation = true;
      params2.myEnterSessionResyncHeight = false;
      params2.myExitSessionResyncHeight = false;
      params2.myExitSessionResyncVerticalAngle = true;
      params2.myExitSessionRemoveRightTilt = true;
      params2.myExitSessionAdjustMaxVerticalAngle = true;
      params2.myExitSessionMaxVerticalAngle = 90;
      params2.myHeightOffsetVRWithFloor = 0;
      params2.myHeightOffsetVRWithoutFloor = this._myParams.myDefaultHeight;
      params2.myHeightOffsetNonVR = this._myParams.myDefaultHeight;
      params2.myForeheadExtraHeight = this._myParams.myForeheadExtraHeight;
      params2.myFeetRotationKeepUp = true;
      params2.myDebugEnabled = false;
      this._myPlayerHeadManager = new PlayerHeadManager(params2);
    }
    {
      let params2 = new PlayerTransformManagerParams(this._myParams.myEngine);
      params2.myPlayerHeadManager = this._myPlayerHeadManager;
      params2.myMovementCollisionCheckParams = this._myCollisionCheckParamsMovement;
      params2.myTeleportCollisionCheckParams = null;
      params2.myTeleportCollisionCheckParamsCopyFromMovement = true;
      params2.myTeleportCollisionCheckParamsCheck360 = true;
      params2.myHeadCollisionBlockLayerFlags.copy(params2.myMovementCollisionCheckParams.myHorizontalBlockLayerFlags);
      params2.myHeadCollisionBlockLayerFlags.add(params2.myMovementCollisionCheckParams.myVerticalBlockLayerFlags);
      params2.myHeadCollisionObjectsToIgnore.pp_copy(params2.myMovementCollisionCheckParams.myHorizontalObjectsToIgnore);
      let objectsEqualCallback = (first2, second) => first2.pp_equals(second);
      for (let objectToIgnore of params2.myMovementCollisionCheckParams.myVerticalObjectsToIgnore) {
        params2.myHeadCollisionObjectsToIgnore.pp_pushUnique(objectToIgnore, objectsEqualCallback);
      }
      params2.myCollisionRuntimeParams = this._myCollisionRuntimeParams;
      params2.myHeadRadius = 0.15;
      params2.myAlwaysSyncPositionWithReal = !this._myParams.mySyncWithRealWorldPositionOnlyIfValid;
      params2.myAlwaysSyncHeadPositionWithReal = false;
      if (!this._myParams.myViewOcclusionInsideWallsEnabled && !this._myParams.mySyncWithRealWorldPositionOnlyIfValid) {
        params2.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, false);
        params2.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, false);
        params2.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.FAR, false);
        params2.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, false);
        params2.myAlwaysSyncHeadPositionWithReal = !this._myParams.mySyncWithRealWorldPositionOnlyIfValid;
      }
      params2.myMaxDistanceFromRealToSyncEnabled = true;
      params2.myMaxDistanceFromRealToSync = 100;
      params2.myIsFloatingValidIfVerticalMovement = false;
      params2.myIsFloatingValidIfVerticalMovementAndRealOnGround = false;
      params2.myIsFloatingValidIfSteepGround = false;
      params2.myIsFloatingValidIfVerticalMovementAndSteepGround = false;
      params2.myIsFloatingValidIfRealOnGround = false;
      params2.myIsLeaningValidAboveDistance = true;
      params2.myLeaningValidDistance = 2;
      params2.myFloatingSplitCheckEnabled = true;
      params2.myFloatingSplitCheckMaxLength = 0.2;
      params2.myFloatingSplitCheckMaxSteps = 5;
      params2.myRealMovementAllowVerticalAdjustments = false;
      params2.myUpdateRealPositionValid = false;
      params2.myUpdatePositionValid = false;
      params2.myIsBodyCollidingWhenHeightBelowValue = null;
      params2.myIsBodyCollidingWhenHeightAboveValue = null;
      params2.myResetToValidOnEnterSession = true;
      params2.myResetToValidOnExitSession = true;
      params2.myAlwaysResetRealPositionNonVR = true;
      params2.myAlwaysResetRealRotationNonVR = true;
      params2.myAlwaysResetRealHeightNonVR = true;
      params2.myAlwaysResetRealPositionVR = false;
      params2.myAlwaysResetRealRotationVR = false;
      params2.myAlwaysResetRealHeightVR = false;
      params2.myNeverResetRealPositionNonVR = false;
      params2.myNeverResetRealRotationNonVR = true;
      params2.myNeverResetRealHeightNonVR = false;
      params2.myNeverResetRealPositionVR = false;
      params2.myNeverResetRealRotationVR = false;
      params2.myNeverResetRealHeightVR = true;
      params2.myResetRealOnMove = false;
      params2.myDebugEnabled = false;
      this._myPlayerTransformManager = new PlayerTransformManager(params2);
    }
    {
      let params2 = new PlayerObscureManagerParams(this._myParams.myEngine);
      params2.myPlayerTransformManager = this._myPlayerTransformManager;
      params2.myEnabled = this._myParams.myViewOcclusionInsideWallsEnabled;
      params2.myObscureObject = null;
      params2.myObscureMaterial = null;
      params2.myObscureRadius = 0.1;
      params2.myObscureFadeOutSeconds = 0.25;
      params2.myObscureFadeInSeconds = 0.25;
      params2.myObscureFadeEasingFunction = EasingFunction.linear;
      params2.myObscureLevelRelativeDistanceEasingFunction = EasingFunction.linear;
      params2.myDistanceToStartObscureWhenBodyColliding = 0.75;
      params2.myDistanceToStartObscureWhenHeadColliding = 0;
      params2.myDistanceToStartObscureWhenFloating = 0.75;
      params2.myDistanceToStartObscureWhenFar = 0.75;
      params2.myRelativeDistanceToMaxObscureWhenBodyColliding = 0.5;
      params2.myRelativeDistanceToMaxObscureWhenHeadColliding = 0.1;
      params2.myRelativeDistanceToMaxObscureWhenFloating = 0.5;
      params2.myRelativeDistanceToMaxObscureWhenFar = 0.5;
      this._myPlayerObscureManager = new PlayerObscureManager(params2);
    }
    {
      let params2 = new PlayerLocomotionRotateParams(this._myParams.myEngine);
      params2.myPlayerHeadManager = this._myPlayerHeadManager;
      params2.myPlayerTransformManager = this._myPlayerTransformManager;
      params2.myMaxRotationSpeed = this._myParams.myMaxRotationSpeed;
      params2.myIsSnapTurn = this._myParams.myIsSnapTurn;
      params2.mySnapTurnOnlyVR = this._myParams.mySnapTurnOnlyVR;
      params2.mySnapTurnAngle = this._myParams.mySnapTurnAngle;
      if (this._myParams.mySnapTurnSpeedDegrees > Math.PP_EPSILON) {
        params2.mySmoothSnapEnabled = true;
        params2.mySmoothSnapSpeedDegrees = this._myParams.mySnapTurnSpeedDegrees;
      } else {
        params2.mySmoothSnapEnabled = false;
      }
      params2.myRotationMinStickIntensityThreshold = 0.1;
      params2.mySnapTurnActivateThreshold = 0.5;
      params2.mySnapTurnResetThreshold = 0.4;
      params2.myClampVerticalAngle = true;
      params2.myMaxVerticalAngle = 90;
      this._myPlayerLocomotionRotate = new PlayerLocomotionRotate(params2);
      params2.myHandedness = InputUtils.getOppositeHandedness(this._myParams.myMainHand);
    }
    {
      {
        let params2 = new PlayerLocomotionSmoothParams(this._myParams.myEngine);
        params2.myPlayerHeadManager = this._myPlayerHeadManager;
        params2.myPlayerTransformManager = this._myPlayerTransformManager;
        params2.myCollisionCheckParams = this._myCollisionCheckParamsMovement;
        params2.myHandedness = this._myParams.myMainHand;
        params2.myMaxSpeed = this._myParams.myMaxSpeed;
        params2.mySpeedSlowDownPercentageOnWallSlid = this._myParams.mySpeedSlowDownPercentageOnWallSlid;
        params2.myMovementMinStickIntensityThreshold = 0.1;
        params2.myFlyEnabled = this._myParams.myFlyEnabled;
        params2.myMinAngleToFlyUpNonVR = this._myParams.myMinAngleToFlyUpNonVR;
        params2.myMinAngleToFlyDownNonVR = this._myParams.myMinAngleToFlyDownNonVR;
        params2.myMinAngleToFlyUpVR = this._myParams.myMinAngleToFlyUpVR;
        params2.myMinAngleToFlyDownVR = this._myParams.myMinAngleToFlyDownVR;
        params2.myMinAngleToFlyRight = this._myParams.myMinAngleToFlyRight;
        params2.myGravityAcceleration = this._myParams.myGravityAcceleration;
        params2.myMaxGravitySpeed = this._myParams.myMaxGravitySpeed;
        params2.myDirectionInvertForwardWhenUpsideDown = this._myParams.myDirectionInvertForwardWhenUpsideDown;
        params2.myVRDirectionReferenceType = this._myParams.myVRDirectionReferenceType;
        params2.myVRDirectionReferenceObject = this._myParams.myVRDirectionReferenceObject;
        params2.myMoveThroughCollisionShortcutEnabled = this._myParams.myMoveThroughCollisionShortcutEnabled;
        params2.myMoveHeadShortcutEnabled = this._myParams.myMoveHeadShortcutEnabled;
        params2.myTripleSpeedShortcutEnabled = this._myParams.myTripleSpeedShortcutEnabled;
        this._myPlayerLocomotionSmooth = new PlayerLocomotionSmooth(params2, this._myMovementRuntimeParams);
      }
      {
        let params2 = new PlayerLocomotionTeleportParams(this._myParams.myEngine);
        params2.myPlayerHeadManager = this._myPlayerHeadManager;
        params2.myPlayerTransformManager = this._myPlayerTransformManager;
        params2.myCollisionCheckParams = this._myCollisionCheckParamsTeleport;
        params2.myHandedness = this._myParams.myMainHand;
        params2.myDetectionParams.myMaxDistance = this._myParams.myTeleportMaxDistance;
        params2.myDetectionParams.myMaxHeightDifference = this._myParams.myTeleportMaxHeightDifference;
        params2.myDetectionParams.myGroundAngleToIgnoreUpward = this._myCollisionCheckParamsMovement.myGroundAngleToIgnore;
        params2.myDetectionParams.myRotationOnUpEnabled = this._myParams.myTeleportRotationOnUpEnabled;
        params2.myDetectionParams.myMustBeOnGround = true;
        params2.myDetectionParams.myTeleportBlockLayerFlags.copy(this._myParams.myPhysicsBlockLayerFlags);
        params2.myDetectionParams.myTeleportFloorLayerFlags.copy(this._myParams.myPhysicsBlockLayerFlags);
        params2.myDetectionParams.myTeleportFeetPositionMustBeVisible = false;
        params2.myDetectionParams.myTeleportHeadPositionMustBeVisible = false;
        params2.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible = true;
        params2.myDetectionParams.myTeleportParableStartReferenceObject = this._myParams.myTeleportParableStartReferenceObject;
        params2.myDetectionParams.myVisibilityBlockLayerFlags.copy(params2.myDetectionParams.myTeleportBlockLayerFlags);
        params2.myTeleportParams.myTeleportType = this._myParams.myTeleportType;
        params2.myVisualizerParams.myTeleportPositionObject = this._myParams.myTeleportPositionObject;
        params2.myVisualizerParams.myTeleportValidMaterial = this._myParams.myTeleportValidMaterial;
        params2.myVisualizerParams.myTeleportInvalidMaterial = this._myParams.myTeleportInvalidMaterial;
        params2.myVisualizerParams.myTeleportPositionObjectRotateWithHead = this._myParams.myTeleportPositionObjectRotateWithHead;
        params2.myPerformTeleportAsMovement = false;
        params2.myTeleportAsMovementRemoveVerticalMovement = true;
        params2.myTeleportAsMovementExtraVerticalMovementPerMeter = -2;
        params2.myGravityAcceleration = this._myParams.myGravityAcceleration;
        params2.myMaxGravitySpeed = this._myParams.myMaxGravitySpeed;
        params2.myDebugEnabled = false;
        params2.myDebugDetectEnabled = true;
        params2.myDebugShowEnabled = true;
        params2.myDebugVisibilityEnabled = false;
        this._myPlayerLocomotionTeleport = new PlayerLocomotionTeleport(params2, this._myMovementRuntimeParams);
      }
    }
    this._setupLocomotionMovementFSM();
    this._myIdle = false;
    this._myActive = true;
    this._myStarted = false;
    this._myDestroyed = false;
  }
  start() {
    this._fixAlmostUp();
    this._myPlayerHeadManager.start();
    this._myPlayerTransformManager.start();
    this._myPlayerObscureManager.start();
    this._myPlayerLocomotionRotate.start();
    if (this._myParams.myDefaultLocomotionType == PlayerLocomotionType.SMOOTH) {
      this._myLocomotionMovementFSM.perform("startSmooth");
    } else {
      this._myLocomotionMovementFSM.perform("startTeleport");
    }
    this._myStarted = true;
    let currentActive = this._myActive;
    this._myActive = !this._myActive;
    this.setActive(currentActive);
  }
  setActive(active) {
    if (this._myActive != active) {
      this._myActive = active;
      if (this._myStarted) {
        if (this._myActive) {
          this._myPlayerObscureManager.start();
          if (!this._myIdle) {
            this._myLocomotionMovementFSM.perform("resume");
          }
        } else {
          this._myLocomotionMovementFSM.perform("idle");
          this._myPlayerObscureManager.stop();
        }
      }
      this._myPlayerHeadManager.setActive(this._myActive);
      this._myPlayerTransformManager.setActive(this._myActive);
    }
  }
  isStarted() {
    return this._myStarted;
  }
  canStop() {
    let canStop = false;
    if (this._myLocomotionMovementFSM.isInState("smooth") && this._myPlayerLocomotionSmooth.canStop()) {
      canStop = true;
    } else if (this._myLocomotionMovementFSM.isInState("teleport") && this._myPlayerLocomotionTeleport.canStop()) {
      canStop = true;
    }
    return canStop;
  }
  update(dt) {
    this._myPlayerHeadManager.update(dt);
    this._myPlayerTransformManager.update(dt);
    if (this._myParams.mySwitchLocomotionTypeShortcutEnabled && Globals.getLeftGamepad(this._myParams.myEngine).getButtonInfo(GamepadButtonID.THUMBSTICK).isPressEnd(2)) {
      if (this._myLocomotionMovementFSM.isInState("smooth") && this._myPlayerLocomotionSmooth.canStop()) {
        this._myLocomotionMovementFSM.perform("next");
      } else if (this._myLocomotionMovementFSM.isInState("teleport") && this._myPlayerLocomotionTeleport.canStop()) {
        this._myLocomotionMovementFSM.perform("next");
      }
    }
    if (this._myPlayerHeadManager.isSynced()) {
      this._updateCollisionHeight();
      if (!this._myIdle) {
        this._myPlayerLocomotionRotate.update(dt);
        this._myLocomotionMovementFSM.update(dt);
      }
    }
    this._myPlayerObscureManager.update(dt);
  }
  setIdle(idle) {
    this._myIdle = idle;
    if (idle) {
      this._myLocomotionMovementFSM.perform("idle");
    } else {
      this._myLocomotionMovementFSM.perform("resume");
    }
  }
  getPlayerLocomotionSmooth() {
    return this._myPlayerLocomotionSmooth;
  }
  getPlayerLocomotionTeleport() {
    return this._myPlayerLocomotionTeleport;
  }
  getPlayerTransformManager() {
    return this._myPlayerTransformManager;
  }
  getPlayerLocomotionRotate() {
    return this._myPlayerLocomotionRotate;
  }
  getPlayerHeadManager() {
    return this._myPlayerHeadManager;
  }
  getPlayerObscureManager() {
    return this._myPlayerObscureManager;
  }
  _updateCollisionHeight() {
    this._myCollisionCheckParamsMovement.myHeight = this._myPlayerHeadManager.getHeightHead();
    if (this._myCollisionCheckParamsMovement.myHeight <= 1e-6) {
      this._myCollisionCheckParamsMovement.myHeight = 0;
    }
    this._myCollisionCheckParamsTeleport.myHeight = this._myCollisionCheckParamsMovement.myHeight;
  }
  _setupCollisionCheckParamsMovement() {
    let simplifiedParams = new CharacterColliderSetupSimplifiedCreationParams();
    simplifiedParams.myHeight = this._myParams.myDefaultHeight;
    simplifiedParams.myRadius = this._myParams.myCharacterRadius;
    simplifiedParams.myAccuracyLevel = this._myParams.myColliderAccuracy;
    simplifiedParams.myIsPlayer = true;
    simplifiedParams.myCheckOnlyFeet = this._myParams.myColliderCheckOnlyFeet;
    simplifiedParams.myMaxSpeed = this._myParams.myMaxSpeed;
    simplifiedParams.myCanFly = this._myParams.myFlyEnabled;
    simplifiedParams.myShouldSlideAlongWall = this._myParams.myColliderSlideAlongWall;
    simplifiedParams.myCollectGroundInfo = true;
    simplifiedParams.myMaxWalkableGroundAngle = this._myParams.myColliderMaxWalkableGroundAngle;
    simplifiedParams.myShouldSnapOnGround = this._myParams.myColliderSnapOnGround;
    simplifiedParams.myMaxDistanceToSnapOnGround = this._myParams.myColliderMaxDistanceToSnapOnGround;
    simplifiedParams.myMaxWalkableGroundStepHeight = this._myParams.myColliderMaxWalkableGroundStepHeight;
    simplifiedParams.myShouldNotFallFromEdges = this._myParams.myColliderPreventFallingFromEdges;
    simplifiedParams.myHorizontalCheckBlockLayerFlags.copy(this._myParams.myPhysicsBlockLayerFlags);
    let physXComponents = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getComponents(PhysXComponent);
    for (let physXComponent of physXComponents) {
      simplifiedParams.myHorizontalCheckObjectsToIgnore.pp_pushUnique(physXComponent.object, (first2, second) => first2.pp_equals(second));
    }
    simplifiedParams.myVerticalCheckBlockLayerFlags.copy(simplifiedParams.myHorizontalCheckBlockLayerFlags);
    simplifiedParams.myVerticalCheckObjectsToIgnore.pp_copy(simplifiedParams.myHorizontalCheckObjectsToIgnore);
    simplifiedParams.myHorizontalCheckDebugEnabled = this._myParams.myDebugHorizontalEnabled && Globals.isDebugEnabled(this._myParams.myEngine);
    simplifiedParams.myVerticalCheckDebugEnabled = this._myParams.myDebugVerticalEnabled && Globals.isDebugEnabled(this._myParams.myEngine);
    let colliderSetup = CharacterColliderSetupUtils.createSimplified(simplifiedParams);
    this._myCollisionCheckParamsMovement = CollisionCheckBridge.convertCharacterColliderSetupToCollisionCheckParams(colliderSetup, this._myCollisionCheckParamsMovement, this._myParams.myEngine);
  }
  _setupCollisionCheckParamsTeleport() {
    this._myCollisionCheckParamsTeleport = CollisionCheckUtils.generate360TeleportParamsFromMovementParams(this._myCollisionCheckParamsMovement);
    this._myCollisionCheckParamsTeleport.myGroundAngleToIgnore = 61;
    this._myCollisionCheckParamsTeleport.myTeleportMustBeOnIgnorableGroundAngle = true;
    this._myCollisionCheckParamsTeleport.myTeleportMustBeOnGround = true;
  }
  _fixAlmostUp() {
    let defaultUp = vec3_create(0, 1, 0);
    let angleWithDefaultUp = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getUp().vec3_angle(defaultUp);
    if (angleWithDefaultUp < 1) {
      let forward = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getForward();
      let flatForward = forward.vec3_clone();
      flatForward[1] = 0;
      let defaultForward = vec3_create(0, 0, 1);
      let angleWithDefaultForward = defaultForward.vec3_angleSigned(flatForward, defaultUp);
      Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_resetRotation();
      Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_rotateAxis(angleWithDefaultForward, defaultUp);
    }
  }
  _setupLocomotionMovementFSM() {
    this._myLocomotionMovementFSM = new FSM();
    this._myLocomotionMovementFSM.addState("init");
    this._myLocomotionMovementFSM.addState("smooth", (dt) => this._myPlayerLocomotionSmooth.update(dt));
    this._myLocomotionMovementFSM.addState("teleport", (dt) => this._myPlayerLocomotionTeleport.update(dt));
    this._myLocomotionMovementFSM.addState("idleSmooth");
    this._myLocomotionMovementFSM.addState("idleTeleport");
    this._myLocomotionMovementFSM.addTransition("init", "smooth", "startSmooth", function() {
      this._myPlayerLocomotionSmooth.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("init", "teleport", "startTeleport", function() {
      this._myPlayerLocomotionSmooth.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("smooth", "teleport", "next", function() {
      this._myPlayerLocomotionSmooth.stop();
      this._myPlayerLocomotionTeleport.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("teleport", "smooth", "next", function() {
      this._myPlayerLocomotionTeleport.stop();
      this._myPlayerLocomotionSmooth.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("smooth", "idleSmooth", "idle", function() {
      this._myPlayerLocomotionSmooth.stop();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("teleport", "idleTeleport", "idle", function() {
      this._myPlayerLocomotionTeleport.stop();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("idleSmooth", "smooth", "resume", function() {
      this._myPlayerLocomotionSmooth.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("idleTeleport", "teleport", "resume", function() {
      this._myPlayerLocomotionTeleport.start();
    }.bind(this));
    this._myLocomotionMovementFSM.init("init");
  }
  destroy() {
    this._myDestroyed = true;
    this._myPlayerHeadManager.destroy();
    this._myPlayerLocomotionSmooth.destroy();
    this._myPlayerTransformManager.destroy();
    this._myPlayerObscureManager.destroy();
    this._myPlayerLocomotionTeleport.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion_smooth.js
var PlayerLocomotionSmoothParams = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this.myPlayerHeadManager = null;
    this.myPlayerTransformManager = null;
    this.myCollisionCheckParams = null;
    this.myMaxSpeed = 0;
    this.mySpeedSlowDownPercentageOnWallSlid = 1;
    this.myMovementMinStickIntensityThreshold = 0;
    this.myFlyEnabled = false;
    this.myMinAngleToFlyUpNonVR = 0;
    this.myMinAngleToFlyDownNonVR = 0;
    this.myMinAngleToFlyUpVR = 0;
    this.myMinAngleToFlyDownVR = 0;
    this.myMinAngleToFlyRight = 0;
    this.myGravityAcceleration = 0;
    this.myMaxGravitySpeed = 0;
    this.myVRDirectionReferenceType = PlayerLocomotionDirectionReferenceType.HEAD;
    this.myVRDirectionReferenceObject = null;
    this.myHandedness = Handedness.LEFT;
    this.myMoveThroughCollisionShortcutEnabled = false;
    this.myMoveHeadShortcutEnabled = false;
    this.myTripleSpeedShortcutEnabled = false;
    this.myEngine = engine2;
  }
};
var PlayerLocomotionSmooth = class extends PlayerLocomotionMovement {
  constructor(params, locomotionRuntimeParams) {
    super(locomotionRuntimeParams);
    this._myParams = params;
    this._myCurrentSpeed = 0;
    this._myLastHorizontalMovement = vec3_create();
    this._myDirectionReference = Globals.getPlayerObjects(this._myParams.myEngine).myHead;
    this._myStickIdleTimer = new Timer(0.25, false);
    let directionConverterNonVRParams = new Direction2DTo3DConverterParams(this._myParams.myEngine);
    directionConverterNonVRParams.myAutoUpdateFlyForward = this._myParams.myFlyEnabled;
    directionConverterNonVRParams.myAutoUpdateFlyRight = this._myParams.myFlyEnabled;
    directionConverterNonVRParams.myMinAngleToFlyForwardUp = this._myParams.myMinAngleToFlyUpNonVR;
    directionConverterNonVRParams.myMinAngleToFlyForwardDown = this._myParams.myMinAngleToFlyDownNonVR;
    directionConverterNonVRParams.myMinAngleToFlyRightUp = this._myParams.myMinAngleToFlyRight;
    directionConverterNonVRParams.myMinAngleToFlyRightDown = this._myParams.myMinAngleToFlyRight;
    directionConverterNonVRParams.myInvertForwardWhenUpsideDown = this._myParams.myDirectionInvertForwardWhenUpsideDown;
    let directionConverterVRParams = new Direction2DTo3DConverterParams(this._myParams.myEngine);
    directionConverterVRParams.myAutoUpdateFlyForward = this._myParams.myFlyEnabled;
    directionConverterVRParams.myAutoUpdateFlyRight = this._myParams.myFlyEnabled;
    directionConverterVRParams.myMinAngleToFlyForwardUp = this._myParams.myMinAngleToFlyUpVR;
    directionConverterVRParams.myMinAngleToFlyForwardDown = this._myParams.myMinAngleToFlyDownVR;
    directionConverterVRParams.myMinAngleToFlyRightUp = this._myParams.myMinAngleToFlyRight;
    directionConverterVRParams.myMinAngleToFlyRightDown = this._myParams.myMinAngleToFlyRight;
    directionConverterVRParams.myInvertForwardWhenUpsideDown = this._myParams.myDirectionInvertForwardWhenUpsideDown;
    this._myDirectionConverterNonVR = new Direction2DTo3DConverter(directionConverterNonVRParams);
    this._myDirectionConverterVR = new Direction2DTo3DConverter(directionConverterVRParams);
    this._myCurrentDirectionConverter = this._myDirectionConverterNonVR;
    this._myDestroyed = false;
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myParams.myEngine);
  }
  start() {
    this._myCurrentSpeed = 0;
    this._myLastHorizontalMovement.vec3_zero();
  }
  getParams() {
    return this._myParams;
  }
  getCurrentSpeed() {
    return this._myCurrentSpeed;
  }
  getLastHorizontalSpeed() {
    return this._myLastHorizontalMovement;
  }
  update(dt) {
  }
  destroy() {
    this._myDestroyed = true;
    XRUtils.unregisterSessionStartEndEventListeners(this, this._myParams.myEngine);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
PlayerLocomotionSmooth.prototype.update = function() {
  let playerUp = vec3_create();
  let headMovement = vec3_create();
  let direction2 = vec3_create();
  let directionOnUp = vec3_create();
  let verticalMovement = vec3_create();
  let feetTransformQuat = quat2_create();
  let directionReferenceTransformQuat = quat2_create();
  return function update(dt) {
    this._myCurrentSpeed = 0;
    this._myLastHorizontalMovement.vec3_zero();
    playerUp = this._myParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    headMovement.vec3_zero();
    let axes = Globals.getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
    axes[0] = Math.abs(axes[0]) > this._myParams.myMovementMinStickIntensityThreshold ? axes[0] : 0;
    axes[1] = Math.abs(axes[1]) > this._myParams.myMovementMinStickIntensityThreshold ? axes[1] : 0;
    let horizontalMovement = false;
    let maxSpeed = this._myParams.myMaxSpeed;
    if (this._myParams.myTripleSpeedShortcutEnabled && Globals.isDebugEnabled(this._myParams.myEngine)) {
      if (Globals.getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.SELECT).isPressed()) {
        maxSpeed *= 3;
      }
    }
    if (!axes.vec2_isZero()) {
      this._myStickIdleTimer.start();
      direction2 = this._myCurrentDirectionConverter.convertTransformQuat(axes, this._myDirectionReference.pp_getTransformQuat(directionReferenceTransformQuat), playerUp, direction2);
      if (!direction2.vec3_isZero()) {
        this._myLocomotionRuntimeParams.myIsFlying = this._myLocomotionRuntimeParams.myIsFlying || direction2.vec3_componentAlongAxis(playerUp, directionOnUp).vec3_length() > 1e-6;
        if (!this._myLocomotionRuntimeParams.myIsFlying) {
          direction2 = direction2.vec3_removeComponentAlongAxis(playerUp, direction2);
        }
        let movementIntensity = axes.vec2_length();
        this._myCurrentSpeed = Math.pp_lerp(0, maxSpeed, movementIntensity);
        if (this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsSliding && this._myParams.mySpeedSlowDownPercentageOnWallSlid != 1) {
          let slowPercentage = this._myParams.mySpeedSlowDownPercentageOnWallSlid;
          let slidStrength = Math.pp_mapToRange(Math.abs(this._myLocomotionRuntimeParams.myCollisionRuntimeParams.mySlidingMovementAngle), 0, 90, 0, 1);
          slowPercentage = Math.pp_lerp(1, slowPercentage, slidStrength);
          this._myCurrentSpeed = this._myCurrentSpeed * slowPercentage;
        }
        headMovement = direction2.vec3_scale(this._myCurrentSpeed * dt, headMovement);
        horizontalMovement = true;
      }
    } else {
      if (this._myStickIdleTimer.isRunning()) {
        this._myStickIdleTimer.update(dt);
        if (this._myStickIdleTimer.isDone()) {
          this._myCurrentDirectionConverter.resetFly();
        }
      }
    }
    if (this._myParams.myFlyEnabled) {
      if (Globals.getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed()) {
        verticalMovement = playerUp.vec3_scale(maxSpeed * dt, verticalMovement);
        headMovement = headMovement.vec3_add(verticalMovement, headMovement);
        this._myLocomotionRuntimeParams.myIsFlying = true;
      } else if (Globals.getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).isPressed()) {
        verticalMovement = playerUp.vec3_scale(-maxSpeed * dt, verticalMovement);
        headMovement = headMovement.vec3_add(verticalMovement, headMovement);
        this._myLocomotionRuntimeParams.myIsFlying = true;
      }
      if (Globals.getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).isPressEnd(2)) {
        this._myLocomotionRuntimeParams.myIsFlying = false;
      }
    }
    if (this._myParams.myMoveHeadShortcutEnabled && Globals.isDebugEnabled(this._myParams.myEngine) && Globals.getGamepads(this._myParams.myEngine)[InputUtils.getOppositeHandedness(this._myParams.myHandedness)].getButtonInfo(GamepadButtonID.THUMBSTICK).isPressed()) {
      this._myParams.myPlayerTransformManager.getPlayerHeadManager().moveFeet(headMovement);
    } else if (this._myParams.myMoveThroughCollisionShortcutEnabled && Globals.isDebugEnabled(this._myParams.myEngine) && Globals.getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.THUMBSTICK).isPressed()) {
      this._myParams.myPlayerTransformManager.move(headMovement, this._myLocomotionRuntimeParams.myCollisionRuntimeParams, true);
      if (horizontalMovement) {
        this._myParams.myPlayerTransformManager.resetReal();
      }
    } else {
      if (!this._myLocomotionRuntimeParams.myIsFlying) {
        this._myLocomotionRuntimeParams.myGravitySpeed += this._myParams.myGravityAcceleration * dt;
        if (Math.abs(this._myLocomotionRuntimeParams.myGravitySpeed) > Math.abs(this._myParams.myMaxGravitySpeed)) {
          this._myLocomotionRuntimeParams.myGravitySpeed = Math.pp_sign(this._myParams.myGravityAcceleration) * Math.abs(this._myParams.myMaxGravitySpeed);
        }
        verticalMovement = playerUp.vec3_scale(this._myLocomotionRuntimeParams.myGravitySpeed * dt, verticalMovement);
        headMovement = headMovement.vec3_add(verticalMovement, headMovement);
      } else {
        this._myLocomotionRuntimeParams.myGravitySpeed = 0;
      }
      feetTransformQuat = this._myParams.myPlayerTransformManager.getTransformQuat(feetTransformQuat);
      this._myParams.myPlayerTransformManager.move(headMovement, this._myLocomotionRuntimeParams.myCollisionRuntimeParams);
      if (horizontalMovement) {
        this._myParams.myPlayerTransformManager.resetReal();
        this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myFixedMovement.vec3_removeComponentAlongAxis(
          this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myOriginalUp,
          this._myLastHorizontalMovement
        );
      }
      if (this._myLocomotionRuntimeParams.myGravitySpeed > 0 && this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnCeiling || this._myLocomotionRuntimeParams.myGravitySpeed < 0 && this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnGround) {
        this._myLocomotionRuntimeParams.myGravitySpeed = 0;
      }
    }
    if (this._myLocomotionRuntimeParams.myCollisionRuntimeParams.myIsOnGround) {
      this._myLocomotionRuntimeParams.myIsFlying = false;
      this._myCurrentDirectionConverter.resetFly();
    }
  };
}();
PlayerLocomotionSmooth.prototype._onXRSessionStart = function() {
  return function _onXRSessionStart(session) {
    switch (this._myParams.myVRDirectionReferenceType) {
      case 0:
        this._myDirectionReference = Globals.getPlayerObjects(this._myParams.myEngine).myHead;
        break;
      case 1:
        this._myDirectionReference = Globals.getPlayerObjects(this._myParams.myEngine).myHands[this._myParams.myHandedness];
        break;
      case 2:
        this._myDirectionReference = this._myParams.myVRDirectionReferenceObject;
        break;
    }
    this._myCurrentDirectionConverter = this._myDirectionConverterVR;
    this._myCurrentDirectionConverter.resetFly();
  };
}();
PlayerLocomotionSmooth.prototype._onXRSessionEnd = function() {
  return function _onXRSessionEnd(session) {
    this._myDirectionReference = Globals.getPlayerObjects(this._myParams.myEngine).myHead;
    this._myCurrentDirectionConverter = this._myDirectionConverterNonVR;
    this._myCurrentDirectionConverter.resetFly();
  };
}();
Object.defineProperty(PlayerLocomotionSmooth.prototype, "_onXRSessionStart", { enumerable: false });
Object.defineProperty(PlayerLocomotionSmooth.prototype, "_onXRSessionEnd", { enumerable: false });

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion_component.js
var PlayerLocomotionComponent = class extends Component {
  start() {
    CollisionCheckBridge.initBridge(this.engine);
    let params = new PlayerLocomotionParams(this.engine);
    params.myDefaultLocomotionType = this._myDefaultLocomotionType;
    params.mySwitchLocomotionTypeShortcutEnabled = this._mySwitchLocomotionTypeShortcutEnabled;
    params.myDefaultHeight = this._myDefaultHeight;
    params.myMaxSpeed = this._myMaxSpeed;
    params.myMaxRotationSpeed = this._myMaxRotationSpeed;
    params.myGravityAcceleration = this._myGravityAcceleration;
    params.myMaxGravitySpeed = this._myMaxGravitySpeed;
    params.myCharacterRadius = this._myCharacterRadius;
    params.mySpeedSlowDownPercentageOnWallSlid = this._mySpeedSlowDownPercentageOnWallSlid;
    params.myIsSnapTurn = this._myIsSnapTurn;
    params.mySnapTurnOnlyVR = this._mySnapTurnOnlyVR;
    params.mySnapTurnAngle = this._mySnapTurnAngle;
    params.mySnapTurnSpeedDegrees = this._mySnapTurnSpeedDegrees;
    params.myFlyEnabled = this._myFlyEnabled;
    params.myStartFlying = this._myStartFlying;
    params.myMinAngleToFlyUpNonVR = this._myMinAngleToFlyUpNonVR;
    params.myMinAngleToFlyDownNonVR = this._myMinAngleToFlyDownNonVR;
    params.myMinAngleToFlyUpVR = this._myMinAngleToFlyUpVR;
    params.myMinAngleToFlyDownVR = this._myMinAngleToFlyDownVR;
    params.myMinAngleToFlyRight = this._myMinAngleToFlyRight;
    params.myMainHand = InputUtils.getHandednessByIndex(this._myMainHand);
    params.myDirectionInvertForwardWhenUpsideDown = this._myDirectionInvertForwardWhenUpsideDown;
    params.myVRDirectionReferenceType = this._myVRDirectionReferenceType;
    params.myVRDirectionReferenceObject = this._myVRDirectionReferenceObject;
    params.myForeheadExtraHeight = 0.1;
    params.myTeleportType = this._myTeleportType;
    params.myTeleportMaxDistance = this._myTeleportMaxDistance;
    params.myTeleportMaxHeightDifference = this._myTeleportMaxHeightDifference;
    params.myTeleportRotationOnUpEnabled = this._myTeleportRotationOnUpEnabled;
    params.myTeleportValidMaterial = this._myTeleportValidMaterial;
    params.myTeleportInvalidMaterial = this._myTeleportInvalidMaterial;
    params.myTeleportPositionObject = this._myTeleportPositionObject;
    params.myTeleportPositionObjectRotateWithHead = this._myTeleportPositionObjectRotateWithHead;
    params.myTeleportParableStartReferenceObject = this._myTeleportParableStartReferenceObject;
    params.mySyncWithRealWorldPositionOnlyIfValid = this._mySyncWithRealWorldPositionOnlyIfValid;
    params.myViewOcclusionInsideWallsEnabled = this._myViewOcclusionInsideWallsEnabled;
    params.myColliderAccuracy = this._myColliderAccuracy;
    params.myColliderCheckOnlyFeet = this._myColliderCheckOnlyFeet;
    params.myColliderSlideAlongWall = this._myColliderSlideAlongWall;
    params.myColliderMaxWalkableGroundAngle = this._myColliderMaxWalkableGroundAngle;
    params.myColliderSnapOnGround = this._myColliderSnapOnGround;
    params.myColliderMaxDistanceToSnapOnGround = this._myColliderMaxDistanceToSnapOnGround;
    params.myColliderMaxWalkableGroundStepHeight = this._myColliderMaxWalkableGroundStepHeight;
    params.myColliderPreventFallingFromEdges = this._myColliderPreventFallingFromEdges;
    params.myMoveThroughCollisionShortcutEnabled = this._myMoveThroughCollisionShortcutEnabled;
    params.myMoveHeadShortcutEnabled = this._myMoveHeadShortcutEnabled;
    params.myTripleSpeedShortcutEnabled = this._myTripleSpeedShortcutEnabled;
    params.myDebugHorizontalEnabled = this._myDebugHorizontalEnabled;
    params.myDebugVerticalEnabled = this._myDebugVerticalEnabled;
    params.myPhysicsBlockLayerFlags.copy(this._getPhysicsBlockLayersFlags());
    this._myPlayerLocomotion = new PlayerLocomotion(params);
    this._myStartCounter = 1;
    this._myResetReal = true;
  }
  update(dt) {
    if (this._myStartCounter > 0) {
      this._myStartCounter--;
      if (this._myStartCounter == 0) {
        this._myPlayerLocomotion.start();
      }
      this._myPlayerLocomotion.getPlayerHeadManager().update(dt);
    } else {
      if (this._myResetReal) {
        this._myResetReal = false;
        this._myPlayerLocomotion.getPlayerTransformManager().resetReal(true, true);
      }
      CollisionCheckBridge.getCollisionCheck(this.engine)._myTotalRaycasts = 0;
      this._myPlayerLocomotion.update(dt);
    }
  }
  getPlayerLocomotion() {
    return this._myPlayerLocomotion;
  }
  onActivate() {
    if (this._myStartCounter == 0) {
      if (this._myPlayerLocomotion != null) {
        this._myPlayerLocomotion.setActive(true);
      }
    }
  }
  onDeactivate() {
    if (this._myStartCounter == 0) {
      if (this._myPlayerLocomotion != null) {
        this._myPlayerLocomotion.setActive(false);
      }
    }
  }
  _getPhysicsBlockLayersFlags() {
    let physicsFlags = new PhysicsLayerFlags();
    let flags = [...this._myPhysicsBlockLayerFlags.split(",")];
    for (let i = 0; i < flags.length; i++) {
      physicsFlags.setFlagActive(i, flags[i].trim() == "1");
    }
    return physicsFlags;
  }
  onDestroy() {
    this._myPlayerLocomotion?.destroy();
  }
};
__publicField(PlayerLocomotionComponent, "TypeName", "pp-player-locomotion");
__publicField(PlayerLocomotionComponent, "Properties", {
  _myDefaultLocomotionType: Property.enum(["Smooth", "Teleport"], "Smooth"),
  _mySwitchLocomotionTypeShortcutEnabled: Property.bool(true),
  // double press main hand (default left) thumbstick to switch
  _myPhysicsBlockLayerFlags: Property.string("0, 0, 0, 0, 0, 0, 0, 0"),
  _myDefaultHeight: Property.float(1.75),
  _myCharacterRadius: Property.float(0.3),
  _myMaxSpeed: Property.float(2),
  _myMaxRotationSpeed: Property.float(100),
  _myGravityAcceleration: Property.float(-20),
  _myMaxGravitySpeed: Property.float(-15),
  _mySpeedSlowDownPercentageOnWallSlid: Property.float(1),
  _myIsSnapTurn: Property.bool(true),
  _mySnapTurnOnlyVR: Property.bool(true),
  _mySnapTurnAngle: Property.float(30),
  _mySnapTurnSpeedDegrees: Property.float(0),
  _myFlyEnabled: Property.bool(false),
  _myStartFlying: Property.bool(false),
  _myMinAngleToFlyUpNonVR: Property.float(30),
  _myMinAngleToFlyDownNonVR: Property.float(50),
  _myMinAngleToFlyUpVR: Property.float(60),
  _myMinAngleToFlyDownVR: Property.float(1),
  _myMinAngleToFlyRight: Property.float(60),
  _myMainHand: Property.enum(["Left", "Right"], "Left"),
  _myDirectionInvertForwardWhenUpsideDown: Property.bool(true),
  _myVRDirectionReferenceType: Property.enum(["Head", "Hand", "Custom Object"], "Head"),
  _myVRDirectionReferenceObject: Property.object(),
  _myTeleportType: Property.enum(["Instant", "Blink", "Shift"], "Shift"),
  _myTeleportMaxDistance: Property.float(3),
  _myTeleportMaxHeightDifference: Property.float(1.25),
  _myTeleportRotationOnUpEnabled: Property.bool(false),
  _myTeleportValidMaterial: Property.material(),
  _myTeleportInvalidMaterial: Property.material(),
  _myTeleportPositionObject: Property.object(),
  _myTeleportPositionObjectRotateWithHead: Property.bool(true),
  _myTeleportParableStartReferenceObject: Property.object(),
  // these 2 flags works 100% properly only if both true or false
  _mySyncWithRealWorldPositionOnlyIfValid: Property.bool(true),
  // valid means the real player has not moved inside walls
  _myViewOcclusionInsideWallsEnabled: Property.bool(true),
  _myColliderAccuracy: Property.enum(["Very Low", "Low", "Medium", "High", "Very High"], "High"),
  _myColliderCheckOnlyFeet: Property.bool(false),
  _myColliderSlideAlongWall: Property.bool(true),
  _myColliderMaxWalkableGroundAngle: Property.float(30),
  _myColliderSnapOnGround: Property.bool(true),
  _myColliderMaxDistanceToSnapOnGround: Property.float(0.1),
  _myColliderMaxWalkableGroundStepHeight: Property.float(0.1),
  _myColliderPreventFallingFromEdges: Property.bool(false),
  _myDebugHorizontalEnabled: Property.bool(false),
  _myDebugVerticalEnabled: Property.bool(false),
  _myMoveThroughCollisionShortcutEnabled: Property.bool(false),
  // main hand (default left) thumbstick pressed while moving
  _myMoveHeadShortcutEnabled: Property.bool(false),
  // non main hand (default right) thumbstick pressed while moving
  _myTripleSpeedShortcutEnabled: Property.bool(false)
  // main hand (default left) select pressed while moving
});

// js/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_detection_state_visibility.js
PlayerLocomotionTeleportDetectionState.prototype._isTeleportPositionVisible = function() {
  let playerUp = vec3_create();
  let offsetFeetTeleportPosition = vec3_create();
  let headTeleportPosition = vec3_create();
  return function _isTeleportPositionVisible(teleportPosition) {
    let isVisible = true;
    if (this._myTeleportParams.myDetectionParams.myTeleportFeetPositionMustBeVisible || this._myTeleportParams.myDetectionParams.myTeleportHeadPositionMustBeVisible || this._myTeleportParams.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible) {
      playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
      let isHeadVisible = false;
      let isFeetVisible = false;
      if (this._myTeleportParams.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible || this._myTeleportParams.myDetectionParams.myTeleportHeadPositionMustBeVisible) {
        let headheight = this._myTeleportParams.myPlayerHeadManager.getHeightHead();
        headTeleportPosition = teleportPosition.vec3_add(playerUp.vec3_scale(headheight, headTeleportPosition), headTeleportPosition);
        isHeadVisible = this._isPositionVisible(headTeleportPosition);
      } else {
        isHeadVisible = true;
      }
      if (this._myTeleportParams.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible && isHeadVisible) {
        isFeetVisible = true;
      } else {
        if (this._myTeleportParams.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible || this._myTeleportParams.myDetectionParams.myTeleportFeetPositionMustBeVisible && isHeadVisible) {
          offsetFeetTeleportPosition = teleportPosition.vec3_add(playerUp.vec3_scale(this._myTeleportParams.myDetectionParams.myVisibilityCheckFeetPositionVerticalOffset, offsetFeetTeleportPosition), offsetFeetTeleportPosition);
          isFeetVisible = this._isPositionVisible(offsetFeetTeleportPosition);
        } else {
          isFeetVisible = true;
        }
      }
      isVisible = isHeadVisible && isFeetVisible;
    }
    return isVisible;
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._isPositionVisible = function() {
  let playerUp = vec3_create();
  let standardUp = vec3_create(0, 1, 0);
  let standardForward = vec3_create(0, 0, 1);
  let referenceUp = vec3_create();
  let headPosition = vec3_create();
  let direction2 = vec3_create();
  let fixedRight = vec3_create();
  let fixedForward = vec3_create();
  let fixedUp = vec3_create();
  let raycastEndPosition = vec3_create();
  let raycastParams = new RaycastParams();
  let raycastResult = new RaycastResults();
  let objectsEqualCallback = (first2, second) => first2.pp_equals(second);
  return function _isPositionVisible(position) {
    let isVisible = true;
    playerUp = this._myTeleportParams.myPlayerHeadManager.getPlayer().pp_getUp(playerUp);
    let currentHead = this._myTeleportParams.myPlayerHeadManager.getHead();
    headPosition = currentHead.pp_getPosition(headPosition);
    direction2 = position.vec3_sub(headPosition, direction2).vec3_normalize(direction2);
    referenceUp.vec3_copy(standardUp);
    if (direction2.vec3_angle(standardUp) < 1e-4) {
      referenceUp.vec3_copy(standardForward);
    }
    fixedRight = direction2.vec3_cross(referenceUp, fixedRight);
    fixedUp = fixedRight.vec3_cross(direction2, fixedUp);
    fixedForward.vec3_copy(direction2);
    fixedUp.vec3_normalize(fixedUp);
    fixedForward.vec3_normalize(fixedForward);
    let checkPositions = this._getVisibilityCheckPositions(headPosition, fixedUp, fixedForward);
    let distance5 = headPosition.vec3_distance(position);
    for (let checkPosition of checkPositions) {
      raycastParams.myOrigin.vec3_copy(checkPosition);
      raycastParams.myDirection.vec3_copy(fixedForward);
      raycastParams.myDistance = distance5;
      raycastParams.myPhysics = Globals.getPhysics(this._myTeleportParams.myEngine);
      raycastParams.myBlockLayerFlags.setMask(this._myTeleportParams.myDetectionParams.myVisibilityBlockLayerFlags.getMask());
      raycastParams.myObjectsToIgnore.pp_copy(this._myTeleportParams.myCollisionCheckParams.myHorizontalObjectsToIgnore);
      for (let objectToIgnore of this._myTeleportParams.myCollisionCheckParams.myVerticalObjectsToIgnore) {
        raycastParams.myObjectsToIgnore.pp_pushUnique(objectToIgnore, objectsEqualCallback);
      }
      raycastParams.myIgnoreHitsInsideCollision = true;
      raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
      if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugVisibilityEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
        Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
      }
      if (raycastResult.isColliding()) {
        raycastEndPosition = checkPosition.vec3_add(fixedForward.vec3_scale(distance5, raycastEndPosition), raycastEndPosition);
        let hit = raycastResult.myHits.pp_first();
        if (this._myTeleportParams.myDetectionParams.myVisibilityCheckDistanceFromHitThreshold == 0 || hit.myPosition.vec3_distance(raycastEndPosition) > this._myTeleportParams.myDetectionParams.myVisibilityCheckDistanceFromHitThreshold + 1e-5) {
          isVisible = false;
          break;
        }
      }
    }
    return isVisible;
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._getVisibilityCheckPositions = function() {
  let checkPositions = [];
  let cachedCheckPositions = [];
  let currentCachedCheckPositionIndex = 0;
  let _localGetCachedCheckPosition = function() {
    let item = null;
    while (cachedCheckPositions.length <= currentCachedCheckPositionIndex) {
      cachedCheckPositions.push(vec3_create());
    }
    item = cachedCheckPositions[currentCachedCheckPositionIndex];
    currentCachedCheckPositionIndex++;
    return item;
  };
  let currentDirection = vec3_create();
  return function _getVisibilityCheckPositions(position, up, forward) {
    checkPositions.length = 0;
    currentCachedCheckPositionIndex = 0;
    {
      let tempCheckPosition = _localGetCachedCheckPosition();
      tempCheckPosition.vec3_copy(position);
      checkPositions.push(tempCheckPosition);
    }
    let radiusStep = this._myTeleportParams.myDetectionParams.myVisibilityCheckRadius / this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceStepAmount;
    let sliceAngle = 360 / this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceSliceAmount;
    let currentStepRotation = 0;
    for (let i = 0; i < this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceStepAmount; i++) {
      let currentRadius = radiusStep * (i + 1);
      currentDirection = up.vec3_rotateAxis(currentStepRotation, forward, currentDirection);
      for (let j = 0; j < this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceSliceAmount; j++) {
        let tempCheckPosition = _localGetCachedCheckPosition();
        let sliceDirection = currentDirection.vec3_rotateAxis(sliceAngle * j, forward, tempCheckPosition);
        checkPositions.push(position.vec3_add(sliceDirection.vec3_scale(currentRadius, sliceDirection), sliceDirection));
      }
      currentStepRotation += this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceRotationPerStep;
    }
    return checkPositions;
  };
}();

// js/pp/input/cauldron/components/finger_cursor_component.js
var FingerCursorComponent = class extends Component {
  init() {
    this._myLastTarget = null;
    this._myHandInputSource = null;
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myDoubleClickTimer = 0;
    this._myTripleClickTimer = 0;
    this._myMultipleClickObject = null;
    this._myMultipleClickDelay = 0.3;
  }
  start() {
    this._myCursorParentObject = this.object.pp_addObject();
    if (this._myCursorObject == null) {
      this._myCursorObject = this._myCursorParentObject.pp_addObject();
    } else {
      this._myCursorObject.pp_setParent(this._myCursorParentObject);
    }
    this._myCollisionComponent = this._myCursorObject.pp_addComponent(CollisionComponent);
    this._myCollisionComponent.collider = Collider.Sphere;
    this._myCollisionComponent.group = 1 << this._myCollisionGroup;
    this._myCollisionComponent.extents = vec3_create(this._myCollisionSize, this._myCollisionSize, this._myCollisionSize);
  }
  update(dt) {
    if (this._myDoubleClickTimer > 0) {
      this._myDoubleClickTimer -= dt;
    }
    if (this._myTripleClickTimer > 0) {
      this._myTripleClickTimer -= dt;
    }
    this._myCursorParentObject.pp_setTransformQuat(Globals.getPlayerObjects(this.engine).myReferenceSpace.pp_getTransformQuat());
    this._updateHand();
    if (this._myHandInputSource) {
      let overlaps = this._myCollisionComponent.queryOverlaps();
      let overlapTarget = null;
      for (let i = 0; i < overlaps.length; ++i) {
        let object = overlaps[i].object;
        let target = object.pp_getComponent(CursorTarget);
        if (target && (overlapTarget == null || !target.isSurface)) {
          overlapTarget = target;
          if (!target.isSurface) {
            break;
          }
        }
      }
      if (!overlapTarget) {
        this._targetTouchEnd();
      } else if (!overlapTarget.equals(this._myLastTarget)) {
        this._targetTouchEnd();
        this._myLastTarget = overlapTarget;
        this._targetTouchStart();
      }
    } else {
      this._targetTouchEnd();
    }
  }
  _targetTouchStart() {
    this._myLastTarget.onHover.notify(this._myLastTarget.object, this);
    this._myLastTarget.onDown.notify(this._myLastTarget.object, this);
  }
  _targetTouchEnd() {
    if (this._myLastTarget) {
      if (this._myMultipleClicksEnabled && this._myTripleClickTimer > 0 && this._myMultipleClickObject && this._myMultipleClickObject.pp_equals(this._myLastTarget.object)) {
        this._myLastTarget.onTripleClick.notify(this._myLastTarget.object, this);
        this._myTripleClickTimer = 0;
      } else if (this._myMultipleClicksEnabled && this._myDoubleClickTimer > 0 && this._myMultipleClickObject && this._myMultipleClickObject.pp_equals(this._myLastTarget.object)) {
        this._myLastTarget.onDoubleClick.notify(this._myLastTarget.object, this);
        this._myTripleClickTimer = this._myMultipleClickDelay;
        this._myDoubleClickTimer = 0;
      } else {
        this._myLastTarget.onClick.notify(this._myLastTarget.object, this);
        this._myTripleClickTimer = 0;
        this._myDoubleClickTimer = this._myMultipleClickDelay;
        this._myMultipleClickObject = this._myLastTarget.object;
      }
      this._myLastTarget.onUp.notify(this._myLastTarget.object, this);
      this._myLastTarget.onUnhover.notify(this._myLastTarget.object, this);
      this._myLastTarget = null;
    }
  }
  onActivate() {
    this._myCursorParentObject.pp_setActive(true);
  }
  onDeactivate() {
    this._myCursorParentObject.pp_setActive(false);
  }
  _updateHand() {
    this._myHandInputSource = InputUtils.getInputSource(this._myHandednessType, InputSourceType.TRACKED_HAND, this.engine);
    if (this._myHandInputSource) {
      let tip = XRUtils.getFrame(this.engine).getJointPose(this._myHandInputSource.hand.get(TrackedHandJointID.INDEX_FINGER_TIP), XRUtils.getReferenceSpace(this.engine));
      if (tip) {
        this._myCursorObject.pp_setRotationLocalQuat([
          tip.transform.orientation.x,
          tip.transform.orientation.y,
          tip.transform.orientation.z,
          tip.transform.orientation.w
        ]);
        this._myCursorObject.pp_setPositionLocal([
          tip.transform.position.x,
          tip.transform.position.y,
          tip.transform.position.z
        ]);
      }
    }
  }
};
__publicField(FingerCursorComponent, "TypeName", "pp-finger-cursor");
__publicField(FingerCursorComponent, "Properties", {
  _myHandedness: Property.enum(["Left", "Right"], "Left"),
  _myMultipleClicksEnabled: Property.bool(true),
  _myCollisionGroup: Property.int(1),
  _myCollisionSize: Property.float(0.0125),
  _myCursorObject: Property.object(null)
});

// js/pp/input/cauldron/components/switch_hand_object_component.js
var SwitchHandObjectComponent = class extends Component {
  start() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myFirstUpdate = true;
    this._myCurrentInputSourceType = null;
  }
  onActivate() {
    this._myFirstUpdate = true;
  }
  update(dt) {
    if (this._myFirstUpdate) {
      this._myFirstUpdate = false;
      this._start();
    }
    let inputSourceType = InputUtils.getInputSourceTypeByHandedness(this._myHandednessType, this.engine);
    if (inputSourceType != null && this._myCurrentInputSourceType != inputSourceType) {
      this._myCurrentInputSourceType = inputSourceType;
      if (inputSourceType == InputSourceType.TRACKED_HAND) {
        if (this._myGamepad != null) {
          this._myGamepad.pp_setActive(false);
        }
        if (this._myTrackedHand != null) {
          this._myTrackedHand.pp_setActive(true);
        }
      } else if (inputSourceType == InputSourceType.GAMEPAD) {
        if (this._myTrackedHand != null) {
          this._myTrackedHand.pp_setActive(false);
        }
        if (this._myGamepad != null) {
          this._myGamepad.pp_setActive(true);
        }
      }
    }
  }
  _start() {
    if (this._myGamepad != null) {
      this._myGamepad.pp_setActive(false);
    }
    if (this._myTrackedHand != null) {
      this._myTrackedHand.pp_setActive(false);
    }
    this._myCurrentInputSourceType = null;
  }
};
__publicField(SwitchHandObjectComponent, "TypeName", "pp-switch-hand-object");
__publicField(SwitchHandObjectComponent, "Properties", {
  _myHandedness: Property.enum(["Left", "Right"], "Left"),
  _myGamepad: Property.object(),
  _myTrackedHand: Property.object()
});

// js/pp/input/cauldron/components/tracked_hand_draw_joint_component.js
var TrackedHandDrawJointComponent = class extends Component {
  start() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myJointIDType = InputUtils.getJointIDByIndex(this._myJointID);
    this._buildTrackedHandHierarchy();
  }
  update(dt) {
  }
  _buildTrackedHandHierarchy() {
    this._myJointMeshObject = this.object.pp_addObject();
    let mesh = this._myJointMeshObject.pp_addComponent(MeshComponent);
    mesh.mesh = this._myJointMesh;
    mesh.material = this._myJointMaterial;
    this._myJointMeshObject.pp_setScaleLocal(0);
  }
};
__publicField(TrackedHandDrawJointComponent, "TypeName", "pp-tracked-hand-draw-joint");
__publicField(TrackedHandDrawJointComponent, "Properties", {
  _myHandedness: Property.enum(["Left", "Right"], "Left"),
  _myJointID: Property.enum(
    [
      "Wrist",
      "Thumb Metacarpal",
      "Thumb Phalanx Proximal",
      "Thumb Phalanx Distal",
      "Thumb Tip",
      "Index Metacarpal",
      "Index Phalanx Proximal",
      "Index Phalanx Intermediate",
      "Index Phalanx Distal",
      "Index Tip",
      "Middle Metacarpal",
      "Middle Phalanx Proximal",
      "Middle Phalanx Intermediate",
      "Middle Phalanx Distal",
      "Middle Tip",
      "Ring Metacarpal",
      "Ring Phalanx Proximal",
      "Ring Phalanx Intermediate",
      "Ring Phalanx Distal",
      "Ring Tip",
      "Pinky Metacarpal",
      "Pinky Phalanx Proximal",
      "Pinky Phalanx Intermediate",
      "Pinky Phalanx Distal",
      "Pinky Tip"
    ],
    "Wrist"
  ),
  _myJointMesh: Property.mesh(),
  _myJointMaterial: Property.material()
});
TrackedHandDrawJointComponent.prototype.update = function() {
  let transformQuat4 = quat2_create();
  return function update(dt) {
    let jointPose = Globals.getTrackedHandPose(this._myHandednessType, this.engine).getJointPose(this._myJointIDType);
    this._myJointMeshObject.pp_setTransformLocalQuat(jointPose.getTransformQuat(transformQuat4, null));
    this._myJointMeshObject.pp_setScaleLocal(jointPose.getJointRadius());
  };
}();

// js/pp/input/cauldron/components/tracked_hand_draw_all_joints_component.js
var TrackedHandDrawAllJointsComponent = class extends Component {
  start() {
    this._buildTrackedHandHierarchy();
  }
  _buildTrackedHandHierarchy() {
    this._myTrackedHandMeshObject = this.object.pp_addObject();
    this._myJointMeshObjectList = [];
    for (let jointIDKey in TrackedHandJointID) {
      let jointID = TrackedHandJointID[jointIDKey];
      if (!this._myHideMetacarpals || jointID != TrackedHandJointID.THUMB_METACARPAL && jointID != TrackedHandJointID.INDEX_FINGER_METACARPAL && jointID != TrackedHandJointID.MIDDLE_FINGER_METACARPAL && jointID != TrackedHandJointID.RING_FINGER_METACARPAL && jointID != TrackedHandJointID.PINKY_FINGER_METACARPAL) {
        let jointObject = this._myTrackedHandMeshObject.pp_addObject();
        this._myJointMeshObjectList[jointID] = jointObject;
        jointObject.pp_addComponent(
          TrackedHandDrawJointComponent,
          {
            "_myHandedness": this._myHandedness,
            "_myJointID": TrackedHandJointIDIndex[jointIDKey],
            "_myJointMesh": this._myJointMesh,
            "_myJointMaterial": this._myJointMaterial
          }
        );
      }
    }
  }
};
__publicField(TrackedHandDrawAllJointsComponent, "TypeName", "pp-tracked-hand-draw-all-joints");
__publicField(TrackedHandDrawAllJointsComponent, "Properties", {
  _myHandedness: Property.enum(["Left", "Right"], "Left"),
  _myHideMetacarpals: Property.bool(true),
  _myJointMesh: Property.mesh(),
  _myJointMaterial: Property.material()
});

// js/pp/input/cauldron/components/tracked_hand_draw_skin_component.js
var TrackedHandDrawSkinComponent = class extends Component {
  start() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._prepareJoints();
  }
  update(dt) {
  }
  _prepareJoints() {
    this._myJoints = [];
    let skinJointIDs = this._myHandSkin.jointIds;
    for (let i = 0; i < skinJointIDs.length; i++) {
      this._myJoints[i] = ObjectUtils.wrapObject(skinJointIDs[i]);
    }
  }
};
__publicField(TrackedHandDrawSkinComponent, "TypeName", "pp-tracked-hand-draw-skin");
__publicField(TrackedHandDrawSkinComponent, "Properties", {
  _myHandedness: Property.enum(["Left", "Right"], "Left"),
  _myHandSkin: Property.skin(null)
});
TrackedHandDrawSkinComponent.prototype.update = function() {
  let transformQuat4 = quat2_create();
  return function update(dt) {
    for (let i = 0; i < this._myJoints.length; i++) {
      let jointObject = this._myJoints[i];
      let jointID = jointObject.pp_getName();
      let jointPose = Globals.getTrackedHandPose(this._myHandednessType, this.engine).getJointPose(jointID);
      jointObject.pp_setTransformLocalQuat(jointPose.getTransformQuat(transformQuat4, null));
    }
  };
}();

// js/pp/input/gamepad/cauldron/gamepad_mesh_animator_component.js
var GamepadMeshAnimatorComponent = class extends Component {
  start() {
    let gamepad = null;
    if (this._myHandedness == HandednessIndex.LEFT) {
      gamepad = Globals.getLeftGamepad(this.engine);
    } else {
      gamepad = Globals.getRightGamepad(this.engine);
    }
    if (this._mySelect != null) {
      this._mySelectOriginalRotation = this._mySelect.pp_getRotationLocalQuat();
      this._mySelectOriginalLeft = this._mySelect.pp_getLeftLocal();
    }
    if (this._mySqueeze != null) {
      this._mySqueezeOriginalPosition = this._mySqueeze.pp_getPositionLocal();
      this._mySqueezeOriginalRotation = this._mySqueeze.pp_getRotationLocalQuat();
      this._mySqueezeOriginalLeft = this._mySqueeze.pp_getLeftLocal();
      this._mySqueezeOriginalForward = this._mySqueeze.pp_getForwardLocal();
    }
    if (this._myThumbstick != null) {
      this._myThumbstickOriginalPosition = this._myThumbstick.pp_getPositionLocal();
      this._myThumbstickOriginalRotation = this._myThumbstick.pp_getRotationLocalQuat();
      this._myThumbstickOriginalLeft = this._myThumbstick.pp_getLeftLocal();
      this._myThumbstickOriginalUp = this._myThumbstick.pp_getUpLocal();
      this._myThumbstickOriginalForward = this._myThumbstick.pp_getForwardLocal();
    }
    if (this._myTopButton != null) {
      this._myTopButtonOriginalPosition = this._myTopButton.pp_getPositionLocal();
      this._myTopButtonOriginalUp = this._myTopButton.pp_getUpLocal();
    }
    if (this._myBottomButton != null) {
      this._myBottomButtonOriginalPosition = this._myBottomButton.pp_getPositionLocal();
      this._myBottomButtonOriginalUp = this._myBottomButton.pp_getUpLocal();
    }
    if (this._myThumbstick != null) {
      gamepad.registerButtonEventListener(GamepadButtonID.THUMBSTICK, GamepadButtonEvent.PRESS_START, this, this._thumbstickPressedStart.bind(this));
      gamepad.registerButtonEventListener(GamepadButtonID.THUMBSTICK, GamepadButtonEvent.PRESS_END, this, this._thumbstickPressedEnd.bind(this));
    }
    if (this._myTopButton != null) {
      gamepad.registerButtonEventListener(GamepadButtonID.TOP_BUTTON, GamepadButtonEvent.PRESS_START, this, this._topButtonPressedStart.bind(this));
      gamepad.registerButtonEventListener(GamepadButtonID.TOP_BUTTON, GamepadButtonEvent.PRESS_END, this, this._topButtonPressedEnd.bind(this));
    }
    if (this._myBottomButton != null) {
      gamepad.registerButtonEventListener(GamepadButtonID.BOTTOM_BUTTON, GamepadButtonEvent.PRESS_START, this, this._bottomButtonPressedStart.bind(this));
      gamepad.registerButtonEventListener(GamepadButtonID.BOTTOM_BUTTON, GamepadButtonEvent.PRESS_END, this, this._bottomButtonPressedEnd.bind(this));
    }
    if (this._mySelect != null) {
      gamepad.registerButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.VALUE_CHANGED, this, this._selectValueChanged.bind(this));
    }
    if (this._mySqueeze != null) {
      gamepad.registerButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.VALUE_CHANGED, this, this._squeezeValueChanged.bind(this));
    }
    if (this._myThumbstick != null) {
      gamepad.registerAxesEventListener(GamepadAxesID.THUMBSTICK, GamepadAxesEvent.AXES_CHANGED, this, this._thumbstickValueChanged.bind(this));
    }
  }
  _thumbstickPressedStart() {
  }
  _thumbstickPressedEnd(buttonInfo, gamepad) {
    this._myThumbstick.pp_setPositionLocal(this._myThumbstickOriginalPosition);
  }
  _topButtonPressedStart(buttonInfo, gamepad) {
    this._myTopButton.pp_translateAxisLocal(-this._myTopButtonPressOffset, this._myTopButtonOriginalUp);
  }
  _topButtonPressedEnd(buttonInfo, gamepad) {
    this._myTopButton.pp_setPositionLocal(this._myTopButtonOriginalPosition);
  }
  _bottomButtonPressedStart(buttonInfo, gamepad) {
    this._myBottomButton.pp_translateAxisLocal(-this._myBottomButtonPressOffset, this._myBottomButtonOriginalUp);
  }
  _bottomButtonPressedEnd(buttonInfo, gamepad) {
    this._myBottomButton.pp_setPositionLocal(this._myBottomButtonOriginalPosition);
  }
  _selectValueChanged(buttonInfo, gamepad) {
    this._mySelect.pp_setRotationLocalQuat(this._mySelectOriginalRotation);
    if (buttonInfo.getValue() > 1e-5) {
      this._mySelect.pp_rotateAxisLocal(this._mySelectRotateAngle * buttonInfo.getValue(), this._mySelectOriginalLeft);
    }
  }
  _squeezeValueChanged(buttonInfo, gamepad) {
    this._mySqueeze.pp_setPositionLocal(this._mySqueezeOriginalPosition);
    this._mySqueeze.pp_setRotationLocalQuat(this._mySqueezeOriginalRotation);
    if (buttonInfo.getValue() > 1e-5) {
      if (this._myUsePressForSqueeze) {
        let translation = this._mySqueezePressOffset;
        if (this._myHandedness == 1) {
          translation *= -1;
        }
        this._mySqueeze.pp_translateAxisLocal(translation * buttonInfo.getValue(), this._mySqueezeOriginalLeft);
      } else {
        let rotation = -this._mySqueezeRotateAngle;
        if (this._myHandedness == 1) {
          rotation *= -1;
        }
        this._mySqueeze.pp_rotateAxisLocal(rotation * buttonInfo.getValue(), this._mySqueezeOriginalForward);
      }
    }
  }
  _thumbstickValueChanged(axesInfo, gamepad) {
    this._myThumbstick.pp_setRotationLocalQuat(this._myThumbstickOriginalRotation);
    let leftRotation = this._myThumbstickRotateAngle * axesInfo.myAxes[1];
    let forwardRotation = this._myThumbstickRotateAngle * axesInfo.myAxes[0];
    if (Math.abs(leftRotation) > 1e-4) {
      this._myThumbstick.pp_rotateAxisLocal(leftRotation, this._myThumbstickOriginalLeft);
    }
    if (Math.abs(forwardRotation) > 1e-4) {
      this._myThumbstick.pp_rotateAxisLocal(forwardRotation, this._myThumbstickOriginalForward);
    }
  }
};
__publicField(GamepadMeshAnimatorComponent, "TypeName", "pp-gamepad-mesh-animator");
__publicField(GamepadMeshAnimatorComponent, "Properties", {
  _myHandedness: Property.enum(["Left", "Right"], "Left"),
  _mySelect: Property.object(null),
  _mySqueeze: Property.object(null),
  _myThumbstick: Property.object(null),
  _myTopButton: Property.object(null),
  _myBottomButton: Property.object(null),
  _mySelectRotateAngle: Property.float(15),
  _mySqueezeRotateAngle: Property.float(11),
  _myThumbstickRotateAngle: Property.float(15),
  _myThumbstickPressOffset: Property.float(625e-6),
  _myTopButtonPressOffset: Property.float(15e-4),
  _myBottomButtonPressOffset: Property.float(15e-4),
  _myUsePressForSqueeze: Property.bool(false),
  _mySqueezePressOffset: Property.float(15e-4)
});
GamepadMeshAnimatorComponent.prototype._thumbstickPressedStart = function() {
  let upTranslation = vec3_create();
  return function _thumbstickPressedStart(buttonInfo, gamepad) {
    this._myThumbstickOriginalUp.vec3_scale(-this._myThumbstickPressOffset, upTranslation);
    this._myThumbstick.pp_translateLocal(upTranslation);
  };
}();

// js/pp/input/gamepad/cauldron/gamepad_utils.js
var _mySimultaneousPressMaxDelay = 0.15;
var _mySimultaneousTouchMaxDelay = 0.15;
function setSimultaneousPressMaxDelay(simultaneousPressMaxDelay) {
  _mySimultaneousPressMaxDelay = simultaneousPressMaxDelay;
}
function setSimultaneousTouchMaxDelay(simultaneousTouchMaxDelay) {
  _mySimultaneousTouchMaxDelay = simultaneousTouchMaxDelay;
}
function getSimultaneousPressMaxDelay() {
  return _mySimultaneousPressMaxDelay;
}
function getSimultaneousTouchMaxDelay() {
  return _mySimultaneousTouchMaxDelay;
}
function isAnyButtonPressStart(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let atLeastOneButtonPressStart = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (button.isPressStart(multiplePressCount)) {
        atLeastOneButtonPressStart = true;
        break;
      }
    }
    if (atLeastOneButtonPressStart) {
      break;
    }
  }
  return atLeastOneButtonPressStart;
}
function areButtonsPressStart(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let areButtonPressedRecently = true;
  let atLeastOneButtonPressStart = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (!(button.myPressed && (multiplePressCount == null || button.myMultiplePressStartCount == multiplePressCount) && button.myTimePressed < _mySimultaneousPressMaxDelay)) {
        areButtonPressedRecently = false;
        break;
      }
      if (button.isPressStart(multiplePressCount)) {
        atLeastOneButtonPressStart = true;
      }
    }
    if (!areButtonPressedRecently) {
      break;
    }
  }
  return areButtonPressedRecently && atLeastOneButtonPressStart;
}
function isAnyButtonPressEnd(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let atLeastOneButtonPressEnd = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (button.isPressEnd(multiplePressCount)) {
        atLeastOneButtonPressEnd = true;
        break;
      }
    }
    if (atLeastOneButtonPressEnd) {
      break;
    }
  }
  return atLeastOneButtonPressEnd;
}
function areButtonsPressEnd(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let areButtonNotPressedRecently = true;
  let atLeastOneButtonPressEnd = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (!(!button.myPressed && (multiplePressCount == null || button.myMultiplePressEndCount == multiplePressCount) && button.myTimeNotPressed < _mySimultaneousPressMaxDelay)) {
        areButtonNotPressedRecently = false;
        break;
      }
      if (button.isPressEnd(multiplePressCount)) {
        atLeastOneButtonPressEnd = true;
      }
    }
    if (!areButtonNotPressedRecently) {
      break;
    }
  }
  return areButtonNotPressedRecently && atLeastOneButtonPressEnd;
}
function isAnyButtonTouchStart(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let atLeastOneButtonTouchStart = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (button.isTouchStart(multiplePressCount)) {
        atLeastOneButtonTouchStart = true;
        break;
      }
    }
    if (atLeastOneButtonTouchStart) {
      break;
    }
  }
  return atLeastOneButtonTouchStart;
}
function areButtonsTouchStart(...gamepadButtonIDsList) {
  let multipleTouchCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multipleTouchCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let areButtonTouchedRecently = true;
  let atLeastOneButtonTouchStart = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (!(button.myTouched && (multipleTouchCount == null || button.myMultipleTouchStartCount == multipleTouchCount) && button.myTimeTouched < _mySimultaneousTouchMaxDelay)) {
        areButtonTouchedRecently = false;
        break;
      }
      if (button.isTouchStart(multipleTouchCount)) {
        atLeastOneButtonTouchStart = true;
      }
    }
    if (!areButtonTouchedRecently) {
      break;
    }
  }
  return areButtonTouchedRecently && atLeastOneButtonTouchStart;
}
function isAnyButtonTouchEnd(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let atLeastOneButtonTouchEnd = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (button.isTouchEnd(multiplePressCount)) {
        atLeastOneButtonTouchEnd = true;
        break;
      }
    }
    if (atLeastOneButtonTouchEnd) {
      break;
    }
  }
  return atLeastOneButtonTouchEnd;
}
function areButtonsTouchEnd(...gamepadButtonIDsList) {
  let multipleTouchCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multipleTouchCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let areButtonNotTouchedRecently = true;
  let atLeastOneButtonTouchEnd = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (!(!button.myTouched && (multipleTouchCount == null || button.myMultipleTouchEndCount == multipleTouchCount) && button.myTimeNotTouched < _mySimultaneousTouchMaxDelay)) {
        areButtonNotTouchedRecently = false;
        break;
      }
      if (button.isTouchEnd(multipleTouchCount)) {
        atLeastOneButtonTouchEnd = true;
      }
    }
    if (!areButtonNotTouchedRecently) {
      break;
    }
  }
  return areButtonNotTouchedRecently && atLeastOneButtonTouchEnd;
}
var GamepadUtils = {
  setSimultaneousPressMaxDelay,
  setSimultaneousTouchMaxDelay,
  getSimultaneousPressMaxDelay,
  getSimultaneousTouchMaxDelay,
  isAnyButtonPressStart,
  areButtonsPressStart,
  areButtonsPressEnd,
  isAnyButtonTouchStart,
  areButtonsTouchStart,
  isAnyButtonTouchEnd,
  areButtonsTouchEnd
};

// js/pp/input/gamepad/cauldron/gamepad_control_scheme_component.js
var GamepadControlSchemeComponent = class extends Component {
  start() {
    this._myTextMaterialFinal = this._myTextMaterial != null ? this._myTextMaterial : Globals.getDefaultMaterials(this.engine).myText.clone();
    this._myLineMaterialFinal = this._myLineMaterial != null ? this._myLineMaterial : Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myControlSchemeDirection = this._myHandednessType == Handedness.LEFT ? 1 : -1;
    this._myVisible = false;
    this._mySetVisibleNextUpdate = false;
    this._createControlScheme();
    this.setVisible(this._myShowOnStart);
    this._myVisibleBackup = this._myVisible;
  }
  update(dt) {
    if (this._mySetVisibleNextUpdate) {
      this._mySetVisibleNextUpdate = false;
      this.setVisible(false);
      this.setVisible(this._myVisibleBackup);
    }
  }
  onActivate() {
    this._mySetVisibleNextUpdate = true;
  }
  onDeactivate() {
    this._myVisibleBackup = this._myVisible;
    this.setVisible(false);
  }
  isVisible() {
    return this._myVisible;
  }
  setVisible(visible) {
    this._myVisible = visible;
    if (this._myParentObject != null) {
      this._myParentObject.pp_setActive(this._myVisible);
      if (this._myVisible) {
        this._hideEmptySchemes();
      }
    }
  }
  setSelectText(text) {
    this._mySelectText = text;
    this._mySelectTextComponent.text = this._mySelectText;
    this.setVisible(this._myVisible);
  }
  setSqueezeText(text) {
    this._mySqueezeText = text;
    this._mySqueezeTextComponent.text = this._mySqueezeText;
    this.setVisible(this._myVisible);
  }
  setThumbstickText(text) {
    this._myThumbstickText = text;
    this._myThumbstickTextComponent.text = this._myThumbstickText;
    this.setVisible(this._myVisible);
  }
  setBottomButtonText(text) {
    this._myBottomButtonText = text;
    this._myBottomButtonTextComponent.text = this._myBottomButtonText;
    this.setVisible(this._myVisible);
  }
  setTopButtonText(text) {
    this._myTopButtonText = text;
    this._myTopButtonTextComponent.text = this._myTopButtonText;
    this.setVisible(this._myVisible);
  }
  _createControlScheme() {
    this._myParentObject = this.object.pp_addObject();
    let distanceFromButton = 0.02 * this._myDistanceFromButtonsMultiplier;
    let lineLength = 0.0935 * this._myLineLengthMultiplier;
    let referenceObject = this._myThumbstick;
    this._mySelectObject = this._myParentObject.pp_addObject();
    this._mySelectTextComponent = this._addScheme(
      this._mySelect,
      referenceObject,
      vec3_create(0, 0, distanceFromButton),
      vec3_create(lineLength * this._myControlSchemeDirection, 0, 0),
      this._mySelectObject
    );
    this._mySelectTextComponent.text = this._mySelectText;
    this._mySqueezeObject = this._myParentObject.pp_addObject();
    this._mySqueezeTextComponent = this._addScheme(
      this._mySqueeze,
      referenceObject,
      vec3_create(distanceFromButton * this._myControlSchemeDirection, 0, 0),
      vec3_create(lineLength * this._myControlSchemeDirection, 0, 0),
      this._mySqueezeObject
    );
    this._mySqueezeTextComponent.text = this._mySqueezeText;
    this._myThumbstickObject = this._myParentObject.pp_addObject();
    this._myThumbstickTextComponent = this._addScheme(
      this._myThumbstick,
      referenceObject,
      vec3_create(0, distanceFromButton, 0),
      vec3_create(-lineLength * this._myControlSchemeDirection, 0, 0),
      this._myThumbstickObject
    );
    this._myThumbstickTextComponent.text = this._myThumbstickText;
    let thumbstickPositionLocal = this._myThumbstick.pp_getPositionLocal();
    let thumbstickUpLocal = this._myThumbstick.pp_getUpLocal();
    {
      let bottomButtonPositionLocal = this._myBottomButton.pp_getPositionLocal();
      let difference = bottomButtonPositionLocal.vec3_sub(thumbstickPositionLocal);
      let differenceOnUp = difference.vec3_valueAlongAxis(thumbstickUpLocal);
      this._myBottomButtonObject = this._myParentObject.pp_addObject();
      this._myBottomButtonTextComponent = this._addScheme(
        this._myBottomButton,
        referenceObject,
        vec3_create(0, distanceFromButton - differenceOnUp, 0),
        vec3_create(0, 0, -lineLength),
        this._myBottomButtonObject
      );
      this._myBottomButtonTextComponent.text = this._myBottomButtonText;
    }
    {
      let topButtonPositionLocal = this._myTopButton.pp_getPositionLocal();
      let difference = topButtonPositionLocal.vec3_sub(thumbstickPositionLocal);
      let differenceOnUp = difference.vec3_valueAlongAxis(thumbstickUpLocal);
      this._myTopButtonObject = this._myParentObject.pp_addObject();
      this._myTopButtonTextComponent = this._addScheme(
        this._myTopButton,
        referenceObject,
        vec3_create(0, distanceFromButton - differenceOnUp, 0),
        vec3_create(-lineLength * this._myControlSchemeDirection, 0, 0).vec3_rotateAxis(-45 * this._myControlSchemeDirection, vec3_create(0, 1, 0)),
        this._myTopButtonObject
      );
      this._myTopButtonTextComponent.text = this._myTopButtonText;
    }
  }
  _addScheme(buttonObject, referenceObject, startOffset, endOffset, parentObject) {
    let buttonPosition = buttonObject.pp_getPositionLocal();
    let referenceForward = referenceObject.pp_getForwardLocal();
    let referenceRight = referenceObject.pp_getRightLocal();
    let referenceUp = referenceObject.pp_getUpLocal();
    let lineStart = buttonPosition.vec3_add(referenceRight.vec3_scale(startOffset[0]));
    lineStart.vec3_add(referenceUp.vec3_scale(startOffset[1]), lineStart);
    lineStart.vec3_add(referenceForward.vec3_scale(startOffset[2]), lineStart);
    let lineEnd = lineStart.vec3_add(referenceRight.vec3_scale(endOffset[0]));
    lineEnd.vec3_add(referenceUp.vec3_scale(endOffset[1]), lineEnd);
    lineEnd.vec3_add(referenceForward.vec3_scale(endOffset[2]), lineEnd);
    let textOffset = 0.01 * this._myTextOffsetMultiplier;
    let textPosition = lineEnd.vec3_add(referenceForward.vec3_scale(-textOffset));
    this._addLine(lineStart, lineEnd, parentObject);
    let textComponent = this._addText(textPosition, referenceForward, referenceUp, parentObject);
    return textComponent;
  }
  _addLine(start, end, parentObject) {
    let lineDirection = end.vec3_sub(start);
    let length10 = lineDirection.vec3_length();
    lineDirection.vec3_normalize(lineDirection);
    let lineParentObject = parentObject.pp_addObject();
    let lineObject = lineParentObject.pp_addObject();
    let lineMesh = lineObject.pp_addComponent(MeshComponent);
    lineMesh.mesh = Globals.getDefaultMeshes(this.engine).myCylinder;
    lineMesh.material = this._myLineMaterialFinal;
    lineParentObject.pp_setPositionLocal(start);
    let thickness = 1e-3 * this._myLineThicknessMultiplier;
    lineObject.pp_scaleObject(vec3_create(thickness / 2, length10 / 2, thickness / 2));
    lineObject.pp_setUpLocal(lineDirection);
    lineObject.pp_translateObject(vec3_create(0, length10 / 2, 0));
  }
  _addText(position, forward, up, parentObject) {
    let textObject = parentObject.pp_addObject();
    textObject.pp_setPositionLocal(position);
    textObject.pp_lookToLocal(up, forward);
    textObject.pp_scaleObject(0.0935 * this._myTextScaleMultiplier);
    let textComponent = textObject.pp_addComponent(TextComponent);
    textComponent.alignment = Alignment.Center;
    textComponent.justification = Justification.Top;
    textComponent.material = this._myTextMaterialFinal;
    return textComponent;
  }
  _hideEmptySchemes() {
    if (this._mySelectText.length == 0) {
      this._mySelectObject.pp_setActive(false);
    }
    if (this._mySqueezeText.length == 0) {
      this._mySqueezeObject.pp_setActive(false);
    }
    if (this._myThumbstickText.length == 0) {
      this._myThumbstickObject.pp_setActive(false);
    }
    if (this._myBottomButtonText.length == 0) {
      this._myBottomButtonObject.pp_setActive(false);
    }
    if (this._myTopButtonText.length == 0) {
      this._myTopButtonObject.pp_setActive(false);
    }
  }
};
__publicField(GamepadControlSchemeComponent, "TypeName", "pp-gamepad-control-scheme");
__publicField(GamepadControlSchemeComponent, "Properties", {
  _myShowOnStart: Property.bool(true),
  _myHandedness: Property.enum(["Left", "Right"], "Left"),
  _mySelectText: Property.string(""),
  _mySqueezeText: Property.string(""),
  _myThumbstickText: Property.string(""),
  _myBottomButtonText: Property.string(""),
  _myTopButtonText: Property.string(""),
  _mySelect: Property.object(null),
  _mySqueeze: Property.object(null),
  _myThumbstick: Property.object(null),
  _myBottomButton: Property.object(null),
  _myTopButton: Property.object(null),
  _myTextScaleMultiplier: Property.float(1),
  _myTextOffsetMultiplier: Property.float(1),
  _myLineLengthMultiplier: Property.float(1),
  _myLineThicknessMultiplier: Property.float(1),
  _myDistanceFromButtonsMultiplier: Property.float(1),
  _myTextMaterial: Property.material(),
  _myLineMaterial: Property.material()
});

// js/pp/input/gamepad/gamepad_cores/virtual_gamepad_gamepad_core.js
var VirtualGamepadGamepadCore = class extends GamepadCore {
  constructor(virtualGamepad, handPose) {
    super(handPose);
    this._myVirtualGamepad = virtualGamepad;
    this._myButtonData = this._createButtonData();
    this._myAxesData = this._createAxesData();
    this._myHapticActuators = [];
  }
  isGamepadCoreActive() {
    return this._myVirtualGamepad.isVisible();
  }
  getButtonData(buttonID) {
    this._myButtonData.myPressed = false;
    this._myButtonData.myTouched = false;
    this._myButtonData.myValue = 0;
    if (this.isGamepadCoreActive()) {
      if (this._myVirtualGamepad.isButtonPressed(this.getHandedness(), buttonID)) {
        this._myButtonData.myPressed = true;
        this._myButtonData.myTouched = true;
        this._myButtonData.myValue = 1;
      }
    }
    return this._myButtonData;
  }
  getAxesData(axesID) {
    this._myAxesData.vec2_zero();
    if (this.isGamepadCoreActive()) {
      this._myVirtualGamepad.getAxes(this.getHandedness(), axesID, this._myAxesData);
    }
    return this._myAxesData;
  }
  getHapticActuators() {
    return this._myHapticActuators;
  }
};

// js/pp/input/gamepad/virtual_gamepad/virtual_gamepad_icon.js
var VirtualGamepadIconType = {
  NONE: 0,
  LABEL: 1,
  IMAGE: 2,
  DOT: 3,
  CIRCLE: 4,
  SQUARE: 5,
  RING: 6,
  FRAME: 7
};
var VirtualGamepadIconParams = class {
  constructor() {
    this.myBackgroundColor = "";
    this.myBackgroundPressedColor = "";
    this.myIconColor = "";
    this.myIconPressedColor = "";
    this.myIconType = VirtualGamepadIconType.NONE;
    this.myOverallHoveredBrightness = 1;
    this.myLabel = "";
    this.myLabelFontSize = 0;
    this.myLabelFontFamily = "";
    this.myLabelFontWeight = "";
    this.myImageURL = "";
    this.myImagePressedBrightness = 1;
  }
};
var VirtualGamepadIcon = class {
  constructor(iconElementParent, iconParams, minSizeMultiplier, scale11, engine2 = Globals.getMainEngine()) {
    this._myEngine = engine2;
    this._myParams = iconParams;
    this._myIconContainerElement = null;
    this._myBackgroundElement = null;
    this._myIconElement = null;
    this._myPressed = false;
    this._myMouseHover = false;
    this._myMouseHoverEnabled = true;
    this._myDestroyed = false;
    this._build(iconElementParent, minSizeMultiplier, scale11);
  }
  update(dt) {
    if (this._myPressed || !this._myMouseHover || !this._myMouseHoverEnabled) {
      this._myIconContainerElement.style.filter = "none";
    } else {
      this._myIconContainerElement.style.filter = "brightness(" + this._myParams.myOverallHoveredBrightness + ")";
    }
  }
  reset() {
    this.setPressed(false);
    this._myMouseHover = false;
    this._myIconContainerElement.style.filter = "none";
  }
  setPressed(pressed) {
    if (this._myPressed != pressed) {
      this._myPressed = pressed;
      if (this._myPressed) {
        this._myBackgroundElement.style.fill = this._myParams.myBackgroundPressedColor;
        if (this._myIconElement != null) {
          if (this._myIconElement.style.strokeWidth.length > 0) {
            this._myIconElement.style.stroke = this._myParams.myIconPressedColor;
          } else {
            this._myIconElement.style.fill = this._myParams.myIconPressedColor;
          }
          if (this._myParams.myIconType == VirtualGamepadIconType.IMAGE) {
            this._myIconElement.style.filter = "brightness(" + this._myParams.myImagePressedBrightness + ")";
          }
        }
      } else {
        this._myBackgroundElement.style.fill = this._myParams.myBackgroundColor;
        if (this._myIconElement != null) {
          if (this._myIconElement.style.strokeWidth.length > 0) {
            this._myIconElement.style.stroke = this._myParams.myIconColor;
          } else {
            this._myIconElement.style.fill = this._myParams.myIconColor;
          }
          if (this._myParams.myIconType == VirtualGamepadIconType.IMAGE) {
            this._myIconElement.style.filter = "none";
          }
        }
      }
    }
  }
  onMouseEnter() {
    this._myMouseHover = true;
  }
  onMouseLeave() {
    this._myMouseHover = false;
  }
  setMouseHoverEnabled(enabled) {
    this._myMouseHoverEnabled = enabled;
  }
  _build(iconElementParent, minSizeMultiplier, scale11) {
    this._myIconContainerElement = Globals.getDocument(this._myEngine).createElementNS("http://www.w3.org/2000/svg", "svg");
    this._myIconContainerElement.style.position = "absolute";
    this._myIconContainerElement.style.width = "100%";
    this._myIconContainerElement.style.height = "100%";
    iconElementParent.appendChild(this._myIconContainerElement);
    this._myBackgroundElement = Globals.getDocument(this._myEngine).createElementNS("http://www.w3.org/2000/svg", "circle");
    this._myBackgroundElement.setAttributeNS(null, "cx", "50%");
    this._myBackgroundElement.setAttributeNS(null, "cy", "50%");
    this._myBackgroundElement.setAttributeNS(null, "r", "50%");
    this._myBackgroundElement.style.fill = this._myParams.myBackgroundColor;
    this._myIconContainerElement.appendChild(this._myBackgroundElement);
    switch (this._myParams.myIconType) {
      case VirtualGamepadIconType.NONE:
        break;
      case VirtualGamepadIconType.LABEL:
        this._myIconElement = Globals.getDocument(this._myEngine).createElementNS("http://www.w3.org/2000/svg", "text");
        this._myIconElement.setAttributeNS(null, "x", "50%");
        this._myIconElement.setAttributeNS(null, "y", "50%");
        this._myIconElement.style.textAlign = "center";
        this._myIconElement.style.textAnchor = "middle";
        this._myIconElement.style.dominantBaseline = "central";
        this._myIconElement.style.alignmentBaseline = "central";
        this._myIconElement.style.fontFamily = this._myParams.myLabelFontFamily;
        this._myIconElement.style.fontWeight = this._myParams.myLabelFontWeight;
        this._myIconElement.style.fontSize = this._createSizeValue(this._myParams.myLabelFontSize * scale11, minSizeMultiplier);
        this._myIconElement.style.fill = this._myParams.myIconColor;
        this._myIconElement.textContent = this._myParams.myLabel;
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.IMAGE:
        this._myIconElement = Globals.getDocument(this._myEngine).createElementNS("http://www.w3.org/2000/svg", "image");
        this._myIconElement.setAttributeNS(null, "x", "0%");
        this._myIconElement.setAttributeNS(null, "y", "0%");
        this._myIconElement.setAttribute("href", this._myParams.myImageURL);
        this._myIconElement.style.width = "100%";
        this._myIconElement.style.height = "100%";
        this._myIconElement.style.filter = "none";
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.DOT:
        this._myIconElement = Globals.getDocument(this._myEngine).createElementNS("http://www.w3.org/2000/svg", "circle");
        this._myIconElement.setAttributeNS(null, "cx", "50%");
        this._myIconElement.setAttributeNS(null, "cy", "50%");
        this._myIconElement.setAttributeNS(null, "r", "17.5%");
        this._myIconElement.style.fill = this._myParams.myIconColor;
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.CIRCLE:
        this._myIconElement = Globals.getDocument(this._myEngine).createElementNS("http://www.w3.org/2000/svg", "circle");
        this._myIconElement.setAttributeNS(null, "cx", "50%");
        this._myIconElement.setAttributeNS(null, "cy", "50%");
        this._myIconElement.setAttributeNS(null, "r", "24%");
        this._myIconElement.style.fill = this._myParams.myIconColor;
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.SQUARE:
        this._myIconElement = Globals.getDocument(this._myEngine).createElementNS("http://www.w3.org/2000/svg", "rect");
        this._myIconElement.setAttributeNS(null, "x", "28%");
        this._myIconElement.setAttributeNS(null, "y", "28%");
        this._myIconElement.setAttributeNS(null, "rx", "10%");
        this._myIconElement.setAttributeNS(null, "ry", "10%");
        this._myIconElement.setAttributeNS(null, "width", "44%");
        this._myIconElement.setAttributeNS(null, "height", "44%");
        this._myIconElement.style.fill = this._myParams.myIconColor;
        this._myIconElement.style.transformOrigin = "center";
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.RING:
        this._myIconElement = Globals.getDocument(this._myEngine).createElementNS("http://www.w3.org/2000/svg", "circle");
        this._myIconElement.setAttributeNS(null, "cx", "50%");
        this._myIconElement.setAttributeNS(null, "cy", "50%");
        this._myIconElement.setAttributeNS(null, "r", "20%");
        this._myIconElement.style.fill = "#00000000";
        this._myIconElement.style.stroke = this._myParams.myIconColor;
        this._myIconElement.style.strokeWidth = "10%";
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.FRAME:
        this._myIconElement = Globals.getDocument(this._myEngine).createElementNS("http://www.w3.org/2000/svg", "rect");
        this._myIconElement.setAttributeNS(null, "x", "31.5%");
        this._myIconElement.setAttributeNS(null, "y", "31.5%");
        this._myIconElement.setAttributeNS(null, "rx", "10%");
        this._myIconElement.setAttributeNS(null, "ry", "10%");
        this._myIconElement.setAttributeNS(null, "width", "37%");
        this._myIconElement.setAttributeNS(null, "height", "37%");
        this._myIconElement.style.fill = "#00000000";
        this._myIconElement.style.stroke = this._myParams.myIconColor;
        this._myIconElement.style.strokeWidth = "10%";
        this._myIconElement.style.transformOrigin = "center";
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
    }
  }
  _createSizeValue(value, minSizeMultiplier) {
    return "min(" + value.toFixed(3) + "vmax," + (value * minSizeMultiplier).toFixed(3) + "vw)";
  }
  _invertColors() {
    if (this._myIconElement.style.strokeWidth.length > 0) {
      this._myBackgroundElement.style.fill = this._myParams.myIconColor;
      this._myIconElement.style.fill = this._myParams.myIconColor;
      this._myIconElement.style.stroke = this._myParams.myBackgroundColor;
    } else {
      this._myBackgroundElement.style.fill = this._myParams.myIconColor;
      this._myIconElement.style.fill = this._myParams.myBackgroundColor;
    }
  }
  destroy() {
    this._myDestroyed = true;
    this._myIconContainerElement.remove();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/input/gamepad/virtual_gamepad/virtual_gamepad_params.js
var VirtualGamepadButtonParams = class {
  constructor() {
    this.myIconParams = new VirtualGamepadIconParams();
  }
};
var VirtualGamepadThumbstickParams = class {
  constructor() {
    this.myBackgroundColor = "";
    this.myMaxDistanceFromCenterMultiplier = 1;
    this.myReleaseTransitionSeconds = 0.2;
    this.myMoveTransitionSeconds = 0;
    this.myIncludeBackgroundToDetection = false;
    this.myIconParams = new VirtualGamepadIconParams();
  }
};
var VirtualGamepadParams = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this.myShowOnDesktop = false;
    this.myShowOnMobile = false;
    this.myShowOnHeadset = false;
    this.myAutoUpdateVisibility = false;
    this.myOpacity = 1;
    this.myInterfaceScale = 1;
    this.myMarginScale = 1;
    this.myReleaseOnPointerLeave = true;
    this.myStopPropagatingMouseDownEvents = true;
    this.myButtonParams = [];
    this.myButtonParams[Handedness.LEFT] = [];
    this.myButtonParams[Handedness.RIGHT] = [];
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.SELECT] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.SQUEEZE] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.THUMBSTICK] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.TOP_BUTTON] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.BOTTOM_BUTTON] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.SELECT] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.SQUEEZE] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.THUMBSTICK] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.TOP_BUTTON] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.BOTTOM_BUTTON] = new VirtualGamepadButtonParams();
    this.myThumbstickParams = [];
    this.myThumbstickParams[Handedness.LEFT] = [];
    this.myThumbstickParams[Handedness.RIGHT] = [];
    this.myThumbstickParams[Handedness.LEFT][GamepadAxesID.THUMBSTICK] = new VirtualGamepadThumbstickParams();
    this.myThumbstickParams[Handedness.RIGHT][GamepadAxesID.THUMBSTICK] = new VirtualGamepadThumbstickParams();
    this.myButtonsOrder = [];
    this.myButtonsOrder[Handedness.LEFT] = [null, null, null, null, null];
    this.myButtonsOrder[Handedness.RIGHT] = [null, null, null, null, null];
    this.myThumbsticksOrder = [];
    this.myThumbsticksOrder[Handedness.LEFT] = [null];
    this.myThumbsticksOrder[Handedness.RIGHT] = [null];
    this.myValidPointerButtons = [];
    this.myMarginLeft = 0;
    this.myMarginRight = 0;
    this.myMarginBottom = 0;
    this.myThumbstickSize = 0;
    this.myButtonSize = 0;
    this.myButtonsRingRadius = 0;
    this.myButtonsRingStartAngle = 0;
    this.myButtonsRingEndAngle = 0;
    this.myFontSize = 0;
    this.myMinSizeMultiplier = 0;
    this.myDisableMouseHoverWhenPressed = false;
    this.myEngine = engine2;
  }
  defaultConfig() {
    this.myShowOnMobile = true;
    this.myAutoUpdateVisibility = true;
    this.myOpacity = 0.5;
    let backgroundColor = "#616161";
    let iconColor = "#e0e0e0";
    let buttonHoveredBrightness = 0.75;
    let thumbstickHoveredBrightness = 0.75;
    let thumbstickIncludeBackgroundToDetection = true;
    for (let handedness in this.myButtonParams) {
      for (let gamepadButtonID in this.myButtonParams[handedness]) {
        let buttonParams = this.myButtonParams[handedness][gamepadButtonID];
        buttonParams.myIconParams.myBackgroundColor = backgroundColor;
        buttonParams.myIconParams.myBackgroundPressedColor = iconColor;
        buttonParams.myIconParams.myIconColor = iconColor;
        buttonParams.myIconParams.myIconPressedColor = backgroundColor;
        buttonParams.myIconParams.myOverallHoveredBrightness = buttonHoveredBrightness;
      }
    }
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.SQUEEZE].myIconParams.myIconType = VirtualGamepadIconType.SQUARE;
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.SQUEEZE].myIconParams.myIconType = VirtualGamepadIconType.SQUARE;
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.SELECT].myIconParams.myIconType = VirtualGamepadIconType.FRAME;
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.SELECT].myIconParams.myIconType = VirtualGamepadIconType.FRAME;
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.TOP_BUTTON].myIconParams.myIconType = VirtualGamepadIconType.CIRCLE;
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.TOP_BUTTON].myIconParams.myIconType = VirtualGamepadIconType.CIRCLE;
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.BOTTOM_BUTTON].myIconParams.myIconType = VirtualGamepadIconType.RING;
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.BOTTOM_BUTTON].myIconParams.myIconType = VirtualGamepadIconType.RING;
    this.myButtonParams[Handedness.LEFT][GamepadButtonID.THUMBSTICK].myIconParams.myIconType = VirtualGamepadIconType.DOT;
    this.myButtonParams[Handedness.RIGHT][GamepadButtonID.THUMBSTICK].myIconParams.myIconType = VirtualGamepadIconType.DOT;
    for (let handedness in this.myThumbstickParams) {
      for (let gamepadAxesID in this.myThumbstickParams[handedness]) {
        let thumbstickParams = this.myThumbstickParams[handedness][gamepadAxesID];
        thumbstickParams.myBackgroundColor = backgroundColor;
        thumbstickParams.myIconParams.myBackgroundColor = iconColor;
        thumbstickParams.myIconParams.myBackgroundPressedColor = iconColor;
        thumbstickParams.myIconParams.myIconColor = backgroundColor;
        thumbstickParams.myIconParams.myIconPressedColor = backgroundColor;
        thumbstickParams.myIconParams.myOverallHoveredBrightness = thumbstickHoveredBrightness;
        thumbstickParams.myIncludeBackgroundToDetection = thumbstickIncludeBackgroundToDetection;
      }
    }
    this.myButtonsOrder[Handedness.LEFT][0] = [Handedness.LEFT, GamepadButtonID.SQUEEZE];
    this.myButtonsOrder[Handedness.LEFT][1] = [Handedness.LEFT, GamepadButtonID.SELECT];
    this.myButtonsOrder[Handedness.LEFT][2] = [Handedness.LEFT, GamepadButtonID.TOP_BUTTON];
    this.myButtonsOrder[Handedness.LEFT][3] = [Handedness.LEFT, GamepadButtonID.BOTTOM_BUTTON];
    this.myButtonsOrder[Handedness.LEFT][4] = [Handedness.LEFT, GamepadButtonID.THUMBSTICK];
    this.myButtonsOrder[Handedness.RIGHT][0] = [Handedness.RIGHT, GamepadButtonID.SQUEEZE];
    this.myButtonsOrder[Handedness.RIGHT][1] = [Handedness.RIGHT, GamepadButtonID.SELECT];
    this.myButtonsOrder[Handedness.RIGHT][2] = [Handedness.RIGHT, GamepadButtonID.TOP_BUTTON];
    this.myButtonsOrder[Handedness.RIGHT][3] = [Handedness.RIGHT, GamepadButtonID.BOTTOM_BUTTON];
    this.myButtonsOrder[Handedness.RIGHT][4] = [Handedness.RIGHT, GamepadButtonID.THUMBSTICK];
    this.myThumbsticksOrder[Handedness.LEFT][0] = [Handedness.LEFT, GamepadAxesID.THUMBSTICK];
    this.myThumbsticksOrder[Handedness.RIGHT][0] = [Handedness.RIGHT, GamepadAxesID.THUMBSTICK];
    this.myMarginLeft = 3;
    this.myMarginRight = 3;
    this.myMarginBottom = 3;
    this.myThumbstickSize = 15;
    this.myButtonSize = 5;
    this.myButtonsRingRadius = 12;
    this.myButtonsRingStartAngle = 385;
    this.myButtonsRingEndAngle = 245;
    this.myMinSizeMultiplier = 5 / 3;
    this.myDisableMouseHoverWhenPressed = true;
    this.myValidPointerButtons = [0];
  }
};

// js/pp/input/gamepad/virtual_gamepad/virtual_gamepad_virtual_button.js
var VirtualGamepadVirtualButton = class {
  constructor(buttonElementParent, virtualGamepadParams, virtualButtonHandedness, virtualButtonIndex, gamepadButtonHandedness, gamepadButtonID) {
    this._myButtonElement = null;
    this._myButtonIcon = null;
    this._myButtonDetectionElement = null;
    this._myActive = true;
    this._myPointerID = null;
    this._myPointerButton = null;
    this._myPressed = false;
    this._myVirtualGamepadParams = virtualGamepadParams;
    this._myParams = this._myVirtualGamepadParams.myButtonParams[gamepadButtonHandedness][gamepadButtonID];
    this._build(buttonElementParent, virtualButtonHandedness, virtualButtonIndex);
    this._myPointerDownEventListener = this._onPointerDown.bind(this, this._myVirtualGamepadParams.myStopPropagatingPointerDownEvents);
    this._myPointerUpEventListener = this._onPointerUp.bind(this);
    this._myPointerLeaveEventListener = this._onPointerLeave.bind(this);
    this._myMouseEnterEventListener = this._onButtonEnter.bind(this);
    this._myMouseLeaveEventListener = this._onButtonLeave.bind(this);
    this._myButtonDetectionElement.addEventListener("pointerdown", this._myPointerDownEventListener);
    Globals.getBody(this._myVirtualGamepadParams.myEngine).addEventListener("pointerup", this._myPointerUpEventListener);
    if (this._myVirtualGamepadParams.myReleaseOnPointerLeave) {
      Globals.getBody(this._myVirtualGamepadParams.myEngine).addEventListener("pointerleave", this._myPointerLeaveEventListener);
    }
    this._myButtonDetectionElement.addEventListener("mouseenter", this._myMouseEnterEventListener);
    this._myButtonDetectionElement.addEventListener("mouseleave", this._myMouseLeaveEventListener);
    this._myDestroyed = false;
  }
  isPressed() {
    return this._myActive && this._myPressed;
  }
  setActive(active) {
    if (this._myActive != active) {
      this.reset();
      this._myButtonIcon.reset();
    }
    this._myActive = active;
  }
  setMouseHoverEnabled(hoverActive) {
    this._myButtonIcon.setMouseHoverEnabled(hoverActive);
  }
  reset() {
    this._myButtonIcon.setPressed(false);
    this._myPressed = false;
    this._myPointerID = null;
    this._myPointerButton = null;
  }
  update(dt) {
    this._myButtonIcon.update(dt);
  }
  _onPointerDown(stopPropagatingPointerDownEvents, event) {
    if (!this._myActive)
      return;
    if (this._myPressed)
      return;
    if (!this._myVirtualGamepadParams.myValidPointerButtons.pp_hasEqual(event.button))
      return;
    if (stopPropagatingPointerDownEvents) {
      event.stopPropagation();
    }
    event.preventDefault();
    this._myButtonIcon.setPressed(true);
    this._myPointerID = event.pointerId;
    this._myPointerButton = event.button;
    this._myPressed = true;
  }
  _onPointerUp(event) {
    if (!this._myActive)
      return;
    if (!this._myPressed)
      return;
    if (this._myPointerID != event.pointerId)
      return;
    if (this._myPointerButton != null && this._myPointerButton != event.button)
      return;
    this.reset();
  }
  _onPointerLeave(event) {
    if (!this._myActive)
      return;
    if (this._myPointerID != event.pointerId)
      return;
    this.reset();
  }
  _onButtonEnter(event) {
    if (!this._myActive)
      return;
    this._myButtonIcon.onMouseEnter(event);
  }
  _onButtonLeave(event) {
    if (!this._myActive)
      return;
    this._myButtonIcon.onMouseLeave(event);
  }
  _build(buttonElementParent, virtualButtonHandedness, virtualButtonIndex) {
    let buttonSize = this._myVirtualGamepadParams.myButtonSize * this._myVirtualGamepadParams.myInterfaceScale;
    let buttonsRingRadius = this._myVirtualGamepadParams.myButtonsRingRadius * this._myVirtualGamepadParams.myInterfaceScale;
    let thumbstickSize = this._myVirtualGamepadParams.myThumbstickSize * this._myVirtualGamepadParams.myInterfaceScale;
    let marginBottom = this._myVirtualGamepadParams.myMarginBottom * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let marginLeft = this._myVirtualGamepadParams.myMarginLeft * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let marginRight = this._myVirtualGamepadParams.myMarginRight * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let buttonRingStartAngle = this._myVirtualGamepadParams.myButtonsRingStartAngle;
    let buttonRingEndAngle = this._myVirtualGamepadParams.myButtonsRingEndAngle;
    let minSizeMultiplier = Math.max(1, this._myVirtualGamepadParams.myMinSizeMultiplier / this._myVirtualGamepadParams.myInterfaceScale);
    let buttonsAmount = this._myVirtualGamepadParams.myButtonsOrder[Handedness.LEFT].length;
    let angleStep = (buttonRingEndAngle - buttonRingStartAngle) / (buttonsAmount - 1);
    let currentAngle = Math.pp_angleClamp(buttonRingStartAngle + angleStep * virtualButtonIndex);
    if (virtualButtonHandedness == Handedness.RIGHT) {
      currentAngle = 270 + (270 - currentAngle);
      currentAngle = Math.pp_angleClamp(currentAngle, true);
    }
    let counterAngle = 360 - currentAngle;
    this._myButtonContainer = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElement("div");
    this._myButtonContainer.style.position = "absolute";
    this._myButtonContainer.style.width = this._createSizeValue(buttonSize, minSizeMultiplier);
    this._myButtonContainer.style.height = this._createSizeValue(buttonSize, minSizeMultiplier);
    let centerOnThumbstickBottom = marginBottom + thumbstickSize / 2 - buttonSize / 2;
    this._myButtonContainer.style.bottom = this._createSizeValue(centerOnThumbstickBottom, minSizeMultiplier);
    if (virtualButtonHandedness == Handedness.LEFT) {
      let centerOnThumbstickLeft = marginLeft + thumbstickSize / 2 - buttonSize / 2;
      this._myButtonContainer.style.left = this._createSizeValue(centerOnThumbstickLeft, minSizeMultiplier);
    } else {
      let centerOnThumbstickRight = marginRight + thumbstickSize / 2 - buttonSize / 2;
      this._myButtonContainer.style.right = this._createSizeValue(centerOnThumbstickRight, minSizeMultiplier);
    }
    this._myButtonContainer.style.transform = "rotate(" + currentAngle + "deg) translateX(" + this._createSizeValue(buttonsRingRadius, minSizeMultiplier) + ")";
    buttonElementParent.appendChild(this._myButtonContainer);
    this._myButtonElement = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElement("div");
    this._myButtonElement.style.position = "absolute";
    this._myButtonElement.style.width = "100%";
    this._myButtonElement.style.height = "100%";
    this._myButtonElement.style.transform = "rotate(" + counterAngle + "deg)";
    this._myButtonContainer.appendChild(this._myButtonElement);
    this._myButtonIcon = new VirtualGamepadIcon(this._myButtonElement, this._myParams.myIconParams, minSizeMultiplier, this._myVirtualGamepadParams.myInterfaceScale, this._myVirtualGamepadParams.myEngine);
    let buttonElementStill = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElement("div");
    buttonElementStill.style.position = "absolute";
    buttonElementStill.style.width = "100%";
    buttonElementStill.style.height = "100%";
    buttonElementStill.style.transform = "rotate(" + counterAngle + "deg)";
    this._myButtonContainer.appendChild(buttonElementStill);
    let buttonDetectionElementSVG = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElementNS("http://www.w3.org/2000/svg", "svg");
    buttonDetectionElementSVG.style.position = "absolute";
    buttonDetectionElementSVG.style.width = "100%";
    buttonDetectionElementSVG.style.height = "100%";
    buttonElementStill.appendChild(buttonDetectionElementSVG);
    let buttonDetectionElement = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElementNS("http://www.w3.org/2000/svg", "circle");
    buttonDetectionElement.setAttributeNS(null, "cx", "50%");
    buttonDetectionElement.setAttributeNS(null, "cy", "50%");
    buttonDetectionElement.setAttributeNS(null, "r", "50%");
    buttonDetectionElement.style.fill = "#00000000";
    buttonDetectionElementSVG.appendChild(buttonDetectionElement);
    this._myButtonDetectionElement = buttonDetectionElement;
  }
  _createSizeValue(value, minSizeMultiplier) {
    return "min(" + value.toFixed(3) + "vmax," + (value * minSizeMultiplier).toFixed(3) + "vw)";
  }
  destroy() {
    this._myDestroyed = true;
    this._myButtonDetectionElement.removeEventListener("pointerdown", this._myPointerDownEventListener);
    Globals.getBody(this._myVirtualGamepadParams.myEngine).removeEventListener("pointerup", this._myPointerUpEventListener);
    Globals.getBody(this._myVirtualGamepadParams.myEngine).removeEventListener("pointerleave", this._myPointerLeaveEventListener);
    this._myButtonDetectionElement.removeEventListener("mouseenter", this._myMouseEnterEventListener);
    this._myButtonDetectionElement.removeEventListener("mouseleave", this._myPointerUpEventLis_myMouseLeaveEventListenertener);
    this._myButtonIcon.destroy();
    this._myButtonContainer.remove();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/input/gamepad/virtual_gamepad/virtual_gamepad_virtual_thumbstick.js
var VirtualGamepadVirtualThumbstick = class {
  constructor(thumbstickElementParent, virtualGamepadParams, virtualThumbstickHandedness, gamepadThumbstickHandedness, gamepadAxesID) {
    this._myThumbstickElement = null;
    this._myThumbstickIcon = null;
    this._myThumbstickBackground = null;
    this._myThumbstickDetectionElement = null;
    this._myActive = true;
    this._myPointerID = null;
    this._myPointerButton = null;
    this._myThumbstickDragStartPosition = vec2_create();
    this._myAxes = vec2_create();
    this._myPressed = false;
    this._myVirtualGamepadParams = virtualGamepadParams;
    this._myParams = this._myVirtualGamepadParams.myThumbstickParams[gamepadThumbstickHandedness][gamepadAxesID];
    this._build(thumbstickElementParent, virtualThumbstickHandedness);
    this._myPointerDownEventListener = this._onPointerDown.bind(this, this._myVirtualGamepadParams.myStopPropagatingPointerDownEvents);
    this._myPointerUpEventListener = this._onPointerUp.bind(this);
    this._myPointerMoveEventListener = this._onPointerMove.bind(this);
    this._myPointerLeaveEventListener = this._onPointerLeave.bind(this);
    this._myMouseEnterEventListener = this._onThumbstickEnter.bind(this);
    this._myMouseLeaveEventListener = this._onThumbstickLeave.bind(this);
    this._myThumbstickDetectionElement.addEventListener("pointerdown", this._myPointerDownEventListener);
    Globals.getBody(this._myVirtualGamepadParams.myEngine).addEventListener("pointerup", this._myPointerUpEventListener);
    Globals.getBody(this._myVirtualGamepadParams.myEngine).addEventListener("pointermove", this._myPointerMoveEventListener);
    if (this._myVirtualGamepadParams.myReleaseOnPointerLeave) {
      Globals.getBody(this._myVirtualGamepadParams.myEngine).addEventListener("pointerleave", this._myPointerLeaveEventListener);
    }
    this._myThumbstickDetectionElement.addEventListener("mouseenter", this._myMouseEnterEventListener);
    this._myThumbstickDetectionElement.addEventListener("mouseleave", this._myMouseLeaveEventListener);
    this._myDestroyed = false;
  }
  isPressed() {
    return this._myActive && this._myPressed;
  }
  getAxes() {
    return this._myAxes;
  }
  setActive(active) {
    if (this._myActive != active) {
      this.reset();
      this._myThumbstickIcon.reset();
    }
    this._myActive = active;
  }
  setMouseHoverEnabled(hoverActive) {
    this._myThumbstickIcon.setMouseHoverEnabled(hoverActive);
  }
  reset() {
    this._myThumbstickIcon.setPressed(false);
    this._myAxes[0] = 0;
    this._myAxes[1] = 0;
    this._myPressed = false;
    this._myPointerID = null;
    this._myPointerButton = null;
    this._myThumbstickElement.style.transition = "all " + this._myParams.myReleaseTransitionSeconds + "s ease 0s";
    this._myThumbstickElement.style.transform = "translate(0px, 0px)";
  }
  update(dt) {
    this._myThumbstickIcon.update(dt);
  }
  _onPointerDown(stopPropagatingPointerDownEvents, event) {
    if (!this._myActive)
      return;
    if (this._myPressed)
      return;
    if (!this._myVirtualGamepadParams.myValidPointerButtons.pp_hasEqual(event.button))
      return;
    if (stopPropagatingPointerDownEvents) {
      event.stopPropagation();
    }
    event.preventDefault();
    this._myThumbstickIcon.setPressed(true);
    this._myPointerID = event.pointerId;
    this._myPointerButton = event.button;
    this._myThumbstickDragStartPosition[0] = event.clientX;
    this._myThumbstickDragStartPosition[1] = event.clientY;
    this._myPressed = true;
  }
  _onPointerUp(event) {
    if (!this._myActive)
      return;
    if (!this._myPressed)
      return;
    if (this._myPointerID != event.pointerId)
      return;
    if (this._myPointerButton != null && this._myPointerButton != event.button)
      return;
    this.reset();
  }
  _onPointerLeave(event) {
    if (!this._myActive)
      return;
    if (this._myPointerID != event.pointerId)
      return;
    this.reset();
  }
  _onThumbstickEnter(event) {
    this._myThumbstickIcon.onMouseEnter(event);
  }
  _onThumbstickLeave(event) {
    this._myThumbstickIcon.onMouseLeave(event);
  }
  _onPointerMove(event) {
    if (!this._myActive)
      return;
    if (!this._myPressed)
      return;
    if (event.pointerId != this._myPointerID)
      return;
    let mouseX = event.clientX;
    let mouseY = event.clientY;
    let backgroundRect = this._myThumbstickBackground.getBoundingClientRect();
    let maxDistanceFromCenter = backgroundRect.width / 2 * this._myParams.myMaxDistanceFromCenterMultiplier;
    let xDiff = mouseX - this._myThumbstickDragStartPosition[0];
    let yDiff = mouseY - this._myThumbstickDragStartPosition[1];
    let angle4 = Math.atan2(yDiff, xDiff);
    let distanceFromDragStart = Math.min(maxDistanceFromCenter, Math.hypot(xDiff, yDiff));
    let translateThumbstickX = distanceFromDragStart * Math.cos(angle4);
    let translateThumbstickY = distanceFromDragStart * Math.sin(angle4);
    this._myThumbstickElement.style.transition = "all " + this._myParams.myMoveTransitionSeconds + "s ease-out 0s";
    this._myThumbstickElement.style.transform = "translate(" + translateThumbstickX + "px, " + translateThumbstickY + "px)";
    this._myAxes[0] = translateThumbstickX / maxDistanceFromCenter;
    this._myAxes[1] = -(translateThumbstickY / maxDistanceFromCenter);
  }
  _build(thumbstickElementParent, virtualThumbstickHandedness) {
    let thumbstickSize = this._myVirtualGamepadParams.myThumbstickSize * this._myVirtualGamepadParams.myInterfaceScale;
    let marginBottom = this._myVirtualGamepadParams.myMarginBottom * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let marginLeft = this._myVirtualGamepadParams.myMarginLeft * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let marginRight = this._myVirtualGamepadParams.myMarginRight * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let minSizeMultiplier = Math.max(1, this._myVirtualGamepadParams.myMinSizeMultiplier / this._myVirtualGamepadParams.myInterfaceScale);
    this._myThumbstickContainer = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElement("div");
    this._myThumbstickContainer.style.position = "absolute";
    this._myThumbstickContainer.style.width = this._createSizeValue(thumbstickSize, minSizeMultiplier);
    this._myThumbstickContainer.style.height = this._createSizeValue(thumbstickSize, minSizeMultiplier);
    this._myThumbstickContainer.style.bottom = this._createSizeValue(marginBottom, minSizeMultiplier);
    if (virtualThumbstickHandedness == Handedness.LEFT) {
      this._myThumbstickContainer.style.left = this._createSizeValue(marginLeft, minSizeMultiplier);
    } else {
      this._myThumbstickContainer.style.right = this._createSizeValue(marginRight, minSizeMultiplier);
    }
    thumbstickElementParent.appendChild(this._myThumbstickContainer);
    let thumbstickContainerSVG = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElementNS("http://www.w3.org/2000/svg", "svg");
    thumbstickContainerSVG.style.position = "absolute";
    thumbstickContainerSVG.style.width = "100%";
    thumbstickContainerSVG.style.height = "100%";
    this._myThumbstickContainer.appendChild(thumbstickContainerSVG);
    this._myThumbstickBackground = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElementNS("http://www.w3.org/2000/svg", "circle");
    this._myThumbstickBackground.setAttributeNS(null, "cx", "50%");
    this._myThumbstickBackground.setAttributeNS(null, "cy", "50%");
    this._myThumbstickBackground.setAttributeNS(null, "r", "48%");
    this._myThumbstickBackground.style.fill = this._myParams.myBackgroundColor;
    thumbstickContainerSVG.appendChild(this._myThumbstickBackground);
    this._myThumbstickElement = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElement("div");
    this._myThumbstickElement.style.position = "absolute";
    this._myThumbstickElement.style.width = "34%";
    this._myThumbstickElement.style.height = "34%";
    this._myThumbstickElement.style.top = "33%";
    this._myThumbstickElement.style.left = "33%";
    this._myThumbstickContainer.appendChild(this._myThumbstickElement);
    this._myThumbstickIcon = new VirtualGamepadIcon(this._myThumbstickElement, this._myParams.myIconParams, minSizeMultiplier, this._myVirtualGamepadParams.myScale, this._myVirtualGamepadParams.myEngine);
    if (this._myParams.myIncludeBackgroundToDetection) {
      let thumbstickBackgroundDetectionElementSVG = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElementNS("http://www.w3.org/2000/svg", "svg");
      thumbstickBackgroundDetectionElementSVG.style.position = "absolute";
      thumbstickBackgroundDetectionElementSVG.style.width = "100%";
      thumbstickBackgroundDetectionElementSVG.style.height = "100%";
      this._myThumbstickContainer.appendChild(thumbstickBackgroundDetectionElementSVG);
      let thumbstickBackgroundDetectionElement = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElementNS("http://www.w3.org/2000/svg", "circle");
      thumbstickBackgroundDetectionElement.setAttributeNS(null, "cx", "50%");
      thumbstickBackgroundDetectionElement.setAttributeNS(null, "cy", "50%");
      thumbstickBackgroundDetectionElement.setAttributeNS(null, "r", "48%");
      thumbstickBackgroundDetectionElement.style.fill = "#00000000";
      thumbstickBackgroundDetectionElementSVG.appendChild(thumbstickBackgroundDetectionElement);
      this._myThumbstickDetectionElement = thumbstickBackgroundDetectionElement;
    } else {
      let thumbstickElementStill = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElement("div");
      thumbstickElementStill.style.position = "absolute";
      thumbstickElementStill.style.width = "34%";
      thumbstickElementStill.style.height = "34%";
      thumbstickElementStill.style.top = "33%";
      thumbstickElementStill.style.left = "33%";
      this._myThumbstickContainer.appendChild(thumbstickElementStill);
      let thumbstickDetectionElementSVG = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElementNS("http://www.w3.org/2000/svg", "svg");
      thumbstickDetectionElementSVG.style.position = "absolute";
      thumbstickDetectionElementSVG.style.width = "100%";
      thumbstickDetectionElementSVG.style.height = "100%";
      thumbstickElementStill.appendChild(thumbstickDetectionElementSVG);
      let thumbstickDetectionElement = Globals.getDocument(this._myVirtualGamepadParams.myEngine).createElementNS("http://www.w3.org/2000/svg", "circle");
      thumbstickDetectionElement.setAttributeNS(null, "cx", "50%");
      thumbstickDetectionElement.setAttributeNS(null, "cy", "50%");
      thumbstickDetectionElement.setAttributeNS(null, "r", "50%");
      thumbstickDetectionElement.style.fill = "#00000000";
      thumbstickDetectionElementSVG.appendChild(thumbstickDetectionElement);
      this._myThumbstickDetectionElement = thumbstickDetectionElement;
    }
  }
  _createSizeValue(value, minSizeMultiplier) {
    return "min(" + value.toFixed(3) + "vmax," + (value * minSizeMultiplier).toFixed(3) + "vw)";
  }
  destroy() {
    this._myDestroyed = true;
    this._myThumbstickDetectionElement.removeEventListener("pointerdown", this._myPointerDownEventListener);
    Globals.getBody(this._myVirtualGamepadParams.myEngine).removeEventListener("pointerup", this._myPointerUpEventListener);
    Globals.getBody(this._myVirtualGamepadParams.myEngine).removeEventListener("pointermove", this._myPointerMoveEventListener);
    Globals.getBody(this._myVirtualGamepadParams.myEngine).removeEventListener("pointerleave", this._myPointerLeaveEventListener);
    this._myThumbstickDetectionElement.removeEventListener("mouseenter", this._myMouseEnterEventListener);
    this._myThumbstickDetectionElement.removeEventListener("mouseleave", this._myPointerUpEventLis_myMouseLeaveEventListenertener);
    this._myThumbstickIcon.destroy();
    this._myThumbstickContainer.remove();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/input/gamepad/virtual_gamepad/virtual_gamepad.js
var VirtualGamepad = class {
  constructor(params = new VirtualGamepadParams()) {
    this._myParams = params;
    this._myVisible = true;
    this._myVirtualGamepadContainer = null;
    this._myVirtualGamepadVirtualButtons = [];
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT] = [];
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT] = [];
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT][GamepadButtonID.SELECT] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT][GamepadButtonID.SQUEEZE] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT][GamepadButtonID.THUMBSTICK] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT][GamepadButtonID.TOP_BUTTON] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT][GamepadButtonID.BOTTOM_BUTTON] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT][GamepadButtonID.SELECT] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT][GamepadButtonID.SQUEEZE] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT][GamepadButtonID.THUMBSTICK] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT][GamepadButtonID.TOP_BUTTON] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT][GamepadButtonID.BOTTOM_BUTTON] = null;
    this._myButtonsAmount = this._myVirtualGamepadVirtualButtons[Handedness.LEFT].length;
    this._myVirtualGamepadVirtualThumbsticks = [];
    this._myVirtualGamepadVirtualThumbsticks[Handedness.LEFT] = [];
    this._myVirtualGamepadVirtualThumbsticks[Handedness.RIGHT] = [];
    this._myVirtualGamepadVirtualThumbsticks[Handedness.LEFT][GamepadAxesID.THUMBSTICK] = null;
    this._myVirtualGamepadVirtualThumbsticks[Handedness.RIGHT][GamepadAxesID.THUMBSTICK] = null;
    this._myGestureStartEventListener = null;
    this._myDestroyed = false;
  }
  isVisible() {
    return this._myVisible;
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      if (this._myVirtualGamepadContainer != null) {
        if (this._myVisible) {
          this._myVirtualGamepadContainer.style.display = "block";
        } else {
          this._myVirtualGamepadContainer.style.display = "none";
        }
        for (let handedness in this._myVirtualGamepadVirtualButtons) {
          for (let gamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
            let button = this._myVirtualGamepadVirtualButtons[handedness][gamepadButtonID];
            if (button != null) {
              button.setActive(this._myVisible);
            }
          }
        }
        for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
          for (let gamepadAxesID in this._myVirtualGamepadVirtualThumbsticks[handedness]) {
            let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][gamepadAxesID];
            if (thumbstick != null) {
              thumbstick.setActive(this._myVisible);
            }
          }
        }
      }
    }
  }
  isButtonPressed(handedness, gamepadButtonID) {
    if (!this._myVisible)
      return false;
    let button = this._myVirtualGamepadVirtualButtons[handedness][gamepadButtonID];
    if (button != null) {
      return button.isPressed();
    }
    return false;
  }
  getAxes(handedness, gamepadAxesID, outAxes = vec2_create(0, 0)) {
    if (!this._myVisible)
      return outAxes;
    let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][gamepadAxesID];
    if (thumbstick != null) {
      outAxes.vec2_copy(thumbstick.getAxes());
    }
    return outAxes;
  }
  start() {
    this._buildVirtualGamepad();
    let currentVisible = this._myVisible;
    this._myVisible = !this._myVisible;
    this.setVisible(currentVisible);
  }
  update(dt) {
    if (this._myParams.myAutoUpdateVisibility) {
      if (XRUtils.isSessionActive(this._myParams.myEngine) && XRUtils.isVRSupported(this._myParams.myEngine)) {
        this.setVisible(false);
      } else if (this._myParams.myShowOnDesktop && BrowserUtils.isDesktop() && !XRUtils.isVRSupported(this._myParams.myEngine)) {
        this.setVisible(true);
      } else if (this._myParams.myShowOnHeadset && BrowserUtils.isDesktop() && XRUtils.isVRSupported(this._myParams.myEngine)) {
        this.setVisible(true);
      } else if (this._myParams.myShowOnMobile && BrowserUtils.isMobile()) {
        this.setVisible(true);
      } else {
        this.setVisible(false);
      }
    }
    if (this._myVisible) {
      for (let handedness in this._myVirtualGamepadVirtualButtons) {
        for (let gamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
          let button = this._myVirtualGamepadVirtualButtons[handedness][gamepadButtonID];
          if (button != null) {
            button.update(dt);
          }
        }
      }
      for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
        for (let gamepadAxesID in this._myVirtualGamepadVirtualThumbsticks[handedness]) {
          let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][gamepadAxesID];
          if (thumbstick != null) {
            thumbstick.update(dt);
          }
        }
      }
      this._setMouseHoverEnabled(!(this._myParams.myDisableMouseHoverWhenPressed && this._isAnyElementPressed()));
    }
  }
  _buildVirtualGamepad() {
    this._setupDocumentBody();
    this._myVirtualGamepadContainer = Globals.getDocument(this._myParams.myEngine).createElement("div");
    this._myVirtualGamepadContainer.style.display = "block";
    this._myVirtualGamepadContainer.style.opacity = this._myParams.myOpacity.toString();
    Globals.getBody(this._myParams.myEngine).appendChild(this._myVirtualGamepadContainer);
    let leftDiv = Globals.getDocument(this._myParams.myEngine).createElement("div");
    this._myVirtualGamepadContainer.appendChild(leftDiv);
    let rightDiv = Globals.getDocument(this._myParams.myEngine).createElement("div");
    this._myVirtualGamepadContainer.appendChild(rightDiv);
    let buttonsAmount = this._myParams.myButtonsOrder[Handedness.LEFT].length;
    for (let i = 0; i < buttonsAmount; i++) {
      if (this._myParams.myButtonsOrder[Handedness.LEFT][i] != null) {
        let gamepadButtonHandedness = this._myParams.myButtonsOrder[Handedness.LEFT][i][0];
        let gamepadButtonID = this._myParams.myButtonsOrder[Handedness.LEFT][i][1];
        this._buildButton(leftDiv, Handedness.LEFT, i, gamepadButtonHandedness, gamepadButtonID);
      }
      if (this._myParams.myButtonsOrder[Handedness.RIGHT][i] != null) {
        let gamepadButtonHandedness = this._myParams.myButtonsOrder[Handedness.RIGHT][i][0];
        let gamepadButtonID = this._myParams.myButtonsOrder[Handedness.RIGHT][i][1];
        this._buildButton(rightDiv, Handedness.RIGHT, i, gamepadButtonHandedness, gamepadButtonID);
      }
    }
    let thumbsticksAmount = this._myParams.myThumbsticksOrder[Handedness.LEFT].length;
    for (let i = 0; i < thumbsticksAmount; i++) {
      if (this._myParams.myThumbsticksOrder[Handedness.LEFT][i] != null) {
        let gamepadThumbstickHandedness = this._myParams.myThumbsticksOrder[Handedness.LEFT][i][0];
        let gamepadAxesID = this._myParams.myThumbsticksOrder[Handedness.LEFT][i][1];
        this._buildThumbstick(leftDiv, Handedness.LEFT, gamepadThumbstickHandedness, gamepadAxesID);
      }
      if (this._myParams.myThumbsticksOrder[Handedness.RIGHT][i] != null) {
        let gamepadThumbstickHandedness = this._myParams.myThumbsticksOrder[Handedness.RIGHT][i][0];
        let gamepadAxesID = this._myParams.myThumbsticksOrder[Handedness.RIGHT][i][1];
        this._buildThumbstick(rightDiv, Handedness.RIGHT, gamepadThumbstickHandedness, gamepadAxesID);
      }
    }
  }
  _setupDocumentBody() {
    Globals.getBody(this._myParams.myEngine).style.overflow = "hidden";
    Globals.getBody(this._myParams.myEngine).style.userSelect = "none";
    Globals.getBody(this._myParams.myEngine).style.webkitUserSelect = "none";
    Globals.getBody(this._myParams.myEngine).style.webkitTapHighlightColor = "transparent";
    Globals.getBody(this._myParams.myEngine).style.touchAction = "none";
    this._myGestureStartEventListener = function(e) {
      e.preventDefault();
    };
    Globals.getDocument(this._myParams.myEngine).addEventListener("gesturestart", this._myGestureStartEventListener);
  }
  _buildButton(buttonElementParent, virtualButtonHandedness, virtualButtonIndex, gamepadButtonHandedness, gamepadButtonID) {
    let virtualGamepadVirtualButton = new VirtualGamepadVirtualButton(buttonElementParent, this._myParams, virtualButtonHandedness, virtualButtonIndex, gamepadButtonHandedness, gamepadButtonID);
    this._myVirtualGamepadVirtualButtons[gamepadButtonHandedness][gamepadButtonID] = virtualGamepadVirtualButton;
  }
  _buildThumbstick(thumbstickElementParent, virtualThumbstickHandedness, gamepadThumbstickHandedness, gamepadAxesID) {
    let virtualGamepadVirtualThumbstick = new VirtualGamepadVirtualThumbstick(thumbstickElementParent, this._myParams, virtualThumbstickHandedness, gamepadThumbstickHandedness, gamepadAxesID);
    this._myVirtualGamepadVirtualThumbsticks[gamepadThumbstickHandedness][gamepadAxesID] = virtualGamepadVirtualThumbstick;
  }
  _createSizeValue(value, minSizeMultiplier) {
    return "min(" + value.toFixed(3) + "vmax," + (value * minSizeMultiplier).toFixed(3) + "vw)";
  }
  _isAnyElementPressed() {
    let anyElementPressed = false;
    for (let handedness in this._myVirtualGamepadVirtualButtons) {
      for (let gamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
        let button = this._myVirtualGamepadVirtualButtons[handedness][gamepadButtonID];
        if (button != null && button.isPressed()) {
          anyElementPressed = true;
          break;
        }
      }
    }
    if (!anyElementPressed) {
      for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
        for (let gamepadAxesID in this._myVirtualGamepadVirtualThumbsticks[handedness]) {
          let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][gamepadAxesID];
          if (thumbstick != null && thumbstick.isPressed()) {
            anyElementPressed = true;
            break;
          }
        }
      }
    }
    return anyElementPressed;
  }
  _setMouseHoverEnabled(hoverActive) {
    for (let handedness in this._myVirtualGamepadVirtualButtons) {
      for (let gamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
        let button = this._myVirtualGamepadVirtualButtons[handedness][gamepadButtonID];
        if (button != null) {
          button.setMouseHoverEnabled(hoverActive);
        }
      }
    }
    for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
      for (let gamepadAxesID in this._myVirtualGamepadVirtualThumbsticks[handedness]) {
        let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][gamepadAxesID];
        if (thumbstick != null) {
          thumbstick.setMouseHoverEnabled(hoverActive);
        }
      }
    }
  }
  destroy() {
    this._myDestroyed = true;
    Globals.getDocument(this._myParams.myEngine).removeEventListener("gesturestart", this._myGestureStartEventListener);
    for (let handedness in this._myVirtualGamepadVirtualButtons) {
      for (let gamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
        let button = this._myVirtualGamepadVirtualButtons[handedness][gamepadButtonID];
        if (button != null) {
          button.destroy();
        }
      }
    }
    for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
      for (let gamepadAxesID in this._myVirtualGamepadVirtualThumbsticks[handedness]) {
        let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][gamepadAxesID];
        if (thumbstick != null) {
          thumbstick.destroy();
        }
      }
    }
    this._myVirtualGamepadContainer.remove();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/input/gamepad/virtual_gamepad/virtual_gamepad_component.js
var VirtualGamepadComponent = class extends Component {
  start() {
    let params = new VirtualGamepadParams(this.engine);
    params.defaultConfig();
    for (let handedness in params.myButtonParams) {
      for (let gamepadButtonID in params.myButtonParams[handedness]) {
        let buttonParams = params.myButtonParams[handedness][gamepadButtonID];
        buttonParams.myIconParams.myBackgroundColor = this._myBackgroundColor;
        buttonParams.myIconParams.myBackgroundPressedColor = this._myIconColor;
        buttonParams.myIconParams.myIconColor = this._myIconColor;
        buttonParams.myIconParams.myIconPressedColor = this._myBackgroundColor;
      }
    }
    for (let handedness in params.myThumbstickParams) {
      for (let gamepadAxesID in params.myThumbstickParams[handedness]) {
        let thumbstickParams = params.myThumbstickParams[handedness][gamepadAxesID];
        thumbstickParams.myBackgroundColor = this._myBackgroundColor;
        thumbstickParams.myIconParams.myBackgroundColor = this._myIconColor;
        thumbstickParams.myIconParams.myBackgroundPressedColor = this._myIconColor;
        thumbstickParams.myIconParams.myIconColor = this._myBackgroundColor;
        thumbstickParams.myIconParams.myIconPressedColor = this._myBackgroundColor;
      }
    }
    params.myOpacity = this._myOpacity;
    params.myInterfaceScale = this._myInterfaceScale;
    params.myMarginScale = this._myMarginScale;
    params.myShowOnDesktop = this._myShowOnDesktop;
    params.myShowOnMobile = this._myShowOnMobile;
    params.myShowOnHeadset = this._myShowOnHeadset;
    if (params.myShowOnDesktop || params.myShowOnMobile || params.myShowOnHeadset) {
      params.myAutoUpdateVisibility = true;
    } else {
      params.myAutoUpdateVisibility = false;
    }
    this._advancedConfig(params);
    this._myVirtualGamepad = new VirtualGamepad(params);
    this._myVirtualGamepad.setVisible(false);
    this._myVirtualGamepad.start();
    this._myFirstUpdate = true;
    this._myLeftVirtualGamepadGamepadCore = null;
    this._myRightVirtualGamepadGamepadCore = null;
  }
  update(dt) {
    if (this._myFirstUpdate) {
      this._myFirstUpdate = false;
      if (this._myAddToUniversalGamepad) {
        this._myLeftVirtualGamepadGamepadCore = new VirtualGamepadGamepadCore(this._myVirtualGamepad, Globals.getLeftGamepad(this.engine).getGamepadCore("pp_left_xr_gamepad").getHandPose());
        this._myRightVirtualGamepadGamepadCore = new VirtualGamepadGamepadCore(this._myVirtualGamepad, Globals.getRightGamepad(this.engine).getGamepadCore("pp_right_xr_gamepad").getHandPose());
        Globals.getLeftGamepad(this.engine).addGamepadCore("pp_left_virtual_gamepad", this._myLeftVirtualGamepadGamepadCore);
        Globals.getRightGamepad(this.engine).addGamepadCore("pp_right_virtual_gamepad", this._myRightVirtualGamepadGamepadCore);
      }
    }
    this._myVirtualGamepad.update(dt);
  }
  _advancedConfig(params) {
    params.myButtonsOrder[Handedness.LEFT] = [null, null, null, null, null];
    params.myButtonsOrder[Handedness.RIGHT] = [null, null, null, null, null];
    {
      let buttonParams = params.myButtonParams[Handedness.LEFT][GamepadButtonID.SELECT];
      buttonParams.myIconParams.myIconType = this._myLeftSelectButtonIconType;
      buttonParams.myIconParams.myLabel = this._myLeftSelectIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myLeftSelectIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myLeftSelectButtonVisible) {
        params.myButtonsOrder[Handedness.LEFT][this._myLeftSelectButtonOrderIndex] = [Handedness.LEFT, GamepadButtonID.SELECT];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.LEFT][GamepadButtonID.SQUEEZE];
      buttonParams.myIconParams.myIconType = this._myLeftSqueezeButtonIconType;
      buttonParams.myIconParams.myLabel = this._myLeftSqueezeIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myLeftSqueezeIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myLeftSqueezeButtonVisible) {
        params.myButtonsOrder[Handedness.LEFT][this._myLeftSqueezeButtonOrderIndex] = [Handedness.LEFT, GamepadButtonID.SQUEEZE];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.LEFT][GamepadButtonID.THUMBSTICK];
      buttonParams.myIconParams.myIconType = this._myLeftThumbstickButtonIconType;
      buttonParams.myIconParams.myLabel = this._myLeftThumbstickButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myLeftThumbstickButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myLeftThumbstickButtonVisible) {
        params.myButtonsOrder[Handedness.LEFT][this._myLeftThumbstickButtonOrderIndex] = [Handedness.LEFT, GamepadButtonID.THUMBSTICK];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.LEFT][GamepadButtonID.TOP_BUTTON];
      buttonParams.myIconParams.myIconType = this._myLeftTopButtonIconType;
      buttonParams.myIconParams.myLabel = this._myLeftTopButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myLeftTopButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myLeftTopButtonVisible) {
        params.myButtonsOrder[Handedness.LEFT][this._myLeftTopButtonOrderIndex] = [Handedness.LEFT, GamepadButtonID.TOP_BUTTON];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.LEFT][GamepadButtonID.BOTTOM_BUTTON];
      buttonParams.myIconParams.myIconType = this._myLeftBottomButtonIconType;
      buttonParams.myIconParams.myLabel = this._myLeftBottomButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myLeftBottomButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myLeftBottomButtonVisible) {
        params.myButtonsOrder[Handedness.LEFT][this._myLeftBottomButtonOrderIndex] = [Handedness.LEFT, GamepadButtonID.BOTTOM_BUTTON];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.RIGHT][GamepadButtonID.SELECT];
      buttonParams.myIconParams.myIconType = this._myRightSelectButtonIconType;
      buttonParams.myIconParams.myLabel = this._myRightSelectIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myRightSelectIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myRightSelectButtonVisible) {
        params.myButtonsOrder[Handedness.RIGHT][this._myRightSelectButtonOrderIndex] = [Handedness.RIGHT, GamepadButtonID.SELECT];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.RIGHT][GamepadButtonID.SQUEEZE];
      buttonParams.myIconParams.myIconType = this._myRightSqueezeButtonIconType;
      buttonParams.myIconParams.myLabel = this._myRightSqueezeIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myRightSqueezeIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myRightSqueezeButtonVisible) {
        params.myButtonsOrder[Handedness.RIGHT][this._myRightSqueezeButtonOrderIndex] = [Handedness.RIGHT, GamepadButtonID.SQUEEZE];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.RIGHT][GamepadButtonID.THUMBSTICK];
      buttonParams.myIconParams.myIconType = this._myRightThumbstickButtonIconType;
      buttonParams.myIconParams.myLabel = this._myRightThumbstickButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myRightThumbstickButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myRightThumbstickButtonVisible) {
        params.myButtonsOrder[Handedness.RIGHT][this._myRightThumbstickButtonOrderIndex] = [Handedness.RIGHT, GamepadButtonID.THUMBSTICK];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.RIGHT][GamepadButtonID.TOP_BUTTON];
      buttonParams.myIconParams.myIconType = this._myRightTopButtonIconType;
      buttonParams.myIconParams.myLabel = this._myRightTopButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myRightTopButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myRightTopButtonVisible) {
        params.myButtonsOrder[Handedness.RIGHT][this._myRightTopButtonOrderIndex] = [Handedness.RIGHT, GamepadButtonID.TOP_BUTTON];
      }
    }
    {
      let buttonParams = params.myButtonParams[Handedness.RIGHT][GamepadButtonID.BOTTOM_BUTTON];
      buttonParams.myIconParams.myIconType = this._myRightBottomButtonIconType;
      buttonParams.myIconParams.myLabel = this._myRightBottomButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myRightBottomButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      if (this._myRightBottomButtonVisible) {
        params.myButtonsOrder[Handedness.RIGHT][this._myRightBottomButtonOrderIndex] = [Handedness.RIGHT, GamepadButtonID.BOTTOM_BUTTON];
      }
    }
  }
  onDestroy() {
    Globals.getLeftGamepad(this.engine)?.removeGamepadCore("pp_left_virtual_gamepad");
    Globals.getRightGamepad(this.engine)?.removeGamepadCore("pp_right_virtual_gamepad");
    this._myLeftVirtualGamepadGamepadCore.destroy();
    this._myRightVirtualGamepadGamepadCore.destroy();
    this._myVirtualGamepad.destroy();
  }
};
__publicField(VirtualGamepadComponent, "TypeName", "pp-virtual-gamepad");
__publicField(VirtualGamepadComponent, "Properties", {
  _myShowOnDesktop: Property.bool(false),
  // You may have to enable headset too
  _myShowOnMobile: Property.bool(true),
  _myShowOnHeadset: Property.bool(false),
  // Not 100% reliable, this is true if the device supports XR and it is Desktop
  _myAddToUniversalGamepad: Property.bool(true),
  _myOpacity: Property.float(0.5),
  _myIconColor: Property.string("#e0e0e0"),
  _myBackgroundColor: Property.string("#616161"),
  _myInterfaceScale: Property.float(1),
  _myMarginScale: Property.float(1),
  ADVANCED_PARAMS_BELOW: Property.string(""),
  _myLabelFontSize: Property.float(2),
  _myLabelFontFamily: Property.string("sans-serif"),
  _myLabelFontWeight: Property.string("bold"),
  _myImagePressedBrightness: Property.float(0.5),
  _myLeftSelectButtonVisible: Property.bool(true),
  _myLeftSelectButtonOrderIndex: Property.int(1),
  _myLeftSelectButtonIconType: Property.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Frame"),
  _myLeftSelectButtonIconLabelOrImageUrl: Property.string(""),
  _myLeftSqueezeButtonVisible: Property.bool(true),
  _myLeftSqueezeButtonOrderIndex: Property.int(0),
  _myLeftSqueezeButtonIconType: Property.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Square"),
  _myLeftSqueezeButtonIconLabelOrImageUrl: Property.string(""),
  _myLeftThumbstickButtonVisible: Property.bool(true),
  _myLeftThumbstickButtonOrderIndex: Property.int(4),
  _myLeftThumbstickButtonIconType: Property.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Dot"),
  _myLeftThumbstickButtonIconLabelOrImageUrl: Property.string(""),
  _myLeftTopButtonVisible: Property.bool(true),
  _myLeftTopButtonOrderIndex: Property.int(2),
  _myLeftTopButtonIconType: Property.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Circle"),
  _myLeftTopButtonIconLabelOrImageUrl: Property.string(""),
  _myLeftBottomButtonVisible: Property.bool(true),
  _myLeftBottomButtonOrderIndex: Property.int(3),
  _myLeftBottomButtonIconType: Property.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Ring"),
  _myLeftBottomButtonIconLabelOrImageUrl: Property.string(""),
  _myRightSelectButtonVisible: Property.bool(true),
  _myRightSelectButtonOrderIndex: Property.int(1),
  _myRightSelectButtonIconType: Property.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Frame"),
  _myRightSelectButtonIconLabelOrImageUrl: Property.string(""),
  _myRightSqueezeButtonVisible: Property.bool(true),
  _myRightSqueezeButtonOrderIndex: Property.int(0),
  _myRightSqueezeButtonIconType: Property.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Square"),
  _myRightSqueezeButtonIconLabelOrImageUrl: Property.string(""),
  _myRightThumbstickButtonVisible: Property.bool(true),
  _myRightThumbstickButtonOrderIndex: Property.int(4),
  _myRightThumbstickButtonIconType: Property.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Dot"),
  _myRightThumbstickButtonIconLabelOrImageUrl: Property.string(""),
  _myRightTopButtonVisible: Property.bool(true),
  _myRightTopButtonOrderIndex: Property.int(2),
  _myRightTopButtonIconType: Property.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Circle"),
  _myRightTopButtonIconLabelOrImageUrl: Property.string(""),
  _myRightBottomButtonVisible: Property.bool(true),
  _myRightBottomButtonOrderIndex: Property.int(3),
  _myRightBottomButtonIconType: Property.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Ring"),
  _myRightBottomButtonIconLabelOrImageUrl: Property.string("")
});

// js/pp/input/pose/components/set_player_height_component.js
var SetPlayerHeightComponent = class extends Component {
  start() {
    let localPosition = this.object.pp_getPositionLocal();
    this.object.pp_setPositionLocal(vec3_create(localPosition[0], this._myEyesHeight, localPosition[2]));
    this._myHeightSetOnce = false;
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this.engine);
  }
  _onXRSessionStart() {
    if (this.active && (!this._mySetOnlyOnStart || !this._myHeightSetOnce)) {
      let localPosition = this.object.pp_getPositionLocal();
      if (XRUtils.isReferenceSpaceFloorBased(this.engine)) {
        this.object.pp_setPositionLocal(vec3_create(localPosition[0], 0, localPosition[2]));
      } else if (XRUtils.isDeviceEmulated()) {
        this.object.pp_setPositionLocal(vec3_create(localPosition[0], 0, localPosition[2]));
      } else {
        this.object.pp_setPositionLocal(vec3_create(localPosition[0], this._myEyesHeight, localPosition[2]));
      }
      this._myHeightSetOnce = true;
    }
  }
  _onXRSessionEnd() {
    if (this.active && !this._mySetOnlyOnStart) {
      let localPosition = this.object.pp_getPositionLocal();
      this.object.pp_setPositionLocal(vec3_create(localPosition[0], this._myEyesHeight, localPosition[2]));
    }
  }
};
__publicField(SetPlayerHeightComponent, "TypeName", "pp-set-player-height");
__publicField(SetPlayerHeightComponent, "Properties", {
  _myEyesHeight: Property.float(1.65),
  _mySetOnlyOnStart: Property.bool(false)
});

// js/pp/input/pose/components/set_hand_local_transform_component.js
var SetHandLocalTransformComponent = class extends Component {
  start() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    Globals.getHandPose(this._myHandednessType, this.engine).registerPoseUpdatedEventListener(this, this.onPoseUpdated.bind(this));
  }
  onPoseUpdated() {
  }
  onDestroy() {
    Globals.getHandPose(this._myHandednessType, this.engine)?.unregisterPoseUpdatedEventListener(this);
  }
};
__publicField(SetHandLocalTransformComponent, "TypeName", "pp-set-hand-local-transform");
__publicField(SetHandLocalTransformComponent, "Properties", {
  _myHandedness: Property.enum(["Left", "Right"], "Left")
});
SetHandLocalTransformComponent.prototype.onPoseUpdated = function() {
  let handPoseTransform = quat2_create();
  return function onPoseUpdated(pose) {
    if (this.active && XRUtils.isSessionActive(this.engine)) {
      if (pose.isValid()) {
        this.object.pp_setTransformLocalQuat(pose.getTransformQuat(handPoseTransform, null));
      }
    }
  };
}();

// js/pp/input/pose/components/set_head_local_transform_component.js
var SetHeadLocalTransformComponent = class extends Component {
  start() {
    Globals.getHeadPose(this.engine).registerPoseUpdatedEventListener(this, this.onPoseUpdated.bind(this));
  }
  update(dt) {
  }
  onPoseUpdated() {
  }
  onDestroy() {
    Globals.getHeadPose(this.engine)?.unregisterPoseUpdatedEventListener(this);
  }
};
__publicField(SetHeadLocalTransformComponent, "TypeName", "pp-set-head-local-transform");
__publicField(SetHeadLocalTransformComponent, "Properties", {});
SetHeadLocalTransformComponent.prototype.update = function() {
  let cameraNonXRRotation = quat_create();
  let cameraNonXRUp = vec3_create();
  let cameraNonXRPosition = vec3_create();
  return function update(dt) {
    if (!XRUtils.isSessionActive(this.engine)) {
      let cameraNonXR = Globals.getPlayerObjects(this.engine).myCameraNonXR;
      cameraNonXRRotation = cameraNonXR.pp_getRotationLocalQuat(cameraNonXRRotation);
      if (Globals.isPoseForwardFixed(this.engine)) {
        cameraNonXRRotation.quat_rotateAxisRadians(Math.PI, cameraNonXRRotation.quat_getUp(cameraNonXRUp), cameraNonXRRotation);
      }
      this.object.pp_setPositionLocal(cameraNonXR.pp_getPositionLocal(cameraNonXRPosition));
      this.object.pp_setRotationLocalQuat(cameraNonXRRotation);
    }
  };
}();
SetHeadLocalTransformComponent.prototype.onPoseUpdated = function() {
  let headPoseTransform = quat2_create();
  return function onPoseUpdated(pose) {
    if (this.active && XRUtils.isSessionActive(this.engine)) {
      if (pose.isValid()) {
        this.object.pp_setTransformLocalQuat(pose.getTransformQuat(headPoseTransform, null));
      }
    }
  };
}();

// js/pp/input/pose/components/set_tracked_hand_joint_local_transform_component.js
var SetTrackedHandJointLocalTransformComponent = class extends Component {
  start() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myJointIDType = InputUtils.getJointIDByIndex(this._myJointID);
    Globals.getTrackedHandPose(this._myHandednessType, this.engine).getJointPose(this._myJointIDType).registerPoseUpdatedEventListener(this, this.onPoseUpdated.bind(this));
  }
  onPoseUpdated() {
  }
  onDestroy() {
    Globals.getTrackedHandPose(this._myHandednessType, this.engine)?.getJointPose(this._myJointIDType)?.unregisterPoseUpdatedEventListener(this);
  }
};
__publicField(SetTrackedHandJointLocalTransformComponent, "TypeName", "pp-set-tracked-hand-joint-local-transform");
__publicField(SetTrackedHandJointLocalTransformComponent, "Properties", {
  _myHandedness: Property.enum(["Left", "Right"], "Left"),
  _mySetLocalScaleAsJointRadius: Property.bool(false),
  _myJointID: Property.enum(
    [
      "Wrist",
      "Thumb Metacarpal",
      "Thumb Phalanx Proximal",
      "Thumb Phalanx Distal",
      "Thumb Tip",
      "Index Metacarpal",
      "Index Phalanx Proximal",
      "Index Phalanx Intermediate",
      "Index Phalanx Distal",
      "Index Tip",
      "Middle Metacarpal",
      "Middle Phalanx Proximal",
      "Middle Phalanx Intermediate",
      "Middle Phalanx Distal",
      "Middle Tip",
      "Ring Metacarpal",
      "Ring Phalanx Proximal",
      "Ring Phalanx Intermediate",
      "Ring Phalanx Distal",
      "Ring Tip",
      "Pinky Metacarpal",
      "Pinky Phalanx Proximal",
      "Pinky Phalanx Intermediate",
      "Pinky Phalanx Distal",
      "Pinky Tip"
    ],
    "Wrist"
  )
});
SetTrackedHandJointLocalTransformComponent.prototype.onPoseUpdated = function() {
  let jointPoseTransform = quat2_create();
  return function onPoseUpdated(pose) {
    if (this.active && XRUtils.isSessionActive(this.engine)) {
      if (pose.isValid()) {
        this.object.pp_setTransformLocalQuat(pose.getTransformQuat(jointPoseTransform, null));
        if (this._mySetLocalScaleAsJointRadius) {
          this.object.pp_setScaleLocal(pose.getJointRadius());
        }
      }
    }
  };
}();

// js/pp/input/pose/components/copy_hand_transform_component.js
var CopyHandTransformComponent = class extends Component {
  init() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
  }
  update(dt) {
    let hand = Globals.getPlayerObjects(this.engine).myHands[this._myHandednessType];
    this.object.pp_setTransformQuat(hand.pp_getTransformQuat());
    this.object.pp_setScale(hand.pp_getScale());
  }
};
__publicField(CopyHandTransformComponent, "TypeName", "pp-copy-hand-transform");
__publicField(CopyHandTransformComponent, "Properties", {
  _myHandedness: Property.enum(["Left", "Right"], "Left")
});

// js/pp/input/pose/components/copy_head_transform_component.js
var CopyHeadTransformComponent = class extends Component {
  update(dt) {
    let head = Globals.getPlayerObjects(this.engine).myHead;
    this.object.pp_setTransformQuat(head.pp_getTransformQuat());
    this.object.pp_setScale(head.pp_getScale());
  }
};
__publicField(CopyHeadTransformComponent, "TypeName", "pp-copy-head-transform");
__publicField(CopyHeadTransformComponent, "Properties", {});

// js/pp/input/pose/components/copy_player_transform_component.js
var CopyPlayerTransformComponent = class extends Component {
  update(dt) {
    let player = Globals.getPlayerObjects(this.engine).myPlayer;
    this.object.pp_setTransformQuat(player.pp_getTransformQuat());
    this.object.pp_setScale(player.pp_getScale());
  }
};
__publicField(CopyPlayerTransformComponent, "TypeName", "pp-copy-player-transform");
__publicField(CopyPlayerTransformComponent, "Properties", {});

// js/pp/input/pose/components/copy_reference_space_transform_component.js
var CopyReferenceSpaceTransformComponent = class extends Component {
  update(dt) {
    let referenceSpace = Globals.getPlayerObjects(this.engine).myReferenceSpace;
    this.object.pp_setTransformQuat(referenceSpace.pp_getTransformQuat());
    this.object.pp_setScale(referenceSpace.pp_getScale());
  }
};
__publicField(CopyReferenceSpaceTransformComponent, "TypeName", "pp-copy-reference-space-transform");
__publicField(CopyReferenceSpaceTransformComponent, "Properties", {});

// js/pp/tool/cauldron/tool_types.js
var ToolHandedness = {
  NONE: null,
  LEFT: "left",
  RIGHT: "right"
};
var ToolInputSourceType = {
  NONE: null,
  GAMEPAD: 0,
  TRACKED_HAND: 1
};

// js/pp/tool/cauldron/components/tool_cursor_component.js
var ToolCursorComponent = class extends Component {
  init() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myCursorPositionDefaultOffset = vec3_create(0, -0.035, 0.05);
    this._myCursorRotationDefaultOffset = vec3_create(30, 0, 0);
    this._myCursorMeshScale = vec3_create(25e-4, 25e-4, 25e-4);
    this._myCursorColor = vec4_create(255 / 255, 255 / 255, 255 / 255, 1);
    this._myCursorTargetCollisionGroup = 7;
    this._myStarted = false;
  }
  start() {
    if (Globals.isToolEnabled(this.engine)) {
      this._myToolCursorObject = this.object.pp_addObject();
      this._myCursorObjectXR = this._myToolCursorObject.pp_addObject();
      if (this._myApplyDefaultCursorOffset) {
        this._myCursorObjectXR.pp_setPositionLocal(this._myCursorPositionDefaultOffset);
        this._myCursorObjectXR.pp_rotateObject(this._myCursorRotationDefaultOffset);
      }
      {
        this._myCursorMeshobject = this._myCursorObjectXR.pp_addObject();
        this._myCursorMeshobject.pp_setScale(this._myCursorMeshScale);
        let cursorMeshComponent = this._myCursorMeshobject.pp_addComponent(MeshComponent);
        cursorMeshComponent.mesh = Globals.getDefaultMeshes(this.engine).mySphere;
        cursorMeshComponent.material = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
        cursorMeshComponent.material.color = this._myCursorColor;
        this._myCursorComponentXR = this._myCursorObjectXR.pp_addComponent(Cursor, {
          "collisionGroup": this._myCursorTargetCollisionGroup,
          "handedness": this._myHandedness + 1,
          "cursorObject": this._myCursorMeshobject,
          "styleCursor": false
        });
        this._myCursorComponentXR.rayCastMode = 0;
        if (this._myPulseOnHover) {
          this._myCursorComponentXR.globalTarget.onHover.add(this._pulseOnHover.bind(this), { id: this });
        }
      }
      this._myCursorObjectNonXR = this._myToolCursorObject.pp_addObject();
      {
        this._myCursorComponentNonXR = this._myCursorObjectNonXR.pp_addComponent(Cursor, {
          "collisionGroup": this._myCursorTargetCollisionGroup,
          "handedness": this._myHandedness + 1,
          "styleCursor": this._myUpdatePointerCursorStyle
        });
        this._myCursorComponentNonXR.rayCastMode = 0;
        if (this._myPulseOnHover) {
          this._myCursorComponentNonXR.globalTarget.onHover.add(this._pulseOnHover.bind(this), { id: this });
        }
        this._myCursorComponentNonXR.pp_setViewComponent(Globals.getPlayerObjects(this.engine).myCameraNonXR.pp_getComponent(ViewComponent));
      }
      let fingerCursorMeshObject = null;
      let fingerCollisionSize = 0.0125;
      if (this._myShowFingerCursor) {
        fingerCursorMeshObject = this._myToolCursorObject.pp_addObject();
        let meshComponent = fingerCursorMeshObject.pp_addComponent(MeshComponent);
        meshComponent.mesh = Globals.getDefaultMeshes(this.engine).mySphere;
        meshComponent.material = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
        meshComponent.material.color = this._myCursorColor;
        fingerCursorMeshObject.pp_setScale(fingerCollisionSize);
      }
      this._myFingerCursorObject = this._myToolCursorObject.pp_addObject();
      this._myFingerCursorComponent = this._myFingerCursorObject.pp_addComponent(FingerCursorComponent, {
        "_myHandedness": this._myHandedness,
        "_myMultipleClicksEnabled": true,
        "_myCollisionGroup": this._myCursorTargetCollisionGroup,
        "_myCollisionSize": fingerCollisionSize,
        "_myCursorObject": fingerCursorMeshObject
      });
      this._myCursorComponentXR.active = false;
      this._myCursorComponentNonXR.active = false;
      this._myFingerCursorComponent.active = false;
      this._myStarted = true;
    }
  }
  update(dt) {
  }
  _isUsingHand() {
    let usingHand = false;
    if (XRUtils.getSession(this.engine) && XRUtils.getSession(this.engine).inputSources != null) {
      for (let i = 0; i < XRUtils.getSession(this.engine).inputSources.length; i++) {
        let input = XRUtils.getSession(this.engine).inputSources[i];
        if (input.hand && input.handedness == this._myHandednessType) {
          usingHand = true;
          break;
        }
      }
    }
    return usingHand;
  }
  _pulseOnHover(object) {
    let targetComponent = object.pp_getComponent(CursorTarget);
    if (targetComponent && !targetComponent.isSurface) {
      if (this._myHandedness == 0) {
        if (Globals.getLeftGamepad(this.engine) != null) {
          Globals.getLeftGamepad(this.engine).pulse(0.4, 0);
        }
      } else {
        if (Globals.getRightGamepad(this.engine) != null) {
          Globals.getRightGamepad(this.engine).pulse(0.4, 0);
        }
      }
    }
  }
  onDestroy() {
    if (this._myStarted) {
      this._myCursorComponentXR.globalTarget.onHover.remove(this);
      this._myCursorComponentNonXR.globalTarget.onHover.remove(this);
    }
  }
};
__publicField(ToolCursorComponent, "TypeName", "pp-tool-cursor");
__publicField(ToolCursorComponent, "Properties", {
  _myHandedness: Property.enum(["Left", "Right"], "Left"),
  _myApplyDefaultCursorOffset: Property.bool(true),
  _myPulseOnHover: Property.bool(false),
  _myShowFingerCursor: Property.bool(false),
  _myUpdatePointerCursorStyle: Property.bool(true)
});
ToolCursorComponent.prototype.update = function() {
  let transformQuat4 = quat2_create();
  return function update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myStarted) {
        let usingHand = this._isUsingHand();
        this._myFingerCursorComponent.active = usingHand;
        if (usingHand) {
          this._myCursorComponentXR.active = false;
          this._myCursorComponentNonXR.active = false;
        } else {
          if (XRUtils.isSessionActive(this.engine)) {
            this._myCursorComponentXR.active = !usingHand;
            this._myCursorComponentNonXR.active = false;
          } else {
            this._myCursorComponentNonXR.active = !usingHand;
            this._myCursorComponentXR.active = false;
            this._myCursorObjectNonXR.pp_setTransformQuat(Globals.getPlayerObjects(this.engine).myCameraNonXR.pp_getTransformQuat(transformQuat4));
          }
        }
      }
    }
  };
}();

// js/pp/tool/console_vr/console_vr_types.js
var ConsoleVRWidgetConsoleFunction = {
  DEBUG: 0,
  WARN: 1,
  ERROR: 2,
  LOG: 3,
  INFO: 4,
  ASSERT: 5
};
var ConsoleVRWidgetSender = {
  BROWSER_CONSOLE: 0,
  CONSOLE_VR: 1,
  WINDOW: 2
};
var ConsoleVRWidgetPulseOnNewMessage = {
  NEVER: 0,
  ALWAYS: 1,
  WHEN_HIDDEN: 2
};
var ConsoleVRWidgetMessageType = {
  DEBUG: 0,
  WARN: 1,
  ERROR: 2,
  LOG: 3
};

// js/pp/tool/console_vr/console_vr_widget_config.js
var ConsoleVRWidgetConfig = class {
  constructor() {
    this._setupBuildConfig();
    this._setupRuntimeConfig();
  }
  _setupBuildConfig() {
    this.myBackgroundColor = vec4_create(46 / 255, 46 / 255, 46 / 255, 1);
    this.myCursorTargetCollisionCollider = Collider.Box;
    this.myCursorTargetCollisionGroup = 7;
    this.myCursorTargetCollisionThickness = 1e-3;
    this.myDefaultTextColor = vec4_create(255 / 255, 255 / 255, 255 / 255, 1);
    this.myTextAlignment = Alignment.Center;
    this.myTextJustification = Justification.Middle;
    this.myTextColor = this.myDefaultTextColor;
    this.myMessageTypeColors = [];
    this.myMessageTypeColors[ConsoleVRWidgetMessageType.LOG] = this.myDefaultTextColor;
    this.myMessageTypeColors[ConsoleVRWidgetMessageType.ERROR] = vec4_create(255 / 255, 40 / 255, 40 / 255, 1);
    this.myMessageTypeColors[ConsoleVRWidgetMessageType.WARN] = vec4_create(250 / 255, 220 / 255, 40 / 255, 1);
    this.myMessageTypeColors[ConsoleVRWidgetMessageType.DEBUG] = vec4_create(60 / 255, 200 / 255, 255 / 255, 1);
    this.myMessagesPanelPosition = vec3_create(0, 0.075, 0);
    this.myMessagesBackgroundScale = vec3_create(0.34, 0.15, 1);
    {
      let xPaddingPercentage = 0.03;
      let yPaddingPercentage = xPaddingPercentage * this.myMessagesBackgroundScale[0] / this.myMessagesBackgroundScale[1] * 0.8;
      let xPosition = -this.myMessagesBackgroundScale[0] + this.myMessagesBackgroundScale[0] * xPaddingPercentage;
      let yPosition = this.myMessagesBackgroundScale[1] - this.myMessagesBackgroundScale[1] * yPaddingPercentage;
      this.myMessagesTextsPanelPosition = vec3_create(xPosition, yPosition, 7e-3);
    }
    this.myMessagesTextsPanelScale = vec3_create(0.1, 0.1, 0.1);
    this.myMessagesTextStartString = ".\n";
    this.myMessagesTextAlignment = Alignment.Left;
    this.myMessagesTextJustification = Justification.Top;
    this.myMessagesTextPositions = [];
    this.myMessagesTextPositions[ConsoleVRWidgetMessageType.LOG] = vec3_create(0, 0, 2e-4);
    this.myMessagesTextPositions[ConsoleVRWidgetMessageType.ERROR] = vec3_create(0, 0, 0);
    this.myMessagesTextPositions[ConsoleVRWidgetMessageType.WARN] = vec3_create(0, 0, 0);
    this.myMessagesTextPositions[ConsoleVRWidgetMessageType.DEBUG] = vec3_create(0, 0, 0);
    this.myMessagesTextColors = [];
    this.myMessagesTextColors[ConsoleVRWidgetMessageType.LOG] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.LOG];
    this.myMessagesTextColors[ConsoleVRWidgetMessageType.ERROR] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.ERROR];
    this.myMessagesTextColors[ConsoleVRWidgetMessageType.WARN] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.WARN];
    this.myMessagesTextColors[ConsoleVRWidgetMessageType.DEBUG] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.DEBUG];
    this.myButtonsPanelPosition = vec3_create(0, -0.11, 0.015);
    this.myButtonBackgroundScale = vec3_create(0.04, 0.02, 1);
    this.myButtonTextPosition = vec3_create(0, 0, 7e-3);
    this.myButtonTextScale = vec3_create(0.18, 0.18, 0.18);
    this.myButtonCursorTargetPosition = vec3_create(0, 0, 0);
    this.myButtonCursorTargetPosition[2] = this.myButtonTextPosition[2];
    this.myButtonsCollisionCollider = this.myCursorTargetCollisionCollider;
    this.myButtonsCollisionGroup = this.myCursorTargetCollisionGroup;
    this.myButtonsCollisionExtents = this.myButtonBackgroundScale.pp_clone();
    this.myButtonsCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myClearButtonTextLabel = "clear";
    this.myUpButtonTextLabel = "up";
    this.myDownButtonTextLabel = "down";
    this.myFilterButtonsTextColors = [];
    this.myFilterButtonsTextColors[ConsoleVRWidgetMessageType.LOG] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.LOG];
    this.myFilterButtonsTextColors[ConsoleVRWidgetMessageType.ERROR] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.ERROR];
    this.myFilterButtonsTextColors[ConsoleVRWidgetMessageType.WARN] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.WARN];
    this.myFilterButtonsTextColors[ConsoleVRWidgetMessageType.DEBUG] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.DEBUG];
    this.myFilterButtonsTextLabel = [];
    this.myFilterButtonsTextLabel[ConsoleVRWidgetMessageType.LOG] = "log";
    this.myFilterButtonsTextLabel[ConsoleVRWidgetMessageType.ERROR] = "error";
    this.myFilterButtonsTextLabel[ConsoleVRWidgetMessageType.WARN] = "warn";
    this.myFilterButtonsTextLabel[ConsoleVRWidgetMessageType.DEBUG] = "debug";
    {
      let numberOfButtons = 7;
      let buttonsHorizontalSpace = Math.max(0.68, this.myButtonBackgroundScale[0] * numberOfButtons);
      let numberOfSpacesBetweenButtons = 2 + 3 + 4 + 4 + 1 + 2;
      let spaceWidth = Math.max((buttonsHorizontalSpace - numberOfButtons * this.myButtonBackgroundScale[0] * 2) / numberOfSpacesBetweenButtons, 0);
      let halfButtonWidth = this.myButtonBackgroundScale[0];
      let initialPosition = -buttonsHorizontalSpace / 2;
      this.myFilterButtonsPositions = [];
      this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.LOG] = [initialPosition + spaceWidth * 2 + halfButtonWidth, 0, 0];
      this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.ERROR] = [this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.LOG][0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
      this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.WARN] = [this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.ERROR][0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
      this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.DEBUG] = [this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.WARN][0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
      this.myClearButtonPosition = [this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.DEBUG][0] + halfButtonWidth + spaceWidth * 4 + halfButtonWidth, 0, 0];
      this.myUpButtonPosition = [this.myClearButtonPosition[0] + halfButtonWidth + spaceWidth * 4 + halfButtonWidth, 0, 0];
      this.myDownButtonPosition = [this.myUpButtonPosition[0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
    }
    this.myNotifyIconBackgroundScale = vec3_create(0.01, 0.01, 1);
    this.myNotifyIconPanelPositions = [];
    this.myNotifyIconPanelPositions[ToolHandedness.NONE] = vec3_create(0, 0, 0);
    this.myNotifyIconPanelPositions[ToolHandedness.NONE][0] = -this.myMessagesBackgroundScale[0] + this.myNotifyIconBackgroundScale[0] + 0.01;
    this.myNotifyIconPanelPositions[ToolHandedness.NONE][1] = -this.myMessagesBackgroundScale[1] + this.myNotifyIconBackgroundScale[1] + 0.01;
    this.myNotifyIconPanelPositions[ToolHandedness.NONE][2] = this.myMessagesTextsPanelPosition[2] - 1e-5;
    this.myNotifyIconPanelPositions[ToolHandedness.LEFT] = this.myNotifyIconPanelPositions[ToolHandedness.NONE];
    this.myNotifyIconPanelPositions[ToolHandedness.RIGHT] = this.myNotifyIconPanelPositions[ToolHandedness.NONE];
    this.myNotifyIconCursorTargetPosition = vec3_create(0, 0, 0);
    this.myNotifyIconCursorTargetPosition[2] = this.myButtonsPanelPosition[2] + this.myButtonTextPosition[2] - this.myMessagesTextsPanelPosition[2];
    this.myNotifyIconCollisionExtents = this.myNotifyIconBackgroundScale.pp_clone();
    this.myNotifyIconCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myNotifyIconColor = vec4_create(210 / 255, 210 / 255, 210 / 255, 1);
    this.myPointerCollisionCollider = this.myCursorTargetCollisionCollider;
    this.myPointerCollisionGroup = this.myCursorTargetCollisionGroup;
    {
      let spaceBetweenMessagesAndButtons = Math.abs(this.myMessagesPanelPosition[1] - this.myMessagesBackgroundScale[1] - (this.myButtonsPanelPosition[1] + this.myButtonBackgroundScale[1]));
      let pointerCollisionHalfHeight = this.myMessagesBackgroundScale[1] + this.myButtonBackgroundScale[1] + spaceBetweenMessagesAndButtons / 2;
      this.myPointerCollisionExtents = vec3_create(this.myMessagesBackgroundScale[0], pointerCollisionHalfHeight, this.myCursorTargetCollisionThickness);
    }
    this.myPointerCursorTargetPosition = vec3_create(0, 0, 0);
    this.myPointerCursorTargetPosition[1] = this.myMessagesPanelPosition[1] + this.myMessagesBackgroundScale[1] - this.myPointerCollisionExtents[1];
    this.myPointerCursorTargetPosition[2] = this.myButtonsPanelPosition[2] + this.myButtonTextPosition[2] - 1e-4;
  }
  _setupRuntimeConfig() {
    this.myTabString = "     ";
    this.myAssertStartString = "Assertion failed:";
    this.myMaxCharactersPerLine = 100;
    this.myMaxLineSplits = 500;
    this.myMaxLines = 22;
    this.myMaxMessages = 2e3;
    this.myMaxMessagesDeletePad = 2e3;
    this.myLinesBetweenMessages = 1;
    this.myButtonHoverColor = vec4_create(150 / 255, 150 / 255, 150 / 255, 1);
    this.myButtonDisabledTextColor = this.myBackgroundColor;
    this.myButtonDisabledBackgroundColor = vec4_create(110 / 255, 110 / 255, 110 / 255, 1);
    this.myFilterButtonDisabledTextColor = this.myButtonDisabledTextColor;
    this.myFilterButtonDisabledBackgroundColor = this.myButtonDisabledBackgroundColor;
    this.myScrollDelay = 0.1;
    this.myScrollAmount = 1;
    this.myScrollThumbstickHandedness = ToolHandedness.RIGHT;
    this.myScrollThumbstickDelay = 0.1;
    this.myScrollThumbstickMinThreshold = 0.2;
    this.myScrollThumbstickAmount = 3;
    this.myPulseDelay = 5;
    this.myPulseIntensity = 0.3;
    this.myPulseDuration = 0.085;
    this.myClearBrowserConsoleWhenClearPressed = true;
    this.myGamepadScrollOnlyOnHover = true;
  }
};

// js/pp/tool/console_vr/console_vr_widget_ui.js
var ConsoleVRWidgetUI = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this._myEngine = engine2;
    this._myDestroyed = false;
  }
  build(parentObject, config, params) {
    this._myParentObject = parentObject;
    this._myConfig = config;
    this._myParams = params;
    this._myPlaneMesh = Globals.getDefaultMeshes(this._myEngine).myDoubleSidedPlane;
    this._createSkeleton();
    this._setTransforms();
    this._addComponents();
    this._setTransformForNonXR();
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myEngine);
  }
  setVisible(visible) {
    this.myPivotObject.pp_setActive(visible);
  }
  // Skeleton
  _createSkeleton() {
    this.myPivotObject = this._myParentObject.pp_addObject();
    this._createMessagesSkeleton();
    this._createButtonsSkeleton();
    this._createPointerSkeleton();
  }
  _createMessagesSkeleton() {
    this.myMessagesPanel = this.myPivotObject.pp_addObject();
    this.myMessagesBackground = this.myMessagesPanel.pp_addObject();
    this.myMessagesTextsPanel = this.myMessagesPanel.pp_addObject();
    this.myMessagesTexts = [];
    for (let key in ConsoleVRWidgetMessageType) {
      this.myMessagesTexts[ConsoleVRWidgetMessageType[key]] = this.myMessagesTextsPanel.pp_addObject();
    }
    this.myNotifyIconPanel = this.myMessagesPanel.pp_addObject();
    this.myNotifyIconBackground = this.myNotifyIconPanel.pp_addObject();
    this.myNotifyIconCursorTarget = this.myNotifyIconPanel.pp_addObject();
  }
  _createButtonsSkeleton() {
    this.myButtonsPanel = this.myPivotObject.pp_addObject();
    this.myFilterButtonsPanels = [];
    this.myFilterButtonsBackgrounds = [];
    this.myFilterButtonsTexts = [];
    this.myFilterButtonsCursorTargets = [];
    for (let key in ConsoleVRWidgetMessageType) {
      this.myFilterButtonsPanels[ConsoleVRWidgetMessageType[key]] = this.myButtonsPanel.pp_addObject();
      this.myFilterButtonsBackgrounds[ConsoleVRWidgetMessageType[key]] = this.myFilterButtonsPanels[ConsoleVRWidgetMessageType[key]].pp_addObject();
      this.myFilterButtonsTexts[ConsoleVRWidgetMessageType[key]] = this.myFilterButtonsPanels[ConsoleVRWidgetMessageType[key]].pp_addObject();
      this.myFilterButtonsCursorTargets[ConsoleVRWidgetMessageType[key]] = this.myFilterButtonsPanels[ConsoleVRWidgetMessageType[key]].pp_addObject();
    }
    this.myClearButtonPanel = this.myButtonsPanel.pp_addObject();
    this.myClearButtonBackground = this.myClearButtonPanel.pp_addObject();
    this.myClearButtonText = this.myClearButtonPanel.pp_addObject();
    this.myClearButtonCursorTarget = this.myClearButtonPanel.pp_addObject();
    this.myUpButtonPanel = this.myButtonsPanel.pp_addObject();
    this.myUpButtonBackground = this.myUpButtonPanel.pp_addObject();
    this.myUpButtonText = this.myUpButtonPanel.pp_addObject();
    this.myUpButtonCursorTarget = this.myUpButtonPanel.pp_addObject();
    this.myDownButtonPanel = this.myButtonsPanel.pp_addObject();
    this.myDownButtonBackground = this.myDownButtonPanel.pp_addObject();
    this.myDownButtonText = this.myDownButtonPanel.pp_addObject();
    this.myDownButtonCursorTarget = this.myDownButtonPanel.pp_addObject();
  }
  _createPointerSkeleton() {
    this.myPointerCursorTarget = this.myPivotObject.pp_addObject();
  }
  // Transforms
  _setTransforms() {
    this.myPivotObject.pp_markDirty();
    this._setMessagesTransforms();
    this._setButtonsTransforms();
    this._setPointerTransform();
  }
  _setMessagesTransforms() {
    this.myMessagesPanel.pp_setPositionLocal(this._myConfig.myMessagesPanelPosition);
    this.myMessagesBackground.pp_scaleObject(this._myConfig.myMessagesBackgroundScale);
    this.myMessagesTextsPanel.pp_setPositionLocal(this._myConfig.myMessagesTextsPanelPosition);
    this.myMessagesTextsPanel.pp_scaleObject(this._myConfig.myMessagesTextsPanelScale);
    for (let key in ConsoleVRWidgetMessageType) {
      this.myMessagesTexts[ConsoleVRWidgetMessageType[key]].pp_setPositionLocal(this._myConfig.myMessagesTextPositions[ConsoleVRWidgetMessageType[key]]);
    }
    this.myNotifyIconPanel.pp_setPositionLocal(this._myConfig.myNotifyIconPanelPositions[this._myParams.myHandedness]);
    this.myNotifyIconBackground.pp_scaleObject(this._myConfig.myNotifyIconBackgroundScale);
    this.myNotifyIconCursorTarget.pp_setPositionLocal(this._myConfig.myNotifyIconCursorTargetPosition);
  }
  _setButtonsTransforms() {
    this.myButtonsPanel.pp_setPositionLocal(this._myConfig.myButtonsPanelPosition);
    for (let key in ConsoleVRWidgetMessageType) {
      this.myFilterButtonsPanels[ConsoleVRWidgetMessageType[key]].pp_setPositionLocal(this._myConfig.myFilterButtonsPositions[ConsoleVRWidgetMessageType[key]]);
      this.myFilterButtonsBackgrounds[ConsoleVRWidgetMessageType[key]].pp_scaleObject(this._myConfig.myButtonBackgroundScale);
      this.myFilterButtonsTexts[ConsoleVRWidgetMessageType[key]].pp_setPositionLocal(this._myConfig.myButtonTextPosition);
      this.myFilterButtonsTexts[ConsoleVRWidgetMessageType[key]].pp_scaleObject(this._myConfig.myButtonTextScale);
      this.myFilterButtonsCursorTargets[ConsoleVRWidgetMessageType[key]].pp_setPositionLocal(this._myConfig.myButtonCursorTargetPosition);
    }
    {
      this.myClearButtonPanel.pp_setPositionLocal(this._myConfig.myClearButtonPosition);
      this.myClearButtonBackground.pp_scaleObject(this._myConfig.myButtonBackgroundScale);
      this.myClearButtonText.pp_setPositionLocal(this._myConfig.myButtonTextPosition);
      this.myClearButtonText.pp_scaleObject(this._myConfig.myButtonTextScale);
      this.myClearButtonCursorTarget.pp_setPositionLocal(this._myConfig.myButtonCursorTargetPosition);
    }
    {
      this.myUpButtonPanel.pp_setPositionLocal(this._myConfig.myUpButtonPosition);
      this.myUpButtonBackground.pp_scaleObject(this._myConfig.myButtonBackgroundScale);
      this.myUpButtonText.pp_setPositionLocal(this._myConfig.myButtonTextPosition);
      this.myUpButtonText.pp_scaleObject(this._myConfig.myButtonTextScale);
      this.myUpButtonCursorTarget.pp_setPositionLocal(this._myConfig.myButtonCursorTargetPosition);
    }
    {
      this.myDownButtonPanel.pp_setPositionLocal(this._myConfig.myDownButtonPosition);
      this.myDownButtonBackground.pp_scaleObject(this._myConfig.myButtonBackgroundScale);
      this.myDownButtonText.pp_setPositionLocal(this._myConfig.myButtonTextPosition);
      this.myDownButtonText.pp_scaleObject(this._myConfig.myButtonTextScale);
      this.myDownButtonCursorTarget.pp_setPositionLocal(this._myConfig.myButtonCursorTargetPosition);
    }
  }
  _setPointerTransform() {
    this.myPointerCursorTarget.pp_setPositionLocal(this._myConfig.myPointerCursorTargetPosition);
  }
  // Components
  _addComponents() {
    this._addMessagesComponents();
    this._addButtonsComponents();
    this._addPointerComponents();
  }
  _addMessagesComponents() {
    let messagesBackgroundMeshComp = this.myMessagesBackground.pp_addComponent(MeshComponent);
    messagesBackgroundMeshComp.mesh = this._myPlaneMesh;
    messagesBackgroundMeshComp.material = this._myParams.myPlaneMaterial.clone();
    messagesBackgroundMeshComp.material.color = this._myConfig.myBackgroundColor;
    this.myMessagesTextComponents = [];
    for (let key in ConsoleVRWidgetMessageType) {
      let textComp = this.myMessagesTexts[ConsoleVRWidgetMessageType[key]].pp_addComponent(TextComponent);
      textComp.alignment = this._myConfig.myMessagesTextAlignment;
      textComp.justification = this._myConfig.myMessagesTextJustification;
      textComp.material = this._myParams.myTextMaterial.clone();
      textComp.material.color = this._myConfig.myMessagesTextColors[ConsoleVRWidgetMessageType[key]];
      textComp.lineSpacing = 1.2;
      textComp.text = this._myConfig.myMessagesTextStartString;
      this.myMessagesTextComponents[ConsoleVRWidgetMessageType[key]] = textComp;
    }
    this.myNotifyIconBackgroundComponent = this.myNotifyIconBackground.pp_addComponent(MeshComponent);
    this.myNotifyIconBackgroundComponent.mesh = this._myPlaneMesh;
    this.myNotifyIconBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myNotifyIconBackgroundComponent.material.color = this._myConfig.myNotifyIconColor;
    this.myNotifyIconCursorTargetComponent = this.myNotifyIconCursorTarget.pp_addComponent(CursorTarget);
    this.myNotifyIconCollisionComponent = this.myNotifyIconCursorTarget.pp_addComponent(CollisionComponent);
    this.myNotifyIconCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myNotifyIconCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myNotifyIconCollisionComponent.extents = this._myConfig.myNotifyIconCollisionExtents;
  }
  _addButtonsComponents() {
    this.myFilterButtonsBackgroundComponents = [];
    this.myFilterButtonsTextComponents = [];
    this.myFilterButtonsCursorTargetComponents = [];
    this.myFilterButtonsCollisionComponents = [];
    for (let key in ConsoleVRWidgetMessageType) {
      let buttonBackgroundMeshComp = this.myFilterButtonsBackgrounds[ConsoleVRWidgetMessageType[key]].pp_addComponent(MeshComponent);
      buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
      buttonBackgroundMeshComp.material = this._myParams.myPlaneMaterial.clone();
      buttonBackgroundMeshComp.material.color = this._myConfig.myBackgroundColor;
      let buttonTextComp = this.myFilterButtonsTexts[ConsoleVRWidgetMessageType[key]].pp_addComponent(TextComponent);
      this._setupButtonTextComponent(buttonTextComp);
      buttonTextComp.material.color = this._myConfig.myFilterButtonsTextColors[ConsoleVRWidgetMessageType[key]];
      buttonTextComp.text = this._myConfig.myFilterButtonsTextLabel[ConsoleVRWidgetMessageType[key]];
      let buttonCursorTargetComp = this.myFilterButtonsCursorTargets[ConsoleVRWidgetMessageType[key]].pp_addComponent(CursorTarget);
      let buttonCollisionComp = this.myFilterButtonsCursorTargets[ConsoleVRWidgetMessageType[key]].pp_addComponent(CollisionComponent);
      buttonCollisionComp.collider = this._myConfig.myButtonsCollisionCollider;
      buttonCollisionComp.group = 1 << this._myConfig.myButtonsCollisionGroup;
      buttonCollisionComp.extents = this._myConfig.myButtonsCollisionExtents;
      this.myFilterButtonsBackgroundComponents[ConsoleVRWidgetMessageType[key]] = buttonBackgroundMeshComp;
      this.myFilterButtonsTextComponents[ConsoleVRWidgetMessageType[key]] = buttonTextComp;
      this.myFilterButtonsCursorTargetComponents[ConsoleVRWidgetMessageType[key]] = buttonCursorTargetComp;
      this.myFilterButtonsCollisionComponents[ConsoleVRWidgetMessageType[key]] = buttonCollisionComp;
    }
    {
      let buttonBackgroundMeshComp = this.myClearButtonBackground.pp_addComponent(MeshComponent);
      buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
      buttonBackgroundMeshComp.material = this._myParams.myPlaneMaterial.clone();
      buttonBackgroundMeshComp.material.color = this._myConfig.myBackgroundColor;
      let buttonTextComp = this.myClearButtonText.pp_addComponent(TextComponent);
      this._setupButtonTextComponent(buttonTextComp);
      buttonTextComp.text = this._myConfig.myClearButtonTextLabel;
      let buttonCursorTargetComp = this.myClearButtonCursorTarget.pp_addComponent(CursorTarget);
      let buttonCollisionComp = this.myClearButtonCursorTarget.pp_addComponent(CollisionComponent);
      buttonCollisionComp.collider = this._myConfig.myButtonsCollisionCollider;
      buttonCollisionComp.group = 1 << this._myConfig.myButtonsCollisionGroup;
      buttonCollisionComp.extents = this._myConfig.myButtonsCollisionExtents;
      this.myClearButtonBackgroundComponent = buttonBackgroundMeshComp;
      this.myClearButtonTextComponent = buttonTextComp;
      this.myClearButtonCursorTargetComponent = buttonCursorTargetComp;
      this.myClearButtonCollisionComponent = buttonCollisionComp;
    }
    {
      let buttonBackgroundMeshComp = this.myUpButtonBackground.pp_addComponent(MeshComponent);
      buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
      buttonBackgroundMeshComp.material = this._myParams.myPlaneMaterial.clone();
      buttonBackgroundMeshComp.material.color = this._myConfig.myBackgroundColor;
      let buttonTextComp = this.myUpButtonText.pp_addComponent(TextComponent);
      this._setupButtonTextComponent(buttonTextComp);
      buttonTextComp.text = this._myConfig.myUpButtonTextLabel;
      let buttonCursorTargetComp = this.myUpButtonCursorTarget.pp_addComponent(CursorTarget);
      let buttonCollisionComp = this.myUpButtonCursorTarget.pp_addComponent(CollisionComponent);
      buttonCollisionComp.collider = this._myConfig.myButtonsCollisionCollider;
      buttonCollisionComp.group = 1 << this._myConfig.myButtonsCollisionGroup;
      buttonCollisionComp.extents = this._myConfig.myButtonsCollisionExtents;
      this.myUpButtonBackgroundComponent = buttonBackgroundMeshComp;
      this.myUpButtonTextComponent = buttonTextComp;
      this.myUpButtonCursorTargetComponent = buttonCursorTargetComp;
      this.myUpButtonCollisionComponent = buttonCollisionComp;
    }
    {
      let buttonBackgroundMeshComp = this.myDownButtonBackground.pp_addComponent(MeshComponent);
      buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
      buttonBackgroundMeshComp.material = this._myParams.myPlaneMaterial.clone();
      buttonBackgroundMeshComp.material.color = this._myConfig.myBackgroundColor;
      let buttonTextComp = this.myDownButtonText.pp_addComponent(TextComponent);
      this._setupButtonTextComponent(buttonTextComp);
      buttonTextComp.text = this._myConfig.myDownButtonTextLabel;
      let buttonCursorTargetComp = this.myDownButtonCursorTarget.pp_addComponent(CursorTarget);
      let buttonCollisionComp = this.myDownButtonCursorTarget.pp_addComponent(CollisionComponent);
      buttonCollisionComp.collider = this._myConfig.myButtonsCollisionCollider;
      buttonCollisionComp.group = 1 << this._myConfig.myButtonsCollisionGroup;
      buttonCollisionComp.extents = this._myConfig.myButtonsCollisionExtents;
      this.myDownButtonBackgroundComponent = buttonBackgroundMeshComp;
      this.myDownButtonTextComponent = buttonTextComp;
      this.myDownButtonCursorTargetComponent = buttonCursorTargetComp;
      this.myDownButtonCollisionComponent = buttonCollisionComp;
    }
  }
  _addPointerComponents() {
    this.myPointerCursorTargetComponent = this.myPointerCursorTarget.pp_addComponent(CursorTarget);
    this.myPointerCursorTargetComponent.isSurface = true;
    let collisionComp = this.myPointerCursorTarget.pp_addComponent(CollisionComponent);
    collisionComp.collider = this._myConfig.myPointerCollisionCollider;
    collisionComp.group = 1 << this._myConfig.myPointerCollisionGroup;
    collisionComp.extents = this._myConfig.myPointerCollisionExtents;
    this.myPointerCollisionComponent = collisionComp;
  }
  _setupButtonTextComponent(textComponent) {
    textComponent.alignment = this._myConfig.myTextAlignment;
    textComponent.justification = this._myConfig.myTextJustification;
    textComponent.material = this._myParams.myTextMaterial.clone();
    textComponent.material.color = this._myConfig.myTextColor;
    textComponent.text = "";
  }
  _onXRSessionStart() {
    this._setTransformForXR();
  }
  _onXRSessionEnd() {
    this._setTransformForNonXR();
  }
  _setTransformForXR() {
    this.myNotifyIconPanel.pp_setPositionLocal(this._myConfig.myNotifyIconPanelPositions[this._myParams.myHandedness]);
  }
  _setTransformForNonXR() {
    this.myNotifyIconPanel.pp_setPositionLocal(this._myConfig.myNotifyIconPanelPositions[ToolHandedness.NONE]);
  }
  destroy() {
    this._myDestroyed = true;
    XRUtils.unregisterSessionStartEndEventListeners(this, this._myEngine);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/tool/widget_frame/widget_frame_config.js
var WidgetFrameConfig = class {
  constructor(widgetLetterID, buttonsColumnIndex) {
    this._setupBuildConfig(widgetLetterID, buttonsColumnIndex);
    this._setupRuntimeConfig();
  }
  _setupBuildConfig(widgetLetterID, buttonsColumnIndex) {
    this.myBackgroundColor = vec4_create(46 / 255, 46 / 255, 46 / 255, 1);
    this.myCursorTargetCollisionCollider = Collider.Box;
    this.myCursorTargetCollisionGroup = 7;
    this.myCursorTargetCollisionThickness = 1e-3;
    this.myDefaultTextColor = vec4_create(255 / 255, 255 / 255, 255 / 255, 1);
    this.myTextAlignment = Alignment.Center;
    this.myTextJustification = Justification.Middle;
    this.myTextColor = this.myDefaultTextColor;
    this.myButtonTextScale = vec3_create(0.18, 0.18, 0.18);
    this.myVisibilityButtonBackgroundScale = vec3_create(0.015, 0.015, 1);
    this.myVisibilityButtonTextPosition = vec3_create(0, 0, 7e-3);
    this.myVisibilityButtonTextScale = this.myButtonTextScale;
    let distanceBetweenToolsVisibilityButtons = 0.01;
    let buttonXOffset = this.myVisibilityButtonBackgroundScale[0] * (2 * buttonsColumnIndex) + distanceBetweenToolsVisibilityButtons * buttonsColumnIndex;
    this.myVisibilityButtonPosition = [];
    this.myVisibilityButtonPosition[ToolHandedness.NONE] = {};
    this.myVisibilityButtonPosition[ToolHandedness.NONE].myPosition = vec3_create(-0.3 + buttonXOffset, -0.205, 0.035);
    this.myVisibilityButtonPosition[ToolHandedness.LEFT] = {};
    this.myVisibilityButtonPosition[ToolHandedness.LEFT].myPosition = vec3_create(-0.2 + buttonXOffset, 0.025, 0.015);
    this.myVisibilityButtonPosition[ToolHandedness.RIGHT] = {};
    this.myVisibilityButtonPosition[ToolHandedness.RIGHT].myPosition = vec3_create(0.2 - buttonXOffset, 0.025, 0.015);
    this.myVisibilityButtonText = widgetLetterID;
    this.myVisibilityButtonCursorTargetPosition = vec3_create(0, 0, 0);
    this.myVisibilityButtonCursorTargetPosition[2] = this.myVisibilityButtonTextPosition[2];
    this.myVisibilityButtonCollisionExtents = this.myVisibilityButtonBackgroundScale.pp_clone();
    this.myVisibilityButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myFlagButtonBackgroundScale = vec3_create(0.0125, 0.0125, 1);
    this.myFlagButtonTextPosition = vec3_create(0, 0, 7e-3);
    this.myFlagButtonTextScale = vec3_create(0.15, 0.15, 0.15);
    let distanceBetweenFlagButtons = 75e-4;
    let pinFlagIndex = 0;
    let pinButtonYOffset = this.myVisibilityButtonBackgroundScale[1] + this.myFlagButtonBackgroundScale[1] + distanceBetweenFlagButtons + this.myFlagButtonBackgroundScale[1] * (2 * pinFlagIndex) + distanceBetweenFlagButtons * pinFlagIndex;
    this.myPinButtonPosition = [];
    this.myPinButtonPosition[ToolHandedness.NONE] = {};
    this.myPinButtonPosition[ToolHandedness.NONE].myPosition = this.myVisibilityButtonPosition[ToolHandedness.NONE].myPosition.pp_clone();
    this.myPinButtonPosition[ToolHandedness.NONE].myPosition[1] += pinButtonYOffset;
    this.myPinButtonPosition[ToolHandedness.LEFT] = {};
    this.myPinButtonPosition[ToolHandedness.LEFT].myPosition = this.myVisibilityButtonPosition[ToolHandedness.LEFT].myPosition.pp_clone();
    this.myPinButtonPosition[ToolHandedness.LEFT].myPosition[1] += pinButtonYOffset;
    this.myPinButtonPosition[ToolHandedness.RIGHT] = {};
    this.myPinButtonPosition[ToolHandedness.RIGHT].myPosition = this.myVisibilityButtonPosition[ToolHandedness.RIGHT].myPosition.pp_clone();
    this.myPinButtonPosition[ToolHandedness.RIGHT].myPosition[1] += pinButtonYOffset;
    this.myPinButtonText = "P";
    this.myPinButtonCursorTargetPosition = vec3_create(0, 0, 0);
    this.myPinButtonCursorTargetPosition[2] = this.myFlagButtonTextPosition[2];
    this.myPinButtonCollisionExtents = this.myFlagButtonBackgroundScale.pp_clone();
    this.myPinButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;
  }
  _setupRuntimeConfig() {
    this._initializeObjectsTransforms();
    this.myButtonHoverColor = vec4_create(150 / 255, 150 / 255, 150 / 255, 1);
    this.myButtonDisabledTextColor = this.myBackgroundColor;
    this.myButtonDisabledBackgroundColor = vec4_create(110 / 255, 110 / 255, 110 / 255, 1);
  }
  _initializeObjectsTransforms() {
    this.myPivotObjectTransforms = this._createDefaultObjectTransforms();
    this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.LEFT].myRotation = quat_create(-0.645, 0.425, 0.25, 0.584);
    this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.LEFT].myRotation.quat_normalize(this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.LEFT].myRotation);
    this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.RIGHT].myRotation = quat_create(-0.645, -0.425, -0.25, 0.584);
    this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.RIGHT].myRotation.quat_normalize(this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.RIGHT].myRotation);
    this.myPivotObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.LEFT].myRotation = quat_create(-0.645, 0.425, 0.25, 0.584);
    this.myPivotObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.LEFT].myRotation.quat_normalize(this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.LEFT].myRotation);
    this.myPivotObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.RIGHT].myRotation = quat_create(-0.645, -0.425, -0.25, 0.584);
    this.myPivotObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.RIGHT].myRotation.quat_normalize(this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.RIGHT].myRotation);
    this.myWidgetObjectTransforms = this._createDefaultObjectTransforms();
    this.myWidgetObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.LEFT].myPosition = vec3_create(0.1, 0.23, -0.02);
    this.myWidgetObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.RIGHT].myPosition = vec3_create(0.07, 0.23, -0.02);
    this.myWidgetObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.LEFT].myPosition = vec3_create(0.1, 0.23, -0.02);
    this.myWidgetObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.RIGHT].myPosition = vec3_create(0.07, 0.23, -0.02);
    this._myPivotObjectDistanceFromHeadNonXR = 0.6;
  }
  _createDefaultObjectTransforms() {
    let defaultObjectTransforms = [];
    for (let inputSourceTypeKey in ToolInputSourceType) {
      let inputSourceType = ToolInputSourceType[inputSourceTypeKey];
      defaultObjectTransforms[inputSourceType] = [];
      for (let handednessKey in ToolHandedness) {
        let handedness = ToolHandedness[handednessKey];
        defaultObjectTransforms[inputSourceType][handedness] = {};
        defaultObjectTransforms[inputSourceType][handedness].myPosition = vec3_create(0, 0, 0);
        defaultObjectTransforms[inputSourceType][handedness].myRotation = quat_create(0, 0, 0, 1);
      }
    }
    return defaultObjectTransforms;
  }
};

// js/pp/tool/widget_frame/widget_frame_ui.js
var WidgetFrameUI = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this._myInputSourceType = null;
    this._myParentObject = null;
    this._myPinned = false;
    this._myWidgetVisible = true;
    this._myVisibilityButtonVisible = true;
    this._myEngine = engine2;
    this._myDestroyed = false;
  }
  build(parentObject, config, params) {
    this._myParentObject = parentObject;
    this._myConfig = config;
    this._myParams = params;
    this._myPlaneMesh = Globals.getDefaultMeshes(this._myEngine).myDoubleSidedPlane;
    this._createSkeleton();
    this._setTransforms();
    this._addComponents();
    this._setTransformForNonXR();
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myEngine);
  }
  setWidgetVisible(visible) {
    this._myWidgetVisible = visible;
    this.myFlagsButtonPanel.pp_setActive(visible);
    if (visible) {
      this._updateObjectsTransforms(true);
    }
  }
  setVisibilityButtonVisible(visible) {
    this._myVisibilityButtonVisible = visible;
    this.myVisibilityButtonPanel.pp_setActive(visible);
  }
  setPinned(pinned) {
    if (pinned != this._myPinned) {
      this._myPinned = pinned;
      if (this._myPinned) {
        this.myPivotObject.pp_setParent(Globals.getSceneObjects(this._myEngine).myTools);
      } else {
        this.myPivotObject.pp_setParent(this.myFixForwardObject);
        if (!XRUtils.isSessionActive(this._myEngine)) {
          this._setTransformForNonXR();
        }
        this._updateObjectsTransforms(true);
      }
    }
  }
  update(dt) {
    this._updateObjectsTransforms(false);
  }
  _updateObjectsTransforms(forceRefreshObjectsTransforms) {
    if (XRUtils.isSessionActive(this._myEngine)) {
      let inputSourceType = InputUtils.getInputSourceTypeByHandedness(this._myParams.myHandedness, this._myEngine);
      if (inputSourceType != this._myInputSourceType || forceRefreshObjectsTransforms) {
        this._myInputSourceType = inputSourceType;
        if (!this._myPinned) {
          this.myPivotObject.pp_setPositionLocal(this._myConfig.myPivotObjectTransforms[this._myInputSourceType][this._myParams.myHandedness].myPosition);
          this.myPivotObject.pp_resetRotationLocal();
          this.myPivotObject.pp_rotateObjectQuat(this._myConfig.myPivotObjectTransforms[this._myInputSourceType][this._myParams.myHandedness].myRotation);
          this.myWidgetObject.pp_setPositionLocal(this._myConfig.myWidgetObjectTransforms[this._myInputSourceType][this._myParams.myHandedness].myPosition);
          this.myWidgetObject.pp_resetRotationLocal();
          this.myWidgetObject.pp_rotateObjectQuat(this._myConfig.myWidgetObjectTransforms[this._myInputSourceType][this._myParams.myHandedness].myRotation);
          this.myVisibilityButtonPanel.pp_setPositionLocal(this._myConfig.myVisibilityButtonPosition[this._myParams.myHandedness].myPosition);
          this.myPinButtonPanel.pp_setPositionLocal(this._myConfig.myPinButtonPosition[this._myParams.myHandedness].myPosition);
        }
      }
    } else {
      this.myVisibilityButtonPanel.pp_setActive(this._myWidgetVisible || this._myVisibilityButtonVisible);
    }
  }
  // Skeleton
  _createSkeleton() {
    this.myFixForwardObject = this._myParentObject.pp_addObject();
    if (Globals.isPoseForwardFixed(this._myEngine)) {
      this.myFixForwardObject.pp_rotateObject(vec3_create(0, 180, 0));
    }
    this.myPivotObject = this.myFixForwardObject.pp_addObject();
    this.myWidgetObject = this.myPivotObject.pp_addObject();
    this.myVisibilityButtonPanel = this.myPivotObject.pp_addObject();
    this.myVisibilityButtonBackground = this.myVisibilityButtonPanel.pp_addObject();
    this.myVisibilityButtonText = this.myVisibilityButtonPanel.pp_addObject();
    this.myVisibilityButtonCursorTarget = this.myVisibilityButtonPanel.pp_addObject();
    this.myFlagsButtonPanel = this.myPivotObject.pp_addObject();
    this.myPinButtonPanel = this.myFlagsButtonPanel.pp_addObject();
    this.myPinButtonBackground = this.myPinButtonPanel.pp_addObject();
    this.myPinButtonText = this.myPinButtonPanel.pp_addObject();
    this.myPinButtonCursorTarget = this.myPinButtonPanel.pp_addObject();
    this.myNonXRParentObject = Globals.getPlayerObjects(this._myEngine).myCameraNonXR.pp_addObject();
    this.myNonXRParentObject.pp_translateLocal(vec3_create(0, 0, -this._myConfig._myPivotObjectDistanceFromHeadNonXR));
    this.myNonXRParentObject.pp_lookToLocal(vec3_create(0, 0, 1), vec3_create(0, 1, 0));
  }
  // Transforms
  _setTransforms() {
    this.myPivotObject.pp_markDirty();
    this.myVisibilityButtonPanel.pp_setPositionLocal(this._myConfig.myVisibilityButtonPosition[this._myParams.myHandedness].myPosition);
    this.myVisibilityButtonBackground.pp_scaleObject(this._myConfig.myVisibilityButtonBackgroundScale);
    this.myVisibilityButtonText.pp_setPositionLocal(this._myConfig.myVisibilityButtonTextPosition);
    this.myVisibilityButtonText.pp_scaleObject(this._myConfig.myVisibilityButtonTextScale);
    this.myVisibilityButtonCursorTarget.pp_setPositionLocal(this._myConfig.myVisibilityButtonCursorTargetPosition);
    this.myPinButtonPanel.pp_setPositionLocal(this._myConfig.myPinButtonPosition[this._myParams.myHandedness].myPosition);
    this.myPinButtonBackground.pp_scaleObject(this._myConfig.myFlagButtonBackgroundScale);
    this.myPinButtonText.pp_setPositionLocal(this._myConfig.myFlagButtonTextPosition);
    this.myPinButtonText.pp_scaleObject(this._myConfig.myFlagButtonTextScale);
    this.myPinButtonCursorTarget.pp_setPositionLocal(this._myConfig.myPinButtonCursorTargetPosition);
  }
  // Components
  _addComponents() {
    this.myVisibilityButtonBackgroundComponent = this.myVisibilityButtonBackground.pp_addComponent(MeshComponent);
    this.myVisibilityButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myVisibilityButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myVisibilityButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myVisibilityButtonTextComponent = this.myVisibilityButtonText.pp_addComponent(TextComponent);
    this._setupButtonTextComponent(this.myVisibilityButtonTextComponent);
    this.myVisibilityButtonTextComponent.text = this._myConfig.myVisibilityButtonText;
    this.myVisibilityButtonCursorTargetComponent = this.myVisibilityButtonCursorTarget.pp_addComponent(CursorTarget);
    this.myVisibilityButtonCollisionComponent = this.myVisibilityButtonCursorTarget.pp_addComponent(CollisionComponent);
    this.myVisibilityButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myVisibilityButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myVisibilityButtonCollisionComponent.extents = this._myConfig.myVisibilityButtonCollisionExtents;
    this.myPinButtonBackgroundComponent = this.myPinButtonBackground.pp_addComponent(MeshComponent);
    this.myPinButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPinButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myPinButtonBackgroundComponent.material.color = this._myConfig.myButtonDisabledBackgroundColor;
    this.myPinButtonTextComponent = this.myPinButtonText.pp_addComponent(TextComponent);
    this._setupButtonTextComponent(this.myPinButtonTextComponent);
    this.myPinButtonTextComponent.material.color = this._myConfig.myButtonDisabledTextColor;
    this.myPinButtonTextComponent.text = this._myConfig.myPinButtonText;
    this.myPinButtonCursorTargetComponent = this.myPinButtonCursorTarget.pp_addComponent(CursorTarget);
    this.myPinButtonCollisionComponent = this.myPinButtonCursorTarget.pp_addComponent(CollisionComponent);
    this.myPinButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPinButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPinButtonCollisionComponent.extents = this._myConfig.myPinButtonCollisionExtents;
  }
  _setupButtonTextComponent(textComponent) {
    textComponent.alignment = this._myConfig.myTextAlignment;
    textComponent.justification = this._myConfig.myTextJustification;
    textComponent.material = this._myParams.myTextMaterial.clone();
    textComponent.material.color = this._myConfig.myTextColor;
    textComponent.text = "";
  }
  _onXRSessionStart() {
    this.myVisibilityButtonPanel.pp_setActive(this._myVisibilityButtonVisible);
    this._setTransformForXR();
  }
  _onXRSessionEnd() {
    this._setTransformForNonXR();
  }
  _setTransformForXR() {
    this.myFixForwardObject.pp_setParent(this._myParentObject);
    this.myFixForwardObject.pp_resetTransformLocal();
    if (Globals.isPoseForwardFixed(this._myEngine)) {
      this.myFixForwardObject.pp_rotateObject(vec3_create(0, 180, 0));
    }
    this._updateObjectsTransforms(true);
  }
  _setTransformForNonXR() {
    if (!this._myPinned) {
      this.myFixForwardObject.pp_setParent(this.myNonXRParentObject);
      this.myFixForwardObject.pp_resetTransformLocal();
      this.myPivotObject.pp_setPositionLocal(this._myConfig.myPivotObjectTransforms[ToolInputSourceType.NONE][ToolHandedness.NONE].myPosition);
      this.myPivotObject.pp_resetRotationLocal();
      this.myPivotObject.pp_rotateObjectQuat(this._myConfig.myPivotObjectTransforms[ToolInputSourceType.NONE][ToolHandedness.NONE].myRotation);
      this.myWidgetObject.pp_setPositionLocal(this._myConfig.myWidgetObjectTransforms[ToolInputSourceType.NONE][ToolHandedness.NONE].myPosition);
      this.myWidgetObject.pp_resetRotationLocal();
      this.myWidgetObject.pp_rotateObjectQuat(this._myConfig.myWidgetObjectTransforms[ToolInputSourceType.NONE][ToolHandedness.NONE].myRotation);
      this.myVisibilityButtonPanel.pp_setPositionLocal(this._myConfig.myVisibilityButtonPosition[ToolHandedness.NONE].myPosition);
      this.myPinButtonPanel.pp_setPositionLocal(this._myConfig.myPinButtonPosition[ToolHandedness.NONE].myPosition);
    }
  }
  destroy() {
    this._myDestroyed = true;
    XRUtils.unregisterSessionStartEndEventListeners(this, this._myEngine);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/tool/widget_frame/widget_frame.js
var WidgetParams = class {
  constructor() {
    this.myHandedness = ToolHandedness.NONE;
    this.myPlaneMaterial = null;
    this.myTextMaterial = null;
  }
};
var WidgetFrame = class {
  constructor(widgetLetterID, buttonsColumnIndex, engine2 = Globals.getMainEngine()) {
    this._myWidgetVisible = true;
    this._myPinned = false;
    this._myConfig = new WidgetFrameConfig(widgetLetterID, buttonsColumnIndex);
    this._myParams = null;
    this._myUI = new WidgetFrameUI(engine2);
    this._myShowVisibilityButton = false;
    this._myWidgetVisibleChangedEmitter = new Emitter();
    this._myPinChangedEmitter = new Emitter();
    this._myDestroyed = true;
  }
  getWidgetObject() {
    return this._myUI.myWidgetObject;
  }
  setVisible(visible) {
    this._myWidgetVisible = !visible;
    this._toggleVisibility(false, true);
  }
  isVisible() {
    return this._myWidgetVisible;
  }
  toggleVisibility() {
    this._toggleVisibility(false, true);
  }
  togglePin() {
    this._togglePin(false);
  }
  registerWidgetVisibleChangedEventListener(id, listener) {
    this._myWidgetVisibleChangedEmitter.add(listener, { id });
  }
  unregisterWidgetVisibleChangedEventListener(id) {
    this._myWidgetVisibleChangedEmitter.remove(id);
  }
  registerPinChangedEventListener(id, listener) {
    this._myPinChangedEmitter.add(listener, { id });
  }
  unregisterPinChangedEventListener(id) {
    this._myPinChangedEmitter.remove(id);
  }
  start(parentObject, params) {
    this._myParams = params;
    this._myUI.build(parentObject, this._myConfig, params);
    this._myUI.setVisibilityButtonVisible(params.myShowVisibilityButton);
    this._myShowVisibilityButton = params.myShowVisibilityButton;
    if (!params.myShowOnStart) {
      this._toggleVisibility(false, false);
    }
    this._addListeners();
  }
  update(dt) {
    this._myUI.update(dt);
  }
  _addListeners() {
    let ui = this._myUI;
    ui.myPinButtonCursorTargetComponent.onClick.add(this._togglePin.bind(this, true));
    ui.myPinButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myPinButtonBackgroundComponent.material));
    ui.myPinButtonCursorTargetComponent.onUnhover.add(this._pinUnhover.bind(this, ui.myPinButtonBackgroundComponent.material));
    ui.myVisibilityButtonCursorTargetComponent.onClick.add(this._toggleVisibility.bind(this, true, true));
    ui.myVisibilityButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myVisibilityButtonBackgroundComponent.material));
    ui.myVisibilityButtonCursorTargetComponent.onUnhover.add(this._visibilityUnhover.bind(this, ui.myVisibilityButtonBackgroundComponent.material));
  }
  _toggleVisibility(isButton, notify) {
    this._myWidgetVisible = !this._myWidgetVisible;
    this._myUI.setWidgetVisible(this._myWidgetVisible);
    let textMaterial = this._myUI.myVisibilityButtonTextComponent.material;
    let backgroundMaterial = this._myUI.myVisibilityButtonBackgroundComponent.material;
    if (this._myWidgetVisible) {
      textMaterial.color = this._myConfig.myDefaultTextColor;
      if (!isButton) {
        backgroundMaterial.color = this._myConfig.myBackgroundColor;
      }
    } else {
      textMaterial.color = this._myConfig.myButtonDisabledTextColor;
      if (!isButton) {
        backgroundMaterial.color = this._myConfig.myButtonDisabledBackgroundColor;
      }
    }
    if (notify) {
      this._myWidgetVisibleChangedEmitter.notify(this._myWidgetVisible);
    }
    this._myUI.setVisibilityButtonVisible(this._myShowVisibilityButton);
  }
  _togglePin(isButton) {
    if (this._myWidgetVisible) {
      this._myPinned = !this._myPinned;
      this._myUI.setPinned(this._myPinned);
      let textMaterial = this._myUI.myPinButtonTextComponent.material;
      let backgroundMaterial = this._myUI.myPinButtonBackgroundComponent.material;
      if (this._myPinned) {
        textMaterial.color = this._myConfig.myDefaultTextColor;
        if (!isButton) {
          backgroundMaterial.color = this._myConfig.myBackgroundColor;
        }
      } else {
        textMaterial.color = this._myConfig.myButtonDisabledTextColor;
        if (!isButton) {
          backgroundMaterial.color = this._myConfig.myButtonDisabledBackgroundColor;
        }
      }
      this._myPinChangedEmitter.notify(this._myPinned);
    }
  }
  _genericHover(material) {
    material.color = this._myConfig.myButtonHoverColor;
  }
  _visibilityUnhover(material) {
    if (this._myWidgetVisible) {
      material.color = this._myConfig.myBackgroundColor;
    } else {
      material.color = this._myConfig.myButtonDisabledBackgroundColor;
    }
  }
  _pinUnhover(material) {
    if (this._myPinned) {
      material.color = this._myConfig.myBackgroundColor;
    } else {
      material.color = this._myConfig.myButtonDisabledBackgroundColor;
    }
  }
  destroy() {
    this._myDestroyed = true;
    if (this._myUI != null) {
      this._myUI.destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/tool/console_vr/console_vr_widget.js
var ConsoleVRWidgetParams = class extends WidgetParams {
  constructor() {
    super();
    this.myOverrideBrowserConsole = false;
    this.myShowOnStart = false;
    this.myShowVisibilityButton = false;
    this.myPulseOnNewMessage = ConsoleVRWidgetPulseOnNewMessage.NEVER;
    this.myResetBrowserConsoleOriginalFunctionsOnDestroy = true;
  }
};
var ConsoleVRWidgetMessage = class {
  constructor(messageType, messageLines) {
    this.myType = messageType;
    this.myLines = messageLines;
    this._myOriginalText = messageLines.join("\n");
    this._myMessagesCount = 1;
  }
  hasSameInfo(message) {
    return this._myOriginalText == message._myOriginalText && this.myType == message.myType;
  }
  increaseCount() {
    this._myMessagesCount += 1;
    let countString = "(x".concat(this._myMessagesCount).concat(") ");
    let text = this._myOriginalText;
    text = countString.concat(text);
    this.myLines = text.split("\n");
  }
};
var ConsoleVRWidget = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this._myWidgetFrame = new WidgetFrame("C", 0, engine2);
    this._myWidgetFrame.registerWidgetVisibleChangedEventListener(this, this._widgetVisibleChanged.bind(this));
    this._myConfig = new ConsoleVRWidgetConfig();
    this._myParams = null;
    this._myUI = new ConsoleVRWidgetUI(engine2);
    this._myMessages = [];
    this._myOldBrowserConsole = [];
    this._myOldConsoleVR = [];
    this._myTypeFilters = [];
    for (let key in ConsoleVRWidgetMessageType) {
      this._myTypeFilters[ConsoleVRWidgetMessageType[key]] = false;
    }
    this._myScrollUp = false;
    this._myScrollDown = false;
    this._myScrollOffset = 0;
    this._myScrollTimer = 0;
    this._myScrollThumbstickTimer = 0;
    this._myPulseTimer = 0;
    this._myGamepadScrollEnabled = true;
    if (this._myConfig.myGamepadScrollOnlyOnHover) {
      this._myGamepadScrollEnabled = false;
    }
    this._myErrorEventListener = null;
    this._myUnhandledRejectionEventListener = null;
    this._myConsolePrintAddMessageEnabled = true;
    this._myConsolePrintUpdateTextEnabled = true;
    this._myConsolePrintAddMessageEnabledReset = false;
    this._myConsolePrintUpdateTextEnabledReset = false;
    this._myTextDirty = false;
    this._myEngine = engine2;
    this._myDestroyed = false;
  }
  setVisible(visible) {
    this._myWidgetFrame.setVisible(visible);
  }
  isVisible() {
    return this._myWidgetFrame.isVisible();
  }
  start(parentObject, params) {
    this._myLeftGamepad = Globals.getLeftGamepad(this._myEngine);
    this._myRightGamepad = Globals.getRightGamepad(this._myEngine);
    this._myParams = params;
    this._myWidgetFrame.start(parentObject, params);
    this._myUI.build(this._myWidgetFrame.getWidgetObject(), this._myConfig, params);
    this._myUI.setVisible(this._myWidgetFrame.isVisible());
    this._setNotifyIconActive(false);
    this._addListeners();
    this._overrideConsolesFunctions();
  }
  update(dt) {
    this._myWidgetFrame.update(dt);
    if (this._myWidgetFrame.isVisible()) {
      if (this._myConsolePrintAddMessageEnabledReset) {
        this._myConsolePrintAddMessageEnabledReset = false;
        this._myConsolePrintAddMessageEnabled = true;
      }
      if (this._myConsolePrintUpdateTextEnabledReset) {
        this._myConsolePrintUpdateTextEnabledReset = false;
        this._myConsolePrintUpdateTextEnabled = true;
      }
      if (this._myTextDirty) {
        this._myTextDirty = false;
        this._updateAllTexts();
      }
      this._updateScroll(dt);
    }
    this._updateGamepadsExtraActions(dt);
  }
  // This must be done only when all the setup is complete, to avoid issues with other part of the code calling the console and then triggering the console vr while not ready yet
  _overrideConsolesFunctions() {
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.LOG] = console.log;
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.ERROR] = console.error;
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.WARN] = console.warn;
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.INFO] = console.info;
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.DEBUG] = console.debug;
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.ASSERT] = console.assert;
    this._myOldBrowserConsoleClear = console.clear;
    if (this._myParams.myOverrideBrowserConsole) {
      console.log = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.LOG, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      console.error = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.ERROR, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      console.warn = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.WARN, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      console.info = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.INFO, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      console.debug = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.DEBUG, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      console.assert = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.ASSERT, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      console.clear = this._clearConsole.bind(this, true, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      this._myErrorEventListener = function(errorEvent) {
        if (errorEvent.error != null) {
          this._consolePrint(ConsoleVRWidgetConsoleFunction.ERROR, ConsoleVRWidgetSender.WINDOW, "Uncaught", errorEvent.error.stack);
        } else {
          this._consolePrint(ConsoleVRWidgetConsoleFunction.ERROR, ConsoleVRWidgetSender.WINDOW, "Uncaught", errorEvent.message);
        }
      }.bind(this);
      this._myUnhandledRejectionEventListener = function(errorEvent) {
        this._consolePrint(ConsoleVRWidgetConsoleFunction.ERROR, ConsoleVRWidgetSender.WINDOW, "Uncaught (in promise)", errorEvent.reason);
      }.bind(this);
      Globals.getWindow(this._myEngine).addEventListener("error", this._myErrorEventListener);
      Globals.getWindow(this._myEngine).addEventListener("unhandledrejection", this._myUnhandledRejectionEventListener);
    }
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.LOG] = Globals.getConsoleVR(this._myEngine).log;
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.ERROR] = Globals.getConsoleVR(this._myEngine).error;
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.WARN] = Globals.getConsoleVR(this._myEngine).warn;
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.INFO] = Globals.getConsoleVR(this._myEngine).info;
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.DEBUG] = Globals.getConsoleVR(this._myEngine).debug;
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.ASSERT] = Globals.getConsoleVR(this._myEngine).assert;
    this._myOldConsoleVRClear = Globals.getConsoleVR(this._myEngine).clear;
    Globals.getConsoleVR(this._myEngine).log = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.LOG, ConsoleVRWidgetSender.CONSOLE_VR);
    Globals.getConsoleVR(this._myEngine).error = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.ERROR, ConsoleVRWidgetSender.CONSOLE_VR);
    Globals.getConsoleVR(this._myEngine).warn = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.WARN, ConsoleVRWidgetSender.CONSOLE_VR);
    Globals.getConsoleVR(this._myEngine).info = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.INFO, ConsoleVRWidgetSender.CONSOLE_VR);
    Globals.getConsoleVR(this._myEngine).debug = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.DEBUG, ConsoleVRWidgetSender.CONSOLE_VR);
    Globals.getConsoleVR(this._myEngine).assert = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.ASSERT, ConsoleVRWidgetSender.CONSOLE_VR);
    Globals.getConsoleVR(this._myEngine).clear = this._clearConsole.bind(this, true, ConsoleVRWidgetSender.CONSOLE_VR);
  }
  // Text section
  _updateText(messageType) {
    let consoleText = "";
    if (!this._myTypeFilters[messageType]) {
      let linesCount = 0;
      let i = this._myMessages.length - 1;
      let scrollLinesToSkip = Math.round(this._myScrollOffset);
      while (i >= 0 && linesCount < this._myConfig.myMaxLines) {
        let message = this._myMessages[i];
        if (this._myTypeFilters[message.myType]) {
          i -= 1;
          continue;
        }
        let messageLines = message.myLines.length;
        let linesToSkip = 0;
        if (scrollLinesToSkip > 0) {
          let additionalEmptyLines = 0;
          if (i != this._myMessages.length - 1) {
            additionalEmptyLines = this._myConfig.myLinesBetweenMessages;
          }
          if (scrollLinesToSkip >= messageLines + additionalEmptyLines) {
            scrollLinesToSkip -= messageLines + additionalEmptyLines;
            linesToSkip = messageLines + additionalEmptyLines;
          } else {
            linesToSkip = scrollLinesToSkip;
            scrollLinesToSkip = 0;
          }
        }
        if (i != this._myMessages.length - 1) {
          let emptyLinesToSkip = this._myConfig.myLinesBetweenMessages - Math.max(this._myConfig.myLinesBetweenMessages - linesToSkip, 0);
          let emptyLinesToShow = this._myConfig.myLinesBetweenMessages - emptyLinesToSkip;
          if (linesCount + emptyLinesToShow > this._myConfig.myMaxLines) {
            emptyLinesToShow = this._myMaxLines - linesCount;
          }
          for (let j = 0; j < emptyLinesToShow; j++) {
            consoleText = "\n".concat(consoleText);
          }
          linesCount += emptyLinesToShow;
          linesToSkip -= emptyLinesToSkip;
        }
        let linesToShow = messageLines - linesToSkip;
        if (linesCount + linesToShow > this._myConfig.myMaxLines) {
          linesToShow = this._myConfig.myMaxLines - linesCount;
        }
        if (linesToShow > 0) {
          if (message.myType == messageType) {
            let linesToPrint = message.myLines.slice(messageLines - linesToShow - linesToSkip, messageLines - linesToSkip);
            let text = linesToPrint.join("\n");
            consoleText = text.concat("\n").concat(consoleText);
            linesCount += linesToShow;
          } else {
            for (let j = 0; j < linesToShow; j++) {
              consoleText = "\n".concat(consoleText);
            }
            linesCount += linesToShow;
          }
        }
        i -= 1;
      }
    }
    consoleText = this._myConfig.myMessagesTextStartString.concat(consoleText);
    try {
      this._myConsolePrintUpdateTextEnabled = false;
      this._myUI.myMessagesTextComponents[messageType].text = consoleText;
      this._myConsolePrintUpdateTextEnabled = true;
    } catch (error3) {
      this._myConsolePrintUpdateTextEnabledReset = true;
      throw error3;
    }
  }
  _consolePrint(consoleFunction, sender, ...args) {
    if (this._myConsolePrintAddMessageEnabled && (consoleFunction != ConsoleVRWidgetConsoleFunction.ASSERT || args.length > 0 && !args[0])) {
      try {
        let message = this._argsToMessage(consoleFunction, ...args);
        this._addMessage(message);
        if (this._myMessages.length >= this._myConfig.myMaxMessages + this._myConfig.myMaxMessagesDeletePad) {
          this._myMessages = this._myMessages.slice(this._myMessages.length - this._myConfig.myMaxMessages);
          this._clampScrollOffset();
        }
      } catch (error3) {
        this._myConsolePrintAddMessageEnabled = false;
        this._myConsolePrintAddMessageEnabledReset = true;
        this._myTextDirty = true;
        try {
          let errorMessage = "An error occurred while trying to add a new message to the Console VR Widget";
          let message = new ConsoleVRWidgetMessage(ConsoleVRWidgetMessageType.ERROR, [errorMessage]);
          this._myMessages.push(message);
          ConsoleOriginalFunctions.error(this._myEngine, errorMessage);
        } catch (anotherError) {
        }
        throw error3;
      }
      if (this._myConsolePrintUpdateTextEnabled) {
        this._updateAllTexts();
        this._pulseGamepad();
      } else {
        this._myTextDirty = true;
      }
    }
    switch (sender) {
      case ConsoleVRWidgetSender.BROWSER_CONSOLE:
        this._myOldBrowserConsole[consoleFunction].apply(console, args);
        break;
      case ConsoleVRWidgetSender.CONSOLE_VR:
        this._myOldConsoleVR[consoleFunction].apply(Globals.getConsoleVR(this._myEngine), args);
        break;
      default:
        this._myOldBrowserConsole[consoleFunction].apply(console, args);
        break;
    }
  }
  _argsToMessage(consoleFunction, ...args) {
    if (consoleFunction == ConsoleVRWidgetConsoleFunction.ASSERT) {
      args = args.slice(1);
      args.splice(0, 0, this._myConfig.myAssertStartString);
    }
    let messageType = this._consoleFunctionToMessageType(consoleFunction);
    let formattedText = this._formatArgs(...args);
    let lines = this._splitLongLines(formattedText);
    if (messageType == ConsoleVRWidgetMessageType.INFO) {
      messageType = ConsoleVRWidgetMessageType.LOG;
    } else if (messageType == ConsoleVRWidgetMessageType.EXCEPTION || messageType == ConsoleVRWidgetMessageType.ASSERT) {
      messageType = ConsoleVRWidgetMessageType.ERROR;
    }
    let message = new ConsoleVRWidgetMessage(messageType, lines);
    return message;
  }
  _consoleFunctionToMessageType(consoleFunction) {
    let messageType = ConsoleVRWidgetMessageType.LOG;
    if (consoleFunction < ConsoleVRWidgetConsoleFunction.INFO) {
      messageType = consoleFunction;
    } else if (consoleFunction == ConsoleVRWidgetConsoleFunction.INFO) {
      messageType = ConsoleVRWidgetMessageType.LOG;
    } else {
      messageType = ConsoleVRWidgetMessageType.ERROR;
    }
    return messageType;
  }
  // Here the formatting using placeholder like %d could be implemented in the future
  _formatArgs(...args) {
    let stringifiedArgs = [];
    for (let i = 0; i < args.length; i++) {
      if (args[i] === void 0) {
        stringifiedArgs.push("undefined");
      } else {
        stringifiedArgs.push(this._stringifyItem(args[i]));
      }
    }
    let formattedString = stringifiedArgs.join(" ");
    return formattedString;
  }
  _stringifyItem(item) {
    let stringifiedItem = null;
    if (item instanceof Error) {
      stringifiedItem = item.stack;
    } else if (typeof item === "object") {
      let linesBetweenItems = 2;
      try {
        stringifiedItem = JSON.stringify(item, this._jsonReplacer.bind(this), linesBetweenItems);
      } catch (error3) {
        let cache = /* @__PURE__ */ new WeakSet();
        stringifiedItem = JSON.stringify(item, function(key, value) {
          if (typeof value === "object" && value !== null) {
            if (cache.has(value)) {
              return "<stringify error: object already stringified>";
            }
            cache.add(value);
          }
          return this._jsonReplacer(key, value);
        }.bind(this), linesBetweenItems);
      }
      stringifiedItem = stringifiedItem.replaceAll('"[', "[");
      stringifiedItem = stringifiedItem.replaceAll("'[", "[");
      stringifiedItem = stringifiedItem.replaceAll(']"', "]");
      stringifiedItem = stringifiedItem.replaceAll("]'", "]");
    } else {
      stringifiedItem = item;
    }
    return stringifiedItem;
  }
  _splitLongLines(messageText) {
    let linesToSplit = messageText.split("\n");
    let lines = [];
    for (let i = 0; i < linesToSplit.length; i++) {
      let lineToSplit = linesToSplit[i];
      if (lineToSplit.length > this._myConfig.myMaxCharactersPerLine) {
        let spacesAtStart = this._getSpacesAtStart(lineToSplit);
        let spaceToAdd = this._myConfig.myTabString.concat(spacesAtStart);
        let lineSplits = 0;
        while (lineToSplit.length > this._myConfig.myMaxCharactersPerLine && lineSplits < this._myConfig.myMaxLineSplits) {
          let firstSub = lineToSplit.substr(0, this._myConfig.myMaxCharactersPerLine - 1);
          let secondSub = lineToSplit.substr(this._myConfig.myMaxCharactersPerLine - 1);
          secondSub = spaceToAdd.concat(secondSub);
          lines.push(firstSub);
          lineToSplit = secondSub;
          lineSplits++;
        }
        lines.push(lineToSplit);
      } else {
        lines.push(lineToSplit);
      }
    }
    return lines;
  }
  _getSpacesAtStart(text) {
    let spaces = "";
    let i = 0;
    while (i < text.length && text[i] == " ") {
      spaces = spaces.concat(" ");
      i++;
    }
    return spaces;
  }
  _addMessage(message) {
    let hasSameInfoAsPrev = false;
    if (this._myMessages.length > 0) {
      let lastMessage = this._myMessages[this._myMessages.length - 1];
      if (lastMessage.hasSameInfo(message)) {
        lastMessage.increaseCount();
        hasSameInfoAsPrev = true;
      }
    }
    if (!hasSameInfoAsPrev) {
      this._myMessages.push(message);
    }
    this._adjustScrollOffsetAfterMessageAdded(message, hasSameInfoAsPrev);
    this._updateNotifyIcon(message);
  }
  // If you have scrolled, new messages does not move the scroll position
  _adjustScrollOffsetAfterMessageAdded(message, hasSameInfoAsPrev) {
    if (!hasSameInfoAsPrev && !this._myTypeFilters[message.myType] && this._myScrollOffset > 0) {
      this._myScrollOffset += message.myLines.length + this._myConfig.myLinesBetweenMessages;
    }
  }
  _updateAllTexts() {
    if (this._myWidgetFrame.isVisible()) {
      for (let key in ConsoleVRWidgetMessageType) {
        this._updateText(ConsoleVRWidgetMessageType[key]);
      }
    }
  }
  _updateNotifyIcon(message) {
    if (!this._myTypeFilters[message.myType] && this._myScrollOffset > 0) {
      this._setNotifyIconActive(true);
    }
  }
  _updateScroll(dt) {
    if (this._myScrollUp) {
      this._myScrollTimer += dt;
      while (this._myScrollTimer > this._myConfig.myScrollDelay) {
        this._myScrollTimer -= this._myConfig.myScrollDelay;
        this._myScrollOffset += this._myConfig.myScrollAmount;
      }
    } else if (this._myScrollDown) {
      this._myScrollTimer += dt;
      while (this._myScrollTimer > this._myConfig.myScrollDelay) {
        this._myScrollTimer -= this._myConfig.myScrollDelay;
        this._myScrollOffset -= this._myConfig.myScrollAmount;
      }
    }
    this._clampScrollOffset();
    if (this._myScrollUp || this._myScrollDown) {
      this._updateAllTexts();
    }
    if (this._myScrollOffset == 0) {
      this._setNotifyIconActive(false);
    }
  }
  _clampScrollOffset() {
    let maxScroll = this._getMaxScrollOffset();
    this._myScrollOffset = Math.pp_clamp(this._myScrollOffset, 0, maxScroll);
  }
  _getMaxScrollOffset() {
    return Math.max(this._getLinesCount() - this._myConfig.myMaxLines, 0);
  }
  _getLinesCount() {
    let linesCount = 0;
    for (let message of this._myMessages) {
      if (!this._myTypeFilters[message.myType]) {
        linesCount += message.myLines.length + this._myConfig.myLinesBetweenMessages;
      }
    }
    linesCount -= this._myConfig.myLinesBetweenMessages;
    linesCount = Math.max(linesCount, 0);
    return linesCount;
  }
  // Listener section
  _addListeners() {
    let ui = this._myUI;
    for (let key in ConsoleVRWidgetMessageType) {
      let cursorTarget = ui.myFilterButtonsCursorTargetComponents[ConsoleVRWidgetMessageType[key]];
      let backgroundMaterial = ui.myFilterButtonsBackgroundComponents[ConsoleVRWidgetMessageType[key]].material;
      let textMaterial = ui.myFilterButtonsTextComponents[ConsoleVRWidgetMessageType[key]].material;
      cursorTarget.onSingleClick.add(this._toggleFilter.bind(this, ConsoleVRWidgetMessageType[key], textMaterial));
      cursorTarget.onDoubleClick.add(this._filterAllButOne.bind(this, ConsoleVRWidgetMessageType[key], textMaterial));
      cursorTarget.onTripleClick.add(this._resetFilters.bind(this, ConsoleVRWidgetMessageType[key]));
      cursorTarget.onHover.add(this._filterHover.bind(this, ConsoleVRWidgetMessageType[key], backgroundMaterial));
      cursorTarget.onUnhover.add(this._filterUnhover.bind(this, ConsoleVRWidgetMessageType[key], backgroundMaterial));
    }
    {
      let cursorTarget = ui.myClearButtonCursorTargetComponent;
      let backgroundMaterial = ui.myClearButtonBackgroundComponent.material;
      cursorTarget.onClick.add(this._clearConsole.bind(this, false, null));
      cursorTarget.onHover.add(this._genericHover.bind(this, backgroundMaterial));
      cursorTarget.onUnhover.add(this._genericUnhover.bind(this, backgroundMaterial));
    }
    {
      let cursorTarget = ui.myUpButtonCursorTargetComponent;
      let backgroundMaterial = ui.myUpButtonBackgroundComponent.material;
      cursorTarget.onDoubleClick.add(this._instantScrollUp.bind(this, true));
      cursorTarget.onDown.add(this._setScrollUp.bind(this, true));
      cursorTarget.onDownOnHover.add(this._setScrollUp.bind(this, true));
      cursorTarget.onUp.add(this._setScrollUp.bind(this, false));
      cursorTarget.onUnhover.add(this._setScrollUp.bind(this, false));
      cursorTarget.onHover.add(this._genericHover.bind(this, backgroundMaterial));
      cursorTarget.onUnhover.add(this._genericUnhover.bind(this, backgroundMaterial));
    }
    {
      let cursorTarget = ui.myDownButtonCursorTargetComponent;
      let backgroundMaterial = ui.myDownButtonBackgroundComponent.material;
      cursorTarget.onDoubleClick.add(this._instantScrollDown.bind(this));
      cursorTarget.onDown.add(this._setScrollDown.bind(this, true));
      cursorTarget.onDownOnHover.add(this._setScrollDown.bind(this, true));
      cursorTarget.onUp.add(this._setScrollDown.bind(this, false));
      cursorTarget.onUnhover.add(this._setScrollDown.bind(this, false));
      cursorTarget.onHover.add(this._genericHover.bind(this, backgroundMaterial));
      cursorTarget.onUnhover.add(this._genericUnhover.bind(this, backgroundMaterial));
    }
    {
      let cursorTarget = ui.myNotifyIconCursorTargetComponent;
      let backgroundMaterial = ui.myNotifyIconBackgroundComponent.material;
      cursorTarget.onClick.add(this._instantScrollDown.bind(this));
      cursorTarget.onHover.add(this._genericHover.bind(this, backgroundMaterial));
      cursorTarget.onUnhover.add(this._notifyIconUnhover.bind(this));
    }
    ui.myPointerCursorTargetComponent.onHover.add(this._setGamepadScrollEnabled.bind(this, true));
    ui.myPointerCursorTargetComponent.onUnhover.add(this._setGamepadScrollEnabled.bind(this, false));
  }
  _resetFilters(messageType) {
    if (this._myWidgetFrame.isVisible()) {
      for (let key in ConsoleVRWidgetMessageType) {
        let backgroundMaterial = this._myUI.myFilterButtonsBackgroundComponents[ConsoleVRWidgetMessageType[key]].material;
        let filterTextMaterial = this._myUI.myFilterButtonsTextComponents[ConsoleVRWidgetMessageType[key]].material;
        this._myTypeFilters[ConsoleVRWidgetMessageType[key]] = false;
        filterTextMaterial.color = this._myConfig.myMessageTypeColors[ConsoleVRWidgetMessageType[key]];
        if (ConsoleVRWidgetMessageType[key] != messageType) {
          backgroundMaterial.color = this._myConfig.myBackgroundColor;
        }
      }
      this._clampScrollOffset();
      this._updateAllTexts();
    }
  }
  _filterAllButOne(messageType) {
    if (this._myWidgetFrame.isVisible()) {
      for (let key in ConsoleVRWidgetMessageType) {
        let backgroundMaterial = this._myUI.myFilterButtonsBackgroundComponents[ConsoleVRWidgetMessageType[key]].material;
        let filterTextMaterial = this._myUI.myFilterButtonsTextComponents[ConsoleVRWidgetMessageType[key]].material;
        if (ConsoleVRWidgetMessageType[key] != messageType) {
          this._myTypeFilters[ConsoleVRWidgetMessageType[key]] = true;
          backgroundMaterial.color = this._myConfig.myFilterButtonDisabledBackgroundColor;
          filterTextMaterial.color = this._myConfig.myFilterButtonDisabledTextColor;
        } else {
          this._myTypeFilters[ConsoleVRWidgetMessageType[key]] = false;
          filterTextMaterial.color = this._myConfig.myMessageTypeColors[messageType];
        }
      }
      this._clampScrollOffset();
      this._updateAllTexts();
    }
  }
  _toggleFilter(messageType, textMaterial) {
    if (this._myWidgetFrame.isVisible()) {
      this._myTypeFilters[messageType] = !this._myTypeFilters[messageType];
      if (this._myTypeFilters[messageType]) {
        textMaterial.color = this._myConfig.myFilterButtonDisabledTextColor;
      } else {
        textMaterial.color = this._myConfig.myMessageTypeColors[messageType];
      }
      this._clampScrollOffset();
      this._updateAllTexts();
    }
  }
  _clearConsole(codeDrivenClear = false, sender = null) {
    if (this._myWidgetFrame.isVisible() || codeDrivenClear) {
      this._myMessages = [];
      this._clampScrollOffset();
      this._updateAllTexts();
      if (codeDrivenClear) {
        switch (sender) {
          case ConsoleVRWidgetSender.BROWSER_CONSOLE:
            this._myOldBrowserConsoleClear.apply(console);
            break;
          case ConsoleVRWidgetSender.CONSOLE_VR:
            this._myOldConsoleVRClear.apply(Globals.getConsoleVR(this._myEngine));
            break;
          default:
            break;
        }
      } else if (this._myConfig.myClearBrowserConsoleWhenClearPressed) {
        ConsoleOriginalFunctions.clear(this._myEngine);
      }
    }
  }
  _setScrollUp(value) {
    if (this._myWidgetFrame.isVisible() || !value) {
      if (value) {
        this._myScrollTimer = 0;
      }
      this._myScrollUp = value;
    }
  }
  _setScrollDown(value) {
    if (this._myWidgetFrame.isVisible() || !value) {
      if (value) {
        this._myScrollTimer = 0;
      }
      this._myScrollDown = value;
    }
  }
  _instantScrollUp() {
    if (this._myWidgetFrame.isVisible()) {
      this._myScrollOffset = this._getMaxScrollOffset();
      this._updateAllTexts();
    }
  }
  _instantScrollDown() {
    if (this._myWidgetFrame.isVisible()) {
      this._myScrollOffset = 0;
      this._setNotifyIconActive(false);
      this._updateAllTexts();
    }
  }
  _setNotifyIconActive(active) {
    this._myUI.myNotifyIconPanel.pp_setActive(active && this._myWidgetFrame.isVisible());
  }
  _notifyIconUnhover() {
    let material = this._myUI.myNotifyIconBackgroundComponent.material;
    material.color = this._myConfig.myNotifyIconColor;
  }
  _filterHover(messageType, material) {
    this._genericHover(material);
  }
  _filterUnhover(messageType, material) {
    if (this._myTypeFilters[messageType]) {
      material.color = this._myConfig.myFilterButtonDisabledBackgroundColor;
    } else {
      material.color = this._myConfig.myBackgroundColor;
    }
  }
  _genericHover(material) {
    material.color = this._myConfig.myButtonHoverColor;
  }
  _genericUnhover(material) {
    material.color = this._myConfig.myBackgroundColor;
  }
  // Gamepad section
  _updateGamepadsExtraActions(dt) {
    if (this._myLeftGamepad && this._myRightGamepad) {
      if (this._myLeftGamepad.getButtonInfo(GamepadButtonID.THUMBSTICK).isPressStart() && this._myRightGamepad.getButtonInfo(GamepadButtonID.THUMBSTICK).isPressed() || this._myRightGamepad.getButtonInfo(GamepadButtonID.THUMBSTICK).isPressStart() && this._myLeftGamepad.getButtonInfo(GamepadButtonID.THUMBSTICK).isPressed()) {
        this._toggleVisibility();
      }
      this._myPulseTimer = Math.max(this._myPulseTimer - dt, 0);
      this._updateScrollWithThumbstick(dt);
    }
  }
  _toggleVisibility() {
    this._myWidgetFrame.toggleVisibility();
  }
  _widgetVisibleChanged(visible) {
    this._myUI.setVisible(visible);
    if (visible) {
      this._updateAllTexts();
    }
  }
  _updateScrollWithThumbstick(dt) {
    if (this._myWidgetFrame.isVisible() && this._myGamepadScrollEnabled) {
      let axes = vec2_create(0, 0);
      if (this._myConfig.myScrollThumbstickHandedness == ToolHandedness.LEFT) {
        axes = this._myLeftGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes;
      } else if (this._myConfig.myScrollThumbstickHandedness == ToolHandedness.RIGHT) {
        axes = this._myRightGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes;
      }
      if (Math.abs(axes[1]) > this._myConfig.myScrollThumbstickMinThreshold) {
        this._myScrollThumbstickTimer += dt;
        while (this._myScrollThumbstickTimer > this._myConfig.myScrollThumbstickDelay) {
          this._myScrollThumbstickTimer -= this._myConfig.myScrollThumbstickDelay;
          let normalizedScrollAmount = (Math.abs(axes[1]) - this._myConfig.myScrollThumbstickMinThreshold) / (1 - this._myConfig.myScrollThumbstickMinThreshold);
          this._myScrollOffset += Math.sign(axes[1]) * normalizedScrollAmount * this._myConfig.myScrollThumbstickAmount;
        }
        this._clampScrollOffset();
        this._updateAllTexts();
      } else {
        this._myScrollThumbstickTimer = 0;
      }
    }
  }
  _pulseGamepad() {
    if (this._myLeftGamepad && this._myRightGamepad) {
      let pulseType = this._myParams.myPulseOnNewMessage;
      let pulseEnabled = pulseType == ConsoleVRWidgetPulseOnNewMessage.ALWAYS || !this._myWidgetFrame.isVisible() && pulseType == ConsoleVRWidgetPulseOnNewMessage.WHEN_HIDDEN;
      if (pulseEnabled && this._myPulseTimer == 0) {
        if (this._myParams.myHandedness == ToolHandedness.RIGHT) {
          this._myRightGamepad.pulse(this._myConfig.myPulseIntensity, this._myConfig.myPulseDuration);
        } else {
          this._myLeftGamepad.pulse(this._myConfig.myPulseIntensity, this._myConfig.myPulseDuration);
        }
        this._myPulseTimer = this._myConfig.myPulseDelay;
      }
    }
  }
  _isSimpleArray(array) {
    if (this._isSpecialSimpleArray(array)) {
      return true;
    } else if (Array.isArray(array)) {
      let builtInArray = true;
      for (let element of array) {
        if (element instanceof Object) {
          builtInArray = false;
          break;
        }
      }
      return builtInArray;
    }
    return false;
  }
  _isSpecialSimpleArray(item) {
    return item && item.constructor && (item.constructor.name == "Uint8ClampedArray" || item.constructor.name == "Uint8Array" || item.constructor.name == "Uint16Array" || item.constructor.name == "Uint32Array" || item.constructor.name == "Int8Array" || item.constructor.name == "Int16Array" || item.constructor.name == "Int32Array" || item.constructor.name == "Float32Array" || item.constructor.name == "Float64Array");
  }
  _setGamepadScrollEnabled(enabled) {
    this._myGamepadScrollEnabled = enabled;
    if (!this._myConfig.myGamepadScrollOnlyOnHover) {
      this._myGamepadScrollEnabled = true;
    }
  }
  _jsonReplacer(key, value) {
    if (value instanceof Map) {
      return Array.from(value.entries());
    } else if (this._isSimpleArray(value)) {
      let array = value;
      if (this._isSpecialSimpleArray(array)) {
        let arrayCopy = [];
        for (let i = 0; i < array.length; i++) {
          arrayCopy[i] = array[i];
        }
        array = arrayCopy;
      }
      let stringifiedArray = JSON.stringify(array);
      stringifiedArray = stringifiedArray.split(",").join(", ");
      return stringifiedArray;
    } else {
      return value;
    }
  }
  destroy() {
    this._myDestroyed = true;
    Globals.getWindow(this._myEngine).removeEventListener("error", this._myErrorEventListener);
    Globals.getWindow(this._myEngine).removeEventListener("unhandledrejection", this._myUnhandledRejectionEventListener);
    this._myUI.destroy();
    this._myWidgetFrame.destroy();
    if (this._myParams.myResetBrowserConsoleOriginalFunctionsOnDestroy) {
      console.log = ConsoleOriginalFunctions.getLog(this._myEngine);
      console.error = ConsoleOriginalFunctions.getError(this._myEngine);
      console.warn = ConsoleOriginalFunctions.getWarn(this._myEngine);
      console.info = ConsoleOriginalFunctions.getInfo(this._myEngine);
      console.debug = ConsoleOriginalFunctions.getDebug(this._myEngine);
      console.assert = ConsoleOriginalFunctions.getAssert(this._myEngine);
      console.clear = ConsoleOriginalFunctions.getClear(this._myEngine);
    } else {
      console.log = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.LOG];
      console.error = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.ERROR];
      console.warn = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.WARN];
      console.info = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.INFO];
      console.debug = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.DEBUG];
      console.assert = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.ASSERT];
      console.clear = this._myOldBrowserConsoleClear;
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/tool/console_vr/components/console_vr_tool_component.js
var ConsoleVRToolComponent = class extends Component {
  start() {
    this._myStarted = false;
    if (Globals.isToolEnabled(this.engine)) {
      this.object.pp_addComponent(InitConsoleVRComponent);
      this._myWidget = new ConsoleVRWidget(this.engine);
      let params = new ConsoleVRWidgetParams(this.engine);
      params.myHandedness = [null, "left", "right"][this._myHandedness];
      params.myOverrideBrowserConsole = this._myOverrideBrowserConsole;
      params.myShowOnStart = this._myShowOnStart;
      params.myShowVisibilityButton = this._myShowVisibilityButton;
      params.myPulseOnNewMessage = this._myPulseOnNewMessage;
      params.myPlaneMaterial = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
      params.myTextMaterial = Globals.getDefaultMaterials(this.engine).myText.clone();
      this._myWidget.start(this.object, params);
      this._myWidgetVisibleBackup = null;
      this._myStarted = true;
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myStarted) {
        if (this._myWidgetVisibleBackup != null) {
          this._myWidget.setVisible(false);
          this._myWidget.setVisible(this._myWidgetVisibleBackup);
          this._myWidgetVisibleBackup = null;
        }
        this._myWidget.update(dt);
      }
    } else if (this._myStarted) {
      if (this._myWidgetVisibleBackup == null) {
        this._myWidgetVisibleBackup = this._myWidget.isVisible();
      }
      if (this._myWidget.isVisible()) {
        this._myWidget.setVisible(false);
      }
    }
  }
  onDeactivate() {
    if (this._myStarted) {
      if (this._myWidgetVisibleBackup == null) {
        this._myWidgetVisibleBackup = this._myWidget.isVisible();
      }
      if (this._myWidget.isVisible()) {
        this._myWidget.setVisible(false);
      }
    }
  }
  onDestroy() {
    if (this._myStarted) {
      this._myWidget.destroy();
    }
  }
};
__publicField(ConsoleVRToolComponent, "TypeName", "pp-console-vr-tool");
__publicField(ConsoleVRToolComponent, "Properties", {
  _myHandedness: Property.enum(["None", "Left", "Right"], "None"),
  _myOverrideBrowserConsole: Property.bool(true),
  _myShowOnStart: Property.bool(false),
  _myShowVisibilityButton: Property.bool(false),
  _myPulseOnNewMessage: Property.enum(["Never", "Always", "When Hidden"], "Never")
});

// js/pp/tool/easy_tune/easy_tune_utils.js
var _mySetWidgetCurrentVariableCallbacks = /* @__PURE__ */ new WeakMap();
var _myRefreshWidgetCallbacks = /* @__PURE__ */ new WeakMap();
function setWidgetCurrentVariable(variableName, engine2 = Globals.getMainEngine()) {
  if (_mySetWidgetCurrentVariableCallbacks.has(engine2)) {
    for (let callback of _mySetWidgetCurrentVariableCallbacks.get(engine2).values()) {
      callback(variableName);
    }
  }
}
function refreshWidget(engine2 = Globals.getMainEngine()) {
  if (_myRefreshWidgetCallbacks.has(engine2)) {
    for (let callback of _myRefreshWidgetCallbacks.get(engine2).values()) {
      callback();
    }
  }
}
function importVariables(fileURL = null, resetVariablesDefaultValueOnImport = false, onSuccessCallback = null, onFailureCallback = null, engine2 = Globals.getMainEngine()) {
  if (fileURL == null || fileURL.length == 0) {
    if (Globals.getNavigator(engine2).clipboard) {
      Globals.getNavigator(engine2).clipboard.readText().then(
        function(clipboard) {
          Globals.getEasyTuneVariables(engine2).fromJSON(clipboard, resetVariablesDefaultValueOnImport);
          EasyTuneUtils.refreshWidget(engine2);
          if (onSuccessCallback != null) {
            onSuccessCallback();
          }
          console.log("Easy Tune Variables Imported from: clipboard");
          console.log(clipboard);
        },
        function() {
          if (onFailureCallback != null) {
            onFailureCallback();
          }
          console.error("An error occurred while importing the easy tune variables from: clipboard");
        }
      ).catch(function(reason) {
        if (onFailureCallback != null) {
          onFailureCallback();
        }
        console.error("An error occurred while importing the easy tune variables from: clipboard");
        console.error(reason);
      });
    }
  } else {
    let replacedFileURL = _importExportVariablesReplaceFileURLParams(fileURL, engine2);
    fetch(replacedFileURL).then(
      function(response) {
        if (response.ok) {
          response.text().then(
            function(text) {
              Globals.getEasyTuneVariables(engine2).fromJSON(text, resetVariablesDefaultValueOnImport);
              EasyTuneUtils.refreshWidget(engine2);
              if (onSuccessCallback != null) {
                onSuccessCallback();
              }
              console.log("Easy Tune Variables Imported from:", replacedFileURL);
              console.log(text);
            },
            function(response2) {
              if (onFailureCallback != null) {
                onFailureCallback();
              }
              console.error("An error occurred while importing the easy tune variables from:", replacedFileURL);
              console.error(response2);
            }
          );
        } else {
          if (onFailureCallback != null) {
            onFailureCallback();
          }
          console.error("An error occurred while importing the easy tune variables from:", replacedFileURL);
          console.error(response);
        }
      },
      function(response) {
        if (onFailureCallback != null) {
          onFailureCallback();
        }
        console.error("An error occurred while importing the easy tune variables from:", replacedFileURL);
        console.error(response);
      }
    ).catch(function(reason) {
      if (onFailureCallback != null) {
        onFailureCallback();
      }
      console.error("An error occurred while importing the easy tune variables from:", replacedFileURL);
      console.error(reason);
    });
  }
  EasyTuneUtils.refreshWidget(engine2);
}
function exportVariables(fileURL = null, onSuccessCallback = null, onFailureCallback = null, engine2 = Globals.getMainEngine()) {
  let jsonVariables = Globals.getEasyTuneVariables(engine2).toJSON();
  if (fileURL == null || fileURL.length == 0) {
    if (Globals.getNavigator(engine2).clipboard) {
      Globals.getNavigator(engine2).clipboard.writeText(jsonVariables).then(
        function() {
          if (onSuccessCallback != null) {
            onSuccessCallback();
          }
          console.log("Easy Tune Variables Exported to: clipboard");
          console.log(jsonVariables);
        },
        function() {
          if (onFailureCallback != null) {
            onFailureCallback();
          }
          console.error("An error occurred while exporting the easy tune variables to: clipboard");
        }
      ).catch(function(reason) {
        if (onFailureCallback != null) {
          onFailureCallback();
        }
        console.error("An error occurred while exporting the easy tune variables to: clipboard");
        console.error(reason);
      });
    }
  } else {
    let replacedFileURL = _importExportVariablesReplaceFileURLParams(fileURL, engine2);
    fetch(replacedFileURL, {
      headers: {
        "Accept": "application/json",
        "Content-Type": "application/json"
      },
      method: "POST",
      body: jsonVariables
    }).then(
      function(response) {
        if (response.ok) {
          if (onSuccessCallback != null) {
            onSuccessCallback();
          }
          console.log("Easy Tune Variables Exported to:", replacedFileURL);
          console.log(jsonVariables);
        } else {
          if (onFailureCallback != null) {
            onFailureCallback();
          }
          console.error("An error occurred while exporting the easy tune variables to:", replacedFileURL);
          console.error(response);
        }
      },
      function(response) {
        if (onFailureCallback != null) {
          onFailureCallback();
        }
        console.error("An error occurred while exporting the easy tune variables to:", replacedFileURL);
        console.error(response);
      }
    ).catch(function(reason) {
      if (onFailureCallback != null) {
        onFailureCallback();
      }
      console.error("An error occurred while exporting the easy tune variables to:", replacedFileURL);
      console.error(reason);
    });
  }
}
function addSetWidgetCurrentVariableCallback(id, callback, engine2 = Globals.getMainEngine()) {
  if (!_mySetWidgetCurrentVariableCallbacks.has(engine2)) {
    _mySetWidgetCurrentVariableCallbacks.set(engine2, /* @__PURE__ */ new Map());
  }
  _mySetWidgetCurrentVariableCallbacks.get(engine2).set(id, callback);
}
function removeSetWidgetCurrentVariableCallback(id, engine2 = Globals.getMainEngine()) {
  if (_mySetWidgetCurrentVariableCallbacks.has(engine2)) {
    _mySetWidgetCurrentVariableCallbacks.get(engine2).delete(id);
  }
}
function addRefreshWidgetCallback(id, callback, engine2 = Globals.getMainEngine()) {
  if (!_myRefreshWidgetCallbacks.has(engine2)) {
    _myRefreshWidgetCallbacks.set(engine2, /* @__PURE__ */ new Map());
  }
  _myRefreshWidgetCallbacks.get(engine2).set(id, callback);
}
function removeRefreshWidgetCallback(id, engine2 = Globals.getMainEngine()) {
  if (_myRefreshWidgetCallbacks.has(engine2)) {
    _myRefreshWidgetCallbacks.get(engine2).delete(id);
  }
}
var EasyTuneUtils = {
  setWidgetCurrentVariable,
  refreshWidget,
  importVariables,
  exportVariables,
  addSetWidgetCurrentVariableCallback,
  removeSetWidgetCurrentVariableCallback,
  addRefreshWidgetCallback,
  removeRefreshWidgetCallback
};
var _importExportVariablesReplaceFileURLParams = function() {
  let matchEasyTuneURLParamsRegex = new RegExp("\\{.+?\\}", "g");
  return function _importExportVariablesReplaceFileURLParams2(fileURL, engine2 = Globals.getMainEngine()) {
    let params = fileURL.match(matchEasyTuneURLParamsRegex);
    if (params == null || params.length == 0) {
      return fileURL;
    }
    for (let i = 0; i < params.length; i++) {
      params[i] = params[i].replace("{", "");
      params[i] = params[i].replace("}", "");
    }
    let urlSearchParams = new URL(Globals.getDocument(engine2).location).searchParams;
    let replacedFileURL = fileURL;
    for (let param of params) {
      let searchParamValue = urlSearchParams.get(param);
      if (searchParamValue != null) {
        replacedFileURL = replacedFileURL.replace("{" + param + "}", searchParamValue);
      }
    }
    return replacedFileURL;
  };
}();

// js/pp/tool/easy_tune/easy_tune_variable_types.js
var EasyTuneVariableType = {
  NONE: 0,
  NUMBER: 1,
  BOOL: 2,
  TRANSFORM: 3
};
var EasyTuneVariable = class {
  constructor(name, type, onValueChangedEventListener = null, showOnWidget = true, engine2 = Globals.getMainEngine()) {
    this._myName = name;
    this._myType = type;
    this._myValue = null;
    this._myDefaultValue = null;
    this._myShowOnWidget = showOnWidget;
    this._myWidgetCurrentVariable = false;
    this._myValueChangedEmitter = new Emitter();
    this._myEngine = engine2;
    if (onValueChangedEventListener != null) {
      this.registerValueChangedEventListener(this, onValueChangedEventListener);
    }
  }
  getName() {
    return this._myName;
  }
  getType() {
    return this._myType;
  }
  isWidgetCurrentVariable() {
    return this._myWidgetCurrentVariable;
  }
  setWidgetCurrentVariable(widgetCurrentVariable) {
    this._myWidgetCurrentVariable = widgetCurrentVariable;
  }
  getValue() {
    return this._myValue;
  }
  setValue(value, resetDefaultValue = false) {
    let valueChanged = this._myValue != value;
    this._myValue = value;
    if (resetDefaultValue) {
      EasyTuneVariable.prototype.setDefaultValue.call(this, value);
    }
    EasyTuneUtils.refreshWidget(this._myEngine);
    if (valueChanged) {
      this._myValueChangedEmitter.notify(this.getValue(), this);
    }
  }
  getDefaultValue() {
    return this._myDefaultValue;
  }
  setDefaultValue(value) {
    this._myDefaultValue = value;
  }
  shouldShowOnWidget() {
    return this._myShowOnWidget;
  }
  setShowOnWidget(showOnWidget) {
    this._myShowOnWidget = showOnWidget;
  }
  fromJSON(valueJSON, resetDefaultValue = false) {
    this.setValue(JSON.parse(valueJSON), resetDefaultValue);
  }
  toJSON() {
    return JSON.stringify(this.getValue());
  }
  registerValueChangedEventListener(id, listener) {
    this._myValueChangedEmitter.add(listener, { id });
  }
  unregisterValueChangedEventListener(id) {
    this._myValueChangedEmitter.remove(id);
  }
};
var EasyTuneVariableArray = class extends EasyTuneVariable {
  constructor(name, type, value, onValueChangedEventListener, showOnWidget, engine2) {
    super(name, type, onValueChangedEventListener, showOnWidget, engine2);
    EasyTuneVariableArray.prototype.setValue.call(this, value, true);
  }
  setValue(value, resetDefaultValue = false) {
    let valueChanged = this._myValue != null && !this._myValue.pp_equals(value);
    if (this._myValue == null) {
      this._myValue = value.pp_clone();
    } else {
      this._myValue.pp_copy(value);
    }
    if (resetDefaultValue) {
      EasyTuneVariableArray.prototype.setDefaultValue.call(this, value);
    }
    EasyTuneUtils.refreshWidget(this._myEngine);
    if (valueChanged) {
      this._myValueChangedEmitter.notify(this.getValue(), this);
    }
  }
  setDefaultValue(value) {
    if (this._myDefaultValue == null) {
      this._myDefaultValue = value.pp_clone();
    } else {
      this._myDefaultValue.pp_copy(value);
    }
  }
};
var EasyTuneNumberArray = class extends EasyTuneVariableArray {
  constructor(name, value, onValueChangedEventListener, showOnWidget, decimalPlaces = 3, stepPerSecond = 1, min4 = null, max4 = null, editAllValuesTogether = false, engine2) {
    super(name, EasyTuneVariableType.NUMBER, value, onValueChangedEventListener, showOnWidget, engine2);
    this._myDecimalPlaces = decimalPlaces;
    this._myStepPerSecond = stepPerSecond;
    this._myDefaultStepPerSecond = this._myStepPerSecond;
    this._myMin = min4;
    this._myMax = max4;
    this._myEditAllValuesTogether = editAllValuesTogether;
    this._clampValue(true);
  }
  setMax(max4) {
    this._myMax = max4;
    this._clampValue(false);
  }
  setMin(min4) {
    this._myMin = min4;
    this._clampValue(false);
  }
  _clampValue(resetDefaultValue) {
    let clampedValue = this._myValue.vec_clamp(this._myMin, this._myMax);
    if (!resetDefaultValue) {
      let clampedDefaultValue = this.getDefaultValue().vec_clamp(this._myMin, this._myMax);
      let defaultValueChanged = !clampedDefaultValue.vec_equals(this.getDefaultValue(), 1e-5);
      if (defaultValueChanged) {
        EasyTuneVariableArray.prototype.setDefaultValue.call(this, clampedDefaultValue);
      }
    }
    EasyTuneVariableArray.prototype.setValue.call(this, clampedValue, resetDefaultValue);
  }
};
var EasyTuneNumber = class extends EasyTuneNumberArray {
  constructor(name, value, onValueChangedEventListener, showOnWidget, decimalPlaces, stepPerSecond, min4, max4, engine2) {
    super(name, [value], onValueChangedEventListener, showOnWidget, decimalPlaces, stepPerSecond, min4, max4, engine2);
    this._myTempValue = [0];
    this._myTempDefaultValue = [0];
  }
  getValue() {
    return super.getValue()[0];
  }
  setValue(value, resetDefaultValue = false) {
    this._myTempValue[0] = value;
    super.setValue(this._myTempValue, resetDefaultValue);
  }
  getDefaultValue() {
    return super.getDefaultValue()[0];
  }
  setDefaultValue(value) {
    this._myTempDefaultValue[0] = value;
    super.setDefaultValue(this._myTempValue);
  }
};
var EasyTuneInt = class extends EasyTuneNumber {
  constructor(name, value, onValueChangedEventListener, showOnWidget, stepPerSecond, min4, max4, engine2) {
    super(name, value, onValueChangedEventListener, showOnWidget, 0, stepPerSecond, min4, max4, engine2);
  }
};
var EasyTuneIntArray = class extends EasyTuneNumberArray {
  constructor(name, value, onValueChangedEventListener, showOnWidget, stepPerSecond, min4, max4, editAllValuesTogether, engine2) {
    let roundedValue = value.pp_clone();
    for (let i = 0; i < value.length; i++) {
      roundedValue[i] = Math.round(roundedValue[i]);
    }
    super(name, roundedValue, onValueChangedEventListener, showOnWidget, 0, stepPerSecond, min4 != null ? Math.round(min4) : null, max4 != null ? Math.round(max4) : max4, editAllValuesTogether, engine2);
  }
};
var EasyTuneBoolArray = class extends EasyTuneVariableArray {
  constructor(name, value, onValueChangedEventListener, showOnWidget, engine2) {
    super(name, EasyTuneVariableType.BOOL, value, onValueChangedEventListener, showOnWidget, engine2);
  }
};
var EasyTuneBool = class extends EasyTuneBoolArray {
  constructor(name, value, onValueChangedEventListener, showOnWidget, engine2) {
    super(name, [value], onValueChangedEventListener, showOnWidget, engine2);
    this._myTempValue = [0];
    this._myTempDefaultValue = [0];
  }
  getValue() {
    return super.getValue()[0];
  }
  setValue(value, resetDefaultValue = false) {
    this._myTempValue[0] = value;
    super.setValue(this._myTempValue, resetDefaultValue);
  }
  getDefaultValue() {
    return super.getDefaultValue()[0];
  }
  setDefaultValue(value) {
    this._myTempDefaultValue[0] = value;
    super.setDefaultValue(this._myTempValue);
  }
};
var EasyTuneTransform = class extends EasyTuneVariable {
  constructor(name, value, onValueChangedEventListener, showOnWidget, scaleAsOne = true, decimalPlaces = 3, positionStepPerSecond = 1, rotationStepPerSecond = 50, scaleStepPerSecond = 1, engine2) {
    super(name, EasyTuneVariableType.TRANSFORM, onValueChangedEventListener, showOnWidget, engine2);
    this._myDecimalPlaces = decimalPlaces;
    this._myPosition = value.mat4_getPosition();
    this._myRotation = value.mat4_getRotationDegrees();
    this._myScale = value.mat4_getScale();
    let decimalPlacesMultiplier = Math.pow(10, this._myDecimalPlaces);
    for (let i = 0; i < 3; i++) {
      this._myScale[i] = Math.max(this._myScale[i], 1 / decimalPlacesMultiplier);
    }
    this._myScaleAsOne = scaleAsOne;
    this._myPositionStepPerSecond = positionStepPerSecond;
    this._myRotationStepPerSecond = rotationStepPerSecond;
    this._myScaleStepPerSecond = scaleStepPerSecond;
    this._myDefaultPosition = this._myPosition.vec3_clone();
    this._myDefaultRotation = this._myRotation.vec3_clone();
    this._myDefaultScale = this._myScale.vec3_clone();
    this._myDefaultPositionStepPerSecond = this._myPositionStepPerSecond;
    this._myDefaultRotationStepPerSecond = this._myRotationStepPerSecond;
    this._myDefaultScaleStepPerSecond = this._myScaleStepPerSecond;
    this._myTransform = mat4_create();
    this._myTransform.mat4_setPositionRotationDegreesScale(this._myPosition, this._myRotation, this._myScale);
    this._myTempTransform = mat4_create();
  }
  getValue() {
    this._myTransform.mat4_setPositionRotationDegreesScale(this._myPosition, this._myRotation, this._myScale);
    return this._myTransform;
  }
  setValue(value, resetDefaultValue = false) {
    this._myTempTransform.mat4_setPositionRotationDegreesScale(this._myPosition, this._myRotation, this._myScale);
    value.mat4_getPosition(this._myPosition);
    value.mat4_getRotationDegrees(this._myRotation);
    value.mat4_getScale(this._myScale);
    this._myTransform.mat4_setPositionRotationDegreesScale(this._myPosition, this._myRotation, this._myScale);
    let valueChanged = !this._myTempTransform.pp_equals(this._myTransform);
    if (resetDefaultValue) {
      EasyTuneTransform.prototype.setDefaultValue.call(this, value);
    }
    EasyTuneUtils.refreshWidget(this._myEngine);
    if (valueChanged) {
      this._myValueChangedEmitter.notify(this.getValue(), this);
    }
  }
  setDefaultValue(value) {
    this._myDefaultPosition = value.mat4_getPosition();
    this._myDefaultRotation = value.mat4_getRotationDegrees();
    this._myDefaultScale = value.mat4_getScale();
  }
  fromJSON(valueJSON, resetDefaultValue = false) {
    this.setValue(JSON.parse(valueJSON), resetDefaultValue);
  }
  toJSON() {
    return this.getValue().vec_toString();
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/base/easy_tune_base_widget.js
var EasyTuneBaseWidgetParams = class {
  constructor() {
    this.myVariablesImportCallback = null;
    this.myVariablesExportCallback = null;
  }
};
var EasyTuneBaseWidget = class {
  constructor(params) {
    this._myConfig = null;
    this._myUI = null;
    this._myParams = params;
    this._myVariable = null;
    this._myVisible = true;
    this._myScrollVariableRequestEmitter = new Emitter();
    this._myAppendToVariableName = "";
    this._myScrollVariableActive = false;
    this._myScrollDirection = 0;
    this._myScrollVariableTimer = 0;
    this._myHasScrolled = false;
    this._myResetImportLabelTimer = new Timer(0, false);
    this._myResetExportLabelTimer = new Timer(0, false);
    this._myDestroyed = false;
  }
  setVisible(visible) {
    if (visible) {
      this._refreshUI();
    }
    this._myUI.setVisible(visible);
    this._myVisible = visible;
  }
  setEasyTuneVariable(variable, appendToVariableName) {
    this._myVariable = variable;
    if (typeof appendToVariableName !== "undefined") {
      this._myAppendToVariableName = appendToVariableName;
    } else {
      this._myAppendToVariableName = "";
    }
    this._setEasyTuneVariableHook();
    this._refreshUI();
  }
  isScrollVariableActive() {
    return this._myScrollVariableActive;
  }
  getScrollVariableDirection() {
    return this._myScrollDirection;
  }
  setScrollVariableActive(active, scrollDirection) {
    this._myScrollVariableActive = active;
    this._myScrollDirection = scrollDirection;
    this._myScrollVariableTimer = this._myConfig.myScrollVariableDelay;
    this._myHasScrolled = false;
  }
  getWidget() {
    return this;
  }
  syncWidget(otherEasyTuneWidget) {
    if (otherEasyTuneWidget != null) {
      if (otherEasyTuneWidget._myResetImportLabelTimer.isRunning()) {
        this._myResetImportLabelTimer.start(otherEasyTuneWidget._myResetImportLabelTimer.getTimeLeft());
      } else {
        this._myResetImportLabelTimer.reset();
      }
      if (otherEasyTuneWidget._myResetExportLabelTimer.isRunning()) {
        this._myResetExportLabelTimer.start(otherEasyTuneWidget._myResetExportLabelTimer.getTimeLeft());
      } else {
        this._myResetExportLabelTimer.reset();
      }
      this._myUI.myImportButtonTextComponent.text = otherEasyTuneWidget._myUI.myImportButtonTextComponent.text;
      this._myUI.myExportButtonTextComponent.text = otherEasyTuneWidget._myUI.myExportButtonTextComponent.text;
      this.setScrollVariableActive(otherEasyTuneWidget.isScrollVariableActive(), otherEasyTuneWidget.getScrollVariableDirection());
    } else {
      this._myResetImportLabelTimer.reset();
      this._myUI.myImportButtonTextComponent.text = this._myConfig.myImportButtonText;
      this._myResetExportLabelTimer.reset();
      this._myUI.myExportButtonTextComponent.text = this._myConfig.myExportButtonText;
    }
  }
  onImportSuccess() {
    this._myUI.myImportButtonTextComponent.text = this._myConfig.myImportSuccessButtonText;
    this._myResetImportLabelTimer.start(this._myConfig.myImportExportResetLabelSeconds);
  }
  onImportFailure() {
    this._myUI.myImportButtonTextComponent.text = this._myConfig.myImportFailureButtonText;
    this._myResetImportLabelTimer.start(this._myConfig.myImportExportResetLabelSeconds);
  }
  onExportSuccess() {
    this._myUI.myExportButtonTextComponent.text = this._myConfig.myExportSuccessButtonText;
    this._myResetExportLabelTimer.start(this._myConfig.myImportExportResetLabelSeconds);
  }
  onExportFailure() {
    this._myUI.myExportButtonTextComponent.text = this._myConfig.myExportFailureButtonText;
    this._myResetExportLabelTimer.start(this._myConfig.myImportExportResetLabelSeconds);
  }
  registerScrollVariableRequestEventListener(id, listener) {
    this._myScrollVariableRequestEmitter.add(listener, { id });
  }
  unregisterScrollVariableRequestEventListener(id) {
    this._myScrollVariableRequestEmitter.remove(id);
  }
  start(parentObject, easyTuneParams) {
    this._myConfig.build();
    this._myResetImportLabelTimer.setDuration(this._myConfig.myImportExportResetLabelSeconds);
    this._myResetExportLabelTimer.setDuration(this._myConfig.myImportExportResetLabelSeconds);
    this._myUI.build(parentObject, this._myConfig, easyTuneParams);
    this._myUI.setImportExportButtonsVisible(easyTuneParams.myShowVariablesImportExportButtons);
    this._startHook(parentObject, easyTuneParams);
    this._addListeners();
  }
  update(dt) {
    if (this._isActive()) {
      this._updateHook(dt);
      this._updateScrollVariable(dt);
      this._updateImportExportLabel(dt);
    }
  }
  // Hooks
  _setEasyTuneVariableHook() {
  }
  _refreshUIHook() {
  }
  _startHook(parentObject, easyTuneParams) {
  }
  _addListenersHook() {
  }
  _updateHook(dt) {
  }
  // Hooks end
  _refreshUI() {
    if (this._myVariable) {
      if (this._myVariable.getName() != null) {
        this._myUI.myVariableLabelTextComponent.text = this._myVariable.getName().concat(this._myAppendToVariableName);
      } else {
        let name = "Unknown";
        this._myUI.myVariableLabelTextComponent.text = name.concat(this._myAppendToVariableName);
      }
      this._refreshUIHook();
    }
  }
  _updateScrollVariable(dt) {
    if (this._myScrollVariableActive) {
      if (this._myScrollVariableTimer <= 0) {
        this._scrollVariableRequest(this._myScrollDirection);
        this._myScrollVariableTimer = this._myConfig.myScrollVariableDelay;
        this._myHasScrolled = true;
      } else {
        this._myScrollVariableTimer -= dt;
      }
    }
  }
  _updateImportExportLabel(dt) {
    if (this._myResetImportLabelTimer.isRunning(dt)) {
      this._myResetImportLabelTimer.update(dt);
      if (this._myResetImportLabelTimer.isDone()) {
        this._myResetImportLabelTimer.reset();
        this._myUI.myImportButtonTextComponent.text = this._myConfig.myImportButtonText;
      }
    }
    if (this._myResetExportLabelTimer.isRunning(dt)) {
      this._myResetExportLabelTimer.update(dt);
      if (this._myResetExportLabelTimer.isDone()) {
        this._myResetExportLabelTimer.reset();
        this._myUI.myExportButtonTextComponent.text = this._myConfig.myExportButtonText;
      }
    }
  }
  _isActive() {
    return this._myVisible && this._myVariable;
  }
  _addListeners() {
    let ui = this._myUI;
    ui.myNextButtonCursorTargetComponent.onDown.add(this._setScrollVariableActive.bind(this, true, 1, false));
    ui.myNextButtonCursorTargetComponent.onDownOnHover.add(this._setScrollVariableActive.bind(this, true, 1, false));
    ui.myNextButtonCursorTargetComponent.onUpWithDown.add(this._setScrollVariableActive.bind(this, false, 0, false));
    ui.myNextButtonCursorTargetComponent.onUpWithNoDown.add(this._setScrollVariableActive.bind(this, false, 0, true));
    ui.myNextButtonCursorTargetComponent.onUnhover.add(this._setScrollVariableActive.bind(this, false, 0, true));
    ui.myNextButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myNextButtonBackgroundComponent.material));
    ui.myNextButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myNextButtonBackgroundComponent.material));
    ui.myPreviousButtonCursorTargetComponent.onDown.add(this._setScrollVariableActive.bind(this, true, -1, false));
    ui.myPreviousButtonCursorTargetComponent.onDownOnHover.add(this._setScrollVariableActive.bind(this, true, -1, false));
    ui.myPreviousButtonCursorTargetComponent.onUpWithDown.add(this._setScrollVariableActive.bind(this, false, 0, false));
    ui.myPreviousButtonCursorTargetComponent.onUpWithNoDown.add(this._setScrollVariableActive.bind(this, false, 0, true));
    ui.myPreviousButtonCursorTargetComponent.onUnhover.add(this._setScrollVariableActive.bind(this, false, 0, true));
    ui.myPreviousButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myPreviousButtonBackgroundComponent.material));
    ui.myPreviousButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myPreviousButtonBackgroundComponent.material));
    ui.myImportButtonCursorTargetComponent.onUpWithDown.add(this._importVariables.bind(this));
    ui.myImportButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myImportButtonBackgroundComponent.material));
    ui.myImportButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myImportButtonBackgroundComponent.material));
    ui.myExportButtonCursorTargetComponent.onUpWithDown.add(this._exportVariables.bind(this));
    ui.myExportButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myExportButtonBackgroundComponent.material));
    ui.myExportButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myExportButtonBackgroundComponent.material));
    this._addListenersHook();
  }
  _setScrollVariableActive(active, scrollDirection, skipForceScroll) {
    if (this._isActive() || !active) {
      let forceScroll = !active && !this._myHasScrolled && !skipForceScroll;
      let oldScrollDirection = this._myScrollDirection;
      this.setScrollVariableActive(active, scrollDirection);
      if (forceScroll) {
        this._scrollVariableRequest(oldScrollDirection);
      }
    }
  }
  _scrollVariableRequest(amount) {
    if (this._isActive() && amount != 0) {
      this._myScrollVariableRequestEmitter.notify(amount);
    }
  }
  _genericHover(material) {
    material.color = this._myConfig.myButtonHoverColor;
  }
  _genericUnhover(material) {
    material.color = this._myConfig.myBackgroundColor;
  }
  _importVariables() {
    if (this._myUI.myImportButtonTextComponent.text == this._myConfig.myImportButtonText) {
      this._myUI.myImportButtonTextComponent.text = this._myConfig.myImportingButtonText;
      this._myResetImportLabelTimer.reset();
      this._myParams.myVariablesImportCallback();
    }
  }
  _exportVariables() {
    if (this._myUI.myExportButtonTextComponent.text == this._myConfig.myExportButtonText) {
      this._myUI.myExportButtonTextComponent.text = this._myConfig.myExportingButtonText;
      this._myResetExportLabelTimer.reset();
      this._myParams.myVariablesExportCallback();
    }
  }
  destroy() {
    this._myDestroyed = true;
    if (this._myUI != null) {
      this._myUI.destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/base/easy_tune_base_array_widget_selector.js
var EasyTuneBaseArrayWidgetSelector = class {
  constructor(params, gamepad, engine2 = Globals.getMainEngine()) {
    this._myGamepad = gamepad;
    this._myParentObject = null;
    this._myParams = params;
    this._myEasyTuneParams = null;
    this._myWidgets = /* @__PURE__ */ new Map();
    this._myVariable = null;
    this._myVisible = true;
    this._myAppendToVariableName = null;
    this._myScrollVariableRequestEmitter = new Emitter();
    this._myCurrentArraySize = null;
    this._myEngine = engine2;
    this._myDestroyed = false;
  }
  setEasyTuneVariable(variable, appendToVariableName) {
    this._myVariable = variable;
    this._myCurrentArraySize = this._myVariable.getValue().length;
    this._myAppendToVariableName = appendToVariableName;
    if (!this._myWidgets.has(this._myCurrentArraySize)) {
      this._createWidget(this._myCurrentArraySize);
    }
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.setEasyTuneVariable(variable, appendToVariableName);
    }
    this.setVisible(this._myVisible);
  }
  setVisible(visible) {
    for (let widget of this._myWidgets.values()) {
      widget.setVisible(false);
    }
    if (this._myVariable) {
      this._sizeChangedCheck();
      let widget = this._myWidgets.get(this._myCurrentArraySize);
      if (widget) {
        widget.setVisible(visible);
      }
    }
    this._myVisible = visible;
  }
  isScrollVariableActive() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      return widget.isScrollVariableActive();
    }
    return false;
  }
  getScrollVariableDirection() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      return widget.getScrollVariableDirection();
    }
    return 0;
  }
  setScrollVariableActive(active, scrollDirection) {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.setScrollVariableActive(active, scrollDirection);
    }
  }
  getWidget() {
    return this._myWidgets.get(this._myCurrentArraySize);
  }
  registerScrollVariableRequestEventListener(id, listener) {
    this._myScrollVariableRequestEmitter.add(listener, { id });
  }
  unregisterScrollVariableRequestEventListener(id) {
    this._myScrollVariableRequestEmitter.remove(id);
  }
  start(parentObject, easyTuneParams) {
    this._myParentObject = parentObject;
    this._myEasyTuneParams = easyTuneParams;
    this._createWidget(1);
    if (this._myVariable) {
      this.setEasyTuneVariable(this._myVariable, this._myAppendToVariableName);
    }
  }
  update(dt) {
    if (this._isActive()) {
      this._sizeChangedCheck();
      let widget = this._myWidgets.get(this._myCurrentArraySize);
      if (widget) {
        widget.update(dt);
      }
    }
  }
  onImportSuccess() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.onImportSuccess();
    }
  }
  onImportFailure() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.onImportFailure();
    }
  }
  onExportSuccess() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.onExportSuccess();
    }
  }
  onExportFailure() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.onExportFailure();
    }
  }
  _isActive() {
    return this._myVisible && this._myVariable;
  }
  _scrollVariableRequest(amount) {
    this._myScrollVariableRequestEmitter.notify(amount);
  }
  _createWidget(arraySize) {
    this._myWidgets.set(arraySize, this._getEasyTuneArrayWidget(arraySize));
    this._myWidgets.get(arraySize).start(this._myParentObject, this._myEasyTuneParams);
    this._myWidgets.get(arraySize).setVisible(false);
    this._myWidgets.get(arraySize).registerScrollVariableRequestEventListener(this, this._scrollVariableRequest.bind(this));
  }
  _sizeChangedCheck() {
    if (this._myVariable.getValue().length != this._myCurrentArraySize) {
      this.setEasyTuneVariable(this._myVariable, this._myAppendToVariableName);
    }
  }
  _getEasyTuneArrayWidget(arraySize) {
    return null;
  }
  destroy() {
    this._myDestroyed = true;
    for (let widget of this._myWidgets.values()) {
      widget.destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/base/easy_tune_base_widget_config.js
var EasyTuneBaseWidgetConfig = class {
  constructor() {
  }
  build() {
    this._setupBuildConfig();
    this._setupRuntimeConfig();
  }
  // Hooks
  _getBackPanelMaxY() {
    return this.myDisplayPanelPosition[1] + this.myVariableLabelPanelPosition[1] + this.mySideButtonBackgroundScale[1] + this._mySideButtonDistanceFromBorder * 1.25;
  }
  _getBackPanelMinY() {
    return this.myDisplayPanelPosition[1] - this._mySideButtonDistanceFromBorder * 1.25 - this.mySideButtonBackgroundScale[1];
  }
  _getBackPanelMaxX() {
    return this._mySideButtonPanelHalfWidth;
  }
  _getBackPanelMinX() {
    return -this._mySideButtonPanelHalfWidth;
  }
  // Small Z offset to avoid glitching with other widgets
  _getPivotZOffset() {
    return 0;
  }
  _setupBuildConfigHook() {
  }
  _setupRuntimeConfigHook() {
  }
  // Hooks end
  _setupBuildConfig() {
    this.myBackgroundColor = vec4_create(46 / 255, 46 / 255, 46 / 255, 1);
    this.myCursorTargetCollisionCollider = Collider.Box;
    this.myCursorTargetCollisionGroup = 7;
    this.myCursorTargetCollisionThickness = 1e-3;
    this.myDefaultTextColor = vec4_create(255 / 255, 255 / 255, 255 / 255, 1);
    this.myTextAlignment = Alignment.Center;
    this.myTextJustification = Justification.Middle;
    this.myTextColor = this.myDefaultTextColor;
    this.myLabelTextScale = vec3_create(0.18, 0.18, 0.18);
    this.myButtonTextScale = vec3_create(0.18, 0.18, 0.18);
    this._myPanelZOffset = 0.01;
    this._myColliderZOffset = 0.017;
    this._mySideButtonDistanceFromBorder = 0.0125;
    this._mySideButtonPanelHalfWidth = 0.2;
    this.myPivotObjectPositions = [];
    this.myPivotObjectPositions[ToolHandedness.NONE] = vec3_create(0, 0, this._getPivotZOffset());
    this.myPivotObjectPositions[ToolHandedness.LEFT] = vec3_create(-0.04, 0.02, this._getPivotZOffset());
    this.myPivotObjectPositions[ToolHandedness.RIGHT] = vec3_create(-0.08, 0.02, this._getPivotZOffset());
    this.mySideButtonBackgroundScale = vec3_create(0.015, 0.015, 1);
    this.mySideButtonTextScale = this.myButtonTextScale;
    this.mySideButtonTextPosition = vec3_create(0, 0, 7e-3);
    this.mySideButtonCursorTargetPosition = vec3_create(0, 0, 0);
    this.mySideButtonCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.mySideButtonCollisionExtents = this.mySideButtonBackgroundScale.pp_clone();
    this.mySideButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myLeftSideButtonPosition = vec3_create(0, 0, -1e-5);
    this.myLeftSideButtonPosition[0] = -this._mySideButtonPanelHalfWidth + this.mySideButtonBackgroundScale[0] + this._mySideButtonDistanceFromBorder;
    this.myRightSideButtonPosition = vec3_create(0, 0, -1e-5);
    this.myRightSideButtonPosition[0] = -this.myLeftSideButtonPosition[0];
    this.myDisplayPanelPosition = vec3_create(0, 0.1, 0);
    this.myVariableLabelPanelPosition = vec3_create(0, 0.025, this._myPanelZOffset);
    this.myVariableLabelTextScale = this.myLabelTextScale;
    this.myVariableLabelCursorTargetPosition = vec3_create(0, 0, 0);
    this.myVariableLabelCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myVariableLabelCollisionExtents = vec3_create(0.065, 0.0175, 1);
    this.myVariableLabelCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myNextButtonText = ">";
    this.myPreviousButtonText = "<";
    this._setupBuildConfigHook();
    {
      let maxX = this._getBackPanelMaxX();
      let minX = this._getBackPanelMinX();
      let maxY = this._getBackPanelMaxY();
      let minY = this._getBackPanelMinY();
      this.myBackPanelPosition = [(maxX + minX) / 2, (maxY + minY) / 2, 0];
      this.myBackBackgroundScale = [(maxX - minX) / 2, (maxY - minY) / 2, 1];
      this.myBackBackgroundColor = vec4_create(70 / 255, 70 / 255, 70 / 255, 1);
    }
    this.myImportExportButtonBackgroundScale = vec3_create(0.04, 0.02, 1);
    this.myImportExportButtonTextScale = this.myButtonTextScale;
    this.myImportExportButtonTextPosition = vec3_create(0, 0, 7e-3);
    this.myImportExportPanelPosition = [0, this._getBackPanelMaxY() + this._mySideButtonDistanceFromBorder + this.myImportExportButtonBackgroundScale[1], this._myPanelZOffset];
    this.myImportExportButtonCursorTargetPosition = vec3_create(0, 0, 0);
    this.myImportExportButtonCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myImportExportButtonCollisionExtents = this.myImportExportButtonBackgroundScale.pp_clone();
    this.myImportExportButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myImportButtonText = "Import";
    this.myExportButtonText = "Export";
    this.myImportExportResetLabelSeconds = 2;
    this.myImportingButtonText = "...";
    this.myImportSuccessButtonText = "Done";
    this.myImportFailureButtonText = "Error";
    this.myExportingButtonText = "...";
    this.myExportSuccessButtonText = "Done";
    this.myExportFailureButtonText = "Error";
    this.myImportButtonPosition = vec3_create(0, 0, -1e-5);
    this.myImportButtonPosition[0] = -this.myImportExportButtonBackgroundScale[0] - this._mySideButtonDistanceFromBorder / 2;
    this.myExportButtonPosition = vec3_create(0, 0, -1e-5);
    this.myExportButtonPosition[0] = -this.myImportButtonPosition[0];
    this.myPointerCollisionExtents = this.myBackBackgroundScale.pp_clone();
    this.myPointerCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myPointerCursorTargetPosition = this.myBackPanelPosition.pp_clone();
    this.myPointerCursorTargetPosition[2] = this._myColliderZOffset - 1e-4;
  }
  _setupRuntimeConfig() {
    this.myButtonHoverColor = vec4_create(150 / 255, 150 / 255, 150 / 255, 1);
    this.myScrollVariableDelay = 0.5;
    this._setupRuntimeConfigHook();
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget_config.js
var EasyTuneBoolArrayWidgetConfig = class extends EasyTuneBaseWidgetConfig {
  constructor(arraySize) {
    super();
    this.myArraySize = arraySize;
  }
  _getBackPanelMinY() {
    let valuePanelLastPosition = this.myValuePanelsPositions[this.myArraySize - 1] ? this.myValuePanelsPositions[this.myArraySize - 1][1] : 0;
    return super._getBackPanelMinY() + this.myValuesPanelPosition[1] + valuePanelLastPosition;
  }
  _getPivotZOffset() {
    return 802713e-8;
  }
  _setupBuildConfigHook() {
    this.myIncreaseButtonText = "+";
    this.myDecreaseButtonText = "-";
    this._myValuePanelDistanceFromVariableLabelPanel = 0.055;
    this._myDistanceBetweenValues = this.mySideButtonBackgroundScale[1] * 2 + 0.015;
    this.myValuesPanelPosition = [0, this.myVariableLabelPanelPosition[1] - this._myValuePanelDistanceFromVariableLabelPanel, this._myPanelZOffset];
    this.myValueTextScale = vec3_create(0.4, 0.4, 0.4);
    this.myValueCursorTargetPosition = vec3_create(0, 0, 0);
    this.myValueCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myValueCollisionExtents = vec3_create(0.065, 0.02, 1);
    this.myValueCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myValuePanelsPositions = [];
    this.myValuePanelsPositions[0] = vec3_create(0, 0, 0);
    for (let i = 1; i < this.myArraySize; i++) {
      this.myValuePanelsPositions[i] = this.myValuePanelsPositions[i - 1].pp_clone();
      this.myValuePanelsPositions[i][1] -= this._myDistanceBetweenValues;
    }
  }
  _setupRuntimeConfigHook() {
    this.myTextHoverScaleMultiplier = vec3_create(1.1, 1.1, 1.1);
    this.myThumbstickToggleThreshold = 0.6;
    this.myButtonEditDelay = 0;
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/base/easy_tune_base_widget_ui.js
var EasyTuneBaseWidgetUI = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this._myEngine = engine2;
    this._myDestroyed = false;
  }
  build(parentObject, config, params) {
    this._myParentObject = parentObject;
    this._myConfig = config;
    this._myParams = params;
    this._myImportExportButtonsVisible = true;
    this._myPlaneMesh = Globals.getDefaultMeshes(this._myEngine).myDoubleSidedPlane;
    this._buildHook();
    this._createSkeleton();
    this._setTransforms();
    this._addComponents();
    this._setTransformForNonXR();
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myEngine);
  }
  setVisible(visible) {
    this.myPivotObject.pp_setActive(visible);
    if (visible) {
      this.setImportExportButtonsVisible(this._myImportExportButtonsVisible);
    }
    this._setVisibleHook(visible);
  }
  setImportExportButtonsVisible(visible) {
    this._myImportExportButtonsVisible = visible;
    this.myImportExportPanel.pp_setActive(this._myImportExportButtonsVisible);
  }
  // Hooks
  _buildHook() {
  }
  _setVisibleHook(visible) {
  }
  _createSkeletonHook() {
  }
  _setTransformHook() {
  }
  _addComponentsHook() {
  }
  // Hooks end
  // Skeleton
  _createSkeleton() {
    this.myPivotObject = this._myParentObject.pp_addObject();
    this.myBackPanel = this.myPivotObject.pp_addObject();
    this.myBackBackground = this.myBackPanel.pp_addObject();
    this.myDisplayPanel = this.myPivotObject.pp_addObject();
    this.myVariableLabelPanel = this.myDisplayPanel.pp_addObject();
    this.myVariableLabelText = this.myVariableLabelPanel.pp_addObject();
    this.myVariableLabelCursorTarget = this.myVariableLabelPanel.pp_addObject();
    this.myNextButtonPanel = this.myVariableLabelPanel.pp_addObject();
    this.myNextButtonBackground = this.myNextButtonPanel.pp_addObject();
    this.myNextButtonText = this.myNextButtonPanel.pp_addObject();
    this.myNextButtonCursorTarget = this.myNextButtonPanel.pp_addObject();
    this.myPreviousButtonPanel = this.myVariableLabelPanel.pp_addObject();
    this.myPreviousButtonBackground = this.myPreviousButtonPanel.pp_addObject();
    this.myPreviousButtonText = this.myPreviousButtonPanel.pp_addObject();
    this.myPreviousButtonCursorTarget = this.myPreviousButtonPanel.pp_addObject();
    this.myImportExportPanel = this.myPivotObject.pp_addObject();
    this.myImportButtonPanel = this.myImportExportPanel.pp_addObject();
    this.myImportButtonBackground = this.myImportButtonPanel.pp_addObject();
    this.myImportButtonText = this.myImportButtonPanel.pp_addObject();
    this.myImportButtonCursorTarget = this.myImportButtonPanel.pp_addObject();
    this.myExportButtonPanel = this.myImportExportPanel.pp_addObject();
    this.myExportButtonBackground = this.myExportButtonPanel.pp_addObject();
    this.myExportButtonText = this.myExportButtonPanel.pp_addObject();
    this.myExportButtonCursorTarget = this.myExportButtonPanel.pp_addObject();
    this.myPointerCursorTarget = this.myPivotObject.pp_addObject();
    this._createSkeletonHook();
  }
  // Transforms
  _setTransforms() {
    this.myPivotObject.pp_setPositionLocal(this._myConfig.myPivotObjectPositions[this._myParams.myHandedness]);
    this.myBackPanel.pp_setPositionLocal(this._myConfig.myBackPanelPosition);
    this.myBackBackground.pp_scaleObject(this._myConfig.myBackBackgroundScale);
    this.myDisplayPanel.pp_setPositionLocal(this._myConfig.myDisplayPanelPosition);
    this.myVariableLabelPanel.pp_setPositionLocal(this._myConfig.myVariableLabelPanelPosition);
    this.myVariableLabelText.pp_scaleObject(this._myConfig.myVariableLabelTextScale);
    this.myVariableLabelCursorTarget.pp_setPositionLocal(this._myConfig.myVariableLabelCursorTargetPosition);
    this.myNextButtonPanel.pp_setPositionLocal(this._myConfig.myRightSideButtonPosition);
    this.myNextButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myNextButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myNextButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myNextButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myPreviousButtonPanel.pp_setPositionLocal(this._myConfig.myLeftSideButtonPosition);
    this.myPreviousButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myPreviousButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myPreviousButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myPreviousButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myImportExportPanel.pp_setPositionLocal(this._myConfig.myImportExportPanelPosition);
    this.myImportButtonPanel.pp_setPositionLocal(this._myConfig.myImportButtonPosition);
    this.myImportButtonBackground.pp_scaleObject(this._myConfig.myImportExportButtonBackgroundScale);
    this.myImportButtonText.pp_setPositionLocal(this._myConfig.myImportExportButtonTextPosition);
    this.myImportButtonText.pp_scaleObject(this._myConfig.myImportExportButtonTextScale);
    this.myImportButtonCursorTarget.pp_setPositionLocal(this._myConfig.myImportExportButtonCursorTargetPosition);
    this.myExportButtonPanel.pp_setPositionLocal(this._myConfig.myExportButtonPosition);
    this.myExportButtonBackground.pp_scaleObject(this._myConfig.myImportExportButtonBackgroundScale);
    this.myExportButtonText.pp_setPositionLocal(this._myConfig.myImportExportButtonTextPosition);
    this.myExportButtonText.pp_scaleObject(this._myConfig.myImportExportButtonTextScale);
    this.myExportButtonCursorTarget.pp_setPositionLocal(this._myConfig.myImportExportButtonCursorTargetPosition);
    this.myPointerCursorTarget.pp_setPositionLocal(this._myConfig.myPointerCursorTargetPosition);
    this._setTransformHook();
  }
  // Components
  _addComponents() {
    this.myBackBackgroundComponent = this.myBackBackground.pp_addComponent(MeshComponent);
    this.myBackBackgroundComponent.mesh = this._myPlaneMesh;
    this.myBackBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myBackBackgroundComponent.material.color = this._myConfig.myBackBackgroundColor;
    this.myVariableLabelTextComponent = this.myVariableLabelText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myVariableLabelTextComponent);
    this.myVariableLabelTextComponent.text = " ";
    this.myVariableLabelCursorTargetComponent = this.myVariableLabelCursorTarget.pp_addComponent(CursorTarget);
    this.myVariableLabelCollisionComponent = this.myVariableLabelCursorTarget.pp_addComponent(CollisionComponent);
    this.myVariableLabelCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myVariableLabelCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myVariableLabelCollisionComponent.extents = this._myConfig.myVariableLabelCollisionExtents;
    this.myNextButtonBackgroundComponent = this.myNextButtonBackground.pp_addComponent(MeshComponent);
    this.myNextButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myNextButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myNextButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myNextButtonTextComponent = this.myNextButtonText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myNextButtonTextComponent);
    this.myNextButtonTextComponent.text = this._myConfig.myNextButtonText;
    this.myNextButtonCursorTargetComponent = this.myNextButtonCursorTarget.pp_addComponent(CursorTarget);
    this.myNextButtonCollisionComponent = this.myNextButtonCursorTarget.pp_addComponent(CollisionComponent);
    this.myNextButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myNextButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myNextButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myPreviousButtonBackgroundComponent = this.myPreviousButtonBackground.pp_addComponent(MeshComponent);
    this.myPreviousButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPreviousButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myPreviousButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myPreviousButtonTextComponent = this.myPreviousButtonText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myPreviousButtonTextComponent);
    this.myPreviousButtonTextComponent.text = this._myConfig.myPreviousButtonText;
    this.myPreviousButtonCursorTargetComponent = this.myPreviousButtonCursorTarget.pp_addComponent(CursorTarget);
    this.myPreviousButtonCollisionComponent = this.myPreviousButtonCursorTarget.pp_addComponent(CollisionComponent);
    this.myPreviousButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPreviousButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPreviousButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myImportButtonBackgroundComponent = this.myImportButtonBackground.pp_addComponent(MeshComponent);
    this.myImportButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myImportButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myImportButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myImportButtonTextComponent = this.myImportButtonText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myImportButtonTextComponent);
    this.myImportButtonTextComponent.text = this._myConfig.myImportButtonText;
    this.myImportButtonCursorTargetComponent = this.myImportButtonCursorTarget.pp_addComponent(CursorTarget);
    this.myImportButtonCollisionComponent = this.myImportButtonCursorTarget.pp_addComponent(CollisionComponent);
    this.myImportButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myImportButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myImportButtonCollisionComponent.extents = this._myConfig.myImportExportButtonCollisionExtents;
    this.myExportButtonBackgroundComponent = this.myExportButtonBackground.pp_addComponent(MeshComponent);
    this.myExportButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myExportButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myExportButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myExportButtonTextComponent = this.myExportButtonText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myExportButtonTextComponent);
    this.myExportButtonTextComponent.text = this._myConfig.myExportButtonText;
    this.myExportButtonCursorTargetComponent = this.myExportButtonCursorTarget.pp_addComponent(CursorTarget);
    this.myExportButtonCollisionComponent = this.myExportButtonCursorTarget.pp_addComponent(CollisionComponent);
    this.myExportButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myExportButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myExportButtonCollisionComponent.extents = this._myConfig.myImportExportButtonCollisionExtents;
    this.myPointerCollisionComponent = this.myPointerCursorTarget.pp_addComponent(CollisionComponent);
    this.myPointerCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPointerCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPointerCollisionComponent.extents = this._myConfig.myPointerCollisionExtents;
    this._addComponentsHook();
  }
  _setupTextComponent(textComponent) {
    textComponent.alignment = this._myConfig.myTextAlignment;
    textComponent.justification = this._myConfig.myTextJustification;
    textComponent.material = this._myParams.myTextMaterial.clone();
    textComponent.material.color = this._myConfig.myTextColor;
    textComponent.text = "";
  }
  _onXRSessionStart() {
    this._setTransformForXR();
  }
  _onXRSessionEnd() {
    this._setTransformForNonXR();
  }
  _setTransformForXR() {
    this.myPivotObject.pp_setPositionLocal(this._myConfig.myPivotObjectPositions[this._myParams.myHandedness]);
  }
  _setTransformForNonXR() {
    this.myPivotObject.pp_setPositionLocal(this._myConfig.myPivotObjectPositions[ToolHandedness.NONE]);
  }
  destroy() {
    this._myDestroyed = true;
    XRUtils.unregisterSessionStartEndEventListeners(this, this._myEngine);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget_ui.js
var EasyTuneBoolArrayWidgetUI = class extends EasyTuneBaseWidgetUI {
  constructor(engine2) {
    super(engine2);
  }
  setAdditionalButtonsVisible(visible) {
    this._myAdditionalButtonsVisible = visible;
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValueIncreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
      this.myValueDecreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
    }
  }
  _buildHook() {
    this._myAdditionalButtonsVisible = true;
  }
  _createSkeletonHook() {
    this.myValuesPanel = this.myDisplayPanel.pp_addObject();
    this.myValuePanels = [];
    this.myValueTexts = [];
    this.myValueCursorTargets = [];
    this.myValueIncreaseButtonPanels = [];
    this.myValueIncreaseButtonBackgrounds = [];
    this.myValueIncreaseButtonTexts = [];
    this.myValueIncreaseButtonCursorTargets = [];
    this.myValueDecreaseButtonPanels = [];
    this.myValueDecreaseButtonBackgrounds = [];
    this.myValueDecreaseButtonTexts = [];
    this.myValueDecreaseButtonCursorTargets = [];
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValuePanels[i] = this.myValuesPanel.pp_addObject();
      this.myValueTexts[i] = this.myValuePanels[i].pp_addObject();
      this.myValueCursorTargets[i] = this.myValuePanels[i].pp_addObject();
      this.myValueIncreaseButtonPanels[i] = this.myValuePanels[i].pp_addObject();
      this.myValueIncreaseButtonBackgrounds[i] = this.myValueIncreaseButtonPanels[i].pp_addObject();
      this.myValueIncreaseButtonTexts[i] = this.myValueIncreaseButtonPanels[i].pp_addObject();
      this.myValueIncreaseButtonCursorTargets[i] = this.myValueIncreaseButtonPanels[i].pp_addObject();
      this.myValueDecreaseButtonPanels[i] = this.myValuePanels[i].pp_addObject();
      this.myValueDecreaseButtonBackgrounds[i] = this.myValueDecreaseButtonPanels[i].pp_addObject();
      this.myValueDecreaseButtonTexts[i] = this.myValueDecreaseButtonPanels[i].pp_addObject();
      this.myValueDecreaseButtonCursorTargets[i] = this.myValueDecreaseButtonPanels[i].pp_addObject();
    }
  }
  _setTransformHook() {
    this.myValuesPanel.pp_setPositionLocal(this._myConfig.myValuesPanelPosition);
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValuePanels[i].pp_setPositionLocal(this._myConfig.myValuePanelsPositions[i]);
      this.myValueTexts[i].pp_scaleObject(this._myConfig.myValueTextScale);
      this.myValueCursorTargets[i].pp_setPositionLocal(this._myConfig.myValueCursorTargetPosition);
      this.myValueIncreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myRightSideButtonPosition);
      this.myValueIncreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myValueIncreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myValueIncreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myValueIncreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
      this.myValueDecreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myLeftSideButtonPosition);
      this.myValueDecreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myValueDecreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myValueDecreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myValueDecreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    }
  }
  _addComponentsHook() {
    this.myValueTextComponents = [];
    this.myValueCursorTargetComponents = [];
    this.myValueCollisionComponents = [];
    this.myValueIncreaseButtonBackgroundComponents = [];
    this.myValueIncreaseButtonTextComponents = [];
    this.myValueIncreaseButtonCursorTargetComponents = [];
    this.myValueIncreaseButtonCollisionComponents = [];
    this.myValueDecreaseButtonBackgroundComponents = [];
    this.myValueDecreaseButtonTextComponents = [];
    this.myValueDecreaseButtonCursorTargetComponents = [];
    this.myValueDecreaseButtonCollisionComponents = [];
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValueTextComponents[i] = this.myValueTexts[i].pp_addComponent(TextComponent);
      this._setupTextComponent(this.myValueTextComponents[i]);
      this.myValueTextComponents[i].text = " ";
      this.myValueCursorTargetComponents[i] = this.myValueCursorTargets[i].pp_addComponent(CursorTarget);
      this.myValueCollisionComponents[i] = this.myValueCursorTargets[i].pp_addComponent(CollisionComponent);
      this.myValueCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myValueCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myValueCollisionComponents[i].extents = this._myConfig.myValueCollisionExtents;
      this.myValueIncreaseButtonBackgroundComponents[i] = this.myValueIncreaseButtonBackgrounds[i].pp_addComponent(MeshComponent);
      this.myValueIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myValueIncreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myValueIncreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myValueIncreaseButtonTextComponents[i] = this.myValueIncreaseButtonTexts[i].pp_addComponent(TextComponent);
      this._setupTextComponent(this.myValueIncreaseButtonTextComponents[i]);
      this.myValueIncreaseButtonTextComponents[i].text = this._myConfig.myIncreaseButtonText;
      this.myValueIncreaseButtonCursorTargetComponents[i] = this.myValueIncreaseButtonCursorTargets[i].pp_addComponent(CursorTarget);
      this.myValueIncreaseButtonCollisionComponents[i] = this.myValueIncreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent);
      this.myValueIncreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myValueIncreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myValueIncreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
      this.myValueDecreaseButtonBackgroundComponents[i] = this.myValueDecreaseButtonBackgrounds[i].pp_addComponent(MeshComponent);
      this.myValueDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myValueDecreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myValueDecreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myValueDecreaseButtonTextComponents[i] = this.myValueDecreaseButtonTexts[i].pp_addComponent(TextComponent);
      this._setupTextComponent(this.myValueDecreaseButtonTextComponents[i]);
      this.myValueDecreaseButtonTextComponents[i].text = this._myConfig.myDecreaseButtonText;
      this.myValueDecreaseButtonCursorTargetComponents[i] = this.myValueDecreaseButtonCursorTargets[i].pp_addComponent(CursorTarget);
      this.myValueDecreaseButtonCollisionComponents[i] = this.myValueDecreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent);
      this.myValueDecreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myValueDecreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myValueDecreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
    }
  }
  _setVisibleHook(visible) {
    if (visible) {
      this.setAdditionalButtonsVisible(this._myAdditionalButtonsVisible);
    }
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget.js
var EasyTuneBoolArrayWidget = class extends EasyTuneBaseWidget {
  constructor(params, arraySize, gamepad, engine2 = Globals.getMainEngine()) {
    super(params);
    this._myNonArray = arraySize == null;
    this._myArraySize = this._myNonArray ? 1 : arraySize;
    this._myConfig = new EasyTuneBoolArrayWidgetConfig(this._myArraySize);
    this._myUI = new EasyTuneBoolArrayWidgetUI(engine2);
    this._myGamepad = gamepad;
    this._myValueEditIndex = 0;
    this._myValueButtonEditIntensity = 0;
    this._myValueButtonEditIntensityTimer = 0;
    this._myValueEditEnabled = false;
    this._myTempValue = [];
    this._myTempNonArrayValue = [0];
    this._myTempNonArrayDefaultValue = [0];
  }
  _refreshUIHook() {
    for (let i = 0; i < this._myArraySize; i++) {
      this._myUI.myValueTextComponents[i].text = this._getVariableValue()[i] ? "true" : "false";
    }
  }
  _startHook(parentObject, easyTuneParams) {
    this._myUI.setAdditionalButtonsVisible(easyTuneParams.myShowAdditionalButtons);
  }
  _setEasyTuneVariableHook() {
    if (this._myVariable != null) {
      this._myTempValue.pp_copy(this._getVariableValue());
    }
  }
  _updateHook(dt) {
    this._updateValue(dt);
  }
  _updateValue(dt) {
    let stickVariableIntensity = 0;
    if (this._myGamepad) {
      stickVariableIntensity = this._myGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes[1];
    }
    let valueIntensity = 0;
    if (this._myValueEditEnabled) {
      valueIntensity = stickVariableIntensity;
    } else if (this._myValueButtonEditIntensity != 0) {
      if (this._myValueButtonEditIntensityTimer <= 0) {
        valueIntensity = this._myValueButtonEditIntensity;
      } else {
        this._myValueButtonEditIntensityTimer -= dt;
      }
    }
    if (this._myValueEditIndex >= 0 && this._myValueEditIndex < this._getVariableValue().length) {
      if (Math.abs(valueIntensity) > this._myConfig.myThumbstickToggleThreshold) {
        this._myTempValue.pp_copy(this._getVariableValue());
        this._myTempValue[this._myValueEditIndex] = valueIntensity > 0;
        this._setVariableValue(this._myTempValue);
        this._refreshUI();
      }
    }
  }
  _addListenersHook() {
    let ui = this._myUI;
    ui.myVariableLabelCursorTargetComponent.onClick.add(this._resetAllValues.bind(this));
    ui.myVariableLabelCursorTargetComponent.onHover.add(this._genericTextHover.bind(this, ui.myVariableLabelText));
    ui.myVariableLabelCursorTargetComponent.onUnhover.add(this._genericTextUnhover.bind(this, ui.myVariableLabelText, this._myConfig.myVariableLabelTextScale));
    for (let i = 0; i < this._myArraySize; i++) {
      ui.myValueIncreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, i, 1));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, i, 1));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, i, -1));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, i, -1));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
      ui.myValueCursorTargetComponents[i].onClick.add(this._resetValue.bind(this, i));
      ui.myValueCursorTargetComponents[i].onHover.add(this._setValueEditEnabled.bind(this, i, ui.myValueTexts[i], true));
      ui.myValueCursorTargetComponents[i].onUnhover.add(this._setValueEditEnabled.bind(this, i, ui.myValueTexts[i], false));
    }
  }
  _setValueEditIntensity(index, value) {
    if (this._isActive() || value == 0) {
      if (value != 0) {
        this._myValueButtonEditIntensityTimer = this._myConfig.myButtonEditDelay;
        this._myValueEditIndex = index;
      }
      this._myValueButtonEditIntensity = value;
    }
  }
  _setValueEditEnabled(index, text, enabled) {
    if (this._isActive() || !enabled) {
      if (enabled) {
        this._myValueEditIndex = index;
        text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
      } else {
        text.pp_setScaleLocal(this._myConfig.myValueTextScale);
      }
      this._myValueEditEnabled = enabled;
    }
  }
  _resetValue(index) {
    if (this._isActive()) {
      this._myTempValue.pp_copy(this._getVariableValue());
      this._myTempValue[index] = this._getVariableDefaultValue()[index];
      this._setVariableValue(this._myTempValue);
      this._myUI.myValueTextComponents[index].text = this._getVariableValue()[index] ? "true" : "false";
    }
  }
  _resetAllValues() {
    for (let i = 0; i < this._myArraySize; i++) {
      this._resetValue(i);
    }
  }
  _genericTextHover(text) {
    text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
  }
  _genericTextUnhover(text, originalScale) {
    text.pp_setScaleLocal(originalScale);
  }
  _getVariableValue() {
    if (this._myNonArray) {
      this._myTempNonArrayValue[0] = this._myVariable.getValue();
      return this._myTempNonArrayValue;
    }
    return this._myVariable.getValue();
  }
  _getVariableDefaultValue() {
    if (this._myNonArray) {
      this._myTempNonArrayDefaultValue[0] = this._myVariable.getDefaultValue();
      return this._myTempNonArrayDefaultValue;
    }
    return this._myVariable.getDefaultValue();
  }
  _setVariableValue(value) {
    if (this._myNonArray) {
      this._myVariable.setValue(value[0]);
    } else {
      this._myVariable.setValue(this._myTempValue);
    }
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget_selector.js
var EasyTuneBoolArrayWidgetSelector = class extends EasyTuneBaseArrayWidgetSelector {
  _getEasyTuneArrayWidget(arraySize) {
    return new EasyTuneBoolArrayWidget(this._myParams, arraySize, this._myGamepad, this._myEngine);
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/easy_tune_widget_config.js
var EasyTuneWidgetConfig = class {
  constructor() {
    this._setupRuntimeConfig();
  }
  _setupRuntimeConfig() {
    this.myGamepadHandedness = ToolHandedness.RIGHT;
    this.myScrollVariableDelay = 0.5;
    this.myScrollVariableMinXThreshold = 0.6;
    this.myScrollVariableMaxYThreshold = 0.25;
    this.myScrollVariableButtonID = null;
    this.myRefreshVariablesDelay = null;
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/none/easy_tune_none_widget_config.js
var EasyTuneNoneWidgetConfig = class extends EasyTuneBaseWidgetConfig {
  _getBackPanelMinY() {
    return super._getBackPanelMinY() + this.myTypeNotSupportedPanelPosition[1];
  }
  _getPivotZOffset() {
    return 804713e-8;
  }
  _setupBuildConfigHook() {
    this.myTypeNotSupportedPanelPosition = vec3_create(0, -0.03, this._myPanelZOffset);
    this.myTypeNotSupportedTextScale = vec3_create(0.275, 0.275, 0.275);
    this.myTypeNotSupportedText = "Type Not Supported";
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/none/easy_tune_none_widget_ui.js
var EasyTuneNoneWidgetUI = class extends EasyTuneBaseWidgetUI {
  constructor(engine2) {
    super(engine2);
  }
  _createSkeletonHook() {
    this.myTypeNotSupportedPanel = this.myDisplayPanel.pp_addObject();
    this.myTypeNotSupportedText = this.myTypeNotSupportedPanel.pp_addObject();
    this.myTypeNotSupportedCursorTarget = this.myTypeNotSupportedPanel.pp_addObject();
  }
  _setTransformHook() {
    this.myTypeNotSupportedPanel.pp_setPositionLocal(this._myConfig.myTypeNotSupportedPanelPosition);
    this.myTypeNotSupportedText.pp_scaleObject(this._myConfig.myTypeNotSupportedTextScale);
  }
  _addComponentsHook() {
    this.myTypeNotSupportedTextComponent = this.myTypeNotSupportedText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myTypeNotSupportedTextComponent);
    this.myTypeNotSupportedTextComponent.text = this._myConfig.myTypeNotSupportedText;
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/none/easy_tune_none_widget.js
var EasyTuneNoneWidget = class extends EasyTuneBaseWidget {
  constructor(params, engine2 = Globals.getMainEngine()) {
    super(params);
    this._myConfig = new EasyTuneNoneWidgetConfig();
    this._myUI = new EasyTuneNoneWidgetUI(engine2);
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_array_widget_config.js
var EasyTuneNumberArrayWidgetConfig = class extends EasyTuneBaseWidgetConfig {
  constructor(arraySize) {
    super();
    this.myArraySize = arraySize;
  }
  _getBackPanelMinY() {
    return this.myStepPanelPosition[1] - this._mySideButtonDistanceFromBorder * 1.25 - this.mySideButtonBackgroundScale[1];
  }
  _getPivotZOffset() {
    return 803713e-8;
  }
  _setupBuildConfigHook() {
    this.myIncreaseButtonText = "+";
    this.myDecreaseButtonText = "-";
    this._myValuePanelDistanceFromVariableLabelPanel = 0.055;
    this._myDistanceBetweenValues = this.mySideButtonBackgroundScale[1] * 2 + 0.015;
    this.myValuesPanelPosition = [0, this.myVariableLabelPanelPosition[1] - this._myValuePanelDistanceFromVariableLabelPanel, this._myPanelZOffset];
    this.myValueTextScale = vec3_create(0.4, 0.4, 0.4);
    this.myValueCursorTargetPosition = vec3_create(0, 0, 0);
    this.myValueCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myValueCollisionExtents = vec3_create(0.065, 0.02, 1);
    this.myValueCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myValuePanelsPositions = [];
    this.myValuePanelsPositions[0] = vec3_create(0, 0, 0);
    for (let i = 1; i < this.myArraySize; i++) {
      this.myValuePanelsPositions[i] = this.myValuePanelsPositions[i - 1].pp_clone();
      this.myValuePanelsPositions[i][1] -= this._myDistanceBetweenValues;
    }
    let valuePanelLastPosition = this.myValuePanelsPositions[this.myArraySize - 1] ? this.myValuePanelsPositions[this.myArraySize - 1][1] : 0;
    this.myStepPanelPosition = [0, this.myDisplayPanelPosition[1] + this.myValuesPanelPosition[1] + valuePanelLastPosition - this._myValuePanelDistanceFromVariableLabelPanel, this._myPanelZOffset];
    this.myStepTextScale = this.myLabelTextScale;
    this.myStepStartString = "Step: ";
    this.myStepCursorTargetPosition = vec3_create(0, 0, 0);
    this.myStepCursorTargetPosition[2] = this._myColliderZOffset - this.myStepPanelPosition[2];
    this.myStepCollisionExtents = vec3_create(0.065, 0.0175, 1);
    this.myStepCollisionExtents[2] = this.myCursorTargetCollisionThickness;
  }
  _setupRuntimeConfigHook() {
    this.myTextHoverScaleMultiplier = vec3_create(1.1, 1.1, 1.1);
    this.myEditThumbstickMinThreshold = 0.35;
    this.myStepMultiplierStepPerSecond = 2.25;
    this.myButtonEditDelay = 0;
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_array_widget_ui.js
var EasyTuneNumberArrayWidgetUI = class extends EasyTuneBaseWidgetUI {
  constructor(engine2) {
    super(engine2);
  }
  setAdditionalButtonsVisible(visible) {
    this._myAdditionalButtonsVisible = visible;
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValueIncreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
      this.myValueDecreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
    }
    this.myStepIncreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
    this.myStepDecreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
  }
  _buildHook() {
    this._myAdditionalButtonsVisible = true;
  }
  _createSkeletonHook() {
    this.myValuesPanel = this.myDisplayPanel.pp_addObject();
    this.myValuePanels = [];
    this.myValueTexts = [];
    this.myValueCursorTargets = [];
    this.myValueIncreaseButtonPanels = [];
    this.myValueIncreaseButtonBackgrounds = [];
    this.myValueIncreaseButtonTexts = [];
    this.myValueIncreaseButtonCursorTargets = [];
    this.myValueDecreaseButtonPanels = [];
    this.myValueDecreaseButtonBackgrounds = [];
    this.myValueDecreaseButtonTexts = [];
    this.myValueDecreaseButtonCursorTargets = [];
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValuePanels[i] = this.myValuesPanel.pp_addObject();
      this.myValueTexts[i] = this.myValuePanels[i].pp_addObject();
      this.myValueCursorTargets[i] = this.myValuePanels[i].pp_addObject();
      this.myValueIncreaseButtonPanels[i] = this.myValuePanels[i].pp_addObject();
      this.myValueIncreaseButtonBackgrounds[i] = this.myValueIncreaseButtonPanels[i].pp_addObject();
      this.myValueIncreaseButtonTexts[i] = this.myValueIncreaseButtonPanels[i].pp_addObject();
      this.myValueIncreaseButtonCursorTargets[i] = this.myValueIncreaseButtonPanels[i].pp_addObject();
      this.myValueDecreaseButtonPanels[i] = this.myValuePanels[i].pp_addObject();
      this.myValueDecreaseButtonBackgrounds[i] = this.myValueDecreaseButtonPanels[i].pp_addObject();
      this.myValueDecreaseButtonTexts[i] = this.myValueDecreaseButtonPanels[i].pp_addObject();
      this.myValueDecreaseButtonCursorTargets[i] = this.myValueDecreaseButtonPanels[i].pp_addObject();
    }
    this.myStepPanel = this.myPivotObject.pp_addObject();
    this.myStepText = this.myStepPanel.pp_addObject();
    this.myStepCursorTarget = this.myStepPanel.pp_addObject();
    this.myStepIncreaseButtonPanel = this.myStepPanel.pp_addObject();
    this.myStepIncreaseButtonBackground = this.myStepIncreaseButtonPanel.pp_addObject();
    this.myStepIncreaseButtonText = this.myStepIncreaseButtonPanel.pp_addObject();
    this.myStepIncreaseButtonCursorTarget = this.myStepIncreaseButtonPanel.pp_addObject();
    this.myStepDecreaseButtonPanel = this.myStepPanel.pp_addObject();
    this.myStepDecreaseButtonBackground = this.myStepDecreaseButtonPanel.pp_addObject();
    this.myStepDecreaseButtonText = this.myStepDecreaseButtonPanel.pp_addObject();
    this.myStepDecreaseButtonCursorTarget = this.myStepDecreaseButtonPanel.pp_addObject();
  }
  _setTransformHook() {
    this.myValuesPanel.pp_setPositionLocal(this._myConfig.myValuesPanelPosition);
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValuePanels[i].pp_setPositionLocal(this._myConfig.myValuePanelsPositions[i]);
      this.myValueTexts[i].pp_scaleObject(this._myConfig.myValueTextScale);
      this.myValueCursorTargets[i].pp_setPositionLocal(this._myConfig.myValueCursorTargetPosition);
      this.myValueIncreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myRightSideButtonPosition);
      this.myValueIncreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myValueIncreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myValueIncreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myValueIncreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
      this.myValueDecreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myLeftSideButtonPosition);
      this.myValueDecreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myValueDecreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myValueDecreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myValueDecreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    }
    this.myStepPanel.pp_setPositionLocal(this._myConfig.myStepPanelPosition);
    this.myStepText.pp_scaleObject(this._myConfig.myStepTextScale);
    this.myStepCursorTarget.pp_setPositionLocal(this._myConfig.myStepCursorTargetPosition);
    this.myStepIncreaseButtonPanel.pp_setPositionLocal(this._myConfig.myRightSideButtonPosition);
    this.myStepIncreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myStepIncreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myStepIncreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myStepIncreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myStepDecreaseButtonPanel.pp_setPositionLocal(this._myConfig.myLeftSideButtonPosition);
    this.myStepDecreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myStepDecreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myStepDecreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myStepDecreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
  }
  _addComponentsHook() {
    this.myValueTextComponents = [];
    this.myValueCursorTargetComponents = [];
    this.myValueCollisionComponents = [];
    this.myValueIncreaseButtonBackgroundComponents = [];
    this.myValueIncreaseButtonTextComponents = [];
    this.myValueIncreaseButtonCursorTargetComponents = [];
    this.myValueIncreaseButtonCollisionComponents = [];
    this.myValueDecreaseButtonBackgroundComponents = [];
    this.myValueDecreaseButtonTextComponents = [];
    this.myValueDecreaseButtonCursorTargetComponents = [];
    this.myValueDecreaseButtonCollisionComponents = [];
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValueTextComponents[i] = this.myValueTexts[i].pp_addComponent(TextComponent);
      this._setupTextComponent(this.myValueTextComponents[i]);
      this.myValueTextComponents[i].text = " ";
      this.myValueCursorTargetComponents[i] = this.myValueCursorTargets[i].pp_addComponent(CursorTarget);
      this.myValueCollisionComponents[i] = this.myValueCursorTargets[i].pp_addComponent(CollisionComponent);
      this.myValueCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myValueCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myValueCollisionComponents[i].extents = this._myConfig.myValueCollisionExtents;
      this.myValueIncreaseButtonBackgroundComponents[i] = this.myValueIncreaseButtonBackgrounds[i].pp_addComponent(MeshComponent);
      this.myValueIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myValueIncreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myValueIncreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myValueIncreaseButtonTextComponents[i] = this.myValueIncreaseButtonTexts[i].pp_addComponent(TextComponent);
      this._setupTextComponent(this.myValueIncreaseButtonTextComponents[i]);
      this.myValueIncreaseButtonTextComponents[i].text = this._myConfig.myIncreaseButtonText;
      this.myValueIncreaseButtonCursorTargetComponents[i] = this.myValueIncreaseButtonCursorTargets[i].pp_addComponent(CursorTarget);
      this.myValueIncreaseButtonCollisionComponents[i] = this.myValueIncreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent);
      this.myValueIncreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myValueIncreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myValueIncreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
      this.myValueDecreaseButtonBackgroundComponents[i] = this.myValueDecreaseButtonBackgrounds[i].pp_addComponent(MeshComponent);
      this.myValueDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myValueDecreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myValueDecreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myValueDecreaseButtonTextComponents[i] = this.myValueDecreaseButtonTexts[i].pp_addComponent(TextComponent);
      this._setupTextComponent(this.myValueDecreaseButtonTextComponents[i]);
      this.myValueDecreaseButtonTextComponents[i].text = this._myConfig.myDecreaseButtonText;
      this.myValueDecreaseButtonCursorTargetComponents[i] = this.myValueDecreaseButtonCursorTargets[i].pp_addComponent(CursorTarget);
      this.myValueDecreaseButtonCollisionComponents[i] = this.myValueDecreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent);
      this.myValueDecreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myValueDecreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myValueDecreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
    }
    this.myStepTextComponent = this.myStepText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myStepTextComponent);
    this.myStepTextComponent.text = " ";
    this.myStepCursorTargetComponent = this.myStepCursorTarget.pp_addComponent(CursorTarget);
    this.myStepCollisionComponent = this.myStepCursorTarget.pp_addComponent(CollisionComponent);
    this.myStepCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myStepCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myStepCollisionComponent.extents = this._myConfig.myStepCollisionExtents;
    this.myStepIncreaseButtonBackgroundComponent = this.myStepIncreaseButtonBackground.pp_addComponent(MeshComponent);
    this.myStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myStepIncreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myStepIncreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myStepIncreaseButtonTextComponent = this.myStepIncreaseButtonText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myStepIncreaseButtonTextComponent);
    this.myStepIncreaseButtonTextComponent.text = this._myConfig.myIncreaseButtonText;
    this.myStepIncreaseButtonCursorTargetComponent = this.myStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget);
    this.myStepIncreaseButtonCollisionComponent = this.myStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent);
    this.myStepIncreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myStepIncreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myStepIncreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myStepDecreaseButtonBackgroundComponent = this.myStepDecreaseButtonBackground.pp_addComponent(MeshComponent);
    this.myStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myStepDecreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myStepDecreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myStepDecreaseButtonTextComponent = this.myStepDecreaseButtonText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myStepDecreaseButtonTextComponent);
    this.myStepDecreaseButtonTextComponent.text = this._myConfig.myDecreaseButtonText;
    this.myStepDecreaseButtonCursorTargetComponent = this.myStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget);
    this.myStepDecreaseButtonCollisionComponent = this.myStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent);
    this.myStepDecreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myStepDecreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myStepDecreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
  }
  _setVisibleHook(visible) {
    if (visible) {
      this.setAdditionalButtonsVisible(this._myAdditionalButtonsVisible);
    }
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_array_widget.js
var EasyTuneNumberArrayWidget = class extends EasyTuneBaseWidget {
  constructor(params, arraySize, gamepad, engine2 = Globals.getMainEngine()) {
    super(params);
    this._myGamepad = gamepad;
    this._myNonArray = arraySize == null;
    this._myArraySize = this._myNonArray ? 1 : arraySize;
    this._myConfig = new EasyTuneNumberArrayWidgetConfig(this._myArraySize);
    this._myUI = new EasyTuneNumberArrayWidgetUI(engine2);
    this._myValueEditIndex = -1;
    this._myValueButtonEditIntensity = 0;
    this._myValueButtonEditIntensityTimer = 0;
    this._myStepButtonEditIntensity = 0;
    this._myStepButtonEditIntensityTimer = 0;
    this._myValueEditEnabled = false;
    this._myStepEditEnabled = false;
    this._myValueRealValue = 0;
    this._myStepMultiplierValue = 0;
    this._myStepFastEdit = false;
    this._myTempValue = [];
    this._myTempNonArrayValue = [0];
    this._myTempNonArrayDefaultValue = [0];
  }
  _refreshUIHook() {
    for (let i = 0; i < this._myArraySize; i++) {
      this._myUI.myValueTextComponents[i].text = this._getVariableValue()[i].toFixed(this._myVariable._myDecimalPlaces);
    }
    this._myUI.myStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myStepPerSecond);
  }
  _startHook(parentObject, easyTuneParams) {
    this._myUI.setAdditionalButtonsVisible(easyTuneParams.myShowAdditionalButtons);
  }
  _setEasyTuneVariableHook() {
    if (this._myVariable != null) {
      this._myTempValue.pp_copy(this._getVariableValue());
    }
  }
  _updateHook(dt) {
    this._updateValue(dt);
  }
  _updateValue(dt) {
    let stickVariableIntensity = 0;
    if (this._myGamepad) {
      let y = this._myGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes[1];
      if (Math.abs(y) > this._myConfig.myEditThumbstickMinThreshold) {
        let normalizedEditAmount = (Math.abs(y) - this._myConfig.myEditThumbstickMinThreshold) / (1 - this._myConfig.myEditThumbstickMinThreshold);
        stickVariableIntensity = Math.sign(y) * normalizedEditAmount;
      }
    }
    let valueIntensity = 0;
    if (this._myValueEditEnabled) {
      valueIntensity = stickVariableIntensity;
    } else if (this._myValueButtonEditIntensity != 0) {
      if (this._myValueButtonEditIntensityTimer <= 0) {
        valueIntensity = this._myValueButtonEditIntensity;
      } else {
        this._myValueButtonEditIntensityTimer -= dt;
      }
    }
    if (this._myValueEditIndex >= 0 && this._myValueEditIndex < this._getVariableValue().length) {
      if (valueIntensity != 0) {
        let amountToAdd = valueIntensity * this._myVariable._myStepPerSecond * dt;
        this._myValueRealValue += amountToAdd;
        if (this._myVariable._myMin != null && this._myVariable._myMax != null) {
          this._myValueRealValue = Math.pp_clamp(this._myValueRealValue, this._myVariable._myMin, this._myVariable._myMax);
        } else if (this._myVariable._myMin != null) {
          this._myValueRealValue = Math.max(this._myValueRealValue, this._myVariable._myMin);
        } else if (this._myVariable._myMax != null) {
          this._myValueRealValue = Math.min(this._myValueRealValue, this._myVariable._myMax);
        }
        let decimalPlacesMultiplier = Math.pow(10, this._myVariable._myDecimalPlaces);
        this._myTempValue.pp_copy(this._getVariableValue());
        if (this._myVariable._myEditAllValuesTogether) {
          let newValue = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
          let difference = newValue - this._myTempValue[this._myValueEditIndex];
          for (let i = 0; i < this._myArraySize; i++) {
            this._myTempValue[i] = Math.round((this._myTempValue[i] + difference) * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
            if (this._myVariable._myMin != null && this._myVariable._myMax != null) {
              this._myTempValue[i] = Math.pp_clamp(this._myTempValue[i], this._myVariable._myMin, this._myVariable._myMax);
            } else if (this._myVariable._myMin != null) {
              this._myTempValue[i] = Math.max(this._myTempValue[i], this._myVariable._myMin);
            } else if (this._myVariable._myMax != null) {
              this._myTempValue[i] = Math.min(this._myTempValue[i], this._myVariable._myMax);
            }
            this._myUI.myValueTextComponents[i].text = this._myTempValue[i].toFixed(this._myVariable._myDecimalPlaces);
          }
        } else {
          this._myTempValue[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
          if (this._myVariable._myMin != null && this._myVariable._myMax != null) {
            this._myTempValue[this._myValueEditIndex] = Math.pp_clamp(this._myTempValue[this._myValueEditIndex], this._myVariable._myMin, this._myVariable._myMax);
          } else if (this._myVariable._myMin != null) {
            this._myTempValue[this._myValueEditIndex] = Math.max(this._myTempValue[this._myValueEditIndex], this._myVariable._myMin);
          } else if (this._myVariable._myMax != null) {
            this._myTempValue[this._myValueEditIndex] = Math.min(this._myTempValue[this._myValueEditIndex], this._myVariable._myMax);
          }
          this._myUI.myValueTextComponents[this._myValueEditIndex].text = this._myTempValue[this._myValueEditIndex].toFixed(this._myVariable._myDecimalPlaces);
        }
        this._setVariableValue(this._myTempValue);
      } else {
        this._myValueRealValue = this._getVariableValue()[this._myValueEditIndex];
      }
    }
    let stepIntensity = 0;
    if (this._myStepEditEnabled) {
      stepIntensity = stickVariableIntensity;
    } else if (this._myStepButtonEditIntensity != 0) {
      if (this._myStepButtonEditIntensityTimer <= 0) {
        stepIntensity = this._myStepButtonEditIntensity;
      } else {
        this._myStepButtonEditIntensityTimer -= dt;
      }
    }
    if (stepIntensity != 0) {
      let amountToAdd = 0;
      if (this._myStepFastEdit) {
        amountToAdd = Math.sign(stepIntensity) * 1;
        this._myStepFastEdit = false;
      } else {
        amountToAdd = stepIntensity * this._myConfig.myStepMultiplierStepPerSecond * dt;
      }
      this._myStepMultiplierValue += amountToAdd;
      if (Math.abs(this._myStepMultiplierValue) >= 1) {
        if (Math.sign(this._myStepMultiplierValue) > 0) {
          this._myStepMultiplierValue -= 1;
          this._changeStep(this._myVariable._myStepPerSecond * 10);
        } else {
          this._myStepMultiplierValue += 1;
          this._changeStep(this._myVariable._myStepPerSecond * 0.1);
        }
      }
    } else {
      this._myStepMultiplierValue = 0;
      this._myStepFastEdit = true;
    }
  }
  _addListenersHook() {
    let ui = this._myUI;
    ui.myVariableLabelCursorTargetComponent.onClick.add(this._resetAllValues.bind(this));
    ui.myVariableLabelCursorTargetComponent.onHover.add(this._genericTextHover.bind(this, ui.myVariableLabelText));
    ui.myVariableLabelCursorTargetComponent.onUnhover.add(this._genericTextUnhover.bind(this, ui.myVariableLabelText, this._myConfig.myVariableLabelTextScale));
    for (let i = 0; i < this._myArraySize; i++) {
      ui.myValueIncreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, i, 1));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, i, 1));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, i, -1));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, i, -1));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
      ui.myValueCursorTargetComponents[i].onClick.add(this._resetValue.bind(this, i));
      ui.myValueCursorTargetComponents[i].onHover.add(this._setValueEditEnabled.bind(this, i, ui.myValueTexts[i], true));
      ui.myValueCursorTargetComponents[i].onUnhover.add(this._setValueEditEnabled.bind(this, i, ui.myValueTexts[i], false));
    }
    ui.myStepCursorTargetComponent.onClick.add(this._resetStep.bind(this));
    ui.myStepCursorTargetComponent.onHover.add(this._setStepEditEnabled.bind(this, ui.myStepText, true));
    ui.myStepCursorTargetComponent.onUnhover.add(this._setStepEditEnabled.bind(this, ui.myStepText, false));
    ui.myStepIncreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, 1));
    ui.myStepIncreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, 1));
    ui.myStepIncreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 0));
    ui.myStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 0));
    ui.myStepDecreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, -1));
    ui.myStepDecreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, -1));
    ui.myStepDecreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 0));
    ui.myStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 0));
    ui.myStepIncreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myStepIncreaseButtonBackgroundComponent.material));
    ui.myStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myStepIncreaseButtonBackgroundComponent.material));
    ui.myStepDecreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myStepDecreaseButtonBackgroundComponent.material));
    ui.myStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myStepDecreaseButtonBackgroundComponent.material));
  }
  _setValueEditIntensity(index, value) {
    if (this._isActive() || value == 0) {
      if (value != 0) {
        this._myValueButtonEditIntensityTimer = this._myConfig.myButtonEditDelay;
        this._myValueRealValue = this._getVariableValue()[index];
        this._myValueEditIndex = index;
      }
      this._myValueButtonEditIntensity = value;
    }
  }
  _setStepEditIntensity(value) {
    if (this._isActive() || value == 0) {
      if (value != 0) {
        this._myStepButtonEditIntensityTimer = this._myConfig.myButtonEditDelay;
      }
      this._myStepButtonEditIntensity = value;
    }
  }
  _setValueEditEnabled(index, text, enabled) {
    if (this._isActive() || !enabled) {
      if (enabled) {
        this._myValueRealValue = this._getVariableValue()[index];
        this._myValueEditIndex = index;
        text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
      } else {
        text.pp_setScaleLocal(this._myConfig.myValueTextScale);
      }
      this._myValueEditEnabled = enabled;
    }
  }
  _setStepEditEnabled(text, enabled) {
    if (this._isActive() || !enabled) {
      if (enabled) {
        text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
      } else {
        text.pp_setScaleLocal(this._myConfig.myStepTextScale);
      }
      this._myStepEditEnabled = enabled;
    }
  }
  _resetValue(index) {
    if (this._isActive()) {
      this._myTempValue.pp_copy(this._getVariableValue());
      this._myTempValue[index] = this._getVariableDefaultValue()[index];
      this._setVariableValue(this._myTempValue);
      this._myUI.myValueTextComponents[index].text = this._getVariableValue()[index].toFixed(this._myVariable._myDecimalPlaces);
    }
  }
  _resetAllValues() {
    for (let i = 0; i < this._myArraySize; i++) {
      this._resetValue(i);
    }
  }
  _resetStep() {
    if (this._isActive()) {
      this._changeStep(this._myVariable._myDefaultStepPerSecond);
    }
  }
  _changeStep(step) {
    step = Math.pp_roundDecimal(step, 10);
    this._myVariable._myStepPerSecond = step;
    this._myUI.myStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myStepPerSecond);
  }
  _genericTextHover(text) {
    text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
  }
  _genericTextUnhover(text, originalScale) {
    text.pp_setScaleLocal(originalScale);
  }
  _getVariableValue() {
    if (this._myNonArray) {
      this._myTempNonArrayValue[0] = this._myVariable.getValue();
      return this._myTempNonArrayValue;
    }
    return this._myVariable.getValue();
  }
  _getVariableDefaultValue() {
    if (this._myNonArray) {
      this._myTempNonArrayDefaultValue[0] = this._myVariable.getDefaultValue();
      return this._myTempNonArrayDefaultValue;
    }
    return this._myVariable.getDefaultValue();
  }
  _setVariableValue(value) {
    if (this._myNonArray) {
      this._myVariable.setValue(value[0]);
    } else {
      this._myVariable.setValue(this._myTempValue);
    }
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_widget_selector.js
var EasyTuneNumberArrayWidgetSelector = class extends EasyTuneBaseArrayWidgetSelector {
  _getEasyTuneArrayWidget(arraySize) {
    return new EasyTuneNumberArrayWidget(this._myParams, arraySize, this._myGamepad, this._myEngine);
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/transform/easy_tune_transform_widget_config.js
var EasyTuneTransformWidgetConfig = class extends EasyTuneBaseWidgetConfig {
  _getBackPanelMinY() {
    return super._getBackPanelMinY() + this.myPositionPanelPosition[1] + this.myStepPanelPosition[1];
  }
  _getBackPanelMaxX() {
    return this.myDisplayPanelPosition[0] + this.myRotationPanelPosition[0] + this.myIncreaseButtonPosition[0] + this.mySideButtonBackgroundScale[0] + this._mySideButtonDistanceFromBorder;
  }
  _getBackPanelMinX() {
    return this.myDisplayPanelPosition[0] + this.myScalePanelPosition[0] + this.myDecreaseButtonPosition[0] - this.mySideButtonBackgroundScale[0] - this._mySideButtonDistanceFromBorder;
  }
  _getPivotZOffset() {
    return 805713e-8;
  }
  _setupBuildConfigHook() {
    this.myIncreaseButtonText = "+";
    this.myDecreaseButtonText = "-";
    this.myDecreaseButtonPosition = vec3_create(-0.13, 0, -1e-5);
    this.myIncreaseButtonPosition = vec3_create(-this.myDecreaseButtonPosition[0], 0, -1e-5);
    let distanceBetweenComponents = Math.abs(this.myIncreaseButtonPosition[0]) + Math.abs(this.myRightSideButtonPosition[0]);
    let distanceFromVariableLabel = 0.045;
    this.myPositionPanelPosition = [0, this.myVariableLabelPanelPosition[1] - distanceFromVariableLabel, this._myPanelZOffset];
    this.myRotationPanelPosition = [this.myPositionPanelPosition[0] + distanceBetweenComponents, this.myVariableLabelPanelPosition[1] - distanceFromVariableLabel, this._myPanelZOffset];
    this.myScalePanelPosition = [this.myPositionPanelPosition[0] - distanceBetweenComponents, this.myVariableLabelPanelPosition[1] - distanceFromVariableLabel, this._myPanelZOffset];
    this.myPositionText = "Position";
    this.myRotationText = "Rotation";
    this.myScaleText = "Scale";
    this.myComponentLabelTextScale = this.myLabelTextScale;
    this.myComponentLabelCursorTargetPosition = vec3_create(0, 0, 0);
    this.myComponentLabelCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myComponentLabelCollisionExtents = vec3_create(0.065, 0.0175, 1);
    this.myComponentLabelCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this._myValuePanelDistanceFromVariableLabelPanel = 0.055;
    this._myDistanceBetweenValues = this.mySideButtonBackgroundScale[1] * 2 + 0.015;
    this.myValueTextScale = vec3_create(0.4, 0.4, 0.4);
    this.myValueCursorTargetPosition = vec3_create(0, 0, 0);
    this.myValueCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myValueCollisionExtents = vec3_create(0.065, 0.02, 1);
    this.myValueCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myValuePanelsPositions = [];
    this.myValuePanelsPositions[0] = vec3_create(0, -this._myValuePanelDistanceFromVariableLabelPanel, 0);
    for (let i = 1; i < 3; i++) {
      this.myValuePanelsPositions[i] = this.myValuePanelsPositions[i - 1].pp_clone();
      this.myValuePanelsPositions[i][1] -= this._myDistanceBetweenValues;
    }
    let valuePanelLastPosition = this.myValuePanelsPositions[2][1];
    this.myStepPanelPosition = [0, valuePanelLastPosition - this._myValuePanelDistanceFromVariableLabelPanel, 0];
    this.myStepTextScale = this.myLabelTextScale;
    this.myStepStartString = "Step: ";
    this.myStepCursorTargetPosition = vec3_create(0, 0, 0);
    this.myStepCursorTargetPosition[2] = this._myColliderZOffset - this.myStepPanelPosition[2];
    this.myStepCollisionExtents = vec3_create(0.065, 0.0175, 1);
    this.myStepCollisionExtents[2] = this.myCursorTargetCollisionThickness;
  }
  _setupRuntimeConfigHook() {
    this.myTextHoverScaleMultiplier = vec3_create(1.1, 1.1, 1.1);
    this.myEditThumbstickMinThreshold = 0.35;
    this.myStepMultiplierStepPerSecond = 2.25;
    this.myButtonEditDelay = 0;
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/transform/easy_tune_transform_widget_ui.js
var EasyTuneTransformWidgetUI = class extends EasyTuneBaseWidgetUI {
  constructor(engine2) {
    super(engine2);
  }
  setAdditionalButtonsVisible(visible) {
    this._myAdditionalButtonsVisible = visible;
    for (let i = 0; i < 3; i++) {
      this.myPositionIncreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
      this.myPositionDecreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
    }
    this.myPositionStepIncreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
    this.myPositionStepDecreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
    for (let i = 0; i < 3; i++) {
      this.myRotationIncreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
      this.myRotationDecreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
    }
    this.myRotationStepIncreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
    this.myRotationStepDecreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
    for (let i = 0; i < 3; i++) {
      this.myScaleIncreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
      this.myScaleDecreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
    }
    this.myScaleStepIncreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
    this.myScaleStepDecreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
  }
  _buildHook() {
    this._myAdditionalButtonsVisible = true;
  }
  _createSkeletonHook() {
    this.myPositionPanel = this.myDisplayPanel.pp_addObject();
    this.myPositionLabelText = this.myPositionPanel.pp_addObject();
    this.myPositionLabelCursorTarget = this.myPositionPanel.pp_addObject();
    this.myPositionPanels = [];
    this.myPositionTexts = [];
    this.myPositionCursorTargets = [];
    this.myPositionIncreaseButtonPanels = [];
    this.myPositionIncreaseButtonBackgrounds = [];
    this.myPositionIncreaseButtonTexts = [];
    this.myPositionIncreaseButtonCursorTargets = [];
    this.myPositionDecreaseButtonPanels = [];
    this.myPositionDecreaseButtonBackgrounds = [];
    this.myPositionDecreaseButtonTexts = [];
    this.myPositionDecreaseButtonCursorTargets = [];
    for (let i = 0; i < 3; i++) {
      this.myPositionPanels[i] = this.myPositionPanel.pp_addObject();
      this.myPositionTexts[i] = this.myPositionPanels[i].pp_addObject();
      this.myPositionCursorTargets[i] = this.myPositionPanels[i].pp_addObject();
      this.myPositionIncreaseButtonPanels[i] = this.myPositionPanels[i].pp_addObject();
      this.myPositionIncreaseButtonBackgrounds[i] = this.myPositionIncreaseButtonPanels[i].pp_addObject();
      this.myPositionIncreaseButtonTexts[i] = this.myPositionIncreaseButtonPanels[i].pp_addObject();
      this.myPositionIncreaseButtonCursorTargets[i] = this.myPositionIncreaseButtonPanels[i].pp_addObject();
      this.myPositionDecreaseButtonPanels[i] = this.myPositionPanels[i].pp_addObject();
      this.myPositionDecreaseButtonBackgrounds[i] = this.myPositionDecreaseButtonPanels[i].pp_addObject();
      this.myPositionDecreaseButtonTexts[i] = this.myPositionDecreaseButtonPanels[i].pp_addObject();
      this.myPositionDecreaseButtonCursorTargets[i] = this.myPositionDecreaseButtonPanels[i].pp_addObject();
    }
    this.myRotationPanel = this.myDisplayPanel.pp_addObject();
    this.myRotationLabelText = this.myRotationPanel.pp_addObject();
    this.myRotationLabelCursorTarget = this.myRotationPanel.pp_addObject();
    this.myRotationPanels = [];
    this.myRotationTexts = [];
    this.myRotationCursorTargets = [];
    this.myRotationIncreaseButtonPanels = [];
    this.myRotationIncreaseButtonBackgrounds = [];
    this.myRotationIncreaseButtonTexts = [];
    this.myRotationIncreaseButtonCursorTargets = [];
    this.myRotationDecreaseButtonPanels = [];
    this.myRotationDecreaseButtonBackgrounds = [];
    this.myRotationDecreaseButtonTexts = [];
    this.myRotationDecreaseButtonCursorTargets = [];
    for (let i = 0; i < 3; i++) {
      this.myRotationPanels[i] = this.myRotationPanel.pp_addObject();
      this.myRotationTexts[i] = this.myRotationPanels[i].pp_addObject();
      this.myRotationCursorTargets[i] = this.myRotationPanels[i].pp_addObject();
      this.myRotationIncreaseButtonPanels[i] = this.myRotationPanels[i].pp_addObject();
      this.myRotationIncreaseButtonBackgrounds[i] = this.myRotationIncreaseButtonPanels[i].pp_addObject();
      this.myRotationIncreaseButtonTexts[i] = this.myRotationIncreaseButtonPanels[i].pp_addObject();
      this.myRotationIncreaseButtonCursorTargets[i] = this.myRotationIncreaseButtonPanels[i].pp_addObject();
      this.myRotationDecreaseButtonPanels[i] = this.myRotationPanels[i].pp_addObject();
      this.myRotationDecreaseButtonBackgrounds[i] = this.myRotationDecreaseButtonPanels[i].pp_addObject();
      this.myRotationDecreaseButtonTexts[i] = this.myRotationDecreaseButtonPanels[i].pp_addObject();
      this.myRotationDecreaseButtonCursorTargets[i] = this.myRotationDecreaseButtonPanels[i].pp_addObject();
    }
    this.myScalePanel = this.myDisplayPanel.pp_addObject();
    this.myScaleLabelText = this.myScalePanel.pp_addObject();
    this.myScaleLabelCursorTarget = this.myScalePanel.pp_addObject();
    this.myScalePanels = [];
    this.myScaleTexts = [];
    this.myScaleCursorTargets = [];
    this.myScaleIncreaseButtonPanels = [];
    this.myScaleIncreaseButtonBackgrounds = [];
    this.myScaleIncreaseButtonTexts = [];
    this.myScaleIncreaseButtonCursorTargets = [];
    this.myScaleDecreaseButtonPanels = [];
    this.myScaleDecreaseButtonBackgrounds = [];
    this.myScaleDecreaseButtonTexts = [];
    this.myScaleDecreaseButtonCursorTargets = [];
    for (let i = 0; i < 3; i++) {
      this.myScalePanels[i] = this.myScalePanel.pp_addObject();
      this.myScaleTexts[i] = this.myScalePanels[i].pp_addObject();
      this.myScaleCursorTargets[i] = this.myScalePanels[i].pp_addObject();
      this.myScaleIncreaseButtonPanels[i] = this.myScalePanels[i].pp_addObject();
      this.myScaleIncreaseButtonBackgrounds[i] = this.myScaleIncreaseButtonPanels[i].pp_addObject();
      this.myScaleIncreaseButtonTexts[i] = this.myScaleIncreaseButtonPanels[i].pp_addObject();
      this.myScaleIncreaseButtonCursorTargets[i] = this.myScaleIncreaseButtonPanels[i].pp_addObject();
      this.myScaleDecreaseButtonPanels[i] = this.myScalePanels[i].pp_addObject();
      this.myScaleDecreaseButtonBackgrounds[i] = this.myScaleDecreaseButtonPanels[i].pp_addObject();
      this.myScaleDecreaseButtonTexts[i] = this.myScaleDecreaseButtonPanels[i].pp_addObject();
      this.myScaleDecreaseButtonCursorTargets[i] = this.myScaleDecreaseButtonPanels[i].pp_addObject();
    }
    this.myPositionStepPanel = this.myPositionPanel.pp_addObject();
    this.myPositionStepText = this.myPositionStepPanel.pp_addObject();
    this.myPositionStepCursorTarget = this.myPositionStepPanel.pp_addObject();
    this.myPositionStepIncreaseButtonPanel = this.myPositionStepPanel.pp_addObject();
    this.myPositionStepIncreaseButtonBackground = this.myPositionStepIncreaseButtonPanel.pp_addObject();
    this.myPositionStepIncreaseButtonText = this.myPositionStepIncreaseButtonPanel.pp_addObject();
    this.myPositionStepIncreaseButtonCursorTarget = this.myPositionStepIncreaseButtonPanel.pp_addObject();
    this.myPositionStepDecreaseButtonPanel = this.myPositionStepPanel.pp_addObject();
    this.myPositionStepDecreaseButtonBackground = this.myPositionStepDecreaseButtonPanel.pp_addObject();
    this.myPositionStepDecreaseButtonText = this.myPositionStepDecreaseButtonPanel.pp_addObject();
    this.myPositionStepDecreaseButtonCursorTarget = this.myPositionStepDecreaseButtonPanel.pp_addObject();
    this.myRotationStepPanel = this.myRotationPanel.pp_addObject();
    this.myRotationStepText = this.myRotationStepPanel.pp_addObject();
    this.myRotationStepCursorTarget = this.myRotationStepPanel.pp_addObject();
    this.myRotationStepIncreaseButtonPanel = this.myRotationStepPanel.pp_addObject();
    this.myRotationStepIncreaseButtonBackground = this.myRotationStepIncreaseButtonPanel.pp_addObject();
    this.myRotationStepIncreaseButtonText = this.myRotationStepIncreaseButtonPanel.pp_addObject();
    this.myRotationStepIncreaseButtonCursorTarget = this.myRotationStepIncreaseButtonPanel.pp_addObject();
    this.myRotationStepDecreaseButtonPanel = this.myRotationStepPanel.pp_addObject();
    this.myRotationStepDecreaseButtonBackground = this.myRotationStepDecreaseButtonPanel.pp_addObject();
    this.myRotationStepDecreaseButtonText = this.myRotationStepDecreaseButtonPanel.pp_addObject();
    this.myRotationStepDecreaseButtonCursorTarget = this.myRotationStepDecreaseButtonPanel.pp_addObject();
    this.myScaleStepPanel = this.myScalePanel.pp_addObject();
    this.myScaleStepText = this.myScaleStepPanel.pp_addObject();
    this.myScaleStepCursorTarget = this.myScaleStepPanel.pp_addObject();
    this.myScaleStepIncreaseButtonPanel = this.myScaleStepPanel.pp_addObject();
    this.myScaleStepIncreaseButtonBackground = this.myScaleStepIncreaseButtonPanel.pp_addObject();
    this.myScaleStepIncreaseButtonText = this.myScaleStepIncreaseButtonPanel.pp_addObject();
    this.myScaleStepIncreaseButtonCursorTarget = this.myScaleStepIncreaseButtonPanel.pp_addObject();
    this.myScaleStepDecreaseButtonPanel = this.myScaleStepPanel.pp_addObject();
    this.myScaleStepDecreaseButtonBackground = this.myScaleStepDecreaseButtonPanel.pp_addObject();
    this.myScaleStepDecreaseButtonText = this.myScaleStepDecreaseButtonPanel.pp_addObject();
    this.myScaleStepDecreaseButtonCursorTarget = this.myScaleStepDecreaseButtonPanel.pp_addObject();
  }
  _setTransformHook() {
    this.myPositionPanel.pp_setPositionLocal(this._myConfig.myPositionPanelPosition);
    this.myPositionLabelText.pp_scaleObject(this._myConfig.myComponentLabelTextScale);
    this.myPositionLabelCursorTarget.pp_setPositionLocal(this._myConfig.myComponentLabelCursorTargetPosition);
    for (let i = 0; i < 3; i++) {
      this.myPositionPanels[i].pp_setPositionLocal(this._myConfig.myValuePanelsPositions[i]);
      this.myPositionTexts[i].pp_scaleObject(this._myConfig.myValueTextScale);
      this.myPositionCursorTargets[i].pp_setPositionLocal(this._myConfig.myValueCursorTargetPosition);
      this.myPositionIncreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myIncreaseButtonPosition);
      this.myPositionIncreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myPositionIncreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myPositionIncreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myPositionIncreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
      this.myPositionDecreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myDecreaseButtonPosition);
      this.myPositionDecreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myPositionDecreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myPositionDecreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myPositionDecreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    }
    this.myRotationPanel.pp_setPositionLocal(this._myConfig.myRotationPanelPosition);
    this.myRotationLabelText.pp_scaleObject(this._myConfig.myComponentLabelTextScale);
    this.myRotationLabelCursorTarget.pp_setPositionLocal(this._myConfig.myComponentLabelCursorTargetPosition);
    for (let i = 0; i < 3; i++) {
      this.myRotationPanels[i].pp_setPositionLocal(this._myConfig.myValuePanelsPositions[i]);
      this.myRotationTexts[i].pp_scaleObject(this._myConfig.myValueTextScale);
      this.myRotationCursorTargets[i].pp_setPositionLocal(this._myConfig.myValueCursorTargetPosition);
      this.myRotationIncreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myIncreaseButtonPosition);
      this.myRotationIncreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myRotationIncreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myRotationIncreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myRotationIncreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
      this.myRotationDecreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myDecreaseButtonPosition);
      this.myRotationDecreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myRotationDecreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myRotationDecreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myRotationDecreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    }
    this.myScalePanel.pp_setPositionLocal(this._myConfig.myScalePanelPosition);
    this.myScaleLabelText.pp_scaleObject(this._myConfig.myComponentLabelTextScale);
    this.myScaleLabelCursorTarget.pp_setPositionLocal(this._myConfig.myComponentLabelCursorTargetPosition);
    for (let i = 0; i < 3; i++) {
      this.myScalePanels[i].pp_setPositionLocal(this._myConfig.myValuePanelsPositions[i]);
      this.myScaleTexts[i].pp_scaleObject(this._myConfig.myValueTextScale);
      this.myScaleCursorTargets[i].pp_setPositionLocal(this._myConfig.myValueCursorTargetPosition);
      this.myScaleIncreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myIncreaseButtonPosition);
      this.myScaleIncreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myScaleIncreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myScaleIncreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myScaleIncreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
      this.myScaleDecreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myDecreaseButtonPosition);
      this.myScaleDecreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myScaleDecreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myScaleDecreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myScaleDecreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    }
    this.myPositionStepPanel.pp_setPositionLocal(this._myConfig.myStepPanelPosition);
    this.myPositionStepText.pp_scaleObject(this._myConfig.myStepTextScale);
    this.myPositionStepCursorTarget.pp_setPositionLocal(this._myConfig.myStepCursorTargetPosition);
    this.myPositionStepIncreaseButtonPanel.pp_setPositionLocal(this._myConfig.myIncreaseButtonPosition);
    this.myPositionStepIncreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myPositionStepIncreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myPositionStepIncreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myPositionStepIncreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myPositionStepDecreaseButtonPanel.pp_setPositionLocal(this._myConfig.myDecreaseButtonPosition);
    this.myPositionStepDecreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myPositionStepDecreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myPositionStepDecreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myPositionStepDecreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myRotationStepPanel.pp_setPositionLocal(this._myConfig.myStepPanelPosition);
    this.myRotationStepText.pp_scaleObject(this._myConfig.myStepTextScale);
    this.myRotationStepCursorTarget.pp_setPositionLocal(this._myConfig.myStepCursorTargetPosition);
    this.myRotationStepIncreaseButtonPanel.pp_setPositionLocal(this._myConfig.myIncreaseButtonPosition);
    this.myRotationStepIncreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myRotationStepIncreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myRotationStepIncreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myRotationStepIncreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myRotationStepDecreaseButtonPanel.pp_setPositionLocal(this._myConfig.myDecreaseButtonPosition);
    this.myRotationStepDecreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myRotationStepDecreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myRotationStepDecreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myRotationStepDecreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myScaleStepPanel.pp_setPositionLocal(this._myConfig.myStepPanelPosition);
    this.myScaleStepText.pp_scaleObject(this._myConfig.myStepTextScale);
    this.myScaleStepCursorTarget.pp_setPositionLocal(this._myConfig.myStepCursorTargetPosition);
    this.myScaleStepIncreaseButtonPanel.pp_setPositionLocal(this._myConfig.myIncreaseButtonPosition);
    this.myScaleStepIncreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myScaleStepIncreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myScaleStepIncreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myScaleStepIncreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myScaleStepDecreaseButtonPanel.pp_setPositionLocal(this._myConfig.myDecreaseButtonPosition);
    this.myScaleStepDecreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myScaleStepDecreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myScaleStepDecreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myScaleStepDecreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
  }
  _addComponentsHook() {
    this.myPositionLabelTextComponent = this.myPositionLabelText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myPositionLabelTextComponent);
    this.myPositionLabelTextComponent.text = this._myConfig.myPositionText;
    this.myPositionLabelCursorTargetComponent = this.myPositionLabelCursorTarget.pp_addComponent(CursorTarget);
    this.myPositionLabelCollisionComponent = this.myPositionLabelCursorTarget.pp_addComponent(CollisionComponent);
    this.myPositionLabelCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPositionLabelCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPositionLabelCollisionComponent.extents = this._myConfig.myComponentLabelCollisionExtents;
    this.myPositionTextComponents = [];
    this.myPositionCursorTargetComponents = [];
    this.myPositionCollisionComponents = [];
    this.myPositionIncreaseButtonBackgroundComponents = [];
    this.myPositionIncreaseButtonTextComponents = [];
    this.myPositionIncreaseButtonCursorTargetComponents = [];
    this.myPositionIncreaseButtonCollisionComponents = [];
    this.myPositionDecreaseButtonBackgroundComponents = [];
    this.myPositionDecreaseButtonTextComponents = [];
    this.myPositionDecreaseButtonCursorTargetComponents = [];
    this.myPositionDecreaseButtonCollisionComponents = [];
    for (let i = 0; i < 3; i++) {
      this.myPositionTextComponents[i] = this.myPositionTexts[i].pp_addComponent(TextComponent);
      this._setupTextComponent(this.myPositionTextComponents[i]);
      this.myPositionTextComponents[i].text = " ";
      this.myPositionCursorTargetComponents[i] = this.myPositionCursorTargets[i].pp_addComponent(CursorTarget);
      this.myPositionCollisionComponents[i] = this.myPositionCursorTargets[i].pp_addComponent(CollisionComponent);
      this.myPositionCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myPositionCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myPositionCollisionComponents[i].extents = this._myConfig.myValueCollisionExtents;
      this.myPositionIncreaseButtonBackgroundComponents[i] = this.myPositionIncreaseButtonBackgrounds[i].pp_addComponent(MeshComponent);
      this.myPositionIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myPositionIncreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myPositionIncreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myPositionIncreaseButtonTextComponents[i] = this.myPositionIncreaseButtonTexts[i].pp_addComponent(TextComponent);
      this._setupTextComponent(this.myPositionIncreaseButtonTextComponents[i]);
      this.myPositionIncreaseButtonTextComponents[i].text = this._myConfig.myIncreaseButtonText;
      this.myPositionIncreaseButtonCursorTargetComponents[i] = this.myPositionIncreaseButtonCursorTargets[i].pp_addComponent(CursorTarget);
      this.myPositionIncreaseButtonCollisionComponents[i] = this.myPositionIncreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent);
      this.myPositionIncreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myPositionIncreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myPositionIncreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
      this.myPositionDecreaseButtonBackgroundComponents[i] = this.myPositionDecreaseButtonBackgrounds[i].pp_addComponent(MeshComponent);
      this.myPositionDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myPositionDecreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myPositionDecreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myPositionDecreaseButtonTextComponents[i] = this.myPositionDecreaseButtonTexts[i].pp_addComponent(TextComponent);
      this._setupTextComponent(this.myPositionDecreaseButtonTextComponents[i]);
      this.myPositionDecreaseButtonTextComponents[i].text = this._myConfig.myDecreaseButtonText;
      this.myPositionDecreaseButtonCursorTargetComponents[i] = this.myPositionDecreaseButtonCursorTargets[i].pp_addComponent(CursorTarget);
      this.myPositionDecreaseButtonCollisionComponents[i] = this.myPositionDecreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent);
      this.myPositionDecreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myPositionDecreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myPositionDecreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
    }
    this.myRotationLabelTextComponent = this.myRotationLabelText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myRotationLabelTextComponent);
    this.myRotationLabelTextComponent.text = this._myConfig.myRotationText;
    this.myRotationLabelCursorTargetComponent = this.myRotationLabelCursorTarget.pp_addComponent(CursorTarget);
    this.myRotationLabelCollisionComponent = this.myRotationLabelCursorTarget.pp_addComponent(CollisionComponent);
    this.myRotationLabelCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myRotationLabelCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myRotationLabelCollisionComponent.extents = this._myConfig.myComponentLabelCollisionExtents;
    this.myRotationTextComponents = [];
    this.myRotationCursorTargetComponents = [];
    this.myRotationCollisionComponents = [];
    this.myRotationIncreaseButtonBackgroundComponents = [];
    this.myRotationIncreaseButtonTextComponents = [];
    this.myRotationIncreaseButtonCursorTargetComponents = [];
    this.myRotationIncreaseButtonCollisionComponents = [];
    this.myRotationDecreaseButtonBackgroundComponents = [];
    this.myRotationDecreaseButtonTextComponents = [];
    this.myRotationDecreaseButtonCursorTargetComponents = [];
    this.myRotationDecreaseButtonCollisionComponents = [];
    for (let i = 0; i < 3; i++) {
      this.myRotationTextComponents[i] = this.myRotationTexts[i].pp_addComponent(TextComponent);
      this._setupTextComponent(this.myRotationTextComponents[i]);
      this.myRotationTextComponents[i].text = " ";
      this.myRotationCursorTargetComponents[i] = this.myRotationCursorTargets[i].pp_addComponent(CursorTarget);
      this.myRotationCollisionComponents[i] = this.myRotationCursorTargets[i].pp_addComponent(CollisionComponent);
      this.myRotationCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myRotationCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myRotationCollisionComponents[i].extents = this._myConfig.myValueCollisionExtents;
      this.myRotationIncreaseButtonBackgroundComponents[i] = this.myRotationIncreaseButtonBackgrounds[i].pp_addComponent(MeshComponent);
      this.myRotationIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myRotationIncreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myRotationIncreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myRotationIncreaseButtonTextComponents[i] = this.myRotationIncreaseButtonTexts[i].pp_addComponent(TextComponent);
      this._setupTextComponent(this.myRotationIncreaseButtonTextComponents[i]);
      this.myRotationIncreaseButtonTextComponents[i].text = this._myConfig.myIncreaseButtonText;
      this.myRotationIncreaseButtonCursorTargetComponents[i] = this.myRotationIncreaseButtonCursorTargets[i].pp_addComponent(CursorTarget);
      this.myRotationIncreaseButtonCollisionComponents[i] = this.myRotationIncreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent);
      this.myRotationIncreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myRotationIncreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myRotationIncreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
      this.myRotationDecreaseButtonBackgroundComponents[i] = this.myRotationDecreaseButtonBackgrounds[i].pp_addComponent(MeshComponent);
      this.myRotationDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myRotationDecreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myRotationDecreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myRotationDecreaseButtonTextComponents[i] = this.myRotationDecreaseButtonTexts[i].pp_addComponent(TextComponent);
      this._setupTextComponent(this.myRotationDecreaseButtonTextComponents[i]);
      this.myRotationDecreaseButtonTextComponents[i].text = this._myConfig.myDecreaseButtonText;
      this.myRotationDecreaseButtonCursorTargetComponents[i] = this.myRotationDecreaseButtonCursorTargets[i].pp_addComponent(CursorTarget);
      this.myRotationDecreaseButtonCollisionComponents[i] = this.myRotationDecreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent);
      this.myRotationDecreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myRotationDecreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myRotationDecreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
    }
    this.myScaleLabelTextComponent = this.myScaleLabelText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myScaleLabelTextComponent);
    this.myScaleLabelTextComponent.text = this._myConfig.myScaleText;
    this.myScaleLabelCursorTargetComponent = this.myScaleLabelCursorTarget.pp_addComponent(CursorTarget);
    this.myScaleLabelCollisionComponent = this.myScaleLabelCursorTarget.pp_addComponent(CollisionComponent);
    this.myScaleLabelCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myScaleLabelCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myScaleLabelCollisionComponent.extents = this._myConfig.myComponentLabelCollisionExtents;
    this.myScaleTextComponents = [];
    this.myScaleCursorTargetComponents = [];
    this.myScaleCollisionComponents = [];
    this.myScaleIncreaseButtonBackgroundComponents = [];
    this.myScaleIncreaseButtonTextComponents = [];
    this.myScaleIncreaseButtonCursorTargetComponents = [];
    this.myScaleIncreaseButtonCollisionComponents = [];
    this.myScaleDecreaseButtonBackgroundComponents = [];
    this.myScaleDecreaseButtonTextComponents = [];
    this.myScaleDecreaseButtonCursorTargetComponents = [];
    this.myScaleDecreaseButtonCollisionComponents = [];
    for (let i = 0; i < 3; i++) {
      this.myScaleTextComponents[i] = this.myScaleTexts[i].pp_addComponent(TextComponent);
      this._setupTextComponent(this.myScaleTextComponents[i]);
      this.myScaleTextComponents[i].text = " ";
      this.myScaleCursorTargetComponents[i] = this.myScaleCursorTargets[i].pp_addComponent(CursorTarget);
      this.myScaleCollisionComponents[i] = this.myScaleCursorTargets[i].pp_addComponent(CollisionComponent);
      this.myScaleCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myScaleCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myScaleCollisionComponents[i].extents = this._myConfig.myValueCollisionExtents;
      this.myScaleIncreaseButtonBackgroundComponents[i] = this.myScaleIncreaseButtonBackgrounds[i].pp_addComponent(MeshComponent);
      this.myScaleIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myScaleIncreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myScaleIncreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myScaleIncreaseButtonTextComponents[i] = this.myScaleIncreaseButtonTexts[i].pp_addComponent(TextComponent);
      this._setupTextComponent(this.myScaleIncreaseButtonTextComponents[i]);
      this.myScaleIncreaseButtonTextComponents[i].text = this._myConfig.myIncreaseButtonText;
      this.myScaleIncreaseButtonCursorTargetComponents[i] = this.myScaleIncreaseButtonCursorTargets[i].pp_addComponent(CursorTarget);
      this.myScaleIncreaseButtonCollisionComponents[i] = this.myScaleIncreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent);
      this.myScaleIncreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myScaleIncreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myScaleIncreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
      this.myScaleDecreaseButtonBackgroundComponents[i] = this.myScaleDecreaseButtonBackgrounds[i].pp_addComponent(MeshComponent);
      this.myScaleDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myScaleDecreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myScaleDecreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myScaleDecreaseButtonTextComponents[i] = this.myScaleDecreaseButtonTexts[i].pp_addComponent(TextComponent);
      this._setupTextComponent(this.myScaleDecreaseButtonTextComponents[i]);
      this.myScaleDecreaseButtonTextComponents[i].text = this._myConfig.myDecreaseButtonText;
      this.myScaleDecreaseButtonCursorTargetComponents[i] = this.myScaleDecreaseButtonCursorTargets[i].pp_addComponent(CursorTarget);
      this.myScaleDecreaseButtonCollisionComponents[i] = this.myScaleDecreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent);
      this.myScaleDecreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myScaleDecreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myScaleDecreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
    }
    this.myPositionStepTextComponent = this.myPositionStepText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myPositionStepTextComponent);
    this.myPositionStepTextComponent.text = " ";
    this.myPositionStepCursorTargetComponent = this.myPositionStepCursorTarget.pp_addComponent(CursorTarget);
    this.myPositionStepCollisionComponent = this.myPositionStepCursorTarget.pp_addComponent(CollisionComponent);
    this.myPositionStepCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPositionStepCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPositionStepCollisionComponent.extents = this._myConfig.myStepCollisionExtents;
    this.myPositionStepIncreaseButtonBackgroundComponent = this.myPositionStepIncreaseButtonBackground.pp_addComponent(MeshComponent);
    this.myPositionStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPositionStepIncreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myPositionStepIncreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myPositionStepIncreaseButtonTextComponent = this.myPositionStepIncreaseButtonText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myPositionStepIncreaseButtonTextComponent);
    this.myPositionStepIncreaseButtonTextComponent.text = this._myConfig.myIncreaseButtonText;
    this.myPositionStepIncreaseButtonCursorTargetComponent = this.myPositionStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget);
    this.myPositionStepIncreaseButtonCollisionComponent = this.myPositionStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent);
    this.myPositionStepIncreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPositionStepIncreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPositionStepIncreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myPositionStepDecreaseButtonBackgroundComponent = this.myPositionStepDecreaseButtonBackground.pp_addComponent(MeshComponent);
    this.myPositionStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPositionStepDecreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myPositionStepDecreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myPositionStepDecreaseButtonTextComponent = this.myPositionStepDecreaseButtonText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myPositionStepDecreaseButtonTextComponent);
    this.myPositionStepDecreaseButtonTextComponent.text = this._myConfig.myDecreaseButtonText;
    this.myPositionStepDecreaseButtonCursorTargetComponent = this.myPositionStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget);
    this.myPositionStepDecreaseButtonCollisionComponent = this.myPositionStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent);
    this.myPositionStepDecreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPositionStepDecreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPositionStepDecreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myRotationStepTextComponent = this.myRotationStepText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myRotationStepTextComponent);
    this.myRotationStepTextComponent.text = " ";
    this.myRotationStepCursorTargetComponent = this.myRotationStepCursorTarget.pp_addComponent(CursorTarget);
    this.myRotationStepCollisionComponent = this.myRotationStepCursorTarget.pp_addComponent(CollisionComponent);
    this.myRotationStepCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myRotationStepCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myRotationStepCollisionComponent.extents = this._myConfig.myStepCollisionExtents;
    this.myRotationStepIncreaseButtonBackgroundComponent = this.myRotationStepIncreaseButtonBackground.pp_addComponent(MeshComponent);
    this.myRotationStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myRotationStepIncreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myRotationStepIncreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myRotationStepIncreaseButtonTextComponent = this.myRotationStepIncreaseButtonText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myRotationStepIncreaseButtonTextComponent);
    this.myRotationStepIncreaseButtonTextComponent.text = this._myConfig.myIncreaseButtonText;
    this.myRotationStepIncreaseButtonCursorTargetComponent = this.myRotationStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget);
    this.myRotationStepIncreaseButtonCollisionComponent = this.myRotationStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent);
    this.myRotationStepIncreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myRotationStepIncreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myRotationStepIncreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myRotationStepDecreaseButtonBackgroundComponent = this.myRotationStepDecreaseButtonBackground.pp_addComponent(MeshComponent);
    this.myRotationStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myRotationStepDecreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myRotationStepDecreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myRotationStepDecreaseButtonTextComponent = this.myRotationStepDecreaseButtonText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myRotationStepDecreaseButtonTextComponent);
    this.myRotationStepDecreaseButtonTextComponent.text = this._myConfig.myDecreaseButtonText;
    this.myRotationStepDecreaseButtonCursorTargetComponent = this.myRotationStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget);
    this.myRotationStepDecreaseButtonCollisionComponent = this.myRotationStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent);
    this.myRotationStepDecreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myRotationStepDecreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myRotationStepDecreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myScaleStepTextComponent = this.myScaleStepText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myScaleStepTextComponent);
    this.myScaleStepTextComponent.text = " ";
    this.myScaleStepCursorTargetComponent = this.myScaleStepCursorTarget.pp_addComponent(CursorTarget);
    this.myScaleStepCollisionComponent = this.myScaleStepCursorTarget.pp_addComponent(CollisionComponent);
    this.myScaleStepCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myScaleStepCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myScaleStepCollisionComponent.extents = this._myConfig.myStepCollisionExtents;
    this.myScaleStepIncreaseButtonBackgroundComponent = this.myScaleStepIncreaseButtonBackground.pp_addComponent(MeshComponent);
    this.myScaleStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myScaleStepIncreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myScaleStepIncreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myScaleStepIncreaseButtonTextComponent = this.myScaleStepIncreaseButtonText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myScaleStepIncreaseButtonTextComponent);
    this.myScaleStepIncreaseButtonTextComponent.text = this._myConfig.myIncreaseButtonText;
    this.myScaleStepIncreaseButtonCursorTargetComponent = this.myScaleStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget);
    this.myScaleStepIncreaseButtonCollisionComponent = this.myScaleStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent);
    this.myScaleStepIncreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myScaleStepIncreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myScaleStepIncreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myScaleStepDecreaseButtonBackgroundComponent = this.myScaleStepDecreaseButtonBackground.pp_addComponent(MeshComponent);
    this.myScaleStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myScaleStepDecreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myScaleStepDecreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myScaleStepDecreaseButtonTextComponent = this.myScaleStepDecreaseButtonText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myScaleStepDecreaseButtonTextComponent);
    this.myScaleStepDecreaseButtonTextComponent.text = this._myConfig.myDecreaseButtonText;
    this.myScaleStepDecreaseButtonCursorTargetComponent = this.myScaleStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget);
    this.myScaleStepDecreaseButtonCollisionComponent = this.myScaleStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent);
    this.myScaleStepDecreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myScaleStepDecreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myScaleStepDecreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
  }
  _addStepComponents() {
    this.myPositionStepTextComponent = this.myPositionStepText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myPositionStepTextComponent);
    this.myPositionStepTextComponent.text = " ";
    this.myPositionStepCursorTargetComponent = this.myPositionStepCursorTarget.pp_addComponent(CursorTarget);
    this.myPositionStepCollisionComponent = this.myPositionStepCursorTarget.pp_addComponent(CollisionComponent);
    this.myPositionStepCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPositionStepCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPositionStepCollisionComponent.extents = this._myConfig.myStepCollisionExtents;
    this.myPositionStepIncreaseButtonBackgroundComponent = this.myPositionStepIncreaseButtonBackground.pp_addComponent(MeshComponent);
    this.myPositionStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPositionStepIncreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myPositionStepIncreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myPositionStepIncreaseButtonTextComponent = this.myPositionStepIncreaseButtonText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myPositionStepIncreaseButtonTextComponent);
    this.myPositionStepIncreaseButtonTextComponent.text = this._myConfig.myIncreaseButtonText;
    this.myPositionStepIncreaseButtonCursorTargetComponent = this.myPositionStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget);
    this.myPositionStepIncreaseButtonCollisionComponent = this.myPositionStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent);
    this.myPositionStepIncreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPositionStepIncreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPositionStepIncreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myPositionStepDecreaseButtonBackgroundComponent = this.myPositionStepDecreaseButtonBackground.pp_addComponent(MeshComponent);
    this.myPositionStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPositionStepDecreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myPositionStepDecreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myPositionStepDecreaseButtonTextComponent = this.myPositionStepDecreaseButtonText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myPositionStepDecreaseButtonTextComponent);
    this.myPositionStepDecreaseButtonTextComponent.text = this._myConfig.myDecreaseButtonText;
    this.myPositionStepDecreaseButtonCursorTargetComponent = this.myPositionStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget);
    this.myPositionStepDecreaseButtonCollisionComponent = this.myPositionStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent);
    this.myPositionStepDecreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPositionStepDecreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPositionStepDecreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myRotationStepTextComponent = this.myRotationStepText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myRotationStepTextComponent);
    this.myRotationStepTextComponent.text = " ";
    this.myRotationStepCursorTargetComponent = this.myRotationStepCursorTarget.pp_addComponent(CursorTarget);
    this.myRotationStepCollisionComponent = this.myRotationStepCursorTarget.pp_addComponent(CollisionComponent);
    this.myRotationStepCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myRotationStepCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myRotationStepCollisionComponent.extents = this._myConfig.myStepCollisionExtents;
    this.myRotationStepIncreaseButtonBackgroundComponent = this.myRotationStepIncreaseButtonBackground.pp_addComponent(MeshComponent);
    this.myRotationStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myRotationStepIncreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myRotationStepIncreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myRotationStepIncreaseButtonTextComponent = this.myRotationStepIncreaseButtonText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myRotationStepIncreaseButtonTextComponent);
    this.myRotationStepIncreaseButtonTextComponent.text = this._myConfig.myIncreaseButtonText;
    this.myRotationStepIncreaseButtonCursorTargetComponent = this.myRotationStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget);
    this.myRotationStepIncreaseButtonCollisionComponent = this.myRotationStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent);
    this.myRotationStepIncreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myRotationStepIncreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myRotationStepIncreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myRotationStepDecreaseButtonBackgroundComponent = this.myRotationStepDecreaseButtonBackground.pp_addComponent(MeshComponent);
    this.myRotationStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myRotationStepDecreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myRotationStepDecreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myRotationStepDecreaseButtonTextComponent = this.myRotationStepDecreaseButtonText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myRotationStepDecreaseButtonTextComponent);
    this.myRotationStepDecreaseButtonTextComponent.text = this._myConfig.myDecreaseButtonText;
    this.myRotationStepDecreaseButtonCursorTargetComponent = this.myRotationStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget);
    this.myRotationStepDecreaseButtonCollisionComponent = this.myRotationStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent);
    this.myRotationStepDecreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myRotationStepDecreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myRotationStepDecreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myScaleStepTextComponent = this.myScaleStepText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myScaleStepTextComponent);
    this.myScaleStepTextComponent.text = " ";
    this.myScaleStepCursorTargetComponent = this.myScaleStepCursorTarget.pp_addComponent(CursorTarget);
    this.myScaleStepCollisionComponent = this.myScaleStepCursorTarget.pp_addComponent(CollisionComponent);
    this.myScaleStepCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myScaleStepCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myScaleStepCollisionComponent.extents = this._myConfig.myStepCollisionExtents;
    this.myScaleStepIncreaseButtonBackgroundComponent = this.myScaleStepIncreaseButtonBackground.pp_addComponent(MeshComponent);
    this.myScaleStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myScaleStepIncreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myScaleStepIncreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myScaleStepIncreaseButtonTextComponent = this.myScaleStepIncreaseButtonText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myScaleStepIncreaseButtonTextComponent);
    this.myScaleStepIncreaseButtonTextComponent.text = this._myConfig.myIncreaseButtonText;
    this.myScaleStepIncreaseButtonCursorTargetComponent = this.myScaleStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget);
    this.myScaleStepIncreaseButtonCollisionComponent = this.myScaleStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent);
    this.myScaleStepIncreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myScaleStepIncreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myScaleStepIncreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myScaleStepDecreaseButtonBackgroundComponent = this.myScaleStepDecreaseButtonBackground.pp_addComponent(MeshComponent);
    this.myScaleStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myScaleStepDecreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myScaleStepDecreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myScaleStepDecreaseButtonTextComponent = this.myScaleStepDecreaseButtonText.pp_addComponent(TextComponent);
    this._setupTextComponent(this.myScaleStepDecreaseButtonTextComponent);
    this.myScaleStepDecreaseButtonTextComponent.text = this._myConfig.myDecreaseButtonText;
    this.myScaleStepDecreaseButtonCursorTargetComponent = this.myScaleStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget);
    this.myScaleStepDecreaseButtonCollisionComponent = this.myScaleStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent);
    this.myScaleStepDecreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myScaleStepDecreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myScaleStepDecreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/transform/easy_tune_transform_widget.js
var EasyTuneTransformWidget = class extends EasyTuneBaseWidget {
  constructor(params, gamepad, engine2 = Globals.getMainEngine()) {
    super(params);
    this._myGamepad = gamepad;
    this._myConfig = new EasyTuneTransformWidgetConfig();
    this._myUI = new EasyTuneTransformWidgetUI(engine2);
    this._myValueButtonEditIntensity = 0;
    this._myValueButtonEditIntensityTimer = 0;
    this._myStepButtonEditIntensity = 0;
    this._myStepButtonEditIntensityTimer = 0;
    this._myValueEditEnabled = false;
    this._myStepEditEnabled = false;
    this._myValueRealValue = 0;
    this._myComponentStepValue = 0;
    this._myStepMultiplierValue = 0;
    this._myStepFastEdit = false;
    this._myValueEditIndex = -1;
    this._myComponentIndex = 0;
    this._myStepIndex = 0;
    this._myTempTransformValue = mat4_create();
    this._myTempPositionValue = vec3_create();
    this._myTempRotationValue = vec3_create();
    this._myTempScaleValue = vec3_create();
  }
  _refreshUIHook() {
    for (let i = 0; i < 3; i++) {
      this._myUI.myPositionTextComponents[i].text = this._myVariable._myPosition[i].toFixed(this._myVariable._myDecimalPlaces);
    }
    this._myUI.myPositionStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myPositionStepPerSecond);
    for (let i = 0; i < 3; i++) {
      this._myUI.myRotationTextComponents[i].text = this._myVariable._myRotation[i].toFixed(this._myVariable._myDecimalPlaces);
    }
    this._myUI.myRotationStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myRotationStepPerSecond);
    for (let i = 0; i < 3; i++) {
      this._myUI.myScaleTextComponents[i].text = this._myVariable._myScale[i].toFixed(this._myVariable._myDecimalPlaces);
    }
    this._myUI.myScaleStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myScaleStepPerSecond);
  }
  _startHook(parentObject, easyTuneParams) {
    this._myUI.setAdditionalButtonsVisible(easyTuneParams.myShowAdditionalButtons);
  }
  _setEasyTuneVariableHook() {
    if (this._myVariable != null) {
      this._myTempPositionValue.pp_copy(this._myVariable._myPosition);
      this._myTempRotationValue.pp_copy(this._myVariable._myRotation);
      this._myTempScaleValue.pp_copy(this._myVariable._myScale);
    }
  }
  _updateHook(dt) {
    this._updateValue(dt);
  }
  _updateValue(dt) {
    let stickVariableIntensity = 0;
    if (this._myGamepad) {
      let y = this._myGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes[1];
      if (Math.abs(y) > this._myConfig.myEditThumbstickMinThreshold) {
        let normalizedEditAmount = (Math.abs(y) - this._myConfig.myEditThumbstickMinThreshold) / (1 - this._myConfig.myEditThumbstickMinThreshold);
        stickVariableIntensity = Math.sign(y) * normalizedEditAmount;
      }
    }
    let valueIntensity = 0;
    if (this._myValueEditEnabled) {
      valueIntensity = stickVariableIntensity;
    } else if (this._myValueButtonEditIntensity != 0) {
      if (this._myValueButtonEditIntensityTimer <= 0) {
        valueIntensity = this._myValueButtonEditIntensity;
      } else {
        this._myValueButtonEditIntensityTimer -= dt;
      }
    }
    if (this._myValueEditIndex >= 0 && this._myValueEditIndex < 3) {
      if (valueIntensity != 0) {
        this._myTempPositionValue.pp_copy(this._myVariable._myPosition);
        this._myTempRotationValue.pp_copy(this._myVariable._myRotation);
        this._myTempScaleValue.pp_copy(this._myVariable._myScale);
        let amountToAdd = valueIntensity * this._myComponentStepValue * dt;
        this._myValueRealValue += amountToAdd;
        let decimalPlacesMultiplier = Math.pow(10, this._myVariable._myDecimalPlaces);
        switch (this._myComponentIndex) {
          case 0:
            this._myTempPositionValue[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
            this._myUI.myPositionTextComponents[this._myValueEditIndex].text = this._myTempPositionValue[this._myValueEditIndex].toFixed(this._myVariable._myDecimalPlaces);
            break;
          case 1:
            if (this._myValueRealValue > 180) {
              while (this._myValueRealValue > 180) {
                this._myValueRealValue -= 180;
              }
              this._myValueRealValue = -180 + this._myValueRealValue;
            }
            if (this._myValueRealValue < -180) {
              while (this._myValueRealValue < -180) {
                this._myValueRealValue += 180;
              }
              this._myValueRealValue = 180 - this._myValueRealValue;
            }
            this._myTempRotationValue[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
            this._myUI.myRotationTextComponents[this._myValueEditIndex].text = this._myTempRotationValue[this._myValueEditIndex].toFixed(this._myVariable._myDecimalPlaces);
            break;
          case 2:
            if (this._myValueRealValue <= 0) {
              this._myValueRealValue = 1 / decimalPlacesMultiplier;
            }
            if (this._myVariable._myScaleAsOne) {
              let newValue = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
              let difference = newValue - this._myTempScaleValue[this._myValueEditIndex];
              for (let i = 0; i < 3; i++) {
                this._myTempScaleValue[i] = Math.round((this._myTempScaleValue[i] + difference) * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
                this._myTempScaleValue[i] = Math.max(this._myTempScaleValue[i], 1 / decimalPlacesMultiplier);
                this._myUI.myScaleTextComponents[i].text = this._myTempScaleValue[i].toFixed(this._myVariable._myDecimalPlaces);
              }
            } else {
              this._myTempScaleValue[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
              this._myTempScaleValue[this._myValueEditIndex] = Math.max(this._myTempScaleValue[this._myValueEditIndex], 1 / decimalPlacesMultiplier);
              this._myUI.myScaleTextComponents[this._myValueEditIndex].text = this._myTempScaleValue[this._myValueEditIndex].toFixed(this._myVariable._myDecimalPlaces);
            }
            break;
        }
        this._myTempTransformValue.mat4_setPositionRotationDegreesScale(this._myTempPositionValue, this._myTempRotationValue, this._myTempScaleValue);
        this._myVariable.setValue(this._myTempTransformValue);
      } else {
        switch (this._myComponentIndex) {
          case 0:
            this._myValueRealValue = this._myVariable._myPosition[this._myValueEditIndex];
            break;
          case 1:
            this._myValueRealValue = this._myVariable._myRotation[this._myValueEditIndex];
            break;
          case 2:
            this._myValueRealValue = this._myVariable._myScale[this._myValueEditIndex];
            break;
        }
      }
    }
    let stepIntensity = 0;
    if (this._myStepEditEnabled) {
      stepIntensity = stickVariableIntensity;
    } else if (this._myStepButtonEditIntensity != 0) {
      if (this._myStepButtonEditIntensityTimer <= 0) {
        stepIntensity = this._myStepButtonEditIntensity;
      } else {
        this._myStepButtonEditIntensityTimer -= dt;
      }
    }
    if (stepIntensity != 0) {
      let amountToAdd = 0;
      if (this._myStepFastEdit) {
        amountToAdd = Math.sign(stepIntensity) * 1;
        this._myStepFastEdit = false;
      } else {
        amountToAdd = stepIntensity * this._myConfig.myStepMultiplierStepPerSecond * dt;
      }
      this._myStepMultiplierValue += amountToAdd;
      if (Math.abs(this._myStepMultiplierValue) >= 1) {
        let stepValue = 0;
        switch (this._myStepIndex) {
          case 0:
            stepValue = this._myVariable._myPositionStepPerSecond;
            break;
          case 1:
            stepValue = this._myVariable._myRotationStepPerSecond;
            break;
          case 2:
            stepValue = this._myVariable._myScaleStepPerSecond;
            break;
          default:
            stepValue = 0;
        }
        if (Math.sign(this._myStepMultiplierValue) > 0) {
          this._myStepMultiplierValue -= 1;
          this._changeStep(this._myStepIndex, stepValue * 10);
        } else {
          this._myStepMultiplierValue += 1;
          this._changeStep(this._myStepIndex, stepValue * 0.1);
        }
      }
    } else {
      this._myStepMultiplierValue = 0;
      this._myStepFastEdit = true;
    }
  }
  _addListenersHook() {
    let ui = this._myUI;
    ui.myVariableLabelCursorTargetComponent.onClick.add(this._resetAllValues.bind(this));
    ui.myVariableLabelCursorTargetComponent.onHover.add(this._genericTextHover.bind(this, ui.myVariableLabelText));
    ui.myVariableLabelCursorTargetComponent.onUnhover.add(this._genericTextUnhover.bind(this, ui.myVariableLabelText, this._myConfig.myVariableLabelTextScale));
    ui.myPositionLabelCursorTargetComponent.onClick.add(this._resetComponentValues.bind(this, 0));
    ui.myPositionLabelCursorTargetComponent.onHover.add(this._genericTextHover.bind(this, ui.myPositionLabelText));
    ui.myPositionLabelCursorTargetComponent.onUnhover.add(this._genericTextUnhover.bind(this, ui.myPositionLabelText, this._myConfig.myComponentLabelTextScale));
    for (let i = 0; i < 3; i++) {
      ui.myPositionIncreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, 0, i, 1));
      ui.myPositionIncreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, 0, i, 1));
      ui.myPositionIncreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, 0, i, 0));
      ui.myPositionIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, 0, i, 0));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, 0, i, -1));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, 0, i, -1));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, 0, i, 0));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, 0, i, 0));
      ui.myPositionIncreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myPositionIncreaseButtonBackgroundComponents[i].material));
      ui.myPositionIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myPositionIncreaseButtonBackgroundComponents[i].material));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myPositionDecreaseButtonBackgroundComponents[i].material));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myPositionDecreaseButtonBackgroundComponents[i].material));
      ui.myPositionCursorTargetComponents[i].onClick.add(this._resetValue.bind(this, 0, i));
      ui.myPositionCursorTargetComponents[i].onHover.add(this._setValueEditEnabled.bind(this, 0, i, ui.myPositionTexts[i], true));
      ui.myPositionCursorTargetComponents[i].onUnhover.add(this._setValueEditEnabled.bind(this, 0, i, ui.myPositionTexts[i], false));
    }
    ui.myRotationLabelCursorTargetComponent.onClick.add(this._resetComponentValues.bind(this, 1));
    ui.myRotationLabelCursorTargetComponent.onHover.add(this._genericTextHover.bind(this, ui.myRotationLabelText));
    ui.myRotationLabelCursorTargetComponent.onUnhover.add(this._genericTextUnhover.bind(this, ui.myRotationLabelText, this._myConfig.myComponentLabelTextScale));
    for (let i = 0; i < 3; i++) {
      ui.myRotationIncreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, 1, i, 1));
      ui.myRotationIncreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, 1, i, 1));
      ui.myRotationIncreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, 1, i, 0));
      ui.myRotationIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, 1, i, 0));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, 1, i, -1));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, 1, i, -1));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, 1, i, 0));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, 1, i, 0));
      ui.myRotationIncreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myRotationIncreaseButtonBackgroundComponents[i].material));
      ui.myRotationIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myRotationIncreaseButtonBackgroundComponents[i].material));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myRotationDecreaseButtonBackgroundComponents[i].material));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myRotationDecreaseButtonBackgroundComponents[i].material));
      ui.myRotationCursorTargetComponents[i].onClick.add(this._resetValue.bind(this, 1, i));
      ui.myRotationCursorTargetComponents[i].onHover.add(this._setValueEditEnabled.bind(this, 1, i, ui.myRotationTexts[i], true));
      ui.myRotationCursorTargetComponents[i].onUnhover.add(this._setValueEditEnabled.bind(this, 1, i, ui.myRotationTexts[i], false));
    }
    ui.myScaleLabelCursorTargetComponent.onClick.add(this._resetComponentValues.bind(this, 2));
    ui.myScaleLabelCursorTargetComponent.onHover.add(this._genericTextHover.bind(this, ui.myScaleLabelText));
    ui.myScaleLabelCursorTargetComponent.onUnhover.add(this._genericTextUnhover.bind(this, ui.myScaleLabelText, this._myConfig.myComponentLabelTextScale));
    for (let i = 0; i < 3; i++) {
      ui.myScaleIncreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, 2, i, 1));
      ui.myScaleIncreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, 2, i, 1));
      ui.myScaleIncreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, 2, i, 0));
      ui.myScaleIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, 2, i, 0));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, 2, i, -1));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, 2, i, -1));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, 2, i, 0));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, 2, i, 0));
      ui.myScaleIncreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myScaleIncreaseButtonBackgroundComponents[i].material));
      ui.myScaleIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myScaleIncreaseButtonBackgroundComponents[i].material));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myScaleDecreaseButtonBackgroundComponents[i].material));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myScaleDecreaseButtonBackgroundComponents[i].material));
      ui.myScaleCursorTargetComponents[i].onClick.add(this._resetValue.bind(this, 2, i));
      ui.myScaleCursorTargetComponents[i].onHover.add(this._setValueEditEnabled.bind(this, 2, i, ui.myScaleTexts[i], true));
      ui.myScaleCursorTargetComponents[i].onUnhover.add(this._setValueEditEnabled.bind(this, 2, i, ui.myScaleTexts[i], false));
    }
    ui.myPositionStepCursorTargetComponent.onClick.add(this._resetStep.bind(this, 0));
    ui.myPositionStepCursorTargetComponent.onHover.add(this._setStepEditEnabled.bind(this, 0, ui.myPositionStepText, true));
    ui.myPositionStepCursorTargetComponent.onUnhover.add(this._setStepEditEnabled.bind(this, 0, ui.myPositionStepText, false));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, 0, 1));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, 0, 1));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 0, 0));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 0, 0));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, 0, -1));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, 0, -1));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 0, 0));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 0, 0));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myPositionStepIncreaseButtonBackgroundComponent.material));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myPositionStepIncreaseButtonBackgroundComponent.material));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myPositionStepDecreaseButtonBackgroundComponent.material));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myPositionStepDecreaseButtonBackgroundComponent.material));
    ui.myRotationStepCursorTargetComponent.onClick.add(this._resetStep.bind(this, 1));
    ui.myRotationStepCursorTargetComponent.onHover.add(this._setStepEditEnabled.bind(this, 1, ui.myRotationStepText, true));
    ui.myRotationStepCursorTargetComponent.onUnhover.add(this._setStepEditEnabled.bind(this, 1, ui.myRotationStepText, false));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, 1, 1));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, 1, 1));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 1, 0));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 1, 0));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, 1, -1));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, 1, -1));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 1, 0));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 1, 0));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myRotationStepIncreaseButtonBackgroundComponent.material));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myRotationStepIncreaseButtonBackgroundComponent.material));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myRotationStepDecreaseButtonBackgroundComponent.material));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myRotationStepDecreaseButtonBackgroundComponent.material));
    ui.myScaleStepCursorTargetComponent.onClick.add(this._resetStep.bind(this, 2));
    ui.myScaleStepCursorTargetComponent.onHover.add(this._setStepEditEnabled.bind(this, 2, ui.myScaleStepText, true));
    ui.myScaleStepCursorTargetComponent.onUnhover.add(this._setStepEditEnabled.bind(this, 2, ui.myScaleStepText, false));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, 2, 1));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, 2, 1));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 2, 0));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 2, 0));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, 2, -1));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, 2, -1));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 2, 0));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 2, 0));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myScaleStepIncreaseButtonBackgroundComponent.material));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myScaleStepIncreaseButtonBackgroundComponent.material));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myScaleStepDecreaseButtonBackgroundComponent.material));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myScaleStepDecreaseButtonBackgroundComponent.material));
  }
  _setValueEditIntensity(componentIndex, index, value) {
    if (this._isActive() || value == 0) {
      if (value != 0) {
        switch (componentIndex) {
          case 0:
            this._myValueRealValue = this._myVariable._myPosition[index];
            this._myComponentStepValue = this._myVariable._myPositionStepPerSecond;
            break;
          case 1:
            this._myValueRealValue = this._myVariable._myRotation[index];
            this._myComponentStepValue = this._myVariable._myRotationStepPerSecond;
            break;
          case 2:
            this._myValueRealValue = this._myVariable._myScale[index];
            this._myComponentStepValue = this._myVariable._myScaleStepPerSecond;
            break;
        }
        this._myValueButtonEditIntensityTimer = this._myConfig.myButtonEditDelay;
        this._myValueEditIndex = index;
        this._myComponentIndex = componentIndex;
      }
      this._myValueButtonEditIntensity = value;
    }
  }
  _setStepEditIntensity(index, value) {
    if (this._isActive() || value == 0) {
      if (value != 0) {
        this._myStepButtonEditIntensityTimer = this._myConfig.myButtonEditDelay;
      }
      this._myStepButtonEditIntensity = value;
      this._myStepIndex = index;
    }
  }
  _setValueEditEnabled(componentIndex, index, text, enabled) {
    if (this._isActive() || !enabled) {
      if (enabled) {
        switch (componentIndex) {
          case 0:
            this._myValueRealValue = this._myVariable._myPosition[index];
            this._myComponentStepValue = this._myVariable._myPositionStepPerSecond;
            break;
          case 1:
            this._myValueRealValue = this._myVariable._myRotation[index];
            this._myComponentStepValue = this._myVariable._myRotationStepPerSecond;
            break;
          case 2:
            this._myValueRealValue = this._myVariable._myScale[index];
            this._myComponentStepValue = this._myVariable._myScaleStepPerSecond;
            break;
        }
        this._myValueEditIndex = index;
        this._myComponentIndex = componentIndex;
        text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
      } else {
        text.pp_setScaleLocal(this._myConfig.myValueTextScale);
      }
      this._myValueEditEnabled = enabled;
    }
  }
  _setStepEditEnabled(index, text, enabled) {
    if (this._isActive() || !enabled) {
      if (enabled) {
        text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
      } else {
        text.pp_setScaleLocal(this._myConfig.myStepTextScale);
      }
      this._myStepEditEnabled = enabled;
      this._myStepIndex = index;
    }
  }
  _resetValue(componentIndex, index) {
    if (this._isActive()) {
      this._myTempPositionValue.pp_copy(this._myVariable._myPosition);
      this._myTempRotationValue.pp_copy(this._myVariable._myRotation);
      this._myTempScaleValue.pp_copy(this._myVariable._myScale);
      switch (componentIndex) {
        case 0:
          this._myTempPositionValue[index] = this._myVariable._myDefaultPosition[index];
          this._myUI.myPositionTextComponents[index].text = this._myTempPositionValue[index].toFixed(this._myVariable._myDecimalPlaces);
          break;
        case 1:
          this._myTempRotationValue[index] = this._myVariable._myDefaultRotation[index];
          this._myUI.myRotationTextComponents[index].text = this._myTempRotationValue[index].toFixed(this._myVariable._myDecimalPlaces);
          break;
        case 2:
          this._myTempScaleValue[index] = this._myVariable._myDefaultScale[index];
          this._myUI.myScaleTextComponents[index].text = this._myTempScaleValue[index].toFixed(this._myVariable._myDecimalPlaces);
          break;
      }
      this._myTempTransformValue.mat4_setPositionRotationDegreesScale(this._myTempPositionValue, this._myTempRotationValue, this._myTempScaleValue);
      this._myVariable.setValue(this._myTempTransformValue);
    }
  }
  _resetAllValues() {
    for (let i = 0; i < 3; i++) {
      this._resetComponentValues(i);
    }
  }
  _resetComponentValues(index) {
    for (let i = 0; i < 3; i++) {
      this._resetValue(index, i);
    }
  }
  _resetStep(index) {
    if (this._isActive()) {
      let defaultValue = 0;
      switch (index) {
        case 0:
          defaultValue = this._myVariable._myDefaultPositionStepPerSecond;
          break;
        case 1:
          defaultValue = this._myVariable._myDefaultRotationStepPerSecond;
          break;
        case 2:
          defaultValue = this._myVariable._myDefaultScaleStepPerSecond;
          break;
        default:
          defaultValue = 0;
      }
      this._changeStep(index, defaultValue);
    }
  }
  _changeStep(index, step) {
    step = Math.pp_roundDecimal(step, 10);
    switch (index) {
      case 0:
        this._myVariable._myPositionStepPerSecond = step;
        this._myUI.myPositionStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myPositionStepPerSecond);
        break;
      case 1:
        this._myVariable._myRotationStepPerSecond = step;
        this._myUI.myRotationStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myRotationStepPerSecond);
        break;
      case 2:
        this._myVariable._myScaleStepPerSecond = step;
        this._myUI.myScaleStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myScaleStepPerSecond);
        break;
    }
  }
  _genericTextHover(text) {
    text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
  }
  _genericTextUnhover(text, originalScale) {
    text.pp_setScaleLocal(originalScale);
  }
};

// js/pp/tool/easy_tune/easy_tune_widgets/easy_tune_widget.js
var EasyTuneWidgetParams = class extends WidgetParams {
  constructor() {
    super();
    this.myShowOnStart = false;
    this.myShowVisibilityButton = false;
    this.myShowAdditionalButtons = false;
    this.myGamepadScrollVariableEnabled = false;
    this.myShowVariablesImportExportButtons = false;
    this.myVariablesImportCallback = null;
    this.myVariablesExportCallback = null;
  }
};
var EasyTuneWidget = class {
  constructor(engine2 = Globals.getMainEngine()) {
    this._myStarted = false;
    this._myStartVariable = null;
    this._myWidgetFrame = new WidgetFrame("E", 1, engine2);
    this._myWidgetFrame.registerWidgetVisibleChangedEventListener(this, this._widgetVisibleChanged.bind(this));
    this._myConfig = new EasyTuneWidgetConfig();
    this._myParams = null;
    this._myWidgets = [];
    this._myEasyTuneVariables = null;
    this._myEasyTuneLastSize = 0;
    this._myVariableNames = null;
    this._myCurrentWidget = null;
    this._myCurrentVariable = null;
    this._myScrollVariableTimer = 0;
    this._myGamepad = null;
    this._myRefreshVariablesTimer = 0;
    this._myDirty = false;
    this._myEngine = engine2;
    this._myDestroyed = false;
  }
  setCurrentVariable(variableName) {
    if (!this._myStarted) {
      this._myStartVariable = variableName;
    } else if (this._myEasyTuneVariables.has(variableName)) {
      this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(variableName);
      this._selectCurrentWidget();
    } else {
      console.warn("Can't change easy tune current variable to inexistent variable:", variableName);
    }
  }
  refresh() {
    if (this._myWidgetFrame.isVisible()) {
      this._myDirty = true;
    }
  }
  setVisible(visible) {
    this._myWidgetFrame.setVisible(visible);
  }
  isVisible() {
    return this._myWidgetFrame.isVisible();
  }
  start(parentObject, params, easyTuneVariables) {
    this._myRightGamepad = Globals.getRightGamepad(this._myEngine);
    this._myLeftGamepad = Globals.getLeftGamepad(this._myEngine);
    if (this._myConfig.myGamepadHandedness == ToolHandedness.RIGHT) {
      this._myGamepad = this._myRightGamepad;
    } else if (this._myConfig.myGamepadHandedness == ToolHandedness.LEFT) {
      this._myGamepad = this._myLeftGamepad;
    }
    this._myStarted = true;
    this._myParams = params;
    this._myWidgetFrame.start(parentObject, params);
    this._myEasyTuneVariables = easyTuneVariables;
    this._myEasyTuneLastSize = this.getValidEasyTuneVariablesLength();
    this._myVariableNames = this.getValidEasyTuneVariablesNames();
    if (this.getValidEasyTuneVariablesLength() > 0) {
      this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myVariableNames[0]);
    }
    if (this._myStartVariable != null) {
      if (this._myEasyTuneVariables.has(this._myStartVariable)) {
        this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myStartVariable);
      } else {
        console.warn("Can't change easy tune current variable to inexistent variable:", this._myStartVariable);
      }
    }
    this._initializeWidgets();
  }
  update(dt) {
    this._myWidgetFrame.update(dt);
    if (this.getValidEasyTuneVariablesLength() != this._myEasyTuneLastSize || this._myDirty) {
      this._refreshEasyTuneVariables();
    }
    if (this._myWidgetFrame.isVisible() && this.getValidEasyTuneVariablesLength() > 0) {
      if (this._myConfig.myRefreshVariablesDelay != null) {
        this._myRefreshVariablesTimer += dt;
        if (this._myRefreshVariablesTimer > this._myConfig.myRefreshVariablesDelay) {
          this._myRefreshVariablesTimer = 0;
          this._refreshEasyTuneVariables();
        }
      }
      if (this._myCurrentWidget) {
        this._myCurrentWidget.update(dt);
      }
      if (this._myParams.myGamepadScrollVariableEnabled) {
        this._updateGamepadScrollVariable(dt);
      }
    }
    this._updateGamepadWidgetVisibility();
    this._updateWidgetCurrentVariable();
  }
  _initializeWidgets() {
    let widgetParams = new EasyTuneBaseWidgetParams();
    widgetParams.myVariablesImportCallback = this._importVariables.bind(this);
    widgetParams.myVariablesExportCallback = this._exportVariables.bind(this);
    this._myWidgets[EasyTuneVariableType.NONE] = new EasyTuneNoneWidget(widgetParams, this._myEngine);
    this._myWidgets[EasyTuneVariableType.NUMBER] = new EasyTuneNumberArrayWidgetSelector(widgetParams, this._myGamepad, this._myEngine);
    this._myWidgets[EasyTuneVariableType.BOOL] = new EasyTuneBoolArrayWidgetSelector(widgetParams, this._myGamepad, this._myEngine);
    this._myWidgets[EasyTuneVariableType.TRANSFORM] = new EasyTuneTransformWidget(widgetParams, this._myGamepad, this._myEngine);
    for (let widget of this._myWidgets) {
      if (widget != null) {
        widget.start(this._myWidgetFrame.getWidgetObject(), this._myParams);
        widget.setVisible(false);
        widget.registerScrollVariableRequestEventListener(this, this._scrollVariable.bind(this));
      }
    }
    this._selectCurrentWidget();
  }
  _selectCurrentWidget() {
    if (this.getValidEasyTuneVariablesLength() <= 0) {
      return;
    } else if (this._myCurrentVariable == null) {
      this._myVariableNames = this.getValidEasyTuneVariablesNames();
      this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myVariableNames[0]);
    }
    let prevWidget = null;
    if (this._myCurrentWidget != null) {
      prevWidget = this._myCurrentWidget.getWidget();
    }
    if (this._myCurrentVariable.getType() in this._myWidgets) {
      this._myCurrentWidget = this._myWidgets[this._myCurrentVariable.getType()];
    } else {
      this._myCurrentWidget = this._myWidgets[EasyTuneVariableType.NONE];
    }
    this._myCurrentWidget.setEasyTuneVariable(this._myCurrentVariable, this._createIndexString());
    this._myCurrentWidget.getWidget().syncWidget(prevWidget);
    if (prevWidget != null) {
      prevWidget.setVisible(false);
    }
    this._myCurrentWidget.setVisible(this._myWidgetFrame.isVisible());
  }
  _refreshEasyTuneVariables() {
    this._myVariableNames = this.getValidEasyTuneVariablesNames();
    this._myEasyTuneLastSize = this.getValidEasyTuneVariablesLength();
    if (this.getValidEasyTuneVariablesLength() > 0) {
      if (this._myCurrentVariable && this._myVariableNames.pp_hasEqual(this._myCurrentVariable.getName())) {
        this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myCurrentVariable.getName());
      } else {
        this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myVariableNames[0]);
      }
      this._selectCurrentWidget();
    } else {
      this._myCurrentVariable = null;
      if (this._myCurrentWidget) {
        this._myCurrentWidget.setVisible(false);
        this._myCurrentWidget = null;
      }
    }
    this._myDirty = false;
  }
  _updateGamepadWidgetVisibility() {
    if (this._myGamepad) {
      if (this._myGamepad.getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).isPressStart() && this._myGamepad.getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed() || this._myGamepad.getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && this._myGamepad.getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).isPressed()) {
        this._toggleVisibility();
      }
    }
  }
  _toggleVisibility() {
    this._myWidgetFrame.toggleVisibility();
  }
  _widgetVisibleChanged(visible) {
    for (let widget of this._myWidgets) {
      if (widget != null) {
        widget.setVisible(false);
      }
    }
    if (this._myCurrentWidget) {
      if (this.getValidEasyTuneVariablesLength() > 0) {
        this._myCurrentWidget.setVisible(visible);
      } else {
        this._myCurrentWidget.setVisible(false);
      }
    }
    if (visible) {
      this._refreshEasyTuneVariables();
    }
  }
  _updateGamepadScrollVariable(dt) {
    if (this._myGamepad && (!this._myConfig.myScrollVariableButtonID || this._myGamepad.getButtonInfo(this._myConfig.myScrollVariableButtonID).isPressed())) {
      let x = this._myGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes[0];
      let y = this._myGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes[1];
      if (Math.abs(x) > this._myConfig.myScrollVariableMinXThreshold && Math.abs(y) < this._myConfig.myScrollVariableMaxYThreshold) {
        this._myScrollVariableTimer += dt;
        while (this._myScrollVariableTimer > this._myConfig.myScrollVariableDelay) {
          this._myScrollVariableTimer -= this._myConfig.myScrollVariableDelay;
          this._scrollVariable(Math.sign(x));
        }
      } else {
        this._myScrollVariableTimer = this._myConfig.myScrollVariableDelay;
      }
    } else {
      this._myScrollVariableTimer = this._myConfig.myScrollVariableDelay;
    }
  }
  _scrollVariable(amount) {
    if (this.getValidEasyTuneVariablesLength() <= 0) {
      return;
    }
    let variableIndex = this._getVariableIndex(this._myCurrentVariable);
    if (variableIndex >= 0) {
      let newIndex = ((variableIndex + amount) % this._myVariableNames.length + this._myVariableNames.length) % this._myVariableNames.length;
      if (this._myEasyTuneVariables.has(this._myVariableNames[newIndex])) {
        this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myVariableNames[newIndex]);
        this._selectCurrentWidget();
      } else {
        this._refreshEasyTuneVariables();
      }
    } else {
      this._refreshEasyTuneVariables();
    }
  }
  _createIndexString() {
    let indexString = " (";
    let index = (this._getVariableIndex(this._myCurrentVariable) + 1).toString();
    let length10 = this.getValidEasyTuneVariablesLength().toString();
    while (index.length < length10.length) {
      index = "0".concat(index);
    }
    indexString = indexString.concat(index).concat(" - ").concat(length10).concat(")");
    return indexString;
  }
  _getVariableIndex(variable) {
    let variableIndex = this._myVariableNames.indexOf(variable.getName());
    return variableIndex;
  }
  _updateWidgetCurrentVariable() {
    for (let variable of this._myEasyTuneVariables.getEasyTuneVariablesList()) {
      variable.setWidgetCurrentVariable(false);
    }
    if (this._myWidgetFrame.isVisible() && this._myCurrentVariable) {
      this._myCurrentVariable.setWidgetCurrentVariable(true);
    }
  }
  _importVariables() {
    this._myParams.myVariablesImportCallback(this._onImportSuccess.bind(this), this._onImportFailure.bind(this));
  }
  _exportVariables() {
    this._myParams.myVariablesExportCallback(this._onExportSuccess.bind(this), this._onExportFailure.bind(this));
  }
  _onImportSuccess() {
    if (this._myCurrentWidget) {
      this._myCurrentWidget.onImportSuccess();
    }
  }
  _onImportFailure() {
    if (this._myCurrentWidget) {
      this._myCurrentWidget.onImportFailure();
    }
  }
  _onExportSuccess() {
    if (this._myCurrentWidget) {
      this._myCurrentWidget.onExportSuccess();
    }
  }
  _onExportFailure() {
    if (this._myCurrentWidget) {
      this._myCurrentWidget.onExportFailure();
    }
  }
  destroy() {
    this._myDestroyed = true;
    for (let widget of this._myWidgets) {
      widget.destroy();
    }
    this._myWidgetFrame.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
  getValidEasyTuneVariablesLength() {
    return this.getValidEasyTuneVariablesNames().length;
  }
  getValidEasyTuneVariablesNames() {
    let names = this._myEasyTuneVariables.getEasyTuneVariablesNames();
    let validNames = [];
    for (let name of names) {
      let variable = this._myEasyTuneVariables.getEasyTuneVariable(name);
      if (variable.shouldShowOnWidget()) {
        validNames.push(name);
      }
    }
    return validNames;
  }
};

// js/pp/tool/easy_tune/components/easy_tune_tool_component.js
var EasyTuneToolComponent = class extends Component {
  init() {
    this.object.pp_addComponent(InitEasyTuneVariablesComponent);
    this._myWidget = new EasyTuneWidget(this.engine);
    EasyTuneUtils.addSetWidgetCurrentVariableCallback(this, function(variableName) {
      this._myWidget.setCurrentVariable(variableName);
    }.bind(this), this.engine);
    EasyTuneUtils.addRefreshWidgetCallback(this, function() {
      this._myWidget.refresh();
    }.bind(this), this.engine);
    this._myStarted = false;
  }
  start() {
    if (Globals.isToolEnabled(this.engine)) {
      let params = new EasyTuneWidgetParams();
      params.myHandedness = [null, "left", "right"][this._myHandedness];
      params.myShowOnStart = this._myShowOnStart;
      params.myShowVisibilityButton = this._myShowVisibilityButton;
      params.myShowAdditionalButtons = true;
      params.myGamepadScrollVariableEnabled = this._myGamepadScrollVariableEnabled;
      params.myPlaneMaterial = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
      params.myTextMaterial = Globals.getDefaultMaterials(this.engine).myText.clone();
      params.myShowVariablesImportExportButtons = this._myShowVariablesImportExportButtons;
      params.myVariablesImportCallback = function(onSuccessCallback, onFailureCallback) {
        EasyTuneUtils.importVariables(this._myVariablesImportURL, this._myResetVariablesDefaultValueOnImport, onSuccessCallback, onFailureCallback, this.engine);
      }.bind(this);
      params.myVariablesExportCallback = function(onSuccessCallback, onFailureCallback) {
        EasyTuneUtils.exportVariables(this._myVariablesExportURL, onSuccessCallback, onFailureCallback, this.engine);
      }.bind(this);
      this._myWidget.start(this.object, params, Globals.getEasyTuneVariables(this.engine));
      this._myWidgetVisibleBackup = null;
      this._myStarted = true;
      this._myFirstUpdate = true;
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myStarted) {
        if (this._myFirstUpdate) {
          this._myFirstUpdate = false;
          if (this._myImportVariablesOnStart) {
            EasyTuneUtils.importVariables(this._myVariablesImportURL, this._myResetVariablesDefaultValueOnImport, void 0, void 0, this.engine);
          }
        }
        if (this._myWidgetVisibleBackup != null) {
          this._myWidget.setVisible(false);
          this._myWidget.setVisible(this._myWidgetVisibleBackup);
          this._myWidgetVisibleBackup = null;
        }
        this._myWidget.update(dt);
      }
    } else if (this._myStarted) {
      if (this._myWidgetVisibleBackup == null) {
        this._myWidgetVisibleBackup = this._myWidget.isVisible();
      }
      if (this._myWidget.isVisible()) {
        this._myWidget.setVisible(false);
      }
    }
  }
  onDeactivate() {
    if (this._myStarted) {
      if (this._myWidgetVisibleBackup == null) {
        this._myWidgetVisibleBackup = this._myWidget.isVisible();
      }
      if (this._myWidget.isVisible()) {
        this._myWidget.setVisible(false);
      }
    }
  }
  onDestroy() {
    this._myWidget.destroy();
    EasyTuneUtils.removeSetWidgetCurrentVariableCallback(this, this.engine);
    EasyTuneUtils.removeRefreshWidgetCallback(this, this.engine);
  }
};
__publicField(EasyTuneToolComponent, "TypeName", "pp-easy-tune-tool");
__publicField(EasyTuneToolComponent, "Properties", {
  _myHandedness: Property.enum(["None", "Left", "Right"], "None"),
  _myShowOnStart: Property.bool(false),
  _myShowVisibilityButton: Property.bool(false),
  _myGamepadScrollVariableEnabled: Property.bool(true),
  _myShowVariablesImportExportButtons: Property.bool(false),
  _myVariablesImportURL: Property.string(""),
  // The URL can contain parameters inside brackets, like {param}
  _myVariablesExportURL: Property.string(""),
  // Those parameters will be replaced with the same one on the current page url, like www.currentpage.com/?param=2
  _myImportVariablesOnStart: Property.bool(false),
  _myResetVariablesDefaultValueOnImport: Property.bool(false)
});

// js/pp/tool/easy_tune/components/easy_tune_import_variables_component.js
var EasyTuneImportVariablesComponent = class extends Component {
  start() {
    this._myFirstUpdate = true;
  }
  update(dt) {
    if (this._myFirstUpdate) {
      this._myFirstUpdate = false;
      EasyTuneUtils.importVariables(this._myVariablesImportURL, this._myResetVariablesDefaultValueOnImport, void 0, void 0, this.engine);
    }
  }
};
__publicField(EasyTuneImportVariablesComponent, "TypeName", "pp-easy-tune-import-variables");
__publicField(EasyTuneImportVariablesComponent, "Properties", {
  _myVariablesImportURL: Property.string(""),
  _myResetVariablesDefaultValueOnImport: Property.bool(true)
});

// js/pp/tool/easy_tune/easy_object_tuners/easy_object_tuner.js
var EasyObjectTuner = class {
  constructor(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine2 = Globals.getMainEngine()) {
    this._myObject = object;
    this._myUseTuneTarget = useTuneTarget;
    this._mySetAsWidgetCurrentVariable = setAsWidgetCurrentVariable;
    this._myEasyObject = this._myObject;
    if (this._myUseTuneTarget) {
      this._myEasyObject = Globals.getEasyTuneTarget(engine2);
    }
    this._myPrevEasyObject = null;
    let variableNamePrefix = this._getVariableNamePrefix();
    if (variableName == "") {
      let objectName = this._myObject.pp_getName();
      if (objectName != "") {
        this._myEasyTuneVariableName = variableNamePrefix.concat(objectName);
      } else {
        this._myEasyTuneVariableName = variableNamePrefix.concat(this._myObject.pp_getID());
      }
    } else {
      this._myEasyTuneVariableName = variableNamePrefix.concat(variableName);
    }
    this._myEngine = engine2;
  }
  start() {
    let easyTuneVariable = this._createEasyTuneVariable(this._myEasyTuneVariableName);
    Globals.getEasyTuneVariables(this._myEngine).add(easyTuneVariable);
    if (this._mySetAsWidgetCurrentVariable) {
      EasyTuneUtils.setWidgetCurrentVariable(this._myEasyTuneVariableName, this._myEngine);
    }
  }
  update(dt) {
    if (Globals.getEasyTuneVariables(this._myEngine).isWidgetCurrentVariable(this._myEasyTuneVariableName)) {
      if (this._myUseTuneTarget) {
        this._myEasyObject = Globals.getEasyTuneTarget(this._myEngine);
      }
      if (this._myPrevEasyObject != this._myEasyObject) {
        this._myPrevEasyObject = this._myEasyObject;
        if (this._myEasyObject) {
          let value = this._getObjectValue(this._myEasyObject);
          Globals.getEasyTuneVariables(this._myEngine).set(this._myEasyTuneVariableName, value, true);
        } else {
          let value = this._getDefaultValue();
          Globals.getEasyTuneVariables(this._myEngine).set(this._myEasyTuneVariableName, value, true);
        }
      }
      if (this._myEasyObject) {
        this._updateObjectValue(this._myEasyObject, Globals.getEasyTuneVariables(this._myEngine).get(this._myEasyTuneVariableName));
      }
    }
  }
};

// js/pp/tool/easy_tune/easy_object_tuners/easy_light_attenuation.js
var EasyLightAttenuation = class extends EasyObjectTuner {
  constructor(object, variableName, setAsWidgetCurrentVariable, useTuneTarget) {
    super(object, variableName, setAsWidgetCurrentVariable, useTuneTarget);
  }
  _getVariableNamePrefix() {
    let nameFirstPart = "Light Attenuation ";
    return nameFirstPart;
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneNumber(variableName, this._getDefaultValue(), null, true, 3, 0.01, 0, 1);
  }
  _getObjectValue(object) {
    let attenuation = this._getLightAttenuation(object);
    return attenuation;
  }
  _getDefaultValue() {
    return 0;
  }
  _updateObjectValue(object, value) {
    let attenuation = value;
    let light = object.pp_getComponent(LightComponent);
    if (light) {
      light.color[3] = attenuation;
    }
  }
  _getLightAttenuation(object) {
    let attenuation = this._getDefaultValue();
    let light = object.pp_getComponent(LightComponent);
    if (light) {
      attenuation = light.color[3];
    }
    return attenuation;
  }
};

// js/pp/tool/easy_tune/easy_object_tuners/easy_light_color.js
var EasyLightColor = class extends EasyObjectTuner {
  constructor(colorModel, object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine2) {
    super(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine2);
    this._myColorModel = colorModel;
  }
  _getVariableNamePrefix() {
    let nameFirstPart = null;
    if (this._myColorModel == 0) {
      nameFirstPart = "Light RGB ";
    } else {
      nameFirstPart = "Light HSV ";
    }
    return nameFirstPart;
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneIntArray(variableName, this._getDefaultValue(), null, true, 100, 0, 255);
  }
  _getObjectValue(object) {
    let color = null;
    let lightColor = this._getLightColor(object);
    if (lightColor) {
      if (this._myColorModel == 0) {
        color = ColorUtils.rgbCodeToHuman(lightColor);
      } else {
        color = ColorUtils.hsvCodeToHuman(ColorUtils.rgbToHSV(lightColor));
      }
    } else {
      color = this._getDefaultValue();
    }
    return color;
  }
  _getDefaultValue() {
    return vec3_create();
  }
  _updateObjectValue(object, value) {
    let color = value;
    if (this._myColorModel == 0) {
      color = ColorUtils.rgbHumanToCode(color);
    } else {
      color = ColorUtils.hsvToRGB(ColorUtils.hsvHumanToCode(color));
    }
    let light = object.pp_getComponent(LightComponent);
    if (light != null) {
      light.color[0] = color[0];
      light.color[1] = color[1];
      light.color[2] = color[2];
    }
    if (Globals.getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && Globals.getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed() || Globals.getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && Globals.getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed()) {
      let hsvColor = ColorUtils.color1To255(ColorUtils.rgbToHSV(color));
      let rgbColor = ColorUtils.color1To255(color);
      console.log("RGB:", rgbColor.vec_toString(0), "- HSV:", hsvColor.vec_toString(0));
    }
  }
  _getLightColor(object) {
    let color = null;
    let light = object.pp_getComponent(LightComponent);
    if (light) {
      color = light.color.slice(0, 3);
    }
    return color;
  }
};

// js/pp/tool/easy_tune/easy_object_tuners/easy_mesh_color.js
var EasyMeshColor = class extends EasyObjectTuner {
  constructor(colorModel, colorType, object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine2) {
    super(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine2);
    this._myColorModel = colorModel;
    this._myColorType = colorType;
    this._myColorVariableNames = ["color", "diffuseColor", "ambientColor", "specularColor", "emissiveColor", "fogColor", "ambientFactor"];
  }
  _getVariableNamePrefix() {
    let nameFirstPart = null;
    if (this._myColorModel == 0) {
      nameFirstPart = "Mesh RGB ";
    } else {
      nameFirstPart = "Mesh HSV ";
    }
    return nameFirstPart;
  }
  _createEasyTuneVariable(variableName) {
    if (this._myColorType == 6) {
      return new EasyTuneNumberArray(variableName, this._getDefaultValue(), null, true, 3, 0.1, 0, 1);
    }
    return new EasyTuneIntArray(variableName, this._getDefaultValue(), null, true, 100, 0, 255);
  }
  _getObjectValue(object) {
    let color = null;
    let meshMaterial = this._getMeshMaterial(object);
    if (meshMaterial) {
      if (this._myColorType != 6) {
        color = meshMaterial[this._myColorVariableNames[this._myColorType]].pp_clone();
        if (this._myColorModel == 0) {
          color = ColorUtils.rgbCodeToHuman(color);
        } else {
          color = ColorUtils.hsvCodeToHuman(ColorUtils.rgbToHSV(color));
        }
      } else {
        color = [meshMaterial[this._myColorVariableNames[this._myColorType]]];
      }
    } else {
      color = this._getDefaultValue();
    }
    return color;
  }
  _getDefaultValue() {
    if (this._myColorType == 6) {
      return [0];
    }
    return vec4_create();
  }
  _updateObjectValue(object, value) {
    let color = value;
    if (this._myColorType != 6) {
      if (this._myColorModel == 0) {
        color = ColorUtils.rgbHumanToCode(color);
      } else {
        color = ColorUtils.hsvToRGB(ColorUtils.hsvHumanToCode(color));
      }
    }
    let meshMaterial = this._getMeshMaterial(object);
    if (meshMaterial) {
      meshMaterial[this._myColorVariableNames[this._myColorType]] = color;
    }
    if (this._myColorType != 6) {
      if (Globals.getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && Globals.getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed() || Globals.getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && Globals.getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed()) {
        let hsvColor = ColorUtils.color1To255(ColorUtils.rgbToHSV(color));
        let rgbColor = ColorUtils.color1To255(color);
        console.log("RGB:", rgbColor.vec_toString(0), "- HSV:", hsvColor.vec_toString(0));
      }
    }
  }
  _getMeshMaterial(object) {
    let material = null;
    let mesh = object.pp_getComponent(MeshComponent);
    if (mesh) {
      material = mesh.material;
    }
    return material;
  }
};

// js/pp/tool/easy_tune/easy_object_tuners/easy_scale.js
var EasyScale = class extends EasyObjectTuner {
  constructor(local, scaleAsOne, object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine2) {
    super(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine2);
    this._myLocal = local;
    this._myScaleAsOne = scaleAsOne;
  }
  _getVariableNamePrefix() {
    return "Scale ";
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneNumberArray(variableName, this._getDefaultValue(), null, true, 3, 1, 1e-3, null, this._myScaleAsOne);
  }
  _getObjectValue(object) {
    return this._myLocal ? object.pp_getScaleLocal() : object.pp_getScale();
  }
  _getDefaultValue() {
    return vec3_create(1, 1, 1);
  }
  _updateObjectValue(object, value) {
    if (this._myLocal) {
      object.pp_setScaleLocal(value);
    } else {
      object.pp_setScale(value);
    }
  }
};

// js/pp/tool/easy_tune/easy_object_tuners/easy_transform.js
var EasyTransform = class extends EasyObjectTuner {
  constructor(local, scaleAsOne, object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine2) {
    super(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine2);
    this._myLocal = local;
    this._myScaleAsOne = scaleAsOne;
  }
  _getVariableNamePrefix() {
    return "Transform ";
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneTransform(variableName, this._getDefaultValue(), null, true, this._myScaleAsOne, 3);
  }
  _getObjectValue(object) {
    return this._myLocal ? object.pp_getTransformLocal() : object.pp_getTransform();
  }
  _getDefaultValue() {
    return mat4_create();
  }
  _updateObjectValue(object, value) {
    if (this._myLocal) {
      object.pp_setTransformLocal(value);
    } else {
      object.pp_setTransform(value);
    }
  }
};

// js/pp/tool/easy_tune/easy_object_tuners/easy_mesh_ambient_factor.js
var EasyMeshAmbientFactor = class extends EasyObjectTuner {
  constructor(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine2) {
    super(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine2);
  }
  _getVariableNamePrefix() {
    let nameFirstPart = null;
    if (this._myColorModel == 0) {
      nameFirstPart = "Mesh AF ";
    } else {
      nameFirstPart = "Mesh AF ";
    }
    return nameFirstPart;
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneNumber(variableName, this._getDefaultValue(), null, true, 3, 0.1, 0, 1);
  }
  _getObjectValue(object) {
    let ambientFactor = null;
    let meshMaterial = this._getMeshMaterial(object);
    if (meshMaterial) {
      ambientFactor = meshMaterial.ambientFactor;
    } else {
      ambientFactor = this._getDefaultValue();
    }
    return ambientFactor;
  }
  _getDefaultValue() {
    return 0;
  }
  _updateObjectValue(object, value) {
    let ambientFactor = value;
    let meshMaterial = this._getMeshMaterial(object);
    if (meshMaterial) {
      meshMaterial.ambientFactor = ambientFactor;
    }
  }
  _getMeshMaterial(object) {
    let material = null;
    let mesh = object.pp_getComponent(MeshComponent);
    if (mesh) {
      material = mesh.material;
    }
    return material;
  }
};

// js/pp/tool/easy_tune/easy_object_tuners/easy_text_color.js
var EasyTextColor = class extends EasyObjectTuner {
  constructor(colorModel, colorType, object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine2) {
    super(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine2);
    this._myColorModel = colorModel;
    this._myColorType = colorType;
    this._myColorVariableNames = ["color", "effectColor"];
  }
  _getVariableNamePrefix() {
    let nameFirstPart = null;
    if (this._myColorModel == 0) {
      nameFirstPart = "Text RGB ";
    } else {
      nameFirstPart = "Text HSV ";
    }
    return nameFirstPart;
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneIntArray(variableName, this._getDefaultValue(), null, true, 100, 0, 255);
  }
  _getObjectValue(object) {
    let color = null;
    let textMaterial = this._getTextMaterial(object);
    if (textMaterial) {
      color = textMaterial[this._myColorVariableNames[this._myColorType]].pp_clone();
      if (this._myColorModel == 0) {
        color = ColorUtils.rgbCodeToHuman(color);
      } else {
        color = ColorUtils.hsvCodeToHuman(ColorUtils.rgbToHSV(color));
      }
    } else {
      color = this._getDefaultValue();
    }
    return color;
  }
  _getDefaultValue() {
    return vec4_create();
  }
  _updateObjectValue(object, value) {
    let color = value;
    if (this._myColorModel == 0) {
      color = ColorUtils.rgbHumanToCode(color);
    } else {
      color = ColorUtils.hsvToRGB(ColorUtils.hsvHumanToCode(color));
    }
    let textMaterial = this._getTextMaterial(object);
    if (textMaterial) {
      textMaterial[this._myColorVariableNames[this._myColorType]] = color;
    }
    if (Globals.getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && Globals.getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed() || Globals.getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && Globals.getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed()) {
      let hsvColor = ColorUtils.color1To255(ColorUtils.rgbToHSV(color));
      let rgbColor = ColorUtils.color1To255(color);
      console.log("RGB:", rgbColor.vec_toString(0), "- HSV:", hsvColor.vec_toString(0));
    }
  }
  _getTextMaterial(object) {
    let material = null;
    let text = object.pp_getComponent(TextComponent);
    if (text) {
      material = text.material;
    }
    return material;
  }
};

// js/pp/tool/easy_tune/easy_object_tuners/components/easy_light_attenuation_component.js
var EasyLightAttenuationComponent = class extends Component {
  init() {
    this._myEasyObjectTuner = null;
    if (Globals.isToolEnabled(this.engine)) {
      this._myEasyObjectTuner = new EasyLightAttenuation(this.object, this._myVariableName, this._mySetAsWidgetCurrentVariable, this._myUseTuneTarget);
    }
  }
  start() {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.start();
      }
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      }
    }
  }
};
__publicField(EasyLightAttenuationComponent, "TypeName", "pp-easy-light-attenuation");
__publicField(EasyLightAttenuationComponent, "Properties", {
  _myVariableName: Property.string(""),
  _mySetAsWidgetCurrentVariable: Property.bool(false),
  _myUseTuneTarget: Property.bool(false)
});

// js/pp/tool/easy_tune/easy_object_tuners/components/easy_light_color_component.js
var EasyLightColorComponent = class extends Component {
  init() {
    this._myEasyObjectTuner = null;
    if (Globals.isToolEnabled(this.engine)) {
      this._myEasyObjectTuner = new EasyLightColor(this._myColorModel, this.object, this._myVariableName, this._mySetAsWidgetCurrentVariable, this._myUseTuneTarget);
    }
  }
  start() {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.start();
      }
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      }
    }
  }
};
__publicField(EasyLightColorComponent, "TypeName", "pp-easy-light-color");
__publicField(EasyLightColorComponent, "Properties", {
  _myVariableName: Property.string(""),
  _mySetAsWidgetCurrentVariable: Property.bool(false),
  _myUseTuneTarget: Property.bool(false),
  _myColorModel: Property.enum(["RGB", "HSV"], "HSV")
});

// js/pp/tool/easy_tune/easy_object_tuners/components/easy_mesh_ambient_factor_component.js
var EasyMeshAmbientFactorComponent = class extends Component {
  init() {
    this._myEasyObjectTuner = null;
    if (Globals.isToolEnabled(this.engine)) {
      this._myEasyObjectTuner = new EasyMeshAmbientFactor(this.object, this._myVariableName, this._mySetAsWidgetCurrentVariable, this._myUseTuneTarget);
    }
  }
  start() {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.start();
      }
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      }
    }
  }
  pp_clone(targetObject) {
    let clonedComponent = ComponentUtils.cloneDefault(this, targetObject);
    return clonedComponent;
  }
};
__publicField(EasyMeshAmbientFactorComponent, "TypeName", "pp-easy-mesh-ambient-factor");
__publicField(EasyMeshAmbientFactorComponent, "Properties", {
  _myVariableName: Property.string(""),
  _myUseTuneTarget: Property.bool(false),
  _mySetAsWidgetCurrentVariable: Property.bool(false)
});

// js/pp/tool/easy_tune/easy_object_tuners/components/easy_mesh_color_component.js
var EasyMeshColorComponent = class extends Component {
  init() {
    this._myEasyObjectTuner = null;
    if (Globals.isToolEnabled(this.engine)) {
      this._myEasyObjectTuner = new EasyMeshColor(this._myColorModel, this._myColorType, this.object, this._myVariableName, this._mySetAsWidgetCurrentVariable, this._myUseTuneTarget);
    }
  }
  start() {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.start();
      }
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      }
    }
  }
  pp_clone(targetObject) {
    let clonedComponent = ComponentUtils.cloneDefault(this, targetObject);
    return clonedComponent;
  }
};
__publicField(EasyMeshColorComponent, "TypeName", "pp-easy-mesh-color");
__publicField(EasyMeshColorComponent, "Properties", {
  _myVariableName: Property.string(""),
  _myUseTuneTarget: Property.bool(false),
  _mySetAsWidgetCurrentVariable: Property.bool(false),
  _myColorModel: Property.enum(["RGB", "HSV"], "HSV"),
  _myColorType: Property.enum(["Color", "Diffuse Color", "Ambient Color", "Specular Color", "Emissive Color", "Fog Color", "Ambient Factor"], "Color")
});

// js/pp/tool/easy_tune/easy_object_tuners/components/easy_scale_component.js
var EasyScaleComponent = class extends Component {
  init() {
    this._myEasyObjectTuner = null;
    if (Globals.isToolEnabled(this.engine)) {
      this._myEasyObjectTuner = new EasyScale(this._myLocal, this._myScaleAsOne, this.object, this._myVariableName, this._mySetAsWidgetCurrentVariable, this._myUseTuneTarget);
    }
  }
  start() {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.start();
      }
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      }
    }
  }
};
__publicField(EasyScaleComponent, "TypeName", "pp-easy-scale");
__publicField(EasyScaleComponent, "Properties", {
  _myVariableName: Property.string(""),
  _mySetAsWidgetCurrentVariable: Property.bool(false),
  _myUseTuneTarget: Property.bool(false),
  _myLocal: Property.bool(false),
  _myScaleAsOne: Property.bool(true)
  // Edit all scale values together
});

// js/pp/tool/easy_tune/easy_object_tuners/components/easy_set_tune_target_child_number_component.js
var EasySetTuneTargetChildNumberComponent = class extends Component {
  start() {
    if (Globals.isToolEnabled(this.engine)) {
      this._myEasyTuneVariableName = "Target Child ";
      if (this._myVariableName == "") {
        this._myEasyTuneVariableName = this._myEasyTuneVariableName.concat(this.object.pp_getID());
      } else {
        this._myEasyTuneVariableName = this._myEasyTuneVariableName.concat(this._myVariableName);
      }
      let childrenCount = this.object.pp_getChildren().length;
      let min4 = 1;
      let max4 = childrenCount;
      if (childrenCount == 0) {
        min4 = 0;
        max4 = 0;
      }
      Globals.getEasyTuneVariables(this.engine).add(new EasyTuneInt(this._myEasyTuneVariableName, 0, null, true, 10, min4, max4));
      if (this._mySetAsWidgetCurrentVariable) {
        EasyTuneUtils.setWidgetCurrentVariable(this._myEasyTuneVariableName, this.engine);
      }
      this._myCurrentChildIndex = -1;
      this._myCurrentChildrenCount = childrenCount;
      this._myEasyTuneTarget = null;
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (Globals.getEasyTuneVariables(this.engine).isWidgetCurrentVariable(this._myEasyTuneVariableName)) {
        let childrenCount = this.object.pp_getChildren().length;
        if (childrenCount != this._myCurrentChildrenCount) {
          this._myCurrentChildrenCount = childrenCount;
          let min4 = 1;
          let max4 = childrenCount;
          if (childrenCount == 0) {
            min4 = 0;
            max4 = 0;
          }
          let easyTuneVariable = Globals.getEasyTuneVariables(this.engine).getEasyTuneVariable(this._myEasyTuneVariableName);
          easyTuneVariable.setMin(min4);
          easyTuneVariable.setMax(max4);
        }
        let childIndex = Globals.getEasyTuneVariables(this.engine).get(this._myEasyTuneVariableName);
        if (childIndex != this._myCurrentChildIndex) {
          if (childIndex == 0 && this._myCurrentChildIndex != -1) {
            if (Globals.getEasyTuneTarget(this.engine) == this._myEasyTuneTarget) {
              Globals.removeEasyTuneTarget(this.engine);
            }
            this._myEasyTuneTarget = null;
          } else if (childIndex > 0) {
            this._myEasyTuneTarget = this.object.pp_getChildren()[childIndex - 1];
            Globals.setEasyTuneTarget(this._myEasyTuneTarget, this.engine);
          }
          this._myCurrentChildIndex = childIndex;
        }
      }
    }
  }
};
__publicField(EasySetTuneTargetChildNumberComponent, "TypeName", "pp-easy-set-tune-target-child-number");
__publicField(EasySetTuneTargetChildNumberComponent, "Properties", {
  _myVariableName: Property.string(""),
  _mySetAsWidgetCurrentVariable: Property.bool(false)
});

// js/pp/tool/easy_tune/easy_object_tuners/components/easy_set_tune_target_grab_component.js
var EasySetTuneTargeetGrabComponent = class extends Component {
  start() {
    this._myGrabber = null;
    if (Globals.isToolEnabled(this.engine)) {
      this._myGrabber = this.object.pp_getComponent(GrabberHandComponent);
      this._myEasyTuneTarget = null;
    }
  }
  _onRelease(grabber, grabbable) {
    if (Globals.isToolEnabled(this.engine)) {
      this._myEasyTuneTarget = grabbable.object;
      Globals.setEasyTuneTarget(this._myEasyTuneTarget, this.engine);
    }
  }
  _onGrab(grabber, grabbable) {
    if (Globals.isToolEnabled(this.engine)) {
      if (Globals.getEasyTuneTarget(this.engine) == this._myEasyTuneTarget) {
        Globals.removeEasyTuneTarget(this.engine);
      }
      this._myEasyTuneTarget = null;
    }
  }
  onActivate() {
    if (this._myGrabber != null) {
      this._myGrabber.registerThrowEventListener(this, this._onRelease.bind(this));
    }
  }
  onDeactivate() {
    if (this._myGrabber != null) {
      this._myGrabber.unregisterThrowEventListener(this);
    }
  }
};
__publicField(EasySetTuneTargeetGrabComponent, "TypeName", "pp-easy-set-tune-target-grab");
__publicField(EasySetTuneTargeetGrabComponent, "Properties", {});

// js/pp/tool/easy_tune/easy_object_tuners/components/easy_text_color_component.js
var EasyTextColorComponent = class extends Component {
  init() {
    this._myEasyObjectTuner = null;
    if (Globals.isToolEnabled(this.engine)) {
      this._myEasyObjectTuner = new EasyTextColor(this._myColorModel, this._myColorType, this.object, this._myVariableName, this._mySetAsWidgetCurrentVariable, this._myUseTuneTarget);
    }
  }
  start() {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.start();
      }
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      }
    }
  }
};
__publicField(EasyTextColorComponent, "TypeName", "pp-easy-text-color");
__publicField(EasyTextColorComponent, "Properties", {
  _myVariableName: Property.string(""),
  _mySetAsWidgetCurrentVariable: Property.bool(false),
  _myUseTuneTarget: Property.bool(false),
  _myColorModel: Property.enum(["RGB", "HSV"], "HSV"),
  _myColorType: Property.enum(["Color", "Effect Color"], "Color")
});

// js/pp/tool/easy_tune/easy_object_tuners/components/easy_transform_component.js
var EasyTransformComponent = class extends Component {
  init() {
    this._myEasyObjectTuner = null;
    if (Globals.isToolEnabled(this.engine)) {
      this._myEasyObjectTuner = new EasyTransform(this._myLocal, this._myScaleAsOne, this.object, this._myVariableName, this._mySetAsWidgetCurrentVariable, this._myUseTuneTarget);
    }
  }
  start() {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.start();
      }
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      }
    }
  }
  pp_clone(targetObject) {
    let clonedComponent = ComponentUtils.cloneDefault(this, targetObject);
    return clonedComponent;
  }
};
__publicField(EasyTransformComponent, "TypeName", "pp-easy-transform");
__publicField(EasyTransformComponent, "Properties", {
  _myVariableName: Property.string(""),
  _mySetAsWidgetCurrentVariable: Property.bool(false),
  _myUseTuneTarget: Property.bool(false),
  _myLocal: Property.bool(true),
  _myScaleAsOne: Property.bool(true)
  // Edit all scale values together
});

// js/index.js
var Constants = {
  ProjectName: "VideoGameConsoleExhibit.wlp",
  RuntimeBaseName: "WonderlandRuntime",
  WebXRRequiredFeatures: ["local"],
  WebXROptionalFeatures: ["local", "local-floor", "hand-tracking", "hit-test"]
};
var RuntimeOptions = {
  physx: true,
  loader: false,
  xrFramebufferScaleFactor: 1,
  xrOfferSession: {
    mode: "auto",
    features: Constants.WebXRRequiredFeatures,
    optionalFeatures: Constants.WebXROptionalFeatures
  },
  canvas: "canvas"
};
var engine = await loadRuntime(Constants.RuntimeBaseName, RuntimeOptions);
Object.assign(engine, dist_exports);
window.WL = engine;
engine.onSceneLoaded.once(() => {
  const el = document.getElementById("version");
  if (el)
    setTimeout(() => el.remove(), 2e3);
});
function requestSession(mode) {
  engine.requestXRSession(mode, Constants.WebXRRequiredFeatures, Constants.WebXROptionalFeatures).catch((e) => console.error(e));
}
function setupButtonsXR() {
  const arButton = document.getElementById("ar-button");
  if (arButton) {
    arButton.dataset.supported = engine.arSupported;
    arButton.addEventListener("click", () => requestSession("immersive-ar"));
  }
  const vrButton = document.getElementById("vr-button");
  if (vrButton) {
    vrButton.dataset.supported = engine.vrSupported;
    vrButton.addEventListener("click", () => requestSession("immersive-vr"));
  }
}
if (document.readyState === "loading") {
  window.addEventListener("load", setupButtonsXR);
} else {
  setupButtonsXR();
}
engine.registerComponent(Cursor);
engine.registerComponent(CursorTarget);
engine.registerComponent(FingerCursor);
engine.registerComponent(HandTracking);
engine.registerComponent(HowlerAudioListener);
engine.registerComponent(MouseLookComponent);
engine.registerComponent(PlayerHeight);
engine.registerComponent(TeleportComponent);
engine.registerComponent(VideoTexture);
engine.registerComponent(VrModeActiveSwitch);
engine.registerComponent(ButtonComponent);
engine.registerComponent(GrabbableComponent);
engine.registerComponent(GrabberHandComponent);
engine.registerComponent(PPGatewayComponent);
engine.scene.load(`${Constants.ProjectName}.bin`).catch((e) => {
  console.error(e);
  window.alert(`Failed to load ${Constants.ProjectName}.bin:`, e);
});
/*! Bundled license information:

howler/dist/howler.js:
  (*!
   *  howler.js v2.2.4
   *  howlerjs.com
   *
   *  (c) 2013-2020, James Simpson of GoldFire Studios
   *  goldfirestudios.com
   *
   *  MIT License
   *)
  (*!
   *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
   *  
   *  howler.js v2.2.4
   *  howlerjs.com
   *
   *  (c) 2013-2020, James Simpson of GoldFire Studios
   *  goldfirestudios.com
   *
   *  MIT License
   *)
*/
//# sourceMappingURL=VideoGameConsoleExhibit.wlp-bundle.js.map
