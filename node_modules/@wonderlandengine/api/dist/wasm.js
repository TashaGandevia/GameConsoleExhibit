import { LogTag } from './index.js';
import { Type } from './property.js';
import { RetainEmitter } from './utils/event.js';
import { Logger } from './utils/logger.js';
import { inheritProperties, Animation, Component, Material, Mesh, BrokenComponent, Skin, XR, } from './wonderland.js';
/**
 * Default component parameter value per type.
 */
const _componentDefaults = new Map([
    [Type.Bool, false],
    [Type.Int, 0],
    [Type.Float, 0.0],
    [Type.String, ''],
    [Type.Enum, undefined],
    [Type.Object, null],
    [Type.Mesh, null],
    [Type.Texture, null],
    [Type.Material, null],
    [Type.Animation, null],
    [Type.Skin, null],
    [Type.Color, [0.0, 0.0, 0.0, 1.0]],
]);
/**
 * Setup the defaults value of the properties on a given
 * component class.
 *
 * @param ctor The component class
 */
function _setupDefaults(ctor) {
    for (const name in ctor.Properties) {
        const p = ctor.Properties[name];
        if (p.type === Type.Enum) {
            /* Enum default can be a string or an index. Convert to and/or
             * sanity-check the index. */
            if (p.values?.length) {
                /* Don't try to look up the default if the user specified a
                 * number or we already converted to one. */
                if (typeof p.default !== 'number') {
                    /* If undefined, missing element or wrong type this returns
                     * -1 which becomes 0 below. This matches editor behavior. */
                    p.default = p.values.indexOf(p.default);
                }
                if (p.default < 0 || p.default >= p.values.length) {
                    p.default = 0;
                }
            }
            else {
                /* There's no index value that makes sense */
                p.default = undefined;
            }
        }
        else {
            p.default = p.default ?? _componentDefaults.get(p.type);
        }
        ctor.prototype[name] = p.default;
    }
}
/**
 * Low-level wrapper to interact with the WebAssembly code.
 *
 * @hidden
 */
export class WASM {
    /**
     * Emscripten worker field.
     *
     * @note This api is meant to be used internally.
     */
    worker = '';
    /**
     * Emscripten wasm field.
     *
     * @note This api is meant to be used internally.
     */
    wasm = null;
    /**
     * Emscripten canvas.
     *
     * @note This api is meant to be used internally.
     */
    canvas = null;
    /** Current WebXR  */
    /**
     * Emscripten WebXR session.
     *
     * @note This api is meant to be used internally.
     */
    webxr_session = null;
    /**
     * Emscripten WebXR request session callback.
     *
     * @note This api is meant to be used internally.
     */
    webxr_requestSession = null;
    /**
     * Emscripten WebXR offer session callback.
     *
     * @note This api is meant to be used internally.
     */
    webxr_offerSession = null;
    /**
     * Emscripten WebXR frame.
     *
     * @note This api is meant to be used internally.
     */
    webxr_frame = null;
    /**
     * Emscripten current WebXR reference space.
     *
     * @note This api is meant to be used internally.
     */
    webxr_refSpace = null;
    /**
     * Emscripten WebXR reference spaces.
     *
     * @note This api is meant to be used internally.
     */
    webxr_refSpaces = null;
    /**
     * Emscripten WebXR current reference space type.
     *
     * @note This api is meant to be used internally.
     */
    webxr_refSpaceType = null;
    /**
     * Emscripten WebXR GL projection layer.
     *
     * @note This api is meant to be used internally.
     */
    webxr_baseLayer = null;
    /**
     * Emscripten WebXR framebuffer scale factor.
     *
     * @note This api is meant to be used internally.
     */
    webxr_framebufferScaleFactor = 1.0;
    /**
     * Emscripten WebXR framebuffer(s).
     *
     * @note This api is meant to be used internally.
     */
    /* webxr_fbo will not get overwritten if we are rendering to the
     * default framebuffer, e.g., when using WebXR emulator. */
    webxr_fbo = 0;
    /**
     * Convert a WASM memory view to a JavaScript string.
     *
     * @param ptr Pointer start
     * @param ptrEnd Pointer end
     * @returns JavaScript string
     */
    UTF8ViewToString;
    /** Logger instance. */
    _log = new Logger();
    /** If `true`, logs will not spam the console on error. */
    _deactivate_component_on_error = false;
    /** Temporary memory pointer. */
    _tempMem = null;
    /** Temporary memory size. */
    _tempMemSize = 0;
    /** Temporary float memory view. */
    _tempMemFloat = null;
    /** Temporary int memory view. */
    _tempMemInt = null;
    /** Temporary uint8 memory view. */
    _tempMemUint8 = null;
    /** Temporary uint32 memory view. */
    _tempMemUint32 = null;
    /** Temporary uint16 memory view. */
    _tempMemUint16 = null;
    /** Loading screen .bin file data */
    _loadingScreen = null;
    /** List of callbacks triggered when the scene is loaded. */
    _sceneLoadedCallback = [];
    /**
     * Material definition cache. Each pipeline has its own
     * associated material definition.
     */
    _materialDefinitions = [];
    /** Image cache. */
    _images = [];
    /** Component instances. */
    _components = [];
    /** Component Type info. */
    _componentTypes = [];
    /** Index per component type name. */
    _componentTypeIndices = {};
    /** Wonderland engine instance. */
    _engine = null;
    /**
     * `true` if this runtime is using physx.
     *
     * @note This api is meant to be used internally.
     */
    _withPhysX = false;
    /** Decoder for UTF8 `ArrayBuffer` to JavaScript string. */
    _utf8Decoder = new TextDecoder('utf8');
    /** JavaScript manager index. */
    _jsManagerIndexCached = null;
    /**
     * Registration index of {@link BrokenComponent}.
     *
     * This is used to return dummy instances when a component
     * isn't registered.
     *
     * @hidden
     */
    _brokenComponentIndex = 0;
    /**
     * Create a new instance of the WebAssembly <> API bridge.
     *
     * @param threads `true` if the runtime used has threads support
     */
    constructor(threads) {
        if (threads) {
            this.UTF8ViewToString = (s, e) => {
                if (!s)
                    return '';
                return this._utf8Decoder.decode(this.HEAPU8.slice(s, e));
            };
            return;
        }
        this.UTF8ViewToString = (s, e) => {
            if (!s)
                return '';
            return this._utf8Decoder.decode(this.HEAPU8.subarray(s, e));
        };
        this._brokenComponentIndex = this._registerComponent(BrokenComponent);
    }
    /**
     * Reset the cache of the library.
     *
     * @note Should only be called when tearing down the runtime.
     */
    reset() {
        /* Cancel in-flight images */
        for (const img of this._images) {
            if (!img || !img.src)
                continue;
            img.src = '';
            img.onload = null;
            img.onerror = null;
        }
        this._images = [];
        this.allocateTempMemory(1024);
        this._materialDefinitions = [];
        this._components = [];
        this._componentTypes = [];
        this._componentTypeIndices = {};
        this._jsManagerIndexCached = null;
        this._brokenComponentIndex = this._registerComponent(BrokenComponent);
    }
    /**
     * Checks whether the given component is registered or not.
     *
     * @param ctor  A string representing the component typename (e.g., `'cursor-component'`).
     * @returns `true` if the component is registered, `false` otherwise.
     */
    isRegistered(type) {
        return type in this._componentTypeIndices;
    }
    /**
     * Register a legacy component in this Emscripten instance.
     *
     * @note This api is meant to be used internally.
     *
     * @param typeName The name of the component.
     * @param params An object containing the parameters (properties).
     * @param object The object's prototype.
     * @returns The registration index
     */
    _registerComponentLegacy(typeName, params, object) {
        const ctor = class CustomComponent extends Component {
        };
        ctor.TypeName = typeName;
        ctor.Properties = params;
        Object.assign(ctor.prototype, object);
        return this._registerComponent(ctor);
    }
    /**
     * Register a class component in this Emscripten instance.
     *
     * @note This api is meant to be used internally.
     *
     * @param ctor The class to register.
     * @returns The registration index.
     */
    _registerComponent(ctor) {
        if (!ctor.TypeName)
            throw new Error('no name provided for component.');
        if (!ctor.prototype._triggerInit) {
            throw new Error(`registerComponent(): Component ${ctor.TypeName} must extend Component`);
        }
        inheritProperties(ctor);
        _setupDefaults(ctor);
        const typeIndex = ctor.TypeName in this._componentTypeIndices
            ? this._componentTypeIndices[ctor.TypeName]
            : this._componentTypes.length;
        this._componentTypes[typeIndex] = ctor;
        this._componentTypeIndices[ctor.TypeName] = typeIndex;
        if (ctor === BrokenComponent)
            return typeIndex;
        this._log.info(LogTag.Engine, 'Registered component', ctor.TypeName, `(class ${ctor.name})`, 'with index', typeIndex);
        if (ctor.onRegister)
            ctor.onRegister(this._engine);
        return typeIndex;
    }
    /**
     * Allocate the requested amount of temporary memory
     * in this WASM instance.
     *
     * @param size The number of bytes to allocate
     */
    allocateTempMemory(size) {
        this._log.info(LogTag.Engine, 'Allocating temp mem:', size);
        this._tempMemSize = size;
        if (this._tempMem)
            this._free(this._tempMem);
        this._tempMem = this._malloc(this._tempMemSize);
        this.updateTempMemory();
    }
    /**
     * @todo: Delete this and only keep `allocateTempMemory`
     *
     * @param size Number of bytes to allocate
     */
    requireTempMem(size) {
        if (this._tempMemSize >= size)
            return;
        /* Grow in 1kb increments */
        this.allocateTempMemory(Math.ceil(size / 1024) * 1024);
    }
    /**
     * Update the temporary memory views. This must be called whenever the
     * temporary memory address changes.
     *
     * @note This api is meant to be used internally.
     */
    updateTempMemory() {
        this._tempMemFloat = new Float32Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize >> 2);
        this._tempMemInt = new Int32Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize >> 2);
        this._tempMemUint32 = new Uint32Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize >> 2);
        this._tempMemUint16 = new Uint16Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize >> 1);
        this._tempMemUint8 = new Uint8Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize);
    }
    /**
     * Returns a uint8 buffer view on temporary WASM memory.
     *
     * **Note**: this method might allocate if the requested memory is bigger
     * than the current temporary memory allocated.
     *
     * @param count The number of **elements** required
     * @returns A {@link TypedArray} over the WASM memory
     */
    getTempBufferU8(count) {
        this.requireTempMem(count);
        return this._tempMemUint8;
    }
    /**
     * Returns a uint16 buffer view on temporary WASM memory.
     *
     * **Note**: this method might allocate if the requested memory is bigger
     * than the current temporary memory allocated.
     *
     * @param count The number of **elements** required
     * @returns A {@link TypedArray} over the WASM memory
     */
    getTempBufferU16(count) {
        this.requireTempMem(count * 2);
        return this._tempMemUint16;
    }
    /**
     * Returns a uint32 buffer view on temporary WASM memory.
     *
     * **Note**: this method might allocate if the requested memory is bigger
     * than the current temporary memory allocated.
     *
     * @param count The number of **elements** required.
     * @returns A {@link TypedArray} over the WASM memory.
     */
    getTempBufferU32(count) {
        this.requireTempMem(count * 4);
        return this._tempMemUint32;
    }
    /**
     * Returns a int32 buffer view on temporary WASM memory.
     *
     * **Note**: this method might allocate if the requested memory is bigger
     * than the current temporary memory allocated.
     *
     * @param count The number of **elements** required.
     * @returns A {@link TypedArray} over the WASM memory.
     */
    getTempBufferI32(count) {
        this.requireTempMem(count * 4);
        return this._tempMemInt;
    }
    /**
     * Returns a float32 buffer view on temporary WASM memory.
     *
     * **Note**: this method might allocate if the requested memory is bigger
     * than the current temporary memory allocated.
     *
     * @param count The number of **elements** required.
     * @returns A {@link TypedArray} over the WASM memory.
     */
    getTempBufferF32(count) {
        this.requireTempMem(count * 4);
        return this._tempMemFloat;
    }
    /**
     * Copy the string into temporary WASM memory and retrieve the pointer.
     *
     * @note This method will compute the strlen and append a `\0`.
     *
     * @note The result should be used **directly** otherwise it might get
     * overridden by any next call modifying the temporary memory.
     *
     * @param str The string to write to temporary memory
     * @param byteOffset The starting byte offset in the temporary memory at which
     *     the string should be written. This is useful when using multiple temporaries.
     * @return The temporary pointer onto the WASM memory
     */
    tempUTF8(str, byteOffset = 0) {
        const strLen = this.lengthBytesUTF8(str) + 1;
        this.requireTempMem(strLen + byteOffset);
        const ptr = this._tempMem + byteOffset;
        this.stringToUTF8(str, ptr, strLen);
        return ptr;
    }
    /**
     * Return the index of the component type.
     *
     * @note This method uses malloc and copies the string
     * to avoid overwriting caller's temporary data.
     *
     * @param type The type
     * @return The component type index
     */
    _typeIndexFor(type) {
        const lengthBytes = this.lengthBytesUTF8(type) + 1;
        const mem = this._malloc(lengthBytes);
        this.stringToUTF8(type, mem, lengthBytes);
        const componentType = this._wl_get_component_manager_index(mem);
        this._free(mem);
        return componentType;
    }
    /**
     * Return the name of component type stored at the given index.
     *
     * @param typeIndex The type index
     * @return The name as a string
     */
    _typeNameFor(typeIndex) {
        return this.UTF8ToString(this._wl_component_manager_name(typeIndex));
    }
    /**
     * Returns `true` if the runtime supports physx or not.
     */
    get withPhysX() {
        return this._withPhysX;
    }
    /** JavaScript manager index. */
    get _jsManagerIndex() {
        if (this._jsManagerIndexCached === null) {
            this._jsManagerIndexCached = this._typeIndexFor('js');
        }
        return this._jsManagerIndexCached;
    }
    /**
     * Set the engine instance holding this bridge.
     *
     * @note This api is meant to be used internally.
     *
     * @param engine The engine instance.
     */
    _setEngine(engine) {
        this._engine = engine;
    }
    /* WebAssembly to JS call bridge. */
    _wljs_xr_session_start(mode) {
        if (this._engine.xr === null) {
            this._engine.xr = new XR(this, mode);
            this._engine.onXRSessionStart.notify(this.webxr_session, mode);
        }
    }
    _wljs_xr_session_end() {
        const startEmitter = this._engine.onXRSessionStart;
        if (startEmitter instanceof RetainEmitter)
            startEmitter.reset();
        this._engine.onXRSessionEnd.notify();
        this._engine.xr = null;
    }
    _wljs_xr_disable() {
        /* @todo This could directly be fully handled in JS. */
        this._engine.arSupported = false;
        this._engine.vrSupported = false;
    }
    _wljs_allocate(numComponents) {
        this._components = new Array(numComponents);
    }
    _wljs_init(withPhysX) {
        this._withPhysX = withPhysX;
        /* Target memory for JS API functions that return arrays */
        this.allocateTempMemory(1024);
    }
    _wljs_reallocate(numComponents) {
        if (numComponents > this._components.length) {
            this._components.length = numComponents;
        }
    }
    _wljs_scene_add_material_definition(definitionId) {
        const definition = new Map();
        /* Cache material definition for faster read/write */
        const nbParams = this._wl_material_definition_get_count(definitionId);
        for (let i = 0; i < nbParams; ++i) {
            const name = this.UTF8ToString(this._wl_material_definition_get_param_name(definitionId, i));
            const t = this._wl_material_definition_get_param_type(definitionId, i);
            definition.set(name, {
                index: i,
                type: {
                    type: t & 0xff,
                    componentCount: (t >> 8) & 0xff,
                    metaType: (t >> 16) & 0xff,
                },
            });
        }
        this._materialDefinitions[definitionId] = definition;
    }
    _wljs_set_component_param_bool(c, p, pe, v) {
        const param = this.UTF8ViewToString(p, pe);
        this._components[c][param] = v !== 0;
    }
    _wljs_set_component_param_int(c, p, pe, v) {
        const param = this.UTF8ViewToString(p, pe);
        this._components[c][param] = v;
    }
    _wljs_set_component_param_float(c, p, pe, v) {
        const param = this.UTF8ViewToString(p, pe);
        this._components[c][param] = v;
    }
    _wljs_set_component_param_string(c, p, pe, v, ve) {
        const param = this.UTF8ViewToString(p, pe);
        const value = this.UTF8ViewToString(v, ve);
        this._components[c][param] = value;
    }
    _wljs_set_component_param_color(c, p, pe, v) {
        const param = this.UTF8ViewToString(p, pe);
        this._components[c][param] = new Float32Array([0, 8, 16, 24].map((s) => ((v >>> s) & 0xff) / 255.0));
    }
    _wljs_set_component_param_object(c, p, pe, v) {
        const param = this.UTF8ViewToString(p, pe);
        this._components[c][param] =
            v > 0 ? this._engine.wrapObject(v) : null;
    }
    _wljs_set_component_param_mesh(c, p, pe, v) {
        const param = this.UTF8ViewToString(p, pe);
        this._components[c][param] =
            v > 0 ? new Mesh(this._engine, v) : null;
    }
    _wljs_set_component_param_texture(c, p, pe, v) {
        const param = this.UTF8ViewToString(p, pe);
        this._components[c][param] =
            v > 0 ? this._engine.textures.wrap(v) : null;
    }
    _wljs_set_component_param_material(c, p, pe, v) {
        const param = this.UTF8ViewToString(p, pe);
        this._components[c][param] =
            v > 0 ? new Material(this._engine, v) : null;
    }
    _wljs_set_component_param_animation(c, p, pe, v) {
        const param = this.UTF8ViewToString(p, pe);
        this._components[c][param] =
            v > 0 ? new Animation(this._engine, v) : null;
    }
    _wljs_set_component_param_skin(c, p, pe, v) {
        const param = this.UTF8ViewToString(p, pe);
        this._components[c][param] =
            v > 0 ? new Skin(this._engine, v) : null;
    }
    _wljs_get_component_type_index(namePtr, nameEndPtr) {
        const typename = this.UTF8ViewToString(namePtr, nameEndPtr);
        const index = this._componentTypeIndices[typename];
        if (index === undefined) {
            return this._brokenComponentIndex;
        }
        return index;
    }
    _wljs_component_create(jsManagerIndex, index, id, type, object) {
        const ctor = this._componentTypes[type];
        if (!ctor) {
            throw new Error(`Type index ${type} isn't registered`);
        }
        let component = null;
        try {
            component = new ctor();
        }
        catch (e) {
            this._log.error(LogTag.Component, `Exception during instantiation of component ${ctor.TypeName}`);
            this._log.error(LogTag.Component, e);
            component = new BrokenComponent(this._engine);
        }
        /* Sets the manager and identifier from the outside, to simplify the user's constructor. */
        /* @ts-ignore */
        component._engine = this._engine;
        component._manager = jsManagerIndex;
        component._id = id;
        component._object = this._engine.wrapObject(object);
        try {
            component.resetProperties();
        }
        catch (e) {
            this._log.error(LogTag.Component, `Exception during ${component.type} resetProperties() on object ${component.object.name}`);
            this._log.error(LogTag.Component, e);
        }
        this._components[index] = component;
        return component;
    }
    _wljs_component_init(component) {
        const c = this._components[component];
        c._triggerInit();
    }
    _wljs_component_update(component, dt) {
        const c = this._components[component];
        c._triggerUpdate(dt);
    }
    _wljs_component_onActivate(component) {
        const c = this._components[component];
        if (c)
            c._triggerOnActivate();
    }
    _wljs_component_onDeactivate(component) {
        const c = this._components[component];
        c._triggerOnDeactivate();
    }
    _wljs_component_onDestroy(component) {
        const c = this._components[component];
        c._triggerOnDestroy();
    }
    _wljs_swap(a, b) {
        const componentA = this._components[a];
        this._components[a] = this._components[b];
        this._components[b] = componentA;
    }
    _wljs_copy(src, dst) {
        const destComp = this._components[dst];
        try {
            destComp.copy(this._components[src]);
        }
        catch (e) {
            this._log.error(LogTag.Component, `Exception during ${destComp.type} copy() on object ${destComp.object.name}`);
            this._log.error(LogTag.Component, e);
        }
    }
}
/*
 * Api <> Runtime compatibility.
 *
 * Some features exposed in the API are only available from a specific
 * runtime version.
 *
 * Every added feature must throw by default. If the runtime loaded
 * has the specific feature, the method will be overwritten by Emscripten
 * upon loading.
 */
function throwInvalidRuntime(version) {
    return function () {
        throw new Error(`Feature added in version ${version}.` +
            `\n\t→ Please use a Wonderland Engine editor version >= ${version}`);
    };
}
const requireRuntime1_1_1 = throwInvalidRuntime('1.1.1');
const requireRuntime1_1_5 = throwInvalidRuntime('1.1.5');
/** @todo: Remove at 1.2.0 */
WASM.prototype._wl_physx_component_get_offsetTranslation = requireRuntime1_1_1;
WASM.prototype._wl_physx_component_set_offsetTranslation = requireRuntime1_1_1;
WASM.prototype._wl_physx_component_get_offsetTransform = requireRuntime1_1_1;
WASM.prototype._wl_physx_component_set_offsetRotation = requireRuntime1_1_1;
WASM.prototype._wl_object_clone = requireRuntime1_1_1;
WASM.prototype._wl_physx_component_set_sleepOnActivate = requireRuntime1_1_5;
WASM.prototype._wl_physx_component_get_sleepOnActivate = requireRuntime1_1_5;
WASM.prototype.webxr_offerSession = requireRuntime1_1_5;
