import { Component, Property } from "@wonderlandengine/api";
import { quat, vec3 } from 'gl-matrix';
import { GameGlobals } from "../misc/game_globals";
// From http://theorangeduck.com/page/simple-two-joint
const twoJointIK = (function () {
    let ta = new Float32Array(3);
    let ca = new Float32Array(3);
    let ba = new Float32Array(3);
    let ab = new Float32Array(3);
    let cb = new Float32Array(3);
    let axis0 = new Float32Array(3);
    let axis1 = new Float32Array(3);
    let temp = new Float32Array(3);
    return function (root, middle, a, b, c, targetPos, eps, helper) {
        vec3.sub(ba, b, a); // ba is the vector (b - a) --> mid_World_Pos - root_World_Pos      [root->mid]
        const lab = vec3.length(ba); // lab is the length of ba
        vec3.sub(ta, b, c); // (TEMP) ta is the vector (b - c) --> mid_World_Pos - end_World_Pos
        const lcb = vec3.length(ta); // lcb is the length of (b - c)
        vec3.sub(ta, targetPos, a); // ta  is the vector (t - a) --> target_World_Pos - root_World_Pos  [mid->target]
        const lat = Math.pp_clamp(vec3.length(ta), eps, lab + lcb - eps); // lat is the pp_clamped length of ta to keep in range (with margin eps)
        vec3.sub(ca, c, a); // ca is the vector (c - a) --> end_World_Pos - root_World_Pos [root->end]
        vec3.sub(ab, a, b); // ab is the vector (a - b) --> root_World_Pos - mid_World_Pos [mid->root]
        vec3.sub(cb, c, b); // cb is the vector (c - b) --> end_World_Pos - mid_World_Pos [mid->end]
        vec3.normalize(ca, ca);
        vec3.normalize(ba, ba);
        vec3.normalize(ab, ab);
        vec3.normalize(cb, cb);
        vec3.normalize(ta, ta);
        const ac_ab_0 = Math.acos(vec3.dot(ca, ba)); // to get the angle CAB
        const ba_bc_0 = Math.acos(vec3.dot(ab, cb));
        const ac_at_0 = Math.acos(vec3.dot(ca, ta));
        const ac_ab_1 = Math.acos(Math.pp_clamp((lcb * lcb - lab * lab - lat * lat) / (-2 * lab * lat), -1, 1));
        const ba_bc_1 = Math.acos(Math.pp_clamp((lat * lat - lab * lab - lcb * lcb) / (-2 * lab * lcb), -1, 1));
        vec3.sub(ca, c, a);
        vec3.sub(ba, b, a);
        vec3.sub(ta, targetPos, a);
        vec3.cross(axis1, ca, ta); // axis1 --> Normal to plane containing [root->end] and [root->target]
        if (helper) {
            vec3.sub(ba, helper, b);
            vec3.normalize(ba, ba);
            middle.transformVectorLocal(ba, ba);
        }
        else {
            vec3.sub(ba, b, a);
        }
        vec3.cross(axis0, ca, ba); // axis0 -> Normal to plane containing [root->end] and [root->mid]
        const l = vec3.length(axis0);
        if (l == 0) {
            axis0.set(GameGlobals.left);
        }
        else {
            vec3.scale(axis0, axis0, 1 / l);
        }
        vec3.normalize(axis1, axis1);
        root.rotateAxisAngleRadObject(axis0, (ac_ab_1 - ac_ab_0));
        root.rotateAxisAngleRadObject(axis1, (ac_at_0));
        middle.transformVectorInverseLocal(temp, axis0);
        middle.rotateAxisAngleRadObject(temp, (ba_bc_1 - ba_bc_0));
    };
})();
/**
 * Inverse Kinematics for two-joint chains (e.g. knees or ellbows)
 */
class IKSolverComponent extends Component {
    static TypeName = "iksolver";
    static Properties = {
        /** Root bone, never moves */
        root: Property.object(),
        /** Bone attached to the root */
        middle: Property.object(),
        /** Bone attached to the middle */
        end: Property.object(),
        /** Target the joins should reach for */
        target: Property.object(),
        /** Flag for copying rotation from target to end */
        copyTargetRotation: Property.bool(true),
        /** Helper object to use to determine joint rotation axis */
        helper: Property.object()
    };
    init() {
        this.count = 0;
        this.pos = new Float32Array(3 * 7);
        this.p = [
            this.pos.subarray(0, 3),
            this.pos.subarray(3, 6),
            this.pos.subarray(6, 9),
            this.pos.subarray(9, 12),
            this.pos.subarray(12, 15),
            this.pos.subarray(15, 18),
            this.pos.subarray(18, 21)
        ];
        this.bBend = false;
        this.resetRoot = true;
        // NOTES: RIGHT arm, rotateZ at 0.25 PI gives acceptable elbow
        //
    }
    afixed(ar, dp) {
        let acc = "";
        ar.forEach(I => {
            acc = acc + "," + I.toFixed(dp);
        });
        return acc;
    }
    update() {
        const p = this.p;
        if (this.rootstart) {
            if (this.resetRoot) {
                this.root.pp_setRotationLocalQuat(this.rootstart); //<--- THIS IS IMPORTANT
            }
            this.target.getPositionWorld(p[3]);
            this.root.pp_convertPositionWorldToObject(p[3], p[3]);
        }
        else {
            // if start root angle not yet set, then set it
            // also set the end angle
            // then return from the function, do NOT update the IK initially
            this.count++;
            if (this.count > 2) {
                this.root.setDirty();
                this.rootstart = new Float32Array(4);
                this.root.getRotationLocal(this.rootstart);
                quat.normalize(this.rootstart, this.rootstart);
                this.midstart = this.middle.pp_getRotationLocalQuat();
                let bendAngle = (Math.PI * 0.25); //* 0.3;
                if (this.bBend) {
                    quat.rotateX(this.rootstart, this.rootstart, bendAngle);
                    quat.normalize(this.rootstart, this.rootstart);
                }
                this.middle.pp_setRotationLocalQuat(this.midstart);
                this.endstart = this.end.pp_getRotationLocalQuat();
            }
            return;
        }
        p[0].fill(0);
        this.middle.getPositionLocal(p[1]);
        this.end.getPositionLocal(p[2]);
        this.middle.transformPointLocal(p[2], p[2]);
        this.helper = null;
        if (this.helper) {
            this.helper.getPositionWorld(p[6]);
            this.root.transformPointInverseWorld(p[6], p[6]);
            vec3.copy(p[6], p[1]);
            p[6][1] += 1;
        }
        twoJointIK(this.root, this.middle, p[0], p[1], p[2], p[3], 0.01, this.helper ? p[6] : null);
    }
}
export { IKSolverComponent };
